<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="博客，学习网站，hexo，周琛，周琛的个人博客" />
   
  <meta name="description" content="周琛的博客" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     周琛的博客
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.png" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="琛" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/ZhChen7"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">琛</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['学习', '学习使我快乐', '快乐，开心～'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-muyiyang"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/09/20/muyiyang/"
    >木易杨每日一题</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/09/20/muyiyang/" class="article-date">
  <time datetime="2019-09-20T06:45:02.000Z" itemprop="datePublished">2019-09-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%89%9B%E4%BA%BA%E9%9D%A2%E8%AF%95%E9%A2%98/">牛人面试题</a> / <a class="article-category-link" href="/categories/%E7%89%9B%E4%BA%BA%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%9C%A8%E6%98%93%E6%9D%A8%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">木易杨每日一题</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h2><blockquote>
<p>每天一道大厂前端面试题，一年后再回头，会感谢曾经努力的自己！</p>
<p>待更新状态</p>
<p>今天 2019/12/23 ~ 💪</p>
</blockquote>
<h3 id="第-1-题-（2019-9-19）"><a href="#第-1-题-（2019-9-19）" class="headerlink" title="第 1 题 （2019/9/19）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md#%E7%AC%AC-1-%E9%A2%98%E5%86%99-react--vue-%E9%A1%B9%E7%9B%AE%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8%E5%88%97%E8%A1%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%86%99-key%E5%85%B6%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">第 1 题</a> （2019/9/19）</h3><p><strong>题目</strong>：写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？</p>
<p><strong>公司</strong>：滴滴、饿了么</p>
<p><strong>需了解</strong> ：vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中。可以先了解一下 diff 算法。<br>在交叉对比的时候，当新节点跟旧节点<code>头尾交叉对比</code>没有结果的时候，会根据新节点的 key 去对比旧节点数组中的 key，从而找到相应旧节点（这里对应的是一个 key =&gt; index 的 map 映射）。如果没找到就认为是一个新增节点。而如果没有 key，那么就会采用一种遍历查找的方式去找到对应的旧节点。一种一个 map 映射，另一种是遍历查找。相比而言。map 映射的速度更快。</p>
<p><strong>答案</strong>：</p>
<blockquote>
<p>key 是给每一个 vnode 的唯一 id,可以<code>依靠key</code>,更<code>准确</code>, 更<code>快</code>的拿到 oldVnode 中对应的 vnode 节点。</p>
<p>key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。</p>
</blockquote>
<p>1、更准确</p>
<p>因为带 key 就不是<code>就地复用</code>了，在 sameNode 函数 <code>a.key === b.key</code>对比中可以避免就地复用的情况。所以会更加准确。</p>
<p>2、更快</p>
<p>利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快。(这个观点，就是我最初的那个观点。从这个角度看，map 会比遍历更快。)</p>
<h3 id="第-2-题（2019-9-20）"><a href="#第-2-题（2019-9-20）" class="headerlink" title="第 2 题（2019/9/20）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/4">第 2 题</a>（2019/9/20）</h3><p><strong>题目</strong>：<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code> what &amp; why ?</p>
<p><strong>答案</strong> ：第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是 **真正的答案是[1, NaN, NaN]**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;12&quot;</span>)); <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;08&quot;</span>)); <span class="comment">//8</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;0x16&quot;</span>)); <span class="comment">//22</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;-12&quot;</span>)); <span class="comment">//-12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;   -12&quot;</span>)); <span class="comment">//-12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;   -  12&quot;</span>)); <span class="comment">///NAN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;124ref&quot;</span>)); <span class="comment">//124</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;ref&quot;</span>)); <span class="comment">//NAN</span></span><br></pre></td></tr></table></figure>

<p>以上几乎就是<code>parseInt</code>函数一个形式参数时的所有情况</p>
<p>radix 形参没指定的时候是<strong>10</strong>，其次他是具有有效范围滴：[2, 36]和特殊值 0<br>下面是英语渣渣的我翻译后，简化的<code>parseInt</code>执行步骤：（ECMAScript 原解析-&gt;<a target="_blank" rel="noopener" href="http://www.ecma-international.org/ecma-262/6.0/#sec-parseint-string-radix">传送门</a>）</p>
<ol>
<li>将第一个形参转换为字符串</li>
<li>识别 string 转换是否有<strong>code unit</strong>，如果有 -&gt; <code>-</code>标记为负数，<code>0x</code>或<code>0X</code>则把 radix 赋值为<strong>16</strong></li>
<li>radix 形参（int 类型）是否存在，存在则重新赋值（会对实参进行 Int32 转化，无法转换成 int 类型则不会重新赋值 radix）</li>
<li>radix 为 0，则设置 radix 为默认值 10</li>
<li>如果 radix 为 1，或者大于等于 37，parseInt 直接返回<strong>NaN</strong></li>
<li>如果 radix 为[2, 36]时则代表，string 参数分别是二进制，三进制（如果有得话~）…三十六进制类型</li>
<li>然后对 string 进行的 radix 进制 -&gt; 十进制转换</li>
</ol>
<p>以上就是<code>parseInt</code>转换时的步骤，那么我们来开始解释<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code><br><strong>at first, 答案是[1, NaN, NaN]</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>].map(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(value, index);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(ret);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>这是<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code>内部执行的剖析，<code>value</code>和<code>index</code>相信大家都懂，不懂请自行<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/map">MDN</a>,执行步骤为：<br><code>value=&#39;1&#39;,index=0</code> -&gt; <code>parseInt(value, index)</code><br><code>value=&#39;2&#39;,index=1</code> -&gt; <code>parseInt(value, index)</code><br><code>value=&#39;3&#39;,index=2</code> -&gt; <code>parseInt(value, index)</code><br>抽离出来，其实就是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;1&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;2&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;3&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><code>parseInt(&#39;3&#39;, 2)</code>这是根据二进制对字符串<code>3</code>进行十进制转换对吧！！！<br>exm???有毛病?没毛病，老铁，就是……你家二进制有<code>3</code>?二进制不就是<code>0</code>和<code>1</code>啊</p>
<p>因此返回<strong>NaN</strong>。</p>
<p>解决方案：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnInt</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(element, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>].map(returnInt); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="comment">// Actual result is an array of numbers (as expected)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Same as above, but using the concise arrow function syntax</span></span><br><span class="line">[<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>].map(<span class="function">(<span class="params">str</span>) =&gt;</span> <span class="built_in">parseInt</span>(str));</span><br><span class="line"></span><br><span class="line"><span class="comment">// A simpler way to achieve the above, while avoiding the &quot;gotcha&quot;:</span></span><br><span class="line">[<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>].map(<span class="built_in">Number</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// But unlike parseInt(), Number() will also return a float or (resolved) exponential notation:</span></span><br><span class="line">[<span class="string">&quot;1.1&quot;</span>, <span class="string">&quot;2.2e2&quot;</span>, <span class="string">&quot;3e300&quot;</span>].map(<span class="built_in">Number</span>); <span class="comment">// [1.1, 220, 3e+300]</span></span><br><span class="line"><span class="comment">// For comparison, if we use parseInt() on the array above:</span></span><br><span class="line">[<span class="string">&quot;1.1&quot;</span>, <span class="string">&quot;2.2e2&quot;</span>, <span class="string">&quot;3e300&quot;</span>].map(<span class="function">(<span class="params">str</span>) =&gt;</span> <span class="built_in">parseInt</span>(str)); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="第-3-题（2019-9-21）"><a href="#第-3-题（2019-9-21）" class="headerlink" title="第 3 题（2019/9/21）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5">第 3 题</a>（2019/9/21）</h3><p><strong>题目</strong>：什么是防抖和节流？有什么区别？如何实现？</p>
<p><strong>公司</strong> ：挖财</p>
<p><strong>解析</strong> ：</p>
<p>1、<strong>防抖</strong></p>
<blockquote>
<p>触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间</p>
</blockquote>
<p>思路：</p>
<blockquote>
<p>每次触发事件时都取消之前的延时调用方法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>; <span class="comment">// 创建一个标记用来存放定时器的返回值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout); <span class="comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span></span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;防抖成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inp = <span class="built_in">document</span>.getElementById(<span class="string">&quot;inp&quot;</span>);</span><br><span class="line">inp.addEventListener(<span class="string">&quot;input&quot;</span>, debounce(sayHi, <span class="number">500</span>)); <span class="comment">// 防抖</span></span><br></pre></td></tr></table></figure>

<p>提出问题：请问，为什么要 fn.apply(this, arguments);而不是这样 fn()</p>
<p>解答：加上 apply 确保 在 sayHi 函数里的 this 指向的是 input 对象(不然就指向 window 了，不是我们想要的)。<br>这里的箭头函数依旧是指向 input 对象。</p>
<p><img src="http://static.zxinc520.com/blog/20190921/g4jPyh09vVh7.gif" alt="mark"></p>
<p>防抖应用场景：</p>
<ol>
<li>搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。</li>
<li>表单验证</li>
<li>按钮提交事件。</li>
<li>浏览器窗口缩放，resize 事件等。</li>
</ol>
<p>2、<strong>节流</strong></p>
<blockquote>
<p>高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率</p>
</blockquote>
<p>思路：</p>
<blockquote>
<p>每次触发事件时都判断当前是否有等待执行的延时函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span>; <span class="comment">// 通过闭包保存一个标记</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) <span class="keyword">return</span>; <span class="comment">// 在函数开头判断标记是否为true，不为true则return</span></span><br><span class="line">    canRun = <span class="literal">false</span>; <span class="comment">// 立即设置为false</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 将外部传入的函数的执行放在setTimeout中</span></span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      <span class="comment">// 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉</span></span><br><span class="line">      canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.innerWidth, e.target.innerHeight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, throttle(sayHi, <span class="number">500</span>));</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190921/nJbaVeD1wpaz.gif" alt="mark"></p>
<h3 id="第-4-题-2019-9-22"><a href="#第-4-题-2019-9-22" class="headerlink" title="第 4 题 (2019/9/22)"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md#%E7%AC%AC-4-%E9%A2%98%E4%BB%8B%E7%BB%8D%E4%B8%8B-setmapweakset-%E5%92%8C-weakmap-%E7%9A%84%E5%8C%BA%E5%88%AB">第 4 题</a> (2019/9/22)</h3><p><strong>题目</strong> ：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://muyiy.cn/question/js/4.html">木易杨前端进阶</a></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Set</span><br><span class="line">    成员唯一、无序且不重复</span><br><span class="line">    [value, value]，键值与键名是一致的（或者说只有键值，没有键名）</span><br><span class="line">    可以遍历，方法有：add、delete、has</span><br><span class="line"></span><br><span class="line">WeakSet</span><br><span class="line">    成员都是对象</span><br><span class="line">    成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏</span><br><span class="line">    不能遍历，方法有add、delete、has</span><br><span class="line"></span><br><span class="line">Map</span><br><span class="line">    本质上是键值对的集合，类似集合</span><br><span class="line">    可以遍历，方法很多可以跟各种数据格式转换</span><br><span class="line"></span><br><span class="line">WeakMap</span><br><span class="line">    只接受对象作为键名（null除外），不接受其他类型的值作为键名</span><br><span class="line">    键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的</span><br><span class="line">    不能遍历，方法有get、set、has、delete</span><br><span class="line"></span><br><span class="line"> Set与WeakSet区别:</span><br><span class="line">    1. WeakSet只能存放对象</span><br><span class="line">    2. WeakSet不支持遍历, 没有size熟悉</span><br><span class="line">    3. WeakSet存放的对象不会计入到对象的引用技术, 因此不会影响GC的回收</span><br><span class="line">    4. WeakSet存在的对象如果在外界消失了, 那么在WeakSet里面也会不存在</span><br><span class="line"></span><br><span class="line"> Map与WeakMap区别</span><br><span class="line"> 	1. WeakMap只能接受对象作为键名字(null除外)</span><br><span class="line">	2. WeakMap键名指向对象不会计入对象的引用数</span><br></pre></td></tr></table></figure>

<h3 id="第-5-题-2019-9-22"><a href="#第-5-题-2019-9-22" class="headerlink" title="第 5 题 (2019/9/22)"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/9">第 5 题</a> (2019/9/22)</h3><p><strong>题目：</strong> 介绍下深度优先遍历和广度优先遍历，如何实现？</p>
<p>解析： 我先学习一下啥是 深度优先 和 广度优先… 惭愧！！！</p>
<h3 id="第-6-题-（2019-9-23）"><a href="#第-6-题-（2019-9-23）" class="headerlink" title="第 6 题 （2019/9/23）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/10">第 6 题</a> （2019/9/23）</h3><p><strong>题目</strong> ：请分别用深度优先思想和广度优先思想实现一个拷贝函数？</p>
<blockquote>
<p>弄懂了 优先遍历和广度优先遍历 再来做</p>
</blockquote>
<h3 id="第-7-题-（2019-9-23）"><a href="#第-7-题-（2019-9-23）" class="headerlink" title="第 7 题 （2019/9/23）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20">第 7 题</a> （2019/9/23）</h3><p><strong>题目</strong> ：ES5/ES6 的继承除了写法以外还有什么区别？</p>
<p><strong>解析</strong> ： <a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20">更多</a></p>
<ol>
<li><code>class</code> 声明会提升，但不会初始化赋值。<code>Foo</code> 进入暂时性死区，类似于 <code>let</code>、<code>const</code> 声明变量。</li>
<li><code>class</code> 声明内部会启用严格模式。</li>
<li><code>class</code> 的所有方法（包括静态方法和实例方法）都是不可枚举的。</li>
<li><code>class</code> 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有<code>[[construct]]</code>，不能使用 <code>new</code> 来调用。</li>
<li>必须使用 <code>new</code> 调用 <code>class</code>。</li>
<li><code>class</code> 内部无法重写类名。</li>
</ol>
<h3 id="第-8-题（2019-9-24）"><a href="#第-8-题（2019-9-24）" class="headerlink" title="第 8 题（2019/9/24）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/33">第 8 题</a>（2019/9/24）</h3><p><strong>题目：</strong> setTimeout、Promise、Async/Await 的区别 ？</p>
<p><strong>知识点</strong> ：这里涉及到<code>Microtasks</code>、<code>Macrotasks</code>、event loop 以及 JS 的异步运行机制。<a target="_blank" rel="noopener" href="https://github.com/sisterAn/blog/issues/21">可参考</a></p>
<p><strong>解析</strong> ：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我觉得这题主要是考察这三者在事件循环中的区别，事件循环中分为宏任务队列和微任务队列。</span><br><span class="line">其中 setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；</span><br><span class="line">promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。</span><br></pre></td></tr></table></figure>

<p><strong>1、setTimeout</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>); <span class="comment">//1. 打印 script start</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;settimeout&quot;</span>); <span class="comment">// 4. 打印 settimeout</span></span><br><span class="line">&#125;); <span class="comment">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>); <span class="comment">//3. 打印 script start</span></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;script end-&gt;settimeout</span></span><br></pre></td></tr></table></figure>

<p><strong>2、 Promise</strong></p>
<p>Promise 本身是<strong>同步的立即执行函数</strong>， 当在 executor 中执行 resolve 或者 reject 的时候, 此时是异步操作， 会先执行 then/catch 等，当主栈完成后，才会去调用 resolve/reject 中存放的方法执行，打印 p 的时候，是打印的返回结果，一个 Promise 实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1 end&quot;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;settimeout&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"><span class="comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span></span><br></pre></td></tr></table></figure>

<p>当 JS 主线程执行到 Promise 对象时，</p>
<ul>
<li>promise1.then() 的回调就是一个 task</li>
<li>promise1 是 resolved 或 rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li>
<li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li>
<li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li>
</ul>
<p><strong>3. async/await</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br></pre></td></tr></table></figure>

<p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(func1());</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190924/M0YN5oCKtEhr.png?imageslim" alt="mark"></p>
<p>很显然，func1 的运行结果其实就是一个 Promise 对象。因此我们也可以使用 then 来处理后续逻辑。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func1().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);  <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>await 的含义为等待，也就是 async 函数需要等待 await 后的函数执行完成并且有了返回结果（Promise 对象）之后，才能继续执行下面的代码。await 通过返回一个 Promise 对象来实现同步的效果。</p>
<blockquote>
<p>更多可见 <a target="_blank" rel="noopener" href="https://github.com/sisterAn/blog/issues/21">setTimeout、Promise、Async/Await</a></p>
</blockquote>
<h3 id="第-9-题（2019-9-25）"><a href="#第-9-题（2019-9-25）" class="headerlink" title="第 9 题（2019/9/25）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/33">第 9 题</a>（2019/9/25）</h3><p><strong>题目</strong> ： Async/Await 如何通过同步的方式实现异步？</p>
<p><strong>公司</strong> ：头条、微医</p>
<p><strong>解析</strong> ： [Async/Await 如何通过同步的方式实现异步](Async/Await 如何通过同步的方式实现异步)</p>
<p>首先，<code>async/await</code> 是 <code>Generator</code> 的语法糖</p>
<p>先来看一下二者的对比：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator</span></span><br><span class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res1 = <span class="keyword">yield</span> readFile(path.resolve(__dirname, <span class="string">&#x27;../data/a.json&#x27;</span>), &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">yield</span> readFile(path.resolve(__dirname, <span class="string">&#x27;../data/b.json&#x27;</span>), &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// async/await</span></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> res1 = <span class="keyword">await</span> readFile(path.resolve(__dirname, <span class="string">&#x27;../data/a.json&#x27;</span>), &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> readFile(path.resolve(__dirname, <span class="string">&#x27;../data/b.json&#x27;</span>), &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = readFile();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，<code>async function</code> 代替了 <code>function*</code>，<code>await</code> 代替了 <code>yield</code>，同时也无需自己手写一个自动执行器 <code>run</code> 了</p>
<p>现在再来看看<code>async/await</code> 的特点：</p>
<ul>
<li>当 <code>await</code> 后面跟的是 Promise 对象时，才会异步执行，其它类型的数据会同步执行</li>
<li>执行 <code>const res = readFile();</code> 返回的仍然是个 Promise 对象，上面代码中的 <code>return &#39;done&#39;;</code> 会直接被下面 <code>then</code> 函数接收到</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// done</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-10-题（2019-9-26）"><a href="#第-10-题（2019-9-26）" class="headerlink" title="第 10 题（2019/9/26）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7">第 10 题</a>（2019/9/26）</h3><p><strong>题目类型</strong> ：异步笔试题</p>
<p><strong>公司</strong> ：头条</p>
<blockquote>
<p>请写出下面代码的运行结果</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    script start</span></span><br><span class="line"><span class="comment">    async1 start</span></span><br><span class="line"><span class="comment">    async2</span></span><br><span class="line"><span class="comment">    promise1</span></span><br><span class="line"><span class="comment">    script end</span></span><br><span class="line"><span class="comment">    async1 end</span></span><br><span class="line"><span class="comment">    promise2</span></span><br><span class="line"><span class="comment">    setTimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="第-11-题-（2019-9-26）"><a href="#第-11-题-（2019-9-26）" class="headerlink" title="第 11 题 （2019/9/26）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/8">第 11 题</a> （2019/9/26）</h3><p><strong>公司</strong> ：携程</p>
<blockquote>
<p>已知如下数组：</p>
<p>var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];</p>
<p>编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.flat(<span class="literal">Infinity</span>))).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;); <span class="comment">//使用 flat</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.toString().split(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">  .sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;)</span><br><span class="line">  .map(<span class="built_in">Number</span>); <span class="comment">//利用 toString()</span></span><br></pre></td></tr></table></figure>

<h3 id="第-12-题-（2019-9-27）"><a href="#第-12-题-（2019-9-27）" class="headerlink" title="第 12 题 （2019/9/27）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/11">第 12 题</a> （2019/9/27）</h3><p><strong>题目：</strong> JS 异步解决方案的发展历程以及优缺点。</p>
<p><strong>公司</strong> ：滴滴、挖财、微医、海康</p>
<p><strong>解析：</strong></p>
<ol>
<li><strong>回调函数（callback）</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// callback 函数体</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：回调地狱，不能用 try catch 捕获错误，不能 return</p>
<p>回调地狱的根本问题在于：</p>
<ul>
<li>缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符</li>
<li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（<strong>控制反转</strong>）</li>
<li>嵌套函数过多的多话，很难处理错误</li>
</ul>
<p><strong>优点</strong> ：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）</p>
<ol start="2">
<li><strong>Promise</strong></li>
</ol>
<p>Promise 就是为了解决 callback 的问题而产生的。</p>
<p>Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装</p>
<p><strong>优点</strong> ：解决了回调地狱的问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">&quot;XXX1&quot;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 操作逻辑</span></span><br><span class="line">    <span class="keyword">return</span> ajax(<span class="string">&quot;XXX2&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 操作逻辑</span></span><br><span class="line">    <span class="keyword">return</span> ajax(<span class="string">&quot;XXX3&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 操作逻辑</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong> ：无法取消 Promise ，错误需要通过回调函数来捕获</p>
<ol start="3">
<li><strong>Generato</strong></li>
</ol>
<p><strong>特点</strong> ：可以控制函数的执行，可以配合 co 函数库使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> ajax(<span class="string">&quot;XXX1&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">  <span class="keyword">yield</span> ajax(<span class="string">&quot;XXX2&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">  <span class="keyword">yield</span> ajax(<span class="string">&quot;XXX3&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = fetch();</span><br><span class="line"><span class="keyword">let</span> result1 = it.next();</span><br><span class="line"><span class="keyword">let</span> result2 = it.next();</span><br><span class="line"><span class="keyword">let</span> result3 = it.next();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>Async/await</strong></li>
</ol>
<p>async、await 是异步的终极解决方案</p>
<p><strong>优点</strong>：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题</p>
<p><strong>缺点</strong>：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式</span></span><br><span class="line">  <span class="comment">// 如果有依赖性的话，其实就是解决回调地狱的例子了</span></span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">&quot;XXX1&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">&quot;XXX2&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">&quot;XXX3&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来看一个使用 <code>await</code> 的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + (<span class="keyword">await</span> <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>, a); <span class="comment">// -&gt; &#x27;2&#x27; 10</span></span><br><span class="line">&#125;;</span><br><span class="line">b();</span><br><span class="line">a++;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>, a); <span class="comment">// -&gt; &#x27;1&#x27; 1</span></span><br></pre></td></tr></table></figure>

<p>对于以上代码你可能会有疑惑，让我来解释下原因</p>
<ul>
<li>首先函数 <code>b</code> 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 0，因为 <code>await</code> 内部实现了 <code>generator</code> ，<strong>generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来</strong></li>
<li>因为 <code>await</code> 是异步操作，后来的表达式不返回 <code>Promise</code> 的话，就会包装成 <code>Promise.reslove(返回值)</code>，然后会去执行函数外的同步代码</li>
<li>同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 0 + 10</code></li>
</ul>
<p>上述解释中提到了 <code>await</code> 内部实现了 <code>generator</code>，其实 <code>await</code> 就是 <code>generator</code> 加上 <code>Promise</code>的语法糖，且内部实现了自动执行 <code>generator</code>。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。</p>
<h3 id="第-13-题-（2019-9-28）"><a href="#第-13-题-（2019-9-28）" class="headerlink" title="第 13 题 （2019/9/28）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/19">第 13 题</a> （2019/9/28）</h3><p><strong>题目</strong> ：Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？</p>
<p><strong>公司</strong> ：微医</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">看过 Event Loop 基础原理的就明白，Promise构造函数是同步执行，而 .then .catch .啥啥的是异步（还有process.nextTick等等，大家可以查），</span><br><span class="line">而且放到了微队列中，async/await 中，await 前面的是同步，await 后面的是异步，写法上是这样，但是其实是 语法糖，最后还会转为 Promise.then的形式</span><br><span class="line"></span><br><span class="line">.then()当然是同步执行，只不过是.then的cb被放入了微任务队列，产生了异步执行</span><br><span class="line"></span><br><span class="line">promise是微观任务，setTimeout是宏观任务，先执行微观任务，在执行宏观任务；微观任务里，先执行同步再执行异步</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-14-题-（2019-9-29）"><a href="#第-14-题-（2019-9-29）" class="headerlink" title="第 14 题 （2019/9/29）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/12">第 14 题</a> （2019/9/29）</h3><p><strong>题目</strong> ：情人节福利题，如何实现一个 new ？</p>
<p><strong>公司</strong>：兑吧</p>
<p><strong>解析</strong> ： <a target="_blank" rel="noopener" href="https://alexzhong22c.github.io/2017/08/12/js-new-happen/#%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%BB%93%E6%9E%9C%E8%A7%A3%E6%9E%90">new 创建对象的过程发生了什么</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 的作用</span></span><br><span class="line"><span class="comment">// 创建一个新对象obj</span></span><br><span class="line"><span class="comment">// 把obj的__proto__指向Dog.prototype 实现继承</span></span><br><span class="line"><span class="comment">// 执行构造函数，传递参数，改变this指向 Dog.call(obj, ...args)</span></span><br><span class="line"><span class="comment">// 最后把obj赋值给sanmao</span></span><br><span class="line"><span class="keyword">var</span> _new = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">constructor</span> = Array.prototype.shift.call(arguments);</span><br><span class="line">  let args = arguments;</span><br><span class="line">  const obj = new Object();</span><br><span class="line">  obj.__proto__ = <span class="keyword">constructor</span>.prototype;</span><br><span class="line">  <span class="keyword">constructor</span>.call(obj, ...args);</span><br><span class="line">  return obj;</span><br><span class="line">&#125;;</span><br><span class="line">var simao = _new(Dog, &quot;simao&quot;);</span><br><span class="line">simao.bark();</span><br><span class="line">simao.sayName();</span><br><span class="line">console.log(simao instanceof Dog); // true</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样写是不是简单点啊</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">fn, ...arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">  <span class="keyword">const</span> ret = fn.apply(obj, arg);</span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-15-题-（2019-9-30）"><a href="#第-15-题-（2019-9-30）" class="headerlink" title="第 15 题 （2019/9/30）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/14">第 15 题</a> （2019/9/30）</h3><p><strong>题目</strong> ：简单讲解一下 http2 的多路复用</p>
<p><strong>公司</strong>：网易</p>
<p><strong>解析</strong> ：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在 HTTP/1 中，每次请求都会建立一次HTTP连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：</span><br><span class="line"></span><br><span class="line">    第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）</span><br><span class="line"></span><br><span class="line">    第二个：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。</span><br><span class="line"></span><br><span class="line">HTTP/2的多路复用就是为了解决上述的两个性能问题。</span><br><span class="line">在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。</span><br><span class="line">帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</span><br><span class="line">多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-16-题-（2019-10-01）"><a href="#第-16-题-（2019-10-01）" class="headerlink" title="第 16 题 （2019/10/01）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/15">第 16 题</a> （2019/10/01）</h3><p><strong>题目</strong> ：谈谈你对 TCP 三次握手和四次挥手的理解</p>
<p><strong>解析</strong> ：<a target="_blank" rel="noopener" href="https://juejin.im/post/5ccd0dfc6fb9a0324a08bb73">关于三次握手与四次挥手面试官想考我们什么？— 不看后悔系列</a></p>
<p>三次握手：</p>
<ol>
<li>第一次握手：客户端给服务器发送一个 SYN 报文。</li>
<li>第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。</li>
<li>第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。</li>
<li>服务器收到 ACK 报文之后，三次握手建立完成。</li>
</ol>
<blockquote>
<p><strong>这里我顺便解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以</strong>：<br>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。<br>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>
</blockquote>
<p>四次挥手:</p>
<ol>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于<strong>FIN_WAIT1</strong>状态。</li>
<li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <strong>CLOSE_WAIT</strong>状态。</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <strong>LAST_ACK</strong> 的状态。</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 <strong>TIME_WAIT</strong> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li>
<li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li>
</ol>
<p>这里特别需要主要的就是<strong>TIME_WAIT</strong>这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p>
<p>至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p>
<h3 id="第-17-题-（2019-10-08）"><a href="#第-17-题-（2019-10-08）" class="headerlink" title="第 17 题 （2019/10/08）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/21">第 17 题</a> （2019/10/08）</h3><p><strong>题目</strong> ： A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态 ？</p>
<blockquote>
<p>如果 A 与 B 建立了正常连接后，从未相互发过数据，这个时候 B 突然机器重启，问 A 此时处于 TCP 什么状态？如何消除服务器程序中的这个状态？（超纲题，了解即可）</p>
</blockquote>
<h3 id="第-18-题-（2019-10-08）"><a href="#第-18-题-（2019-10-08）" class="headerlink" title="第 18 题 （2019/10/08）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/17">第 18 题</a> （2019/10/08）</h3><p><strong>题目</strong> ：React 中 setState 什么时候是同步的，什么时候是异步的？</p>
<p><strong>公司</strong> ：微医 <a target="_blank" rel="noopener" href="https://juejin.im/post/5ac1aaad6fb9a028d444bb87">React 中 setState 真的是异步的吗</a></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.在组件生命周期中或者react事件绑定中，setState是通过异步更新的。</span><br><span class="line">2.在延时的回调或者原生事件绑定的回调中调用setState不一定是异步的。</span><br><span class="line">这个结果并不说明setState异步执行的说法是错误的，更加准确的说法应该是setState不能保证同步执行。</span><br><span class="line">Dan Abramov也多次提到今后会将setState彻底改造为异步的，从js conf中提到的suspend新特新也印证了这一点。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里所说的同步异步，并非真正的同步异步，通常是同步执行的。</span><br><span class="line">这里的异步指的是多个状态会合成到一起进行批量更新。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-19-题-（2019-10-08）"><a href="#第-19-题-（2019-10-08）" class="headerlink" title="第 19 题  （2019/10/08）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/18">第 19 题 </a> （2019/10/08）</h3><p><strong>题目</strong> ：React setState 笔试题，下面的代码输出什么？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      val: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">val</span>: <span class="built_in">this</span>.state.val + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.val); <span class="comment">// 第 1 次 log</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">val</span>: <span class="built_in">this</span>.state.val + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.val); <span class="comment">// 第 2 次 log</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123; <span class="attr">val</span>: <span class="built_in">this</span>.state.val + <span class="number">1</span> &#125;);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.val); <span class="comment">// 第 3 次 log</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.setState(&#123; <span class="attr">val</span>: <span class="built_in">this</span>.state.val + <span class="number">1</span> &#125;);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.val); <span class="comment">// 第 4 次 log</span></span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、第一次和第二次都是在 react 自身生命周期内，触发时 isBatchingUpdates 为 <span class="literal">true</span>，所以并不会直接执行更新 state，而是加入了 dirtyComponents，所以打印时获取的都是更新前的状态 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、两次 setState 时，获取到 <span class="built_in">this</span>.state.val 都是 <span class="number">0</span>，所以执行时都是将 <span class="number">0</span> 设置成 <span class="number">1</span>，在 react 内部会被合并掉，只执行一次。设置完成后 state.val 值为 <span class="number">1</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、<span class="built_in">setTimeout</span> 中的代码，触发时 isBatchingUpdates 为 <span class="literal">false</span>，所以能够直接进行更新，所以连着输出 <span class="number">2</span>，<span class="number">3</span>。</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出： 0 0 2 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-20-题-（2019-10-09）"><a href="#第-20-题-（2019-10-09）" class="headerlink" title="第 20 题  （2019/10/09）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/22">第 20 题 </a> （2019/10/09）</h3><p><strong>题目</strong> ：介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？</p>
<p><strong>解析</strong> ：</p>
<p><strong>1、npm 模块安装机制：</strong></p>
<ul>
<li>发出<code>npm install</code>命令</li>
<li>查询 node_modules 目录之中是否已经存在指定模块<ul>
<li>若存在，不再重新安装</li>
<li>若不存在<ul>
<li>npm 向 registry 查询模块压缩包的网址</li>
<li>下载压缩包，存放在根目录下的<code>.npm</code>目录里</li>
<li>解压压缩包到当前项目的<code>node_modules</code>目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>2、npm 实现原理</strong></p>
<p>输入 npm install 命令并敲下回车后，会经历如下几个阶段（以 npm 5.5.1 为例）：</p>
<ol>
<li><strong>执行工程自身 preinstall</strong></li>
</ol>
<p>当前 npm 工程如果定义了 preinstall 钩子此时会被执行。</p>
<ol start="2">
<li><strong>确定首层依赖模块</strong></li>
</ol>
<p>首先需要做的是确定工程中的首层依赖，也就是 dependencies 和 devDependencies 属性中直接指定的模块（假设此时没有添加 npm install 参数）。</p>
<p>工程本身是整棵依赖树的根节点，每个首层依赖模块都是根节点下面的一棵子树，npm 会开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点。</p>
<ol start="3">
<li><strong>获取模块</strong></li>
</ol>
<p>获取模块是一个递归的过程，分为以下几步：</p>
<ul>
<li>获取模块信息。在下载一个模块之前，首先要确定其版本，这是因为 package.json 中往往是 semantic version（semver，语义化版本）。此时如果版本描述文件（npm-shrinkwrap.json 或 package-lock.json）中有该模块信息直接拿即可，如果没有则从仓库获取。如 packaeg.json 中某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。</li>
<li>获取模块实体。上一步会获取到模块的压缩包地址（resolved 字段），npm 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。</li>
<li>查找该模块依赖，如果有依赖则回到第 1 步，如果没有则停止。</li>
</ul>
<ol start="4">
<li><strong>模块扁平化（dedupe）</strong></li>
</ol>
<p>上一步获取到的是一棵完整的依赖树，其中可能包含大量重复模块。比如 A 模块依赖于 loadsh，B 模块同样依赖于 lodash。在 npm3 以前会严格按照依赖树的结构进行安装，因此会造成模块冗余。</p>
<p>从 npm3 开始默认加入了一个 dedupe 的过程。它会遍历所有节点，逐个将模块放在根节点下面，也就是 node-modules 的第一层。当发现有<strong>重复模块</strong>时，则将其丢弃。</p>
<p>这里需要对<strong>重复模块</strong>进行一个定义，它指的是<strong>模块名相同</strong>且 <strong>semver 兼容。每个 semver 都对应一段版本允许范围，如果两个模块的版本允许范围存在交集，那么就可以得到一个兼容</strong>版本，而不必版本号完全一致，这可以使更多冗余模块在 dedupe 过程中被去掉。</p>
<p>比如 node-modules 下 foo 模块依赖 lodash@^1.0.0，bar 模块依赖 lodash@^1.1.0，则 <strong>^1.1.0</strong> 为兼容版本。</p>
<p>而当 foo 依赖 lodash@^2.0.0，bar 依赖 lodash@^1.1.0，则依据 semver 的规则，二者不存在兼容版本。会将一个版本放在 node_modules 中，另一个仍保留在依赖树里。</p>
<p>举个例子，假设一个依赖树原本是这样：</p>
<p>node_modules<br>– foo<br>—- lodash@version1</p>
<p>– bar<br>—- lodash@version2</p>
<p>假设 version1 和 version2 是兼容版本，则经过 dedupe 会成为下面的形式：</p>
<p>node_modules<br>– foo</p>
<p>– bar</p>
<p>– lodash（保留的版本为兼容版本）</p>
<p>假设 version1 和 version2 为非兼容版本，则后面的版本保留在依赖树中：</p>
<p>node_modules<br>– foo<br>– lodash@version1</p>
<p>– bar<br>—- lodash@version2</p>
<ol start="5">
<li><strong>安装模块</strong></li>
</ol>
<p>这一步将会更新工程中的 node_modules，并执行模块中的生命周期函数（按照 preinstall、install、postinstall 的顺序）。</p>
<ol start="6">
<li><strong>执行工程自身生命周期</strong></li>
</ol>
<p>当前 npm 工程如果定义了钩子此时会被执行（按照 install、postinstall、prepublish、prepare 的顺序）。</p>
<p>最后一步是生成或更新版本描述文件，npm install 过程完成。</p>
<p>参考 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/01/npm-install.html">npm 模块安装机制简介</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bbsmax.com/A/qVdemmnEdP/">详解 npm 的模块安装机制</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/66629910">npm install 的实现原理</a></p>
<h3 id="第-21-题-（2019-10-10）"><a href="#第-21-题-（2019-10-10）" class="headerlink" title="第 21 题 （2019/10/10）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/23">第 21 题</a> （2019/10/10）</h3><p><strong>题目：</strong> 有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣</p>
<blockquote>
<p>Object.prototype.toString.call() 、 instanceof 以及 Array.isArray()</p>
</blockquote>
<p><strong>解析：</strong></p>
<p><strong>1、Object.prototype.toString.call()</strong></p>
<p>每一个继承 Object 的对象都有 <code>toString</code> 方法，如果 <code>toString</code> 方法没有重写的话，会返回 <code>[Object type]</code>，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 <code>toString</code> 方法时，会直接返回都是内容的字符串，所以我们需要使用 call 或者 apply 方法来改变 toString 方法的执行上下文。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> an = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;An&quot;</span>];</span><br><span class="line">an.toString(); <span class="comment">// &quot;Hello,An&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(an); <span class="comment">// &quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure>

<p>这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&quot;An&quot;</span>); <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>); <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>(<span class="number">1</span>)); <span class="comment">// &quot;[object Symbol]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>); <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;); <span class="comment">// &quot;[object Function]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123; <span class="attr">name</span>: <span class="string">&quot;An&quot;</span> &#125;); <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Object.prototype.toString.call()</code> 常用于判断浏览器内置对象时。</p>
<p>更多实现可见 <a target="_blank" rel="noopener" href="https://juejin.im/post/591647550ce4630069df1c4a">谈谈 Object.prototype.toString</a></p>
<p><strong>2、instanceof</strong></p>
<p><code>instanceof</code> 的内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code>。</p>
<p>使用 <code>instanceof</code>判断一个对象是否为数组，<code>instanceof</code> 会判断这个对象的原型链上是否会找到对应的 <code>Array</code> 的原型，找到返回 <code>true</code>，否则返回 <code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但 <code>instanceof</code> 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>3、Array.isArray()</strong></p>
<ul>
<li><p>功能：用来判断对象是否为数组</p>
</li>
<li><p>instanceof 与 isArray</p>
<p>当检测 Array 实例时，<code>Array.isArray</code> 优于 <code>instanceof</code> ，因为 <code>Array.isArray</code> 可以检测出 <code>iframes</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">xArray = <span class="built_in">window</span>.frames[<span class="built_in">window</span>.frames.length - <span class="number">1</span>].Array;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> xArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Correctly checking for Array</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Considered harmful, because doesn&#x27;t work though iframes</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.isArray()</code> 与 <code>Object.prototype.toString.call()</code></p>
<p><code>Array.isArray()</code>是 ES5 新增的方法，当不存在 <code>Array.isArray()</code> ，可以用 <code>Object.prototype.toString.call()</code> 实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (!Array.isArray) &#123;</span><br><span class="line">  Array.isArray &#x3D; function(arg) &#123;</span><br><span class="line">    return Object.prototype.toString.call(arg) &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="第-22-题-（2019-10-11）"><a href="#第-22-题-（2019-10-11）" class="headerlink" title="第 22 题 （2019/10/11）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24">第 22 题</a> （2019/10/11）</h3><p><strong>题目：</strong> 介绍下重绘和回流（Repaint &amp; Reflow），以及如何进行优化？</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://juejin.im/post/5a9923e9518825558251c96a">浏览器的回流与重绘 (Reflow &amp; Repaint)</a></p>
<p><strong>1、浏览器渲染机制</strong></p>
<ul>
<li>浏览器采用流式布局模型（<code>Flow Based Layout</code>）</li>
<li>浏览器会把<code>HTML</code>解析成<code>DOM</code>，把<code>CSS</code>解析成<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并就产生了渲染树（<code>Render Tree</code>）。</li>
<li>有了<code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</li>
<li>由于浏览器使用流式布局，对<code>Render Tree</code>的计算通常只需要遍历一次就可以完成，<strong>但 table 及其内部元素除外，他们可能需要多次计算，通常要花 3 倍于同等元素的时间，这也是为什么要避免使用 table 布局的原因之一</strong>。</li>
</ul>
<p><strong>2、重绘</strong></p>
<p>由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如<code>outline</code>, <code>visibility</code>, <code>color</code>、<code>background-color</code>等，重绘的代价是高昂的，因为浏览器必须验证 DOM 树上其他节点元素的可见性。</p>
<p><strong>3、回流</strong></p>
<p>回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及 DOM 中紧随其后的节点、祖先节点元素的随后的回流。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;error&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>我的组件<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>错误：<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>错误的描述…<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>错误纠正<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一步<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二步<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的 HTML 片段中，对该段落(<code>&lt;p&gt;</code>标签)回流将会引发强烈的回流，因为它是一个子节点。这也导致了祖先的回流（<code>div.error</code>和<code>body</code> – 视浏览器而定）。此外，<code>&lt;h5&gt;</code>和<code>&lt;ol&gt;</code>也会有简单的回流，因为其在 DOM 中在回流元素之后。<strong>大部分的回流将导致页面的重新渲染。</strong></p>
<p><strong>回流必定会发生重绘，重绘不一定会引发回流。</strong></p>
<p><strong>4、浏览器优化</strong></p>
<p>现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即 16.6ms）才会清空队列，但当你<strong>获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值</strong>。</p>
<p>主要包括以下属性或方法：</p>
<ul>
<li><code>offsetTop</code>、<code>offsetLeft</code>、<code>offsetWidth</code>、<code>offsetHeight</code></li>
<li><code>scrollTop</code>、<code>scrollLeft</code>、<code>scrollWidth</code>、<code>scrollHeight</code></li>
<li><code>clientTop</code>、<code>clientLeft</code>、<code>clientWidth</code>、<code>clientHeight</code></li>
<li><code>width</code>、<code>height</code></li>
<li><code>getComputedStyle()</code></li>
<li><code>getBoundingClientRect()</code></li>
</ul>
<p>所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列<strong>。</strong></p>
<p><strong>5、减少重绘与回流</strong></p>
<ol>
<li><p>CSS</p>
<ul>
<li><p><strong>使用 transform 替代 top</strong></p>
</li>
<li><p><strong>使用 visibility 替换 display: none</strong> ，因为前者只会引起重绘，后者会引发回流（改变了布局</p>
</li>
<li><p><strong>避免使用 table 布局</strong>，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局。</p>
</li>
<li><p><strong>尽可能在 DOM 树的最末端改变 class</strong>，回流是不可避免的，但可以减少其影响。尽可能在 DOM 树的最末端改变 class，可以限制了回流的范围，使其影响尽可能少的节点。</p>
</li>
<li><p><strong>避免设置多层内联样式</strong>，CSS 选择符<strong>从右往左</strong>匹配查找，避免节点层级过多。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  span &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">  div &gt; a &gt; span &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 <code>span</code> 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 <code>span</code> 标签，然后找到 <code>span</code> 标签上的 <code>a</code> 标签，最后再去找到 <code>div</code> 标签，然后给符合这种条件的 <code>span</code> 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写<strong>过于具体</strong>的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证<strong>层级扁平</strong>。</p>
</li>
<li><p><strong>将动画效果应用到 position 属性为 absolute 或 fixed 的元素上</strong>，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 <code>requestAnimationFrame</code>，详见<a target="_blank" rel="noopener" href="https://github.com/LuNaHaiJiao/blog/issues/30">探讨 requestAnimationFrame</a>。</p>
</li>
<li><p><strong>避免使用 CSS 表达式</strong>，可能会引发回流。</p>
</li>
<li><p><strong>将频繁重绘或者回流的节点设置为图层</strong>，图层能够阻止该节点的渲染行为影响别的节点，例如<code>will-change</code>、<code>video</code>、<code>iframe</code>等标签，浏览器会自动将该节点变为图层。</p>
</li>
<li><p><strong>CSS3 硬件加速（GPU 加速）</strong>，使用 css3 硬件加速，可以让<code>transform</code>、<code>opacity</code>、<code>filters</code>这些动画不会引起回流重绘 。但是对于动画的其它属性，比如<code>background-color</code>这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</p>
</li>
</ul>
</li>
<li><p>JavaScript</p>
<ul>
<li><strong>避免频繁操作样式</strong>，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li>
<li><strong>避免频繁操作 DOM</strong>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM操作</code>，最后再把它添加到文档中。</li>
<li><strong>避免频繁读取会引发回流/重绘的属性</strong>，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li><strong>对具有复杂动画的元素使用绝对定位</strong>，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
</li>
</ol>
<p>详见<a target="_blank" rel="noopener" href="https://github.com/sisterAn/blog/issues/33">浏览器的重绘与回流（Repaint、Reflow）</a></p>
<h3 id="第-23-题-（2019-10-12）"><a href="#第-23-题-（2019-10-12）" class="headerlink" title="第 23 题 （2019/10/12）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/25">第 23 题 </a>（2019/10/12）</h3><p><strong>题目：</strong> 介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景</p>
<p><strong>解析：</strong></p>
<p>我们先来看下这两个模式的实现结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20190329182209470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmODcyOTE0MzM0,size_16,color_FFFFFF,t_70"></p>
<p>观察者模式： 观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。</p>
<p>发布订阅模式： 订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Topic），当发布者（Publisher）发布该事件（Publish topic）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。</p>
<p><strong>区别：</strong></p>
<p>观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心。</p>
<p>观察者模式由具体目标调度，每个被订阅的目标里面都需要有对观察者的处理，这种处理方式比较直接粗暴，但是会造成代码的冗余。</p>
<p>而发布订阅模式中统一由调度中心进行处理，订阅者和发布者互不干扰，消除了发布者和订阅者之间的依赖。这样一方面实现了解耦，还有就是可以实现更细粒度的一些控制。比如发布者发布了很多消息，但是不想所有的订阅者都接收到，就可以在调度中心做一些处理，类似于权限控制之类的。还可以做一些节流操作。</p>
<p><strong>观察者模式是不是发布订阅模式</strong></p>
<p>网上关于这个问题的回答，出现了两极分化，有认为发布订阅模式就是观察者模式的，也有认为观察者模式和发布订阅模式是真不一样的。</p>
<p>其实我不知道发布订阅模式是不是观察者模式，就像我不知道辨别模式的关键是设计意图还是设计结构（理念），虽然《JavaScript 设计模式与开发实践》一书中说了分辨模式的关键是意图而不是结构。</p>
<p>如果以结构来分辨模式，发布订阅模式相比观察者模式多了一个中间件订阅器，所以发布订阅模式是不同于观察者模式的；如果以意图来分辨模式，他们都是实现了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新，那么他们就是同一种模式，发布订阅模式是在观察者模式的基础上做的优化升级。</p>
<p>不过，不管他们是不是同一个设计模式，他们的实现方式确实有差别，我们在使用的时候应该根据场景来判断选择哪个。</p>
<h3 id="第-24-题-（2019-10-13）"><a href="#第-24-题-（2019-10-13）" class="headerlink" title="第 24 题 （2019/10/13）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/45">第 24 题</a> （2019/10/13）</h3><p><strong>题目：</strong> 聊聊 Redux 和 Vuex 的设计思想</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://juejin.im/post/5b6d75dce51d4533d20487b0">关于 Flux,Vuex,Redux 的思考</a> <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/01/flux.html">Flux 架构入门教程</a></p>
<p>Flux 是一种前端状态管理架构思想，专门解决软件的结构问题。<br>基于 Flux 的设计思想，出现了一批前端状态管理框架。<br>他们给出了一些库用于实现 Flux 的思想，并在 Flux 的基础上做了一些改进。<br>在这些框架里，当前最热门的莫过于 Redux 和 Vuex 了</p>
<p><strong>Flux</strong></p>
<p>Flux 数据流的顺序是:</p>
<p>View 发起 Action-&gt;Action 传递到 Dispatcher-&gt;Dispatcher 将通知 Store-&gt;Store 的状态改变通知 View 进行改变</p>
<p><strong>Redux</strong></p>
<p>Redux 相对于 Flux 的改进：</p>
<ul>
<li>把 store 和 Dispatcher 合并,结构更加简单清晰</li>
<li>新增 state 角色，代表每个时间点 store 对应的值，对状态的管理更加明确</li>
</ul>
<p>Redux 数据流的顺序是:</p>
<p>View 调用 store.dispatch 发起 Action-&gt;store 接受 Action(action 传入 reducer 函数,reducer 函数返回一个新的 state)-&gt;通知 store.subscribe 订阅的重新渲染函数</p>
<p>ps:<a href="https://link.juejin.im/?target=https://github.com/reactjs/redux/tree/master/examples/counter">阮一峰老师的 Redux+React 小 demo</a></p>
<p><strong>Vuex</strong></p>
<p>Vuex 是专门为 Vue 设计的状态管理框架,<br>同样基于 Flux 架构，并吸收了 Redux 的优点</p>
<p>Vuex 相对于 Redux 的不同点有:</p>
<ul>
<li>改进了 Redux 中的 Action 和 Reducer 函数，以 mutations 变化函数取代 Reducer，<br>无需 switch,只需在对应的 mutation 函数里改变 state 值即可</li>
<li>由于 Vue 自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的 State 即可</li>
</ul>
<p>Vuex 数据流的顺序是:</p>
<p>View 调用 store.commit 提交对应的请求到 Store 中对应的 mutation 函数-&gt;store 改变(vue 检测到数据变化自动渲染)</p>
<h3 id="第-25-题-（2019-10-14）"><a href="#第-25-题-（2019-10-14）" class="headerlink" title="第 25 题 （2019/10/14）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/26">第 25 题</a> （2019/10/14）</h3><p><strong>题目：</strong> 说说浏览器和 Node 事件循环的区别</p>
<p><strong>解析：</strong></p>
<p><strong>浏览器</strong></p>
<p><strong>关于微任务和宏任务在浏览器的执行顺序是这样的：</strong></p>
<ul>
<li>执行一只 task（宏任务）</li>
<li>执行完 micro-task 队列 （微任务）</li>
</ul>
<p>如此循环往复下去</p>
<blockquote>
<p>浏览器的 task（宏任务）执行顺序在 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">html#event-loops</a> 里面有讲就不翻译了<br>常见的 task（宏任务） 比如：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。<br>常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5 新特性) 等。</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/10/1683863633586974?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p><strong>Node</strong></p>
<p>Node 的事件循环是 libuv 实现的，引用一张官网的图：</p>
<p><img src="https://user-images.githubusercontent.com/20101525/53734427-eba9e880-3ebe-11e9-8511-eb4948e336ae.png"></p>
<p>大体的 task（宏任务）执行顺序是这样的：</p>
<ul>
<li>timers 定时器：本阶段执行已经安排的 setTimeout() 和 setInterval() 的回调函数。</li>
<li>pending callbacks 待定回调：执行延迟到下一个循环迭代的 I/O 回调。</li>
<li>idle, prepare：仅系统内部使用。</li>
<li>poll 轮询：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate() 排定的之外），其余情况 node 将在此处阻塞。</li>
<li>check 检测：setImmediate() 回调函数在这里执行。</li>
<li>close callbacks 关闭的回调函数：一些准备关闭的回调函数，如：socket.on(‘close’, …)。</li>
</ul>
<p><strong>微任务和宏任务在 Node 的执行顺序</strong></p>
<p>Node 10 以前：</p>
<ul>
<li>执行完一个阶段的所有任务</li>
<li>执行完 nextTick 队列里面的内容</li>
<li>然后执行完微任务队列的内容</li>
</ul>
<p>Node 11 以后：<br>和浏览器的行为统一了，都是每执行一个宏任务就执行完微任务队列</p>
<h3 id="第-26-题-（2019-10-16）"><a href="#第-26-题-（2019-10-16）" class="headerlink" title="第 26 题 （2019/10/16）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/28">第 26 题</a> （2019/10/16）</h3><p><strong>题目：</strong> 介绍模块化发展历程</p>
<blockquote>
<p>可从 IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module、<code>&lt;script type=&quot;module&quot;&gt;</code> 这几个角度考虑。</p>
</blockquote>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5c8409bbe4b02b2ce492286a">es6,amd,smd,commonjs 思维导图</a></p>
<p>模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。</p>
<p><strong>IIFE</strong>： 使用自执行函数来编写模块化，特点：<strong>在一个单独的函数作用域中执行代码，避免变量冲突</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    data: [],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>AMD</strong>： 使用 requireJS 来编写模块化，特点：<strong>依赖必须提前声明好</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">&quot;./index.js&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// code 就是index.js 返回的内容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>CMD</strong>： 使用 seaJS 来编写模块化，特点：<strong>支持动态引入依赖文件</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> indexCode = <span class="built_in">require</span>(<span class="string">&quot;./index.js&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>CommonJS</strong>： nodejs 中自带的模块化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>UMD</strong>：兼容 AMD，CommonJS 模块化语法。</p>
<p>**webpack(require.ensure)**：webpack 2.x 版本中的代码分割。</p>
<p><strong>ES Modules</strong>： ES6 引入的模块化，支持 import 来引入另一个 js 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="第-27-题-（2019-10-16）"><a href="#第-27-题-（2019-10-16）" class="headerlink" title="第 27 题 （2019/10/16）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/30">第 27 题</a> （2019/10/16）</h3><p><strong>题目：</strong> 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？。</p>
<p><strong>解析：</strong></p>
<p>在 ES5 中，顶层对象的属性和全局变量是等价的，var 命令和 function 命令声明的全局变量，自然也是顶层对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.f); <span class="comment">// f()&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>但 ES6 规定，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，但 let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> bb = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.aa); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.bb); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>在函数的内部属性<code>[[Scopes]]</code>中找到了</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/8/1678e8be5c831804?imageslim"></p>
<blockquote>
<p>如上图，在全局作用域中用<code>const</code>声明的变量在函数<code>noop</code>中可以正常访问，没有问题。我用<code>dir</code>方法打印出函数<code>noop</code>的属性，最后在<code>[[Scopes]]</code>属性内找到了消失的全局变量<code>abcd</code>。</p>
</blockquote>
<h3 id="第-28-题-（2019-10-17）"><a href="#第-28-题-（2019-10-17）" class="headerlink" title="第 28 题 （2019/10/17）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/31">第 28 题</a> （2019/10/17）</h3><p><strong>题目：</strong> cookie 和 token 都存放在 header 中，为什么不会劫持 token？</p>
<p><strong>解析：</strong></p>
<ol>
<li>首先 token 不是防止 XSS 的，而是为了防止 CSRF 的；</li>
<li>CSRF 攻击的原因是浏览器会自动带上 cookie，而浏览器不会自动带上 token</li>
</ol>
<hr>
<blockquote>
<p>cookie：登陆后后端生成一个 sessionid 放在 cookie 中返回给客户端，并且服务端一直记录着这个 sessionid，客户端以后每次请求都会带上这个 sessionid，服务端通过这个 sessionid 来验证身份之类的操作。所以别人拿到了 cookie 拿到了 sessionid 后，就可以完全替代你。</p>
</blockquote>
<blockquote>
<p>token：登陆后后端不返回一个 token 给客户端，客户端将这个 token 存储起来，然后每次客户端请求都需要开发者手动将 token 放在 header 中带过去，服务端每次只需要对这个 token 进行验证就能使用 token 中的信息来进行下一步操作了。</p>
</blockquote>
<blockquote>
<p>xss：用户通过各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本获取信息，发起请求，之类的操作。</p>
</blockquote>
<blockquote>
<p>csrf：跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了 web 中用户身份验证的一个漏洞：<strong>简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的</strong>。csrf 并不能够拿到用户的任何信息，它只是欺骗用户浏览器，让其以用户的名义进行操作。</p>
</blockquote>
<blockquote>
<p>csrf 例子：假如一家银行用以运行转账操作的 URL 地址如下： <a target="_blank" rel="noopener" href="http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</a><br>那么，一个恶意攻击者可以在另一个网站上放置如下代码： <code>&lt;img src=&quot;&lt;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&gt;&quot;&gt;</code><br>如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 资金。</p>
</blockquote>
<p>上面的两种攻击方式，如果被 xss 攻击了，不管是 token 还是 cookie，都能被拿到，所以对于 xss 攻击来说，cookie 和 token 没有什么区别。但是对于 csrf 来说就有区别了。</p>
<p>以上面的 csrf 攻击为例：</p>
<ul>
<li>cookie：用户点击了链接，cookie 未失效，导致发起请求后后端以为是用户正常操作，于是进行扣款操作。</li>
<li>token：用户点击链接，由于浏览器不会自动带上 token，所以即使发了请求，后端的 token 验证不会通过，所以不会进行扣款操作。</li>
</ul>
<p>这是个人理解的为什么只劫持 cookie 不劫持 token 的原因。</p>
<h3 id="第-29-题-（2019-10-17）"><a href="#第-29-题-（2019-10-17）" class="headerlink" title="第 29 题  （2019/10/17）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/34">第 29 题 </a> （2019/10/17）</h3><p><strong>题目：</strong> 聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的</p>
<p><strong>解析：</strong></p>
<p>VM 主要做了两件微小的事情：</p>
<ul>
<li>从 M 到 V 的映射（Data Binding），这样可以大量节省你人肉来 update View 的代码（将数据绑定到 view）</li>
<li>从 V 到 M 的事件监听（DOM Listeners），这样你的 Model 会随着 View 触发事件而改变 （view 改变的时候改变数据）</li>
</ul>
<p><strong>1、M 到 V 实现</strong></p>
<p>做到这件事的第一步是形成类似于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template</span></span><br><span class="line"><span class="keyword">var</span> tpl = <span class="string">&#x27;&lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">// data</span></span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">text: ‘This is some text‘</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// magic process</span></span><br><span class="line">template(tpl, data); <span class="comment">// &#x27;&lt;p&gt;This is some text&lt;/p&gt;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>中间的 magic process 是模板引擎所做的事情，已经有非常多种模板引擎可供选择</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://developer.mozilla.org/en/docs/JavaScript_templates">JavaScript templates</a></li>
</ul>
<p>当然你比较喜欢造轮子的话也可以自己实现一个</p>
<ul>
<li><a href="https://link.zhihu.com/?target=http://kyleslight.net/article/27">一个 JavaScript 模板引擎的实现</a></li>
</ul>
<p>无论是 Angular 的 $scope，React 的 state 还是 Vue 的 data 都提供了一个较为核心的 model 对象用来保存模型的状态；它们的模板引擎稍有差别，不过大体思路相似；拿到渲染后的 string 接下来做什么不言而喻了（中间还有很多处理，例如利用 model 的 diff 来最小量更新 view ）。</p>
<p>但是仅仅是这样并不够，我们需要知道什么时候来更新 view（ 即 render ），一般来说主要的 VM 做了以下几种选择：</p>
<ul>
<li>VM 实例初始化时</li>
<li>model 动态修改时</li>
</ul>
<p>其中初始化拿到 model 对象然后 render 没什么好讲的；model 被修改的时候如何监听属性的改变是一个问题，目前有以下几种思路：</p>
<ul>
<li>借助于 Object 的 observe 方法</li>
<li>自己在 set，以及数组的常用操作里触发 change 事件</li>
<li>手动 setState()，然后在里面触发 change 事件</li>
</ul>
<p>知道了触发 render 的时机以及如何 render，一个简单的 M 到 V 映射就实现了。</p>
<p><strong>2、V 到 M 实现</strong></p>
<p>从 V 到 M 主要由两类（ 虽然本质上都是监听 DOM ）构成，一类是用户自定义的 listener， 一类是 VM 自动处理的含有 value 属性元素的 listener</p>
<p>第一类类似于你在 Vue 里用 v-on 时绑定的那样，VM 在实例化得时候可以将所有用户自定义的 listener 一次性代理到根元素上，这些 listener 可以访问到你的 model 对象，这样你就可以在 listener 中改变 model</p>
<p>第二类类似于对含有 v-model 与 value 元素的自动处理，我们期望的是例如在一个输入框内</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;message&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>输入值，那么我与之对应的 model 属性 message 也会随之改变，相当于 VM 做了一个默认的 listener，它会监听这些元素的改变然后自动改变 model，具体如何实现相信你也明白了</p>
<h3 id="第-30-题-（2019-10-18）"><a href="#第-30-题-（2019-10-18）" class="headerlink" title="第 30 题 （2019/10/18）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/39">第 30 题</a> （2019/10/18）</h3><p><strong>题目：</strong> 两个数组合并成一个数组</p>
<blockquote>
<p>请把两个数组 [‘A1’, ‘A2’, ‘B1’, ‘B2’, ‘C1’, ‘C2’, ‘D1’, ‘D2’] 和 [‘A’, ‘B’, ‘C’, ‘D’]，合并为 [‘A1’, ‘A2’, ‘A’, ‘B1’, ‘B2’, ‘B’, ‘C1’, ‘C2’, ‘C’, ‘D1’, ‘D2’, ‘D’]。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MergeArray</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a2 = arr2.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item + <span class="number">3</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> arr = [...arr1, ...a2].sort();</span><br><span class="line">  <span class="keyword">return</span> arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.includes(<span class="number">3</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> item.split(<span class="string">&quot;&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-31-题-（2019-10-18）"><a href="#第-31-题-（2019-10-18）" class="headerlink" title="第 31 题 （2019/10/18）"></a>第 31 题 （2019/10/18）</h3><p><strong>题目：</strong> 改造下面的代码，使之输出 0 - 9，写出你能想到的所有解法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<ol>
<li>使用闭包：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  (<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 let</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-32-题-（2019-10-19）"><a href="#第-32-题-（2019-10-19）" class="headerlink" title="第 32 题 （2019/10/19）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/47">第 32 题</a> （2019/10/19）</h3><p><strong>题目：</strong> Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法。</p>
<p><strong>解析：</strong></p>
<p>作者：尤雨溪</p>
<p>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31809713/answer/53544875">https://www.zhihu.com/question/31809713/answer/53544875</a></p>
<p>来源：知乎</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p><strong>1. 原生 DOM 操作 vs. 通过框架封装操作。</strong></p>
<p>这是一个性能 vs. 可维护性的取舍。框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。</p>
<p><strong>2. 对 React 的 Virtual DOM 的误解。</strong></p>
<p>React 从来没有说过 “React 比原生操作 DOM 快”。React 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作… 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。</p>
<p>我们可以比较一下 innerHTML vs. Virtual DOM 的重绘性能消耗：</p>
<ul>
<li>innerHTML: render html string <strong>O(template size)</strong> + 重新创建所有 DOM 元素 <strong>O(DOM size)</strong></li>
<li>Virtual DOM: render Virtual DOM + diff <strong>O(template size)</strong> + 必要的 DOM 更新 <strong>O(DOM change)</strong></li>
</ul>
<p>Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。前面说了，和 DOM 操作比起来，js 计算是极其便宜的。这才是为什么要有 Virtual DOM：它保证了 1）不管你的数据变化多少，每次重绘的性能都可以接受；2) 你依然可以用类似 innerHTML 的思路去写你的应用。</p>
<p><strong>3. MVVM vs. Virtual DOM</strong></p>
<p>相比起 React，其他 MVVM 系框架比如 Angular, Knockout 以及 Vue、Avalon 采用的都是数据绑定：通过 Directive/Binding 对象，观察数据变化并保留对实际 DOM 元素的引用，当有数据变化时进行对应的操作。MVVM 的变化检查是数据层面的，而 React 的检查是 DOM 结构层面的。MVVM 的性能也根据变动检测的实现原理有所不同：Angular 的脏检查使得任何变动都有固定的</p>
<p>O(watcher count)</p>
<p>的代价；Knockout/Vue/Avalon 都采用了依赖收集，在 js 和 DOM 层面都是</p>
<p>O(change)</p>
<p>：</p>
<ul>
<li>脏检查：scope digest <strong>O(watcher count)</strong> + 必要 DOM 更新 <strong>O(DOM change)</strong></li>
<li>依赖收集：重新收集依赖 <strong>O(data change)</strong> + 必要 DOM 更新 <strong>O(DOM change)</strong></li>
</ul>
<p>可以看到，Angular 最不效率的地方在于任何小变动都有的和 watcher 数量相关的性能代价。但是！当所有数据都变了的时候，Angular 其实并不吃亏。依赖收集在初始化和数据变化的时候都需要重新收集依赖，这个代价在小量更新的时候几乎可以忽略，但在数据量庞大的时候也会产生一定的消耗。</p>
<p>MVVM 渲染列表的时候，由于每一行都有自己的数据作用域，所以通常都是每一行有一个对应的 ViewModel 实例，或者是一个稍微轻量一些的利用原型继承的 “scope” 对象，但也有一定的代价。所以，MVVM 列表渲染的初始化几乎一定比 React 慢，因为创建 ViewModel / scope 实例比起 Virtual DOM 来说要昂贵很多。这里所有 MVVM 实现的一个共同问题就是在列表渲染的数据源变动时，尤其是当数据是全新的对象时，如何有效地复用已经创建的 ViewModel 实例和 DOM 元素。假如没有任何复用方面的优化，由于数据是 “全新” 的，MVVM 实际上需要销毁之前的所有实例，重新创建所有实例，最后再进行一次渲染！这就是为什么题目里链接的 angular/knockout 实现都相对比较慢。相比之下，React 的变动检查由于是 DOM 结构层面的，即使是全新的数据，只要最后渲染结果没变，那么就不需要做无用功。</p>
<p>Angular 和 Vue 都提供了列表重绘的优化机制，也就是 “提示” 框架如何有效地复用实例和 DOM 元素。比如数据库里的同一个对象，在两次前端 API 调用里面会成为不同的对象，但是它们依然有一样的 uid。这时候你就可以提示 track by uid 来让 Angular 知道，这两个对象其实是同一份数据。那么原来这份数据对应的实例和 DOM 元素都可以复用，只需要更新变动了的部分。或者，你也可以直接 track by $index 来进行 “原地复用”：直接根据在数组里的位置进行复用。在题目给出的例子里，如果 angular 实现加上 track by $index 的话，后续重绘是不会比 React 慢多少的。甚至在 dbmonster 测试中，Angular 和 Vue 用了 track by $index 以后都比 React 快: <a href="https://link.zhihu.com/?target=http://vuejs.github.io/js-repaint-perfs/">dbmon</a> (注意 Angular 默认版本无优化，优化过的在下面）</p>
<p>顺道说一句，React 渲染列表的时候也需要提供 key 这个特殊 prop，本质上和 track-by 是一回事。</p>
<p><strong>4. 性能比较也要看场合</strong></p>
<p>在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求。Virtual DOM 为了提升小量数据更新时的性能，也需要针对性的优化，比如 shouldComponentUpdate 或是 immutable data。</p>
<ul>
<li>初始渲染：Virtual DOM &gt; 脏检查 &gt;= 依赖收集</li>
<li>小量数据更新：依赖收集 &gt;&gt; Virtual DOM + 优化 &gt; 脏检查（无法优化） &gt; Virtual DOM 无优化</li>
<li>大量数据更新：脏检查 + 优化 &gt;= 依赖收集 + 优化 &gt; Virtual DOM（无法/无需优化）&gt;&gt; MVVM 无优化</li>
</ul>
<p>不要天真地以为 Virtual DOM 就是快，diff 不是免费的，batching 么 MVVM 也能做，而且最终 patch 的时候还不是要用原生 API。在我看来 Virtual DOM 真正的价值从来都不是性能，而是它 1) 为函数式的 UI 编程方式打开了大门；2) 可以渲染到 DOM 以外的 backend，比如 ReactNative。</p>
<h3 id="第-33-题-（2019-10-20）"><a href="#第-33-题-（2019-10-20）" class="headerlink" title="第 33 题 （2019/10/20）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/48">第 33 题</a> （2019/10/20）</h3><p><strong>题目：</strong> 下面的代码打印什么内容，为什么？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p>非严格模式：【输出函数体】</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ƒ b()&#123;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>严格模式：【报错】</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;Uncaught TypeError: Assignment to constant variable.&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>针对这题，在知乎上看到别人的回答说：</p>
<ol>
<li>函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。</li>
<li>对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。</li>
<li>IIFE 中的函数是函数表达式，而不是函数声明。</li>
</ol>
<p>实际上，有点类似于以下代码，但不完全相同，因为使用 const 不管在什么模式下，都会 TypeError 类型的错误</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const foo &#x3D; function () &#123;</span><br><span class="line">foo &#x3D; 10;</span><br><span class="line">console.log(foo)</span><br><span class="line">&#125;</span><br><span class="line">(foo)() &#x2F;&#x2F; Uncaught TypeError: Assignment to constant variable.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>我的理解是，b 函数是一个相当于用 const 定义的常量，内部无法进行重新赋值，如果在严格模式下，会报错”Uncaught TypeError: Assignment to constant variable.”<br>例如下面的：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var b &#x3D; 10;</span><br><span class="line">(function b() &#123;</span><br><span class="line">&#39;use strict&#39;</span><br><span class="line">b &#x3D; 20;</span><br><span class="line">console.log(b)</span><br><span class="line">&#125;)() &#x2F;&#x2F; &quot;Uncaught TypeError: Assignment to constant variable.&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p>这个回答主要表达的是：函数表达式的函数名只在该函数内部有效，且绑定是常量类似 const，不能修改</p>
<h3 id="第-34-题（2019-10-21）"><a href="#第-34-题（2019-10-21）" class="headerlink" title="第 34 题（2019/10/21）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/51">第 34 题</a>（2019/10/21）</h3><p><strong>题目：</strong> 简单改造下面的代码，使之分别打印 10 和 20。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>打印 20：</p>
<p>方法一：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)(b);</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>打印 10：</p>
<p>方法一：（挂载在 全局 window 上）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)(b);</span><br></pre></td></tr></table></figure>

<p>方法二： （挂载在 b 函数（函数也是特殊的对象）上）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  b.b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)(b);</span><br></pre></td></tr></table></figure>

<h3 id="第-35-题-（2019-10-22）"><a href="#第-35-题-（2019-10-22）" class="headerlink" title="第 35 题  （2019/10/22）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/51">第 35 题 </a> （2019/10/22）</h3><p><strong>题目</strong>：浏览器缓存读取规则 ?</p>
<blockquote>
<p>可以分成 Service Worker、Memory Cache、Disk Cache 和 Push Cache，那请求的时候 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache 中？</p>
</blockquote>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/54cc04190252">深入理解浏览器的缓存机制</a> <a target="_blank" rel="noopener" href="https://juejin.im/post/5c22ee806fb9a049fb43b2c5?utm_source=gold_browser_extension">一文读懂前端缓存</a></p>
<p>对于第一个问题前面的文章都说得很详细了我这里就不再多余述<br>第二个问题可以参考我写的<a target="_blank" rel="noopener" href="https://jayzangwill.github.io/blog/2019/02/07/cache/">博文</a> <strong>命中强制缓存时，该从哪拿缓存</strong><br>小节。总的来说：</p>
<ol>
<li>如果开启了 Service Worker 首先会从 Service Worker 中拿</li>
<li>如果新开一个以前打开过的页面缓存会从 Disk Cache 中拿（称为是命中强缓存）</li>
<li>刷新当前页面时浏览器会根据当前运行环境内存来决定是从 Memory Cache 还是从 Disk Cache 中拿（可以看到下图最后几个文件有时候是从 Memory Cache 中拿有时候是从 Disk Cache 中拿）</li>
</ol>
<h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://camo.githubusercontent.com/6254fa34eb5e693a51cb2b5b2eb257f38f0b1634/68747470733a2f2f6a61797a616e6777696c6c2e6769746875622e696f2f626c6f672f696d672f63616368652f7765697a68695f312e676966"></h6><h3 id="第-36-题-（2019-10-22）"><a href="#第-36-题-（2019-10-22）" class="headerlink" title="第 36 题 （2019/10/22）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/54">第 36 题</a> （2019/10/22）</h3><p><strong>题目：</strong> 使用迭代的方式实现 flatten 函数。</p>
<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用迭代的方式实现flatten函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用递归的方式处理</span></span><br><span class="line"><span class="comment"> * wrap内保存结果ret</span></span><br><span class="line"><span class="comment"> * 返回一个递归函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, [<span class="number">7</span>, [<span class="number">8</span>]]]];</span><br><span class="line"><span class="built_in">console</span>.log(wrap()(arr));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.constructor === <span class="built_in">Array</span>) &#123;</span><br><span class="line">        ret.concat(flatten(item));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret.push(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-37-题-（2019-10-22）"><a href="#第-37-题-（2019-10-22）" class="headerlink" title="第 37 题 （2019/10/22）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/65">第 37 题</a> （2019/10/22）</h3><p><strong>题目：</strong> 为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？</p>
<p><strong>解析：</strong> 待续…</p>
<h3 id="第-38-题-（2019-10-23）"><a href="#第-38-题-（2019-10-23）" class="headerlink" title="第 38 题  （2019/10/23）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/57">第 38 题 </a> （2019/10/23）</h3><p><strong>题目：</strong> 下面代码中 a 在什么情况下会打印 1？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = ?;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>)&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>公司：</strong> 京东</p>
<p><strong>考点</strong>： 隐式类型转换</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/399499">从 (a==1&amp;&amp;a==2&amp;&amp;a==3) 成立中看 javascript 的隐式类型转换</a></p>
<p><strong>关于 === 于 ==</strong></p>
<blockquote>
<p>但是我比较喜欢的一本书 <code> You don&#39;t know JS</code>,中作者也写道过一个我比较赞同的观点</p>
<p>很多开发者认为 === 的行为更加容易预测，从而主张使用 === 而远离 ==。我认为这种观点是非常短视的，如果你花点时间去搞清楚它的工作原理，== 将是你开发的强大工具</p>
</blockquote>
<ol>
<li>运算子是对象时候的 valueOf toString 方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  i: <span class="number">1</span>,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.i++;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>); <span class="comment">//1</span></span><br><span class="line">  <span class="built_in">console</span>.log(a.i); <span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果原始类型的值和对象比较，对象会转为原始类型的值，再进行比较。<code>(我想到的也是这种方法)</code>，对象转换成原始类型的值，算法是先调用<code>valueOf</code>方法；如果返回的还是对象，再接着调用<code>toString</code>方法。我们每次比较时候都会执行方法返回 <code>a</code> 的 <code>i</code> 属性同时也改变 <code>i</code> 的值,所以上面 <code>if</code> 执行完以后 <code>a</code> 的 <code>i</code> 属性已经变为了 4，<strong>这里也表现出了 == 比较是有可能会对变量带来副作用的</strong></p>
<p><strong>利用数组的特性</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.join = a.shift;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个答案还是比较巧妙的，我们知道 <code>array</code> 也属于对象，应该和对象的规则一样。关于 <code>array</code> 的原型链上的 <code>toString</code> 方法</p>
<blockquote>
<p>对于数组对象，toString 方法返回一个字符串，该字符串由数组中的每个元素的 toString() 返回值经调用 join() 方法连接（由逗号隔开）组成。</p>
</blockquote>
<p>可以看到数组 <code>toString</code> 会调用本身的 <code>join</code> 方法，这里把自己的<code>join</code>方法该写为<code>shift</code>,每次返回第一个元素，而且原数组删除第一个值，正好可以使判断成立。<strong>这里 == 比较也带来的副作用</strong></p>
<p><strong>利用 with 关键字</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">a</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>with</code> 也是被严重建议不使用的对象，这里也是利用它的特性在代码块里面利用对象的 <code>get</code> 方法动态返回 <code>i</code>.</p>
<p><strong>和 with 类似修改 window 的 get 方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++val;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;yay&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道我们用的全局变量也相当于 <code>window</code> 对象上的一个属性，这里用<code>defineProperty</code> 定义了 <code>a</code>的 <code>get</code> 也使得其动态返回值。和<code>with</code> 有一些类似。</p>
<p><strong>es6 的 Symbol 特性</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; [<span class="built_in">Symbol</span>.toPrimitive]: (<span class="function">(<span class="params">i</span>) =&gt;</span> <span class="function">() =&gt;</span> ++i)(<span class="number">0</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><code>ES6</code> 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。我们之前在定义类的内部私有属性时候习惯用 <code>__xxx</code> ,这种命名方式避免别人定义相同的属性名覆盖原来的属性，有了 <code>Symbol </code> 之后我们完全可以用 <code>Symbol</code>值来代替这种方法，而且完全不用担心被覆盖。</p>
<p>除了定义自己使用的 <code>Symbol</code> 值以外，<code>ES6</code> 还提供了 11 个内置的 <code>Symbol</code> 值，指向语言内部使用的方法。<code>Symbol.toPrimitive</code>就是其中一个，它指向一个方法，表示该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。这里就是改变这个属性，把它的值改为一个 <code>闭包</code> 返回的函数。</p>
<h3 id="第-39-题-（2019-10-24）"><a href="#第-39-题-（2019-10-24）" class="headerlink" title="第 39 题 （2019/10/24）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/59">第 39 题</a> （2019/10/24）</h3><p><strong>题目：</strong> 介绍下 BFC 及其应用</p>
<p><strong>解析：</strong></p>
<p>BFC 就是块级格式上下文，是页面盒模型布局中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。创建 BFC 的方式有：</p>
<ol>
<li>html 根元素</li>
<li>float 浮动</li>
<li>绝对定位</li>
<li>overflow 不为 visiable</li>
<li>display 为表格布局或者弹性布局</li>
</ol>
<p>BFC 主要的作用是：</p>
<ol>
<li>清除浮动</li>
<li>防止同一 BFC 容器中的相邻元素间的外边距重叠问题</li>
</ol>
<h3 id="第-40-题-（2019-10-25）"><a href="#第-40-题-（2019-10-25）" class="headerlink" title="第 40 题  （2019/10/25）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/60">第 40 题 </a> （2019/10/25）</h3><p><strong>题目：</strong> 在 Vue 中，子组件为何不可以修改父组件传递的 Prop?</p>
<blockquote>
<p>如果修改了，Vue 是如何监控到属性的修改并给出警告的。</p>
</blockquote>
<p><strong>解析：</strong></p>
<ol>
<li>子组件为何不可以修改父组件传递的 Prop<br>单向数据流，易于监测数据的流动，出现了错误可以更加迅速的定位到错误发生的位置。</li>
<li>如果修改了，Vue 是如何监控到属性的修改并给出警告的。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> hyphenatedKey = hyphenate(key);</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">    config.isReservedAttr(hyphenatedKey)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">&#x27;&quot;&#x27;</span> +</span><br><span class="line">        hyphenatedKey +</span><br><span class="line">        <span class="string">&#x27;&quot; is a reserved attribute and cannot be used as component prop.&#x27;</span>,</span><br><span class="line">      vm</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  defineReactive$$<span class="number">1</span>(props, key, value, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">&quot;Avoid mutating a prop directly since the value will be &quot;</span> +</span><br><span class="line">          <span class="string">&quot;overwritten whenever the parent component re-renders. &quot;</span> +</span><br><span class="line">          <span class="string">&quot;Instead, use a data or computed property based on the prop&#x27;s &quot;</span> +</span><br><span class="line">          <span class="string">&#x27;value. Prop being mutated: &quot;&#x27;</span> +</span><br><span class="line">          key +</span><br><span class="line">          <span class="string">&#x27;&quot;&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 initProps 的时候，在 defineReactive 时通过判断是否在开发环境，如果是开发环境，会在触发 set 的时候判断是否此 key 是否处于 updatingChildren 中被修改，如果不是，说明此修改来自子组件，触发 warning 提示。</p>
<blockquote>
<p>需要特别注意的是，当你从子组件修改的 prop 属于基础类型时会触发提示。 这种情况下，你是无法修改父组件的数据源的， 因为基础类型赋值时是值拷贝。你直接将另一个非基础类型（Object, array）赋值到此 key 时也会触发提示(但实际上不会影响父组件的数据源)， 当你修改 object 的属性时不会触发提示，并且会修改父组件数据源的数据。</p>
</blockquote>
<h3 id="第-41-题-（2019-10-25）"><a href="#第-41-题-（2019-10-25）" class="headerlink" title="第 41 题 （2019/10/25）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/61">第 41 题</a> （2019/10/25）</h3><p><strong>题目：</strong> 下面代码输出什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">  a = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//20</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong> 分别为 undefined 　 10 　 20，原因是作用域问题，在内部声名 var a = 20;相当于先声明 var a;然后再执行赋值操作，这是在ＩＩＦＥ内形成的独立作用域，如果把 var a=20 注释掉，那么 a 只有在外部有声明，显示的就是外部的Ａ变量的值了。结果Ａ会是 10 　 5 　 5</p>
<h3 id="第-42-题-（2019-10-25）"><a href="#第-42-题-（2019-10-25）" class="headerlink" title="第 42 题  （2019/10/25）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/63">第 42 题 </a> （2019/10/25）</h3><p><strong>题目：</strong> 实现一个 sleep 函数</p>
<blockquote>
<p>比如 sleep(1000) 意味着等待 1000 毫秒，可从 Promise、Generator、Async/Await 等角度实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise1</span></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, time));</span><br><span class="line">&#125;;</span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Generator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">sleepGenerator</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">sleepGenerator(<span class="number">1000</span>)</span><br><span class="line">  .next()</span><br><span class="line">  .value.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//async</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, time));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> out = <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">output();</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">callback, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&quot;function&quot;</span>) <span class="built_in">setTimeout</span>(callback, time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">sleep(output, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ImagineCode/article/details/81089107">Promise | 自个写一个 Promise | Generator</a></li>
</ul>
<h3 id="第-43-题-（2019-10-26）"><a href="#第-43-题-（2019-10-26）" class="headerlink" title="第 43 题 （2019/10/26）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/66">第 43 题</a> （2019/10/26）</h3><p><strong>题目：</strong> 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果</p>
<p><strong>解析：</strong></p>
<p>原题目：</p>
<blockquote>
<p>使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果</p>
</blockquote>
<p>我的答案：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">102</span>, <span class="number">15</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">3</span>, <span class="number">8</span>];</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>根据 MDN 上对<code>Array.sort()</code>的解释，默认的排序方法会将数组元素转换为字符串，然后比较字符串中字符的 UTF-16 编码顺序来进行排序。所以<code>&#39;102&#39;</code> 会排在 <code>&#39;15&#39;</code> 前面。以下是 MDN 中的解释原文：</p>
<blockquote>
<p>The sort() method sorts the elements of an array in place and returns the array. The default sort order is built upon converting the elements into strings, then comparing their sequences of UTF-16 code units values.</p>
</blockquote>
<h3 id="第-44-题-（2019-10-26）"><a href="#第-44-题-（2019-10-26）" class="headerlink" title="第 44 题 （2019/10/26）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/70">第 44 题 </a>（2019/10/26）</h3><p><strong>题目：</strong> 介绍 HTTPS 握手过程</p>
<p><strong>解析：</strong> ~~</p>
<h3 id="第-45-题-（2019-10-26）"><a href="#第-45-题-（2019-10-26）" class="headerlink" title="第 45 题  （2019/10/26）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/74">第 45 题 </a> （2019/10/26）</h3><p><strong>题目：</strong> HTTPS 握手过程中，客户端如何验证证书的合法性</p>
<p><strong>解析：</strong> ~~</p>
<h3 id="第-46-题-（2019-10-26）"><a href="#第-46-题-（2019-10-26）" class="headerlink" title="第 46 题  （2019/10/26）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/76">第 46 题 </a> （2019/10/26）</h3><p><strong>题目：</strong> 输出以下代码执行的结果并解释为什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="number">4</span>,</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">  splice: <span class="built_in">Array</span>.prototype.splice,</span><br><span class="line">  push: <span class="built_in">Array</span>.prototype.push,</span><br><span class="line">&#125;;</span><br><span class="line">obj.push(<span class="number">1</span>);</span><br><span class="line">obj.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">    Object(4) [empty × 2, 1, 2, splice: ƒ, push: ƒ]</span></span><br><span class="line"><span class="comment">    2: 1</span></span><br><span class="line"><span class="comment">    3: 2</span></span><br><span class="line"><span class="comment">    length: 4</span></span><br><span class="line"><span class="comment">    push: ƒ push()</span></span><br><span class="line"><span class="comment">    splice: ƒ splice()</span></span><br><span class="line"><span class="comment">    __proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>我的理解是这样的<br>1: call push 这个方法如果对象有 length 属性，length 属性会加 1 并且返回，这个是在某本书的上看到的，一直记得。<br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push#Description">MDN</a></p>
<blockquote>
<p>push 方法将值追加到数组中。</p>
<p>push 方法有意具有通用性。该方法和 call() 或 apply() 一起使用时，可应用在类似数组的对象上。push 方法根据 length 属性来决定从哪里开始插入给定的值。如果 length 不能被转成一个数值，则插入的元素索引为 0，包括 length 不存在时。当 length 不存在时，将会创建它。</p>
<p>唯一的原生类数组（array-like）对象是 Strings，尽管如此，它们并不适用该方法，因为字符串是不可改变的。</p>
</blockquote>
<ol>
<li>调用 push 方法的时候会在调用对象的 key=length 的地方做一个赋值，不管前面 key 有没有值，也就是说在调用 push 的时候 对象实际被理解为了[0:undefined,1:undefined,2:3,3:4],<br>这样也就有了结果里面的<br>key===2 value =1<br>key===3 value =2 3.额外的<br>这个对象如果有 push 和 splice 会输出会转换为数组，下图为去掉 splice</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/11674767/55370329-b8459280-552c-11e9-96ec-0924b03f70a4.png"></p>
<p>包含 splice 方法</p>
<p><img src="https://user-images.githubusercontent.com/11674767/55370427-065a9600-552d-11e9-9525-236038e73009.png"></p>
<h3 id="第-47-题-（2019-10-27）"><a href="#第-47-题-（2019-10-27）" class="headerlink" title="第 47 题  （2019/10/27）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/81">第 47 题 </a> （2019/10/27）</h3><p><strong>题目：</strong> 双向绑定和 vuex 是否冲突</p>
<p><strong>解析：</strong></p>
<p>在严格模式下直接使用确实会有问题。<br>解决方案：</p>
<blockquote>
<p>官网说的比较详细<br><a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh/guide/forms.html">https://vuex.vuejs.org/zh/guide/forms.html</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;message&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    message: &#123;</span><br><span class="line">        set (value) &#123;</span><br><span class="line">            <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;updateMessage&#x27;</span>, value);</span><br><span class="line">        &#125;,</span><br><span class="line">        get () &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.obj.message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mutations: &#123;</span><br><span class="line">    UPDATE_MESSAGE (state, v) &#123;</span><br><span class="line">        state.obj.message = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">actions: &#123;</span><br><span class="line">    update_message (&#123; commit &#125;, v) &#123;</span><br><span class="line">        commit(<span class="string">&#x27;UPDATE_MESSAGE&#x27;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-48-题-（2019-10-27）"><a href="#第-48-题-（2019-10-27）" class="headerlink" title="第 48 题 （2019/10/27）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/84">第 48 题</a> （2019/10/27）</h3><p><strong>题目：</strong> call 和 apply 的区别是什么，哪个性能更好一些</p>
<p><strong>解析：</strong></p>
<blockquote>
<p><code>**call()**</code> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p>
<p><strong>apply()</strong> 方法调用一个具有给定<code>this</code>值的函数，以及作为一个数组（或<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects">类似数组对象</a>）提供的参数。</p>
</blockquote>
<ol>
<li>Function.prototype.apply 和 Function.prototype.call 的作用是一样的，区别在于传入参数的不同；</li>
<li>第一个参数都是，指定函数体内 this 的指向；</li>
<li>第二个参数开始不同，apply 是传入<strong>带下标的集合</strong>，数组或者类数组，apply 把它传给函数作为参数，call 从第二个开始<strong>传入的参数是不固定的，都会传给函数作为参数</strong>。</li>
<li>call 比 apply 的性能要好，平常可以多用 call, call 传入参数的格式正是内部所需要的格式，参考<a target="_blank" rel="noopener" href="https://github.com/noneven/__/issues/6">call 和 apply 的性能对比</a></li>
</ol>
<h3 id="第-49-题-（2019-10-27）"><a href="#第-49-题-（2019-10-27）" class="headerlink" title="第 49 题  （2019/10/27）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/87">第 49 题 </a> （2019/10/27）</h3><p><strong>题目：</strong> 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/36411025">数据埋点是什么？设置埋点的意义是什么？</a></p>
<blockquote>
<p><strong>1. 埋点是什么？</strong></p>
<p>所谓“埋点”，是 <strong>数据采集领域</strong>（尤其是用户行为数据采集领域）的术语，指的是针对特定用户行为或事件进行捕获、处理和发送的相关技术及其实施过程。比如用户某个 icon 点击次数、观看某个视频的时长等等。</p>
<p>埋点的技术实质，是先监听软件应用运行过程中的事件，当需要关注的事件发生时进行判断和捕获。</p>
<p>特别注意需要明确事件发生时间点、判别条件，这里如果遇到不清楚的，需要和开发沟通清楚，避免采集数据与理想存在差异。例如：期望采集某个 app 的某个广告的有效曝光数，有效曝光的判别条件是停留时长超过 1 秒且有效加载出广告内容。</p>
<p><strong>解答：</strong></p>
</blockquote>
<p>作用：工作中，用于前端监控，比如曝光等等，谷歌和百度的都是用的 1x1 像素的透明 gif 图片；<br>why?</p>
<ol>
<li>没有跨域问题，一般这种上报数据，代码要写通用的；（排除 ajax）</li>
<li>不会阻塞页面加载，影响用户的体验，只要 new Image 对象就好了；（排除 JS/CSS 文件资源方式上报）</li>
<li>在所有图片中，体积最小；（比较 PNG/JPG）</li>
</ol>
<h3 id="第-50-题-（2019-10-28）"><a href="#第-50-题-（2019-10-28）" class="headerlink" title="第 50 题 （2019/10/28）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/88">第 50 题 </a>（2019/10/28）</h3><p><strong>题目：</strong> 实现 (5).add(3).minus(2) 功能。</p>
<blockquote>
<p>例： 5 + 3 - 2，结果为 6</p>
</blockquote>
<p><strong>公司</strong>：百度</p>
<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() + num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.prototype.minus = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() - num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">5</span>).add(<span class="number">3</span>).minus(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h3 id="第-51-题-（2019-10-28）"><a href="#第-51-题-（2019-10-28）" class="headerlink" title="第 51 题 （2019/10/28）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/90">第 51 题</a> （2019/10/28）</h3><p><strong>题目：</strong> Vue 的响应式原理中 Object.defineProperty 有什么缺陷？</p>
<blockquote>
<p>为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？</p>
</blockquote>
<p><strong>解析：</strong> 不懂<del>~</del></p>
<h3 id="第-52-题-（2019-10-28）"><a href="#第-52-题-（2019-10-28）" class="headerlink" title="第 52 题 （2019/10/28）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/92">第 52 题</a> （2019/10/28）</h3><p><strong>题目：</strong> 怎么让一个 div 水平垂直居中</p>
<p><strong>解析：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>1、利用 flex</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、绝对定位</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 或 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、网格布局</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">justify-self</span>: center;</span><br><span class="line">  <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  &amp;::before &#123;</span><br><span class="line">    <span class="selector-tag">content</span>: &quot;&quot;;</span><br><span class="line">    <span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br><span class="line">    <span class="selector-tag">width</span>: 0;</span><br><span class="line">    <span class="selector-tag">height</span>: 100%;</span><br><span class="line">    <span class="selector-tag">vertical-align</span>: <span class="selector-tag">middle</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、补充</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: table-cell</span><br><span class="line">vertical-align: middle;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-53-题-（2019-10-29）"><a href="#第-53-题-（2019-10-29）" class="headerlink" title="第 53 题 （2019/10/29）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/93">第 53 题</a> （2019/10/29）</h3><p><strong>题目：</strong> 输出以下代码的执行结果并解释为什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x = a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b.x); <span class="comment">//&#123; n: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//&#123; n: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//&#123; n: 1, x: &#123; n: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先，a和b同时引用了&#123;n:2&#125;对象，接着执行到a.x &#x3D; a &#x3D; &#123;n：2&#125;语句，尽管赋值是从右到左的没错，但是.的优先级比&#x3D;要高，所以这里首先执行a.x，相当于为a（或者b）所指向的&#123;n:1&#125;对象新增了一个属性x，即此时对象将变为&#123;n:1;x:undefined&#125;。之后按正常情况，从右到左进行赋值，此时执行a &#x3D;&#123;n:2&#125;的时候，a的引用改变，指向了新对象&#123;n：2&#125;,而b依然指向的是旧对象。之后执行a.x &#x3D; &#123;n：2&#125;的时候，并不会重新解析一遍a，而是沿用最初解析a.x时候的a，也即旧对象，故此时旧对象的x的值为&#123;n：2&#125;，旧对象为 &#123;n:1;x:&#123;n：2&#125;&#125;，它被b引用着。</span><br><span class="line">后面输出a.x的时候，又要解析a了，此时的a是指向新对象的a，而这个新对象是没有x属性的，故访问时输出undefined；而访问b.x的时候，将输出旧对象的x的值，即&#123;n:2&#125;。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-54-题-（2019-10-29）"><a href="#第-54-题-（2019-10-29）" class="headerlink" title="第 54 题  （2019/10/29）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/94">第 54 题 </a> （2019/10/29）</h3><p><strong>题目：</strong> 冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？</p>
<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BubbleSort</span>(<span class="params">nums, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j + <span class="number">1</span>] &lt; nums[j]) &#123;</span><br><span class="line">        [nums[j], nums[j + <span class="number">1</span>]] = [nums[j + <span class="number">1</span>], nums[j]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>性质：</p>
<p>1、时间复杂度：O(n^2)</p>
<p>2、空间复杂度：O(1)</p>
<p>3、稳定排序</p>
<p>4、原地排序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改进冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort1</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        pos = j;</span><br><span class="line">        <span class="keyword">const</span> temp = arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i = pos;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-55-题-（2019-10-30）"><a href="#第-55-题-（2019-10-30）" class="headerlink" title="第 55 题 （2019/10/30）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/96">第 55 题</a> （2019/10/30）</h3><p><strong>题目：</strong> 某公司 1 到 12 月份的销售额存在一个对象里面</p>
<blockquote>
<p>如下：{1:222, 2:123, 5:888}，请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null]。</p>
</blockquote>
<blockquote>
<p><code>**Array.from()**</code> 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="number">1</span>: <span class="number">222</span>, <span class="number">2</span>: <span class="number">123</span>, <span class="number">5</span>: <span class="number">888</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.length = <span class="number">13</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(obj).slice(<span class="number">1</span>).map(item = &gt; &#123;</span><br><span class="line">        <span class="keyword">return</span>  item === <span class="literal">undefined</span> ? <span class="literal">null</span> : item</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f(obj))</span><br><span class="line"><span class="comment">//[ 222, 123, null, null, 888, null, null, null, null, null, null, null ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-56-题-（2019-10-30）"><a href="#第-56-题-（2019-10-30）" class="headerlink" title="第 56 题 （2019/10/30）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/98">第 56 题</a> （2019/10/30）</h3><p><strong>题目：</strong> 要求设计 LazyMan 类，实现以下功能。</p>
<p><strong>考点</strong>：数据结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LazyMan(<span class="string">&quot;Tony&quot;</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"></span><br><span class="line">LazyMan(<span class="string">&quot;Tony&quot;</span>).sleep(<span class="number">10</span>).eat(<span class="string">&quot;lunch&quot;</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"><span class="comment">// 等待了10秒...</span></span><br><span class="line"><span class="comment">// I am eating lunch</span></span><br><span class="line"></span><br><span class="line">LazyMan(<span class="string">&quot;Tony&quot;</span>).eat(<span class="string">&quot;lunch&quot;</span>).sleep(<span class="number">10</span>).eat(<span class="string">&quot;dinner&quot;</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"><span class="comment">// I am eating lunch</span></span><br><span class="line"><span class="comment">// 等待了10秒...</span></span><br><span class="line"><span class="comment">// I am eating diner</span></span><br><span class="line"></span><br><span class="line">LazyMan(<span class="string">&quot;Tony&quot;</span>)</span><br><span class="line">  .eat(<span class="string">&quot;lunch&quot;</span>)</span><br><span class="line">  .eat(<span class="string">&quot;dinner&quot;</span>)</span><br><span class="line">  .sleepFirst(<span class="number">5</span>)</span><br><span class="line">  .sleep(<span class="number">10</span>)</span><br><span class="line">  .eat(<span class="string">&quot;junk food&quot;</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"><span class="comment">// 等待了5秒...</span></span><br><span class="line"><span class="comment">// I am eating lunch</span></span><br><span class="line"><span class="comment">// I am eating dinner</span></span><br><span class="line"><span class="comment">// 等待了10秒...</span></span><br><span class="line"><span class="comment">// I am eating junk food</span></span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong> <del>~</del></p>
<h3 id="第-57-题（2019-10-31）"><a href="#第-57-题（2019-10-31）" class="headerlink" title="第 57 题（2019/10/31）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/100">第 57 题</a>（2019/10/31）</h3><p><strong>题目：</strong> 分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。</p>
<p><strong>解析：</strong></p>
<blockquote>
<p>总结一下：</p>
</blockquote>
<p><strong>结构:</strong><br>display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击，<br>visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击<br>opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击</p>
<p><strong>继承：</strong><br>display: none 和 opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。<br>visibility: hidden：是继承属性，子孙节点消失由于继承了 hidden，通过设置 visibility: visible;可以让子孙节点显式。</p>
<p><strong>性能：</strong><br>displaynone : 修改元素会造成文档回流,读屏器不会读取 display: none 元素内容，性能消耗较大<br>visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取 visibility: hidden 元素内容<br>opacity: 0 ： 修改元素会造成重绘，性能消耗较少</p>
<p><strong>联系</strong> ：它们都能让元素不可见</p>
<h3 id="第-58-题（2019-10-31）"><a href="#第-58-题（2019-10-31）" class="headerlink" title="第 58 题（2019/10/31）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/101">第 58 题</a>（2019/10/31）</h3><p><strong>题目：</strong> 第 58 题：箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？</p>
<p><strong>解析：</strong></p>
<blockquote>
<p>引入箭头函数有两个方面的作用：更简短的函数并且不绑定 this</p>
</blockquote>
<p>箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：</p>
<ol>
<li>箭头函数<strong>没有 this</strong>，它会从自己的<strong>作用域链</strong>的上一层继承 this（因此无法使用 apply / call / bind 进行绑定 this 值）；</li>
<li>不可以使用 <strong>arguments 对象</strong>，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>不可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield">yield 命令</a>，因此箭头函数不能用作 Generator 函数。</li>
<li>无法使用 <strong>new 实例化对象</strong>，因为普通构造函数通过 new 实例化对象时 this 指向实例对象，而箭头函数没有 this 值，同时 箭头函数也没有 prototype。</li>
</ol>
<p>new 过程大致是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFunc</span>(<span class="params">father, ...rest</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">  result.__proto__ = father.prototype;</span><br><span class="line">  <span class="keyword">var</span> result2 = father.apply(result, rest);</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (<span class="keyword">typeof</span> result2 === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result2 === <span class="string">&quot;function&quot;</span>) &amp;&amp;</span><br><span class="line">    result2 !== <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> result2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-59-题-（2019-10-31）"><a href="#第-59-题-（2019-10-31）" class="headerlink" title="第 59 题 （2019/10/31）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/102">第 59 题</a> （2019/10/31）</h3><p><strong>题目：</strong> 给定两个数组，写一个方法来计算它们的交集。</p>
<blockquote>
<p>例如：给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">  nums2 = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="comment">// 有个问题， [NaN].indexOf(NaN) === -1</span></span><br><span class="line"><span class="keyword">var</span> newArr1 = nums1.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nums2.indexOf(item) &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">var</span> newArr2 = nums1.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> nums2.includes(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="第-60-题-（2019-10-31）"><a href="#第-60-题-（2019-10-31）" class="headerlink" title="第 60 题 （2019/10/31）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/105">第 60 题</a> （2019/10/31）</h3><p><strong>题目：</strong> 已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。</p>
<blockquote>
<p>&lt;img src=”1.jpg” style=”width:480px!important;”&gt;</p>
</blockquote>
<p><strong>解决方案：</strong></p>
<ol>
<li><code>max-width: 300px</code></li>
<li><code>transform: scale(0.625,0.625) </code></li>
<li><code>zoom: 0.625</code>; <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@viewport/zoom">MDN：zoom</a></li>
<li>解法：</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br><span class="line"><span class="selector-tag">padding</span>: 0 90<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>js：<code>document.getElementsByTagName(&#39;img&#39;)[0].style.width=&#39;300px&#39;</code></li>
</ol>
<h3 id="第-61-题-（2019-11-01）"><a href="#第-61-题-（2019-11-01）" class="headerlink" title="第 61 题 （2019/11/01）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/106">第 61 题</a> （2019/11/01）</h3><p><strong>题目：</strong> 介绍下如何实现 token 加密 ?</p>
<p><strong>解析：</strong></p>
<blockquote>
<p>这个题目是问：生成 token 的方法，比如 <strong>JWT</strong>，还是说利用加密算法，比如对称加密或者非对称加密 加密生成后的 token ?</p>
</blockquote>
<p>这边也是这么做的，后端根据 token 来查权限和是否登录以及失效等</p>
<blockquote>
<p>token 加密方式：</p>
<ul>
<li>服务器通过私钥对一部分信息进行加密生成签名，并将签名和数据拼接在一起作为 token 的一部分。例如 JWT。</li>
<li>使用客户端的 UA 或其他数据作为干扰码对 token 进行加密。</li>
</ul>
</blockquote>
<p>相关参考文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e0ac7c3067eb">Token - 服务端身份验证的流行方案</a></li>
<li><a target="_blank" rel="noopener" href="https://ninghao.net/blog/2834">基于 Token 的身份验证：JSON Web Token</a></li>
</ul>
<blockquote>
<p>jwt 举例</p>
<ol>
<li>需要一个 secret（随机数）</li>
<li>后端利用 secret 和加密算法(如：HMAC-SHA256)对 payload(如账号密码)生成一个字符串(token)，返回前端</li>
<li>前端每次 request 在 header 中带上 token</li>
<li>后端用同样的算法解密</li>
</ol>
</blockquote>
<p>这边也是这么做的，后端根据 token 来查权限和是否登录以及失效等</p>
<h3 id="第-62-题-（2019-11-01）"><a href="#第-62-题-（2019-11-01）" class="headerlink" title="第 62 题  （2019/11/01）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/107">第 62 题 </a> （2019/11/01）</h3><p><strong>题目：</strong> redux 为什么要把 reducer 设计成纯函数</p>
<p><strong>解析：</strong> 学习 react ~~</p>
<h3 id="第-63-题（2019-11-02）"><a href="#第-63-题（2019-11-02）" class="headerlink" title="第 63 题（2019/11/02）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/108">第 63 题</a>（2019/11/02）</h3><p><strong>题目：</strong> 如何设计实现无缝轮播如何设计实现无缝轮播</p>
<p><strong>解析：</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">无限轮播基本插件都可以做到,不过要使用原生代码实现无缝滚动的话我可以提点思路,</span><br><span class="line">因为轮播图基本都在ul盒子里面的li元素,</span><br><span class="line">首先获取第一个li元素和最后一个li元素,</span><br><span class="line">克隆第一个li元素,和最后一个li元素,</span><br><span class="line">分别插入到lastli的后面和firstli的前面,</span><br><span class="line">然后监听滚动事件,如果滑动距离超过x或-x,让其实现跳转下一张图或者跳转上一张,(此处最好设置滑动距离),</span><br><span class="line">然后在滑动最后一张实现最后一张和克隆第一张的无缝转换,当到克隆的第一张的时候停下的时候,,让其切入真的第一张,则实现无线滑动,向前滑动同理</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-64-题（2019-11-02）"><a href="#第-64-题（2019-11-02）" class="headerlink" title="第 64 题（2019/11/02）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/109">第 64 题</a>（2019/11/02）</h3><p><strong>题目：</strong>模拟实现一个 Promise.finally</p>
<p><strong>知识点</strong> ：异步</p>
<p><strong>解析：</strong></p>
<h3 id="第-65-题-（2019-11-02）"><a href="#第-65-题-（2019-11-02）" class="headerlink" title="第 65 题 （2019/11/02）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/111">第 65 题</a> （2019/11/02）</h3><p><strong>题目：</strong> <code>a.b.c.d</code> 和 <code>a[&#39;b&#39;][&#39;c&#39;][&#39;d&#39;]</code>，哪个性能更高？</p>
<p><strong>解析：</strong></p>
<p>应该是 <code>a.b.c.d</code> 比 <code>a[&#39;b&#39;][&#39;c&#39;][&#39;d&#39;]</code> 性能高点，后者还要考虑 <code>[ ]</code> 中是变量的情况，再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点。<br>下图是两者的 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016231512">AST</a> (抽象语法树) 对比：</p>
<p><img src="https://user-images.githubusercontent.com/9009389/56872978-501d9a00-6a61-11e9-9e69-85ff00c031fc.png"></p>
<h3 id="第-66-题-（2019-11-02）"><a href="#第-66-题-（2019-11-02）" class="headerlink" title="第 66 题 （2019/11/02）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/112">第 66 题</a> （2019/11/02）</h3><p><strong>题目：</strong> ES6 代码转成 ES5 代码的实现思路是什么</p>
<p><strong>解析：</strong></p>
<p>回到正题上来，说到 ES6 代码转成 ES5 代码，我们肯定会想到 Babel。所以，我们可以参考 Babel 的实现方式。</p>
<p>那么 Babel 是如何把 ES6 转成 ES5 呢，其大致分为三步：</p>
<ul>
<li>将代码字符串解析成抽象语法树，即所谓的 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016231512">AST</a></li>
<li>对 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016231512">AST</a> 进行处理，在这个阶段可以对 ES6 代码进行相应转换，即转成 ES5 代码</li>
<li>根据处理后的 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016231512">AST</a> 再生成代码字符串</li>
</ul>
<p>基于此，其实我们自己就可以实现一个简单的“编译器”，用于把 ES6 代码转成 ES5。</p>
<p>比如，可以使用 <code>@babel/parser</code> 的 <code>parse</code> 方法，将代码字符串解析成 AST；使用 <code>@babel/core</code> 的 <code>transformFromAstSync</code> 方法，对 AST 进行处理，将其转成 ES5 并生成相应的代码字符串；过程中，可能还需要使用 <code>@babel/traverse</code> 来获取依赖文件等。对此感兴趣的可以看看<a target="_blank" rel="noopener" href="https://github.com/FishPlusOrange/easy-webpack">这个</a>。</p>
<h3 id="第-67-题-（2019-11-03）"><a href="#第-67-题-（2019-11-03）" class="headerlink" title="第 67 题 （2019/11/03）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/113">第 67 题</a> （2019/11/03）</h3><p><strong>题目：</strong> 数组编程题</p>
<blockquote>
<p>随机生成一个长度为 10 的整数类型的数组，例如 <code>[2, 10, 3, 4, 5, 11, 10, 11, 20]</code>，将其排列成一个新数组，要求新数组形式如下，例如 <code>[[2, 3, 4, 5], [10, 11], [20]]</code>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	我理解是：去重排序数组后，分类连续数列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> initArr = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getRandomIntInclusive(<span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个两数之间的随机整数，包括两个数在内</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomIntInclusive</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  min = <span class="built_in">Math</span>.ceil(min);</span><br><span class="line">  max = <span class="built_in">Math</span>.floor(max);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min; <span class="comment">//含最大值，含最小值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newarr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">var</span> pre = <span class="number">0</span>,</span><br><span class="line">    cur = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> xarr = [newarr[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">var</span> Finllyarr = [];</span><br><span class="line">  <span class="keyword">while</span> (cur &lt;= newarr.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newarr[cur] - newarr[pre] === count) &#123;</span><br><span class="line">      xarr.push(newarr[cur]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pre = cur;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">      Finllyarr.push(xarr);</span><br><span class="line">      xarr = [newarr[pre]];</span><br><span class="line">    &#125;</span><br><span class="line">    cur++;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Finllyarr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(GetArr(initArr));</span><br></pre></td></tr></table></figure>

<h3 id="第-68-题-（2019-11-04）"><a href="#第-68-题-（2019-11-04）" class="headerlink" title="第 68 题 （2019/11/04）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/115">第 68 题</a> （2019/11/04）</h3><p><strong>题目：</strong> 如何解决移动端 Retina 屏 1px 像素问题</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://juejin.im/entry/584e427361ff4b006cd22c7c">7 种方法解决移动端 Retina 屏幕 1px 边框问题</a></p>
<ol>
<li>0.5px 边框</li>
<li>使用 border-image 实现</li>
<li>使用 background-image 实现</li>
<li>多背景渐变实现</li>
<li>使用 box-shadow 模拟边框</li>
<li>viewport + rem 实现</li>
<li>伪类 + transform 实现</li>
</ol>
<h3 id="第-69-题-（2019-11-07）"><a href="#第-69-题-（2019-11-07）" class="headerlink" title="第 69 题 （2019/11/07）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/116">第 69 题</a> （2019/11/07）</h3><p><strong>题目：</strong> 如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC’ 变成 ‘aBc’ 。</p>
<p>解析</p>
<ol>
<li>利用 ASCII 码 （A: 65 ，Z：90，a：97，z：122）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Getstr</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">    .split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.charCodeAt() &lt;= <span class="number">90</span> &amp;&amp; item.charCodeAt() &gt;= <span class="number">65</span>)</span><br><span class="line">        <span class="keyword">return</span> item.toLowerCase();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> item.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用 小技巧</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Getstr</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">    .split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item === item.toUpperCase()</span><br><span class="line">        ? item.toLowerCase()</span><br><span class="line">        : item.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-70-题-（2019-11-08）"><a href="#第-70-题-（2019-11-08）" class="headerlink" title="第 70 题 （2019/11/08）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/118">第 70 题</a> （2019/11/08）</h3><p><strong>题目：</strong> 介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的</p>
<p><strong>解析：</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.当修改了一个或多个文件；</span><br><span class="line">2.文件系统接收更改并通知webpack；</span><br><span class="line">3.webpack重新编译构建一个或多个模块，并通知HMR服务器进行更新；</span><br><span class="line">4.HMR Server 使用webSocket通知HMR runtime 需要更新，HMR运行时通过HTTP请求更新jsonp；</span><br><span class="line">5.HMR运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-71-题-（2019-11-14）"><a href="#第-71-题-（2019-11-14）" class="headerlink" title="第 71 题 （2019/11/14）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/119">第 71 题</a> （2019/11/14）</h3><p><strong>题目：</strong> 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。</p>
<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为 T 的 length 是一定的，所以在循环S的的时候 ，循环当前项 i 后面至少还有 T.length 个元素</span></span><br><span class="line"><span class="keyword">const</span> find = <span class="function">(<span class="params">S, T</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (S.length &lt; T.length) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; S.length - T.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (S.substr(i, T.length) === T) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：</span></span><br><span class="line"><span class="keyword">const</span> find = <span class="function">(<span class="params">S, T</span>) =&gt;</span> S.search(T);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：</span></span><br><span class="line"><span class="keyword">const</span> find = <span class="function">(<span class="params">S, T</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> matched = S.match(T);</span><br><span class="line">  <span class="keyword">return</span> matched ? matched.index : <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第-72-题-（2019-11-15）"><a href="#第-72-题-（2019-11-15）" class="headerlink" title="第 72 题 （2019/11/15）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/121">第 72 题</a> （2019/11/15）</h3><p><strong>题目：</strong>为什么普通 <code>for</code> 循环的性能远远高于 <code>forEach</code> 的性能，请解释其中的原因。</p>
<p><strong>解析：</strong></p>
<ul>
<li>for 循环没有任何额外的函数调用栈和上下文；</li>
<li>forEach 函数签名实际上是</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>它不是普通的 for 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能；</p>
<h3 id="第-73-题-（2019-11-15）"><a href="#第-73-题-（2019-11-15）" class="headerlink" title="第 73 题 （2019/11/15）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/122">第 73 题</a> （2019/11/15）</h3><p><strong>题目：</strong> 介绍下 BFC、IFC、GFC 和 FFC</p>
<p><strong>解析：</strong></p>
<p><strong>BFC（Block formatting contexts）：块级格式上下文</strong><br>页面上的一个隔离的渲染区域，那么他是如何产生的呢？可以触发 BFC 的元素有 float、position、overflow、display：table-cell/ inline-block/table-caption ；BFC 有什么作用呢？比如说实现多栏布局’</p>
<p><strong>IFC（Inline formatting contexts）：内联格式上下文</strong><br>IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding/margin 影响)IFC 中的 line box 一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与与 line box 之间，使得 line box 宽度缩短。 同个 ifc 下的多个 line box 高度会不同<br>IFC 中时不可能有块级元素的，当插入块级元素时（如 p 中插入 div）会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。<br>那么 IFC 一般有什么用呢？<br>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。<br>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</p>
<p><strong>GFC（GrideLayout formatting contexts）：网格布局格式化上下文</strong><br>当为一个元素设置 display 值为 grid 的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。那么 GFC 有什么用呢，和 table 又有什么区别呢？首先同样是一个二维的表格，但 GridLayout 会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。</p>
<p><strong>FFC（Flex formatting contexts）:自适应格式上下文</strong><br>display 值为 flex 或者 inline-flex 的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少 safari 和 chrome 还是 OK 的，毕竟这俩在移动端才是王道。Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/dingyufenglian/p/4845477.html">在这</a></p>
<h3 id="第-74-题-（2019-11-16）"><a href="#第-74-题-（2019-11-16）" class="headerlink" title="第 74 题  （2019/11/16）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/123">第 74 题 </a> （2019/11/16）</h3><p><strong>题目：</strong> 使用 JavaScript Proxy 实现简单的数据绑定</p>
<p><strong>解析：</strong> ~~</p>
<h3 id="第-75-题-（2019-11-17）"><a href="#第-75-题-（2019-11-17）" class="headerlink" title="第 75 题 （2019/11/17）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/124">第 75 题</a> （2019/11/17）</h3><p><strong>题目：</strong> 数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少</p>
<p><strong>解析：</strong></p>
<p><strong>考点：</strong> <u>JavaScript 数组底层原理</u></p>
<p>数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)</p>
<p>得出结论：<strong>消耗时间几乎一致，差异可以忽略不计</strong></p>
<blockquote>
<p>Chrome 浏览器 JS 引擎 V8 中，数组有两种存储模式，一种是类似 C 语言中的线性结构存储（索引值连续，且都是正整数的情况下），一种是采用 Hash 结构存储（索引值为负数，数组稀疏，间隔比较大）；</p>
</blockquote>
<p>JavaScript 没有真正意义上的数组，所有的数组其实是对象，其“索引”看起来是数字，其实会被转换成字符串，作为属性名（对象的 key）来使用。所以无论是取第 1 个还是取第 10 万个元素，都是用 key 精确查找哈希表的过程，其消耗时间大致相同。</p>
<blockquote>
<p>推荐一下这篇文章：<a target="_blank" rel="noopener" href="https://juejin.im/entry/59ae664d518825244d207196">深究 JavaScript 数组</a></p>
</blockquote>
<h3 id="第-76-题-（2019-11-17）"><a href="#第-76-题-（2019-11-17）" class="headerlink" title="第 76 题 （2019/11/17）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/125">第 76 题</a> （2019/11/17）</h3><blockquote>
<p>输出以下代码运行结果</p>
<p><strong>考点</strong> ：这题考察的是对象的键名的转换。</p>
<ul>
<li>对象的键名只能是字符串和 Symbol 类型。</li>
<li>其他类型的键名会被转换成字符串类型。</li>
<li>对象转字符串默认会调用 toString 方法。</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="string">&#x27;123&#x27;</span>, c=<span class="number">123</span>;</span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a[b]);  <span class="comment">//c</span></span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="built_in">Symbol</span>(<span class="string">&#x27;123&#x27;</span>), c=<span class="built_in">Symbol</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a[b]); <span class="comment">//b</span></span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">// example 3</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=&#123;<span class="attr">key</span>:<span class="string">&#x27;123&#x27;</span>&#125;, c=&#123;<span class="attr">key</span>:<span class="string">&#x27;456&#x27;</span>&#125;;</span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a[b]); <span class="comment">//c</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="string">&#x27;123&#x27;</span>, c=<span class="number">123</span>;</span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 的键名会被转换成字符串&#x27;123&#x27;，这里会把 b 覆盖掉。</span></span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 c</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="built_in">Symbol</span>(<span class="string">&#x27;123&#x27;</span>), c=<span class="built_in">Symbol</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b 是 Symbol 类型，不需要转换。</span></span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 是 Symbol 类型，不需要转换。任何一个 Symbol 类型的值都是不相等的，所以不会覆盖掉 b。</span></span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 b</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 3</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=&#123;<span class="attr">key</span>:<span class="string">&#x27;123&#x27;</span>&#125;, c=&#123;<span class="attr">key</span>:<span class="string">&#x27;456&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b 不是字符串也不是 Symbol 类型，需要转换成字符串。</span></span><br><span class="line"><span class="comment">// 对象类型会调用 toString 方法转换成字符串 [object Object]。</span></span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 不是字符串也不是 Symbol 类型，需要转换成字符串。</span></span><br><span class="line"><span class="comment">// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。</span></span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 c</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-77-题-（2019-11-18）"><a href="#第-77-题-（2019-11-18）" class="headerlink" title="第 77 题 （2019/11/18）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/126">第 77 题</a> （2019/11/18）</h3><p><strong>题目：</strong></p>
<blockquote>
<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] 和 k = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: [<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步: [<span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">向右旋转 <span class="number">3</span> 步: [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">-1</span>, <span class="number">-100</span>, <span class="number">3</span>, <span class="number">99</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出: [<span class="number">3</span>, <span class="number">99</span>, <span class="number">-1</span>, <span class="number">-100</span>]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: [<span class="number">99</span>, <span class="number">-1</span>, <span class="number">-100</span>, <span class="number">3</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步: [<span class="number">3</span>, <span class="number">99</span>, <span class="number">-1</span>, <span class="number">-100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rotateArr</span>(<span class="params">arr, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    arr.unshift(arr.pop());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-78-题-（2019-11-18）"><a href="#第-78-题-（2019-11-18）" class="headerlink" title="第 78 题  （2019/11/18）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/128">第 78 题 </a> （2019/11/18）</h3><p><strong>题目</strong> ：Vue 的父组件和子组件生命周期钩子执行顺序是什么</p>
<p><strong>解析：</strong></p>
<blockquote>
<p>总结：<u>从外到内，再从内到外</u></p>
</blockquote>
<ol>
<li>加载渲染过程<br><code>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</code></li>
<li>子组件更新过程<br><code>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</code></li>
<li>父组件更新过程<br><code>父beforeUpdate-&gt;父updated</code></li>
<li>销毁过程<br><code>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</code></li>
</ol>
<p><img src="https://segmentfault.com/img/bVbePUv?w=302&h=298"></p>
<h3 id="第-79-题-（2019-11-18）"><a href="#第-79-题-（2019-11-18）" class="headerlink" title="第 79 题 （2019/11/18）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/129">第 79 题</a> （2019/11/18）</h3><p><strong>题目：</strong> input 搜索如何防抖，如何处理中文输入</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013094932">input 事件中文触发多次问题研究</a></p>
<p>简易防抖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-80-题-（2019-11-19）"><a href="#第-80-题-（2019-11-19）" class="headerlink" title="第 80 题 （2019/11/19）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/130">第 80 题</a> （2019/11/19）</h3><p><strong>题目：</strong> 介绍下 Promise.all 使用、原理实现及错误处理</p>
<h3 id="第-81-题-（2019-11-19）"><a href="#第-81-题-（2019-11-19）" class="headerlink" title="第 81 题 （2019/11/19）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/131">第 81 题</a> （2019/11/19）</h3><p><strong>题目：</strong> 打印出 1 - 10000 之间的所有对称数</p>
<blockquote>
<p>例如：121、1331 等</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num.toString() === num.toString().split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (f(i)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-82-题-（2019-11-19）"><a href="#第-82-题-（2019-11-19）" class="headerlink" title="第 82 题 （2019/11/19）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/132">第 82 题</a> （2019/11/19）</h3><blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">12</span>];</span><br><span class="line">输出: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<ol>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ol>
</blockquote>
<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Movezero</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] != <span class="number">0</span>) &#123;</span><br><span class="line">      arr[index++] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; arr.length) &#123;</span><br><span class="line">    arr[index++] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-83-题-（2019-11-20）"><a href="#第-83-题-（2019-11-20）" class="headerlink" title="第 83 题 （2019/11/20）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/133">第 83 题</a> （2019/11/20）</h3><p><strong>题目：</strong> var、let 和 const 区别的实现原理是什么</p>
<p><strong>解析：</strong></p>
<p><strong>区别：</strong></p>
<ol>
<li><p>var 声明的变量会挂载在 window 上，而 let 和 const 声明的变量不会</p>
</li>
<li><p>var 声明变量存在变量提升，let 和 const 不存在变量提升</p>
</li>
<li><p>let 和 const 声明形成块作用域，而 var 不存在此作用域</p>
</li>
<li><p>同一作用域下 let 和 const 不能声明同名变量，而 var 可以</p>
</li>
<li><p>let、const 存在暂存死区</p>
</li>
<li><p>const</p>
<ol>
<li>一旦声明必须赋值,不能使用 null 占位。</li>
<li>声明后不能再修改</li>
<li>如果声明的是复合类型数据，可以修改其属性*</li>
</ol>
</li>
</ol>
<p><strong>var、let、const 实现原理</strong></p>
<p>记得 JS 权威指南中有一句很精辟的描述:　”JavaScript 中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里.”</p>
<p>以下属于推测，在网上没查到确凿的原理机制（若有误望指正）：</p>
<p>原理大概是：在 js 解析的时候，优先解析 const，因为它不能修改的是栈内存在的值和地址。然后解析 let 因为没有块作用域可能底层有处理，最后解析 var</p>
<h3 id="第-84-题-（2019-11-21）"><a href="#第-84-题-（2019-11-21）" class="headerlink" title="第 84 题 （2019/11/21）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/134">第 84 题</a> （2019/11/21）</h3><p><strong>题目：</strong> 请实现一个 add 函数，满足以下功能。</p>
<p><strong>知识点</strong> ：函数柯里化 <a target="_blank" rel="noopener" href="https://github.com/chokcoco/cnblogsArticle/issues/15">题解</a> <u>运用了函数会自行调用 <code>valueOf</code> 方法这个技巧</u></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>); 			<span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);  	<span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)；<span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>之前参阅 2 篇文章，可以参考一二。<br>1、<a target="_blank" rel="noopener" href="https://github.com/yygmind/blog/issues/36#%E6%80%9D%E8%80%83%E9%A2%98">【进阶 6-1 期】JavaScript 高阶函数浅析</a><br>2、<a target="_blank" rel="noopener" href="https://github.com/yygmind/blog/issues/37">【进阶 6-2 期】深入高阶函数应用之柯里化</a></p>
<p>其中第一篇文章给出了前三个功能的实现，并没有覆盖到后面三种。<br>第二篇文章实现了一个通用的柯里化函数，覆盖实现了所有功能。</p>
<p><strong>解析：</strong></p>
<p><strong>去重</strong>（ <u>数字组数</u> ） ：使用高阶函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = arr1.filter(<span class="function">(<span class="params">element, index, self</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> self.indexOf(element) === index;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br><span class="line"><span class="comment">// [1, 2, 3, 5, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="comment">// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]</span></span><br></pre></td></tr></table></figure>

<p>函数作为返回值输出</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isType = <span class="function">(<span class="params">type</span>) =&gt;</span> <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">&quot;[object &quot;</span> + type + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">isType(<span class="string">&quot;String&quot;</span>)(<span class="string">&quot;123&quot;</span>); <span class="comment">// true</span></span><br><span class="line">isType(<span class="string">&quot;Array&quot;</span>)([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// true</span></span><br><span class="line">isType(<span class="string">&quot;Number&quot;</span>)(<span class="number">123</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;进入add&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arg_fn = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;调用fn&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> add.apply(<span class="literal">null</span>, args.concat(arg_fn));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  fn.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;调用valueOf&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    add(1);</span></span><br><span class="line"><span class="comment">    // 输出如下：</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用valueOf</span></span><br><span class="line"><span class="comment">    // 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    add(1)(2);</span></span><br><span class="line"><span class="comment">    // 输出如下：</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用fn</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用valueOf</span></span><br><span class="line"><span class="comment">    // 3</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    add(1)(2)(3);</span></span><br><span class="line"><span class="comment">    // 输出如下：</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用fn</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用fn</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用valueOf</span></span><br><span class="line"><span class="comment">    // 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里有个规律，如果只改写 <code>valueOf()</code> 或是 <code>toString()</code> 其中一个，会优先调用被改写了的方法，而如果两个同时改写，则会像 String 转换规则一样，优先查询 <code>valueOf()</code> 方法，在 <code>valueOf() </code>方法返回的是非原始类型的情况下再查询 <code>toString()</code> 方法。</p>
<h3 id="第-85-题-（2019-11-23）"><a href="#第-85-题-（2019-11-23）" class="headerlink" title="第 85 题 （2019/11/23）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/135">第 85 题</a> （2019/11/23）</h3><p><strong>题目：</strong> react-router 里的 <code>&lt;Link&gt;</code> 标签和 <code>&lt;a&gt;</code> 标签有什么区别</p>
<blockquote>
<p>如何禁掉 <code>&lt;a&gt;</code> 标签默认事件，禁掉之后如何实现跳转。</p>
</blockquote>
<p><strong>解析：</strong></p>
<p>从最终渲染的 DOM 来看，这两者都是链接，都是 <code>&lt;a&gt;</code> 标签，区别是：<br><code>&lt;Link&gt;</code> 是 react-router 里实现路由跳转的链接，一般配合 <code>&lt;Route&gt;</code> 使用，react-router 接管了其默认的链接跳转行为，区别于传统的页面跳转，<code>&lt;Link&gt;</code> 的“跳转”行为只会触发相匹配的 <code>&lt;Route&gt;</code> 对应的页面内容更新，而不会刷新整个页面。<br>而 <code>&lt;a&gt;</code> 标签就是普通的超链接了，用于从当前页面跳转到 href 指向的另一个页面（非锚点情况）。</p>
<h3 id="第-86-题-（2019-11-23）"><a href="#第-86-题-（2019-11-23）" class="headerlink" title="第 86 题 （2019/11/23）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/136">第 86 题</a> （2019/11/23）</h3><p><strong>题目：</strong> 周一算法题之「两数之和」</p>
<blockquote>
<p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p>
<p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>公司</strong> ：京东、快手</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Getarr</span>(<span class="params">num, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pre = <span class="number">0</span>,</span><br><span class="line">    cur = num.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (num.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;至少提供2个数字&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (pre &lt; cur) &#123;</span><br><span class="line">    result = num[pre] + num[cur];</span><br><span class="line">    <span class="keyword">if</span> (result &gt; target) &#123;</span><br><span class="line">      cur--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &lt; target) &#123;</span><br><span class="line">      pre++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> [pre, cur];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-87-题-（2019-11-24）"><a href="#第-87-题-（2019-11-24）" class="headerlink" title="第 87 题 （2019/11/24）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/138">第 87 题</a> （2019/11/24）</h3><p><strong>题目：</strong>在输入框中如何判断输入的是一个正确的网址。</p>
<p><strong>解析：</strong> <u>location 可以获取本页面的 URL 信息</u></p>
<blockquote>
<p>不上正则，一个简单的玩法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUrl</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">	a.href = url</span><br><span class="line">	<span class="keyword">return</span> [</span><br><span class="line">		/^(http|https):$/.test(a.protocol), <span class="comment">// &quot;https:&quot; 协议</span></span><br><span class="line">		a.host,  						<span class="comment">//  &quot;baidu.com&quot; =&gt; 端口（port）</span></span><br><span class="line">		a.pathname !== url,				<span class="comment">// &quot;/&quot;</span></span><br><span class="line">		a.pathname !== <span class="string">`/<span class="subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">	].find(<span class="function"><span class="params">x</span> =&gt;</span> !x) === <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用 <code>URL()</code> 构造函数返回一个新创建的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL"><code>URL</code></a> 对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUrl</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> URL(url);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isUrl = <span class="function">(<span class="params">urlStr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; href, origin, host, hostname, pathname &#125; = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">    <span class="keyword">return</span> href &amp;&amp; origin &amp;&amp; host &amp;&amp; hostname &amp;&amp; pathname &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>正则：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^(https?:\/\/)?([a-z0<span class="number">-9</span>]\.|[a-z0<span class="number">-9</span>][-a-z0<span class="number">-9</span>]*[a-z0<span class="number">-9</span>]\.)*([a-z]+)(:\d+)?(\/.*)?$/;</span><br></pre></td></tr></table></figure>

<h3 id="第-88-题-（2019-12-04）"><a href="#第-88-题-（2019-12-04）" class="headerlink" title="第 88 题 （2019/12/04）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/139">第 88 题</a> （2019/12/04）</h3><p>以下数据结构中，id 代表部门编号，name 是部门名称，parentId 是父部门编号，为 0 代表一级部门，现在要求实现一个 convert 方法，把原始 list 转换成树形结构，parentId 为多少就挂载在该 id 的属性 children 数组下，结构如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始 list 如下</span></span><br><span class="line"><span class="keyword">let</span> list =[</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">&#x27;部门A&#x27;</span>,<span class="attr">parentId</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">&#x27;部门B&#x27;</span>,<span class="attr">parentId</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:<span class="string">&#x27;部门C&#x27;</span>,<span class="attr">parentId</span>:<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">4</span>,<span class="attr">name</span>:<span class="string">&#x27;部门D&#x27;</span>,<span class="attr">parentId</span>:<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">5</span>,<span class="attr">name</span>:<span class="string">&#x27;部门E&#x27;</span>,<span class="attr">parentId</span>:<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">6</span>,<span class="attr">name</span>:<span class="string">&#x27;部门F&#x27;</span>,<span class="attr">parentId</span>:<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">7</span>,<span class="attr">name</span>:<span class="string">&#x27;部门G&#x27;</span>,<span class="attr">parentId</span>:<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">8</span>,<span class="attr">name</span>:<span class="string">&#x27;部门H&#x27;</span>,<span class="attr">parentId</span>:<span class="number">4</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> result = convert(list, ...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换后的结果如下</span></span><br><span class="line"><span class="keyword">let</span> result = [</span><br><span class="line">    &#123;</span><br><span class="line">      id: <span class="number">1</span>,</span><br><span class="line">      name: <span class="string">&#x27;部门A&#x27;</span>,</span><br><span class="line">      parentId: <span class="number">0</span>,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: <span class="number">3</span>,</span><br><span class="line">          name: <span class="string">&#x27;部门C&#x27;</span>,</span><br><span class="line">          parentId: <span class="number">1</span>,</span><br><span class="line">          children: [</span><br><span class="line">            &#123;</span><br><span class="line">              id: <span class="number">6</span>,</span><br><span class="line">              name: <span class="string">&#x27;部门F&#x27;</span>,</span><br><span class="line">              parentId: <span class="number">3</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">              id: <span class="number">16</span>,</span><br><span class="line">              name: <span class="string">&#x27;部门L&#x27;</span>,</span><br><span class="line">              parentId: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: <span class="number">4</span>,</span><br><span class="line">          name: <span class="string">&#x27;部门D&#x27;</span>,</span><br><span class="line">          parentId: <span class="number">1</span>,</span><br><span class="line">          children: [</span><br><span class="line">            &#123;</span><br><span class="line">              id: <span class="number">8</span>,</span><br><span class="line">              name: <span class="string">&#x27;部门H&#x27;</span>,</span><br><span class="line">              parentId: <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">  ···</span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong> ~~</p>
<h3 id="第-89-题-（2019-12-04）"><a href="#第-89-题-（2019-12-04）" class="headerlink" title="第 89 题 （2019/12/04）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/140">第 89 题</a> （2019/12/04）</h3><p><strong>题目</strong> ：设计并实现 Promise.race()</p>
<p><strong>解析：</strong> 代写~</p>
<h3 id="第-90-题-（2019-12-05）"><a href="#第-90-题-（2019-12-05）" class="headerlink" title="第 90 题 （2019/12/05）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/141">第 90 题</a> （2019/12/05）</h3><p><strong>题目：</strong> 实现模糊搜索结果的关键词高亮显示</p>
<p><img src="http://static.zxinc520.com/blog/20191205/sF0nw6wEI0qf.png?imageslim" alt="mark"></p>
<blockquote>
<p>考虑节流、缓存。其实还可以上列表 diff+定时清理缓存</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>auto complete<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      bdi &#123;</span><br><span class="line">        color: rgb(0, 136, 255);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      li &#123;</span><br><span class="line">        list-style: none;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;inp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, timeout = <span class="number">300</span></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> t;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span></span><br><span class="line">        if (t) &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">clearTimeout</span>(t);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        t = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line">          fn.apply(fn, args);</span><br><span class="line">        &#125;, timeout);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">fn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span></span><br><span class="line">        if (!name) &#123;</span><br><span class="line"><span class="javascript">          container.innerHTML = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        if (cache.get(name)) &#123;</span><br><span class="line">          container.innerHTML = cache.get(name);</span><br><span class="line"><span class="javascript">          <span class="keyword">return</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> res = fn.call(fn, name).join(<span class="string">&quot;&quot;</span>);</span></span><br><span class="line">        cache.set(name, res);</span><br><span class="line">        container.innerHTML = res;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">handleInput</span>(<span class="params">value</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`\(<span class="subst">$&#123;value&#125;</span>\)`</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> search = data.reduce(<span class="function">(<span class="params">res, cur</span>) =&gt;</span> &#123;</span></span><br><span class="line">        if (reg.test(cur)) &#123;</span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> match = <span class="built_in">RegExp</span>.$<span class="number">1</span>;</span></span><br><span class="line"><span class="handlebars"><span class="xml">          res.push(`<span class="tag">&lt;<span class="name">li</span>&gt;</span>$&#123;cur.replace(match, &quot;<span class="tag">&lt;<span class="name">bdi</span>&gt;</span>$&amp;<span class="tag">&lt;/<span class="name">bdi</span>&gt;</span>&quot;)&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>`);</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> res;</span></span><br><span class="line">      &#125;, []);</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> search;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> data = [</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;上海野生动物园&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;上饶野生动物园&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;北京巷子&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;上海中心&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;上海黄埔江&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;迪士尼上海&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;陆家嘴上海中心&quot;</span>,</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> container = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.container&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> memorizeInput = memorize(handleInput);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">&quot;.inp&quot;</span>).addEventListener(</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;input&quot;</span>,</span></span><br><span class="line"><span class="javascript">      debounce(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.target.value);</span></span><br><span class="line">        memorizeInput(e.target.value);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="第-91-题-（2019-12-05）"><a href="#第-91-题-（2019-12-05）" class="headerlink" title="第 91 题 （2019/12/05）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/142">第 91 题</a> （2019/12/05）</h3><p><strong>题目：</strong> 介绍下 HTTPS 中间人攻击</p>
<p><strong>解析：</strong></p>
<p>https 协议由 http + ssl 协议构成，具体的链接过程可参考<a target="_blank" rel="noopener" href="https://github.com/lvwxx/blog/issues/3">SSL 或 TLS 握手的概述</a></p>
<p>中间人攻击过程如下：</p>
<ol>
<li>服务器向客户端发送公钥。</li>
<li>攻击者截获公钥，保留在自己手上。</li>
<li>然后攻击者自己生成一个【伪造的】公钥，发给客户端。</li>
<li>客户端收到伪造的公钥后，生成加密 hash 值发给服务器。</li>
<li>攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥。</li>
<li>同时生成假的加密 hash 值，发给服务器。</li>
<li>服务器用私钥解密获得假秘钥。</li>
<li>服务器用加秘钥加密传输信息</li>
</ol>
<p>防范方法：</p>
<ol>
<li>服务端在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性</li>
</ol>
<h3 id="第-92-题-（2019-12-15）"><a href="#第-92-题-（2019-12-15）" class="headerlink" title="第 92 题 （2019/12/15）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/143">第 92 题</a> （2019/12/15）</h3><p><strong>题目：</strong>已知数据格式，实现一个函数 fn 找出链条中所有的父级 id</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="string">&#x27;112&#x27;</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">fn(value) <span class="comment">// 输出 [1， 11， 112]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="string">&quot;112&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">    arr.push(value.slice(<span class="number">0</span>, i + <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.map(<span class="built_in">Number</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第-93-题-（2019-12-15）"><a href="#第-93-题-（2019-12-15）" class="headerlink" title="第 93 题 （2019/12/15）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/144">第 93 题</a> （2019/12/15）</h3><p><strong>题目：</strong> 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log(m+n))。</p>
<p>示例 1：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line">nums2 = [<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>中位数是 2.0</p>
<p>示例 2：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">nums2 = [<span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>中位数是(2 + 3) / 2 = 2.5</p>
<p><strong>解析：</strong></p>
<h3 id="第-94-题-（2019-12-15）"><a href="#第-94-题-（2019-12-15）" class="headerlink" title="第 94 题 （2019/12/15）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/145">第 94 题</a> （2019/12/15）</h3><p><strong>题目：</strong> vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？</p>
<p><strong>解析:</strong></p>
<blockquote>
<p>Well, delegation has two main advantages: one is practical - it saves you from having to add (and remove!!) those listeners individually. But Vue already does that for you.</p>
<p>The other one is performance / memory. But since every click listener in a v-vor loop would use the same callback, this is minimal unless you have hundreds or thousands of rows.</p>
<p>And finally, you can use delegation pretty easily by adding an @click listener to the <ul> element instead of the children. But then you have to resort to checks on the click target to evaluate which item in your data it might represent. So I would only use that if you truly find any performance problems without delegation.</p>
</blockquote>
<p>好，委派有两个主要优点：一个是实用的-它使您不必分别添加（和删除！）这些侦听器。 但是 Vue 已经为您做到了。</p>
<p>另一个是性能/内存。 但是，由于 v-vor 循环中的每个单击侦听器都将使用相同的回调，因此除非您有成百上千的行，否则这是最小的。</p>
<p>最后，您可以通过在&lt;_ul_ &gt;元素（而不是子元素）中添加@click 侦听器来轻松使用委派。 但是随后，您必须求助于点击目标，以评估数据中可能代表的项目。 因此，只有在您真正发现任何性能问题而没有委派的情况下，我才使用它。</p>
<h3 id="第-95-题-（2019-12-23）"><a href="#第-95-题-（2019-12-23）" class="headerlink" title="第 95 题 （2019/12/23）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/148">第 95 题</a> （2019/12/23）</h3><p><strong>题目：</strong> 模拟实现一个深拷贝，并考虑对象相互引用以及 Symbol 拷贝的情况</p>
<p><strong>解析：</strong></p>
<blockquote>
<p>一个不考虑其他数据类型的公共方法，基本满足大部分场景</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">target, cache = new Set()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&quot;object&quot;</span> || cache.has(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target)) &#123;</span><br><span class="line">    target.map(<span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line">      cache.add(t);</span><br><span class="line">      <span class="keyword">return</span> t;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      ...Object.keys(target),</span><br><span class="line">      ...Object.getOwnPropertySymbols(target),</span><br><span class="line">    ].reduce(</span><br><span class="line">      (res, key) =&gt; &#123;</span><br><span class="line">        cache.add(target[key]);</span><br><span class="line">        res[key] = deepCopy(target[key], cache);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">      &#125;,</span><br><span class="line">      target.constructor !== <span class="built_in">Object</span></span><br><span class="line">        ? <span class="built_in">Object</span>.create(target.constructor.prototype)</span><br><span class="line">        : &#123;&#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要问题是</p>
<ol>
<li>symbol 作为 key，不会被遍历到，所以 stringify 和 parse 是不行的</li>
<li>有环引用，stringify 和 parse 也会报错</li>
</ol>
<p>我们另外用<code>getOwnPropertySymbols</code>可以获取 symbol key 可以解决问题 1，用集合记忆曾经遍历过的对象可以解决问题 2。当然，还有很多数据类型要独立去拷贝。比如拷贝一个 RegExp，lodash 是最全的数据类型拷贝了，有空可以研究一下</p>
<p>另外，如果不考虑用 symbol 做 key，还有两种黑科技深拷贝，可以解决环引用的问题，比 stringify 和 parse 优雅强一些</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopyByHistory</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prev = history.state;</span><br><span class="line">  history.replaceState(target, <span class="built_in">document</span>.title);</span><br><span class="line">  <span class="keyword">const</span> res = history.state;</span><br><span class="line">  history.replaceState(prev, <span class="built_in">document</span>.title);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">deepCopyByMessageChannel</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">    channel.port2.onmessage = <span class="function">(<span class="params">ev</span>) =&gt;</span> resolve(ev.data);</span><br><span class="line">    channel.port1.postMessage(target);</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论哪种方法，它们都有一个共性：失去了继承关系，所以剩下的需要我们手动补上去了，故有<code>Object.create(target.constructor.prototype)</code>的操作</p>
</blockquote>
<p>有两个问题：</p>
<ol>
<li>如果 <code>target</code> 是一个数组，拷贝结果没有返回</li>
<li>如果 <code>target</code> 是一个函数，函数没有被深拷贝</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%89%9B%E4%BA%BA%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">牛人面试题</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Step-By-Step"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/09/20/Step-By-Step/"
    >【Step-By-Step】一周面试题深入解析</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/09/20/Step-By-Step/" class="article-date">
  <time datetime="2019-09-20T06:43:04.000Z" itemprop="datePublished">2019-09-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%89%9B%E4%BA%BA%E9%9D%A2%E8%AF%95%E9%A2%98/">牛人面试题</a> / <a class="article-category-link" href="/categories/%E7%89%9B%E4%BA%BA%E9%9D%A2%E8%AF%95%E9%A2%98/Step-By-Step/">Step-By-Step</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="【Step-By-Step】一周面试题深入解析-周刊-01"><a href="#【Step-By-Step】一周面试题深入解析-周刊-01" class="headerlink" title="【Step-By-Step】一周面试题深入解析 / 周刊 01"></a>【Step-By-Step】一周面试题深入解析 / 周刊 01</h2><blockquote>
<p>已完结~</p>
<p>今天 2019/11/04 😜 (ง •_•)ง</p>
</blockquote>
<h3 id="1-如何正确判断-this-的指向？-2019-09-19"><a href="#1-如何正确判断-this-的指向？-2019-09-19" class="headerlink" title="1.如何正确判断 this 的指向？(2019-09-19)"></a>1.如何正确判断 this 的指向？(2019-09-19)</h3><p>如果用一句话说明 this 的指向，那么即是: 谁调用它，this 就指向谁。</p>
<p>但是仅通过这句话，我们很多时候并不能准确判断 this 的指向。因此我们需要借助一些规则去帮助自己：</p>
<p>this 的指向可以按照以下顺序判断:</p>
<p><strong>1、全局环境中的 this</strong></p>
<p>浏览器环境：无论是否在 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式</a> 下，在全局执行环境中（在任何函数体外部）this 都指向全局对象 <code>window</code>;</p>
<p>node 环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部），this 都是空对象 <code>&#123;&#125;</code></p>
<p><strong>2、是否是 <code>new</code> 绑定</strong></p>
<p>如果是 <code>new</code> 绑定，并且构造函数中没有返回 function 或者是 object，那么 this 指向这个新对象。如下:</p>
<blockquote>
<p>构造函数返回值不是 function 或 object。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> Super(<span class="string">&quot;26&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance.age); <span class="comment">//26</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造函数返回值是 function 或 object，这种情况下 this 指向的是返回的对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">&quot;2&quot;</span> &#125;;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> Super(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance.age); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>你可以想知道为什么会这样？我们来看一下 <code>new</code> 的实现原理:</p>
<ol>
<li>创建一个新对象。</li>
<li>这个新对象会被执行 <code>[[原型]]</code> 连接。</li>
<li>属性和方法被加入到 this 引用的对象中。并执行了构造函数中的方法.</li>
<li>如果函数没有返回其他对象，那么 this 指向这个新对象，否则 this 指向构造函数中返回的对象。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line">  target.__proto__ = func.prototype;</span><br><span class="line">  <span class="keyword">let</span> res = func.call(target);</span><br><span class="line">  <span class="comment">//排除 null 的情况</span></span><br><span class="line">  <span class="keyword">if</span> ((res &amp;&amp; <span class="keyword">typeof</span> res == <span class="string">&quot;object&quot;</span>) || <span class="keyword">typeof</span> res == <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3</strong>、函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么 this 绑定的就是指定的对象【归结为显式绑定】。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  info,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">var</span> info = person.info;</span><br><span class="line">info.call(person); <span class="comment">//20</span></span><br><span class="line">info.apply(person); <span class="comment">//20</span></span><br><span class="line">info.bind(person)(); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<p>这里同样需要注意一种<strong>特殊</strong>情况，如果 call,apply 或者 bind 传入的第一个参数值是 <code>undefined</code> 或者 <code>null</code>，严格模式下 this 的值为传入的值 null /undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node 环境为 global，浏览器环境为 window)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//node环境中:非严格模式 global，严格模式为null</span></span><br><span class="line">  <span class="comment">//浏览器环境中:非严格模式 window，严格模式为null</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  info,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">var</span> info = person.info;</span><br><span class="line"><span class="comment">//严格模式抛出错误；</span></span><br><span class="line"><span class="comment">//非严格模式，node下输出undefined（因为全局的age不会挂在 global 上）</span></span><br><span class="line"><span class="comment">//非严格模式。浏览器环境下输出 28（因为全局的age会挂在 window 上）</span></span><br><span class="line">info.call(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><strong>4、</strong>隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: <code>xxx.fn()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  info,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line">person.info(); <span class="comment">//20;执行的是隐式绑定</span></span><br></pre></td></tr></table></figure>

<p><strong>5、</strong> 默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。</p>
<p>非严格模式： node 环境，执行全局对象 global，浏览器环境，执行全局对象 window。</p>
<p>严格模式：执行 undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="comment">//严格模式；抛错</span></span><br><span class="line"><span class="comment">//非严格模式，node下输出 undefined（因为全局的age不会挂在 global 上）</span></span><br><span class="line"><span class="comment">//非严格模式。浏览器环境下输出 28（因为全局的age会挂在 window 上）</span></span><br><span class="line"><span class="comment">//严格模式抛出，因为 this 此时是 undefined</span></span><br><span class="line">info();</span><br></pre></td></tr></table></figure>

<p><strong>6、</strong> 箭头函数的情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  info: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.age); <span class="comment">//this继承的是外层上下文绑定的this</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">age</span>: <span class="number">28</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> info = obj.info();</span><br><span class="line">info(); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> info2 = obj.info.call(person);</span><br><span class="line">info2(); <span class="comment">//28</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/1">点击查看更多</a></p>
<h3 id="2-JS-中原始类型有哪几种？null-是对象吗？原始数据类型和复杂数据类型有什么区别？-2019-09-20"><a href="#2-JS-中原始类型有哪几种？null-是对象吗？原始数据类型和复杂数据类型有什么区别？-2019-09-20" class="headerlink" title="2.JS 中原始类型有哪几种？null 是对象吗？原始数据类型和复杂数据类型有什么区别？(2019-09-20)"></a>2.JS 中原始类型有哪几种？null 是对象吗？原始数据类型和复杂数据类型有什么区别？(2019-09-20)</h3><p><strong>目前，JS 原始类型有六种，分别为:</strong></p>
<ul>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Undefined</li>
<li>Null</li>
<li>Symbol(ES6 新增)</li>
</ul>
<p>ES10 新增了一种基本数据类型：BigInt</p>
<p>复杂数据类型只有一种: Object</p>
<p>null 不是一个对象，尽管 <code>typeof null</code> 输出的是 <code>object</code>，这是一个历史遗留问题，JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，<code>null</code> 表示为全零，所以将它错误的判断为 <code>object</code> 。</p>
<p><strong>基本数据类型和复杂数据类型的区别为:</strong></p>
<p>1、内存的分配不同</p>
<ul>
<li>基本数据类型存储在栈中。</li>
<li>复杂数据类型存储在堆中，栈中存储的变量，是指向堆中的引用地址。</li>
</ul>
<p>2、访问机制不同</p>
<ul>
<li>基本数据类型是按值访问</li>
<li>复杂数据类型按引用访问，JS 不允许直接访问保存在堆内存中的对象，在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值。</li>
</ul>
<p>3、复制变量时不同(a=b)</p>
<ul>
<li>基本数据类型：a=b;是将 b 中保存的原始值的副本赋值给新变量 a，a 和 b 完全独立，互不影响</li>
<li>复杂数据类型：a=b;将 b 保存的对象内存的引用地址赋值给了新变量 a;a 和 b 指向了同一个堆内存地址，其中一个值发生了改变，另一个也会改变。</li>
</ul>
<p>4、参数传递的不同(实参/形参)</p>
<p>函数传参都是按值传递(栈中的存储的内容)：基本数据类型，拷贝的是值；复杂数据类型，拷贝的是引用地址</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/5">点击查看更多</a></p>
</blockquote>
<h3 id="3-说一说你对-HTML5-语义化的理解-2019-09-21"><a href="#3-说一说你对-HTML5-语义化的理解-2019-09-21" class="headerlink" title="3.说一说你对 HTML5 语义化的理解(2019-09-21)"></a>3.说一说你对 HTML5 语义化的理解(2019-09-21)</h3><p>语义化意味着顾名思义，HTML5 的语义化指的是合理正确的使用语义化的标签来创建页面结构，如 header,footer,nav，从标签上即可以直观的知道这个标签的作用，而不是滥用 div。</p>
<p><strong>语义化的优点有:</strong></p>
<ul>
<li>代码结构清晰，易于阅读，利于开发和维护</li>
<li>方便其他设备解析（如屏幕阅读器）根据语义渲染网页。</li>
<li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</li>
<li></li>
</ul>
<h3 id="4-如何让-a-1-amp-amp-a-2-amp-amp-a-3-的值为-true？-2019-09-22"><a href="#4-如何让-a-1-amp-amp-a-2-amp-amp-a-3-的值为-true？-2019-09-22" class="headerlink" title="4.如何让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 的值为 true？(2019-09-22)"></a>4.如何让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 的值为 true？(2019-09-22)</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Blog/issues/31">可参考</a></p>
</blockquote>
<p><strong>4.1 利用隐式转换规则</strong></p>
<p><code>==</code> 操作符在左右数据类型不一致时，会先进行隐式转换。</p>
<p><code>a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</code> 的值意味着其不可能是基本数据类型。因为如果 a 是 null 或者是 undefined bool 类型，都不可能返回 true。</p>
<p>因此可以推测 a 是复杂数据类型，JS 中复杂数据类型只有 <code>object</code>，回忆一下，Object 转换为原始类型会调用什么方法？</p>
<ul>
<li>如果部署了 <code>[Symbol.toPrimitive]</code> 接口，那么调用此接口，若返回的不是基本数据类型，抛出错误。</li>
<li>如果没有部署 <code>[Symbol.toPrimitive]</code> 接口，那么根据要转换的类型，先调用 <code>valueOf</code> / <code>toString</code><ol>
<li>非 Date 类型对象，<code>hint</code> 是 <code>default</code> 时，调用顺序为：<code>valueOf</code> &gt;&gt;&gt; <code>toString</code>，即<code>valueOf</code> 返回的不是基本数据类型，才会继续调用 <code>toString</code>，如果<code>toString</code> 返回的还不是基本数据类型，那么抛出错误。</li>
<li>如果 <code>hint</code> 是 <code>string</code>(Date 对象的 hint 默认是 string) ，调用顺序为：<code>toString</code> &gt;&gt;&gt; <code>valueOf</code>，即<code>toString</code> 返回的不是基本数据类型，才会继续调用 <code>valueOf</code>，如果<code>valueOf</code> 返回的还不是基本数据类型，那么抛出错误。</li>
<li>如果 <code>hint</code> 是 <code>number</code>，调用顺序为： <code>valueOf</code> &gt;&gt;&gt; <code>toString</code></li>
</ol>
</li>
</ul>
<p>那么对于这道题，只要 <code>[Symbol.toPrimitive]</code> 接口，第一次返回的值是 1，然后递增，即成功成立。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]: (<span class="function"><span class="keyword">function</span> (<span class="params">hint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//闭包的特性之一：i 不会被回收</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>调用 <code>valueOf</code> 接口的情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  valueOf: (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//闭包的特性之一：i 不会被回收</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>另外，除了 i 自增的方法外，还可以利用 正则，如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  reg: <span class="regexp">/\d/g</span>,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.reg.exec(<span class="number">123</span>)[<span class="number">0</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>4.2 利用数据劫持</strong></p>
<p>使用 <code>Object.defineProperty</code> 定义的属性，在获取属性时，会调用 <code>get</code> 方法。利用这个特性，我们在 <code>window</code> 对象上定义 <code>a</code> 属性，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i++;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>ES6 新增了 <code>Proxy</code> ，此处我们同样可以利用 <code>Proxy</code> 去实现，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    i: <span class="number">1</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">this</span>.i++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>4.3 数组的 <code>toString</code> 接口默认调用数组的 <code>join</code> 方法，重写数组的 <code>join</code> 方法。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.join = a.shift;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>4.4 利用 <code>with</code> 关键字</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">a</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-防抖-debounce-函数的作用是什么？有哪些应用场景，请实现一个防抖函数。-2019-09-23"><a href="#5-防抖-debounce-函数的作用是什么？有哪些应用场景，请实现一个防抖函数。-2019-09-23" class="headerlink" title="5.防抖(debounce)函数的作用是什么？有哪些应用场景，请实现一个防抖函数。(2019-09-23)"></a>5.防抖(debounce)函数的作用是什么？有哪些应用场景，请实现一个防抖函数。(2019-09-23)</h3><blockquote>
<p><a target="_blank" rel="noopener" href="http://zxinc520.com/lcj/%225d84756e662e3d49cc2c5b01%22">可参考第三题 </a></p>
</blockquote>
<h4 id="防抖函数的作用"><a href="#防抖函数的作用" class="headerlink" title="防抖函数的作用"></a>防抖函数的作用</h4><p>防抖函数的作用就是控制函数在一定时间内的执行次数。防抖意味着 N 秒内函数只会被执行一次，如果 N 秒内再次被触发，则重新计算延迟时间。</p>
<p>举例说明：小思最近在减肥，但是她非常贪吃。为此，与其男朋友约定好，如果 10 天不吃零食，就可以购买一个包(不要问为什么是包，因为包治百病)。但是如果中间吃了一次零食，那么就要重新计算时间，直到小思坚持 10 天没有吃零食，才能购买一个包。所以，管不住嘴的小思，没有机会买包(悲伤的故事)…这就是<strong>防抖</strong>。</p>
<p>不管吃没吃零食，每 10 天买一个包，中间想买包，忍着，等到第十天的时候再买，这种情况是<strong>节流</strong>。如何控制女朋友的消费，各位攻城狮们，get 到了吗？防抖可比节流有效多了！</p>
<h4 id="防抖应用场景"><a href="#防抖应用场景" class="headerlink" title="防抖应用场景"></a>防抖应用场景</h4><ol>
<li>搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。</li>
<li>表单验证</li>
<li>按钮提交事件。</li>
<li>浏览器窗口缩放，resize 事件等。</li>
</ol>
<h2 id="【Step-By-Step】一周面试题深入解析-周刊-02"><a href="#【Step-By-Step】一周面试题深入解析-周刊-02" class="headerlink" title="【Step-By-Step】一周面试题深入解析 / 周刊 02"></a>【Step-By-Step】一周面试题深入解析 / 周刊 02</h2><blockquote>
<p>本周面试题一览:</p>
</blockquote>
<ul>
<li>节流(throttle)函数的作用是什么？有哪些应用场景，请实现一个节流函数</li>
<li>说一说你对 JS 执行上下文栈和作用域链的理解？</li>
<li>什么是 BFC？BFC 的布局规则是什么？如何创建 BFC？</li>
<li>let、const、var 的区别有哪些？</li>
<li>深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？</li>
</ul>
<h3 id="6-节流-throttle-函数的作用是什么？有哪些应用场景，请实现一个节流函数。-2019-09-24"><a href="#6-节流-throttle-函数的作用是什么？有哪些应用场景，请实现一个节流函数。-2019-09-24" class="headerlink" title="6. 节流(throttle)函数的作用是什么？有哪些应用场景，请实现一个节流函数。(2019-09-24)"></a>6. 节流(throttle)函数的作用是什么？有哪些应用场景，请实现一个节流函数。(2019-09-24)</h3><blockquote>
<p><strong>解析</strong>： <a target="_blank" rel="noopener" href="http://zxinc520.com/lcj/%225d84756e662e3d49cc2c5b01%22">可参考第三题 </a></p>
</blockquote>
<p><strong>节流函数的作用：</strong></p>
<p>节流函数的作用是规定一个单位时间，在这个单位时间内最多只能触发一次函数执行，如果这个单位时间内多次触发函数，只能有一次生效。</p>
<p>举例说明：小明的妈妈和小明约定好，如果小明在周考中取得满分，那么当月可以带他去游乐场玩，但是一个月最多只能去一次。</p>
<p>这其实就是一个节流的例子，在一个月的时间内，去游乐场最多只能触发一次。即使这个时间周期内，小明取得多次满分。</p>
<p><strong>节流应用场景：</strong></p>
<p>1.按钮点击事件</p>
<p>2.拖拽事件</p>
<p>3.onScoll</p>
<p>4.计算鼠标移动的距离(mousemove)</p>
<h3 id="7-说一说你对-JS-执行上下文栈和作用域链的理解？-2019-09-24"><a href="#7-说一说你对-JS-执行上下文栈和作用域链的理解？-2019-09-24" class="headerlink" title="7. 说一说你对 JS 执行上下文栈和作用域链的理解？(2019-09-24)"></a>7. 说一说你对 JS 执行上下文栈和作用域链的理解？(2019-09-24)</h3><p><a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/?nsukey=rQHqMrFpKq6JJN//OeubPCslaSTSRyuc/XCznnIDze1SGzwva5SZtzixJ13p2gAlxua95Xa7fraZXwj5tyLRDK33+pNhyfKR/xyzhWNyB/qaIlsDGyQBckNoHQGPveOB24M+cK/gF8Tg1ehUGLWiCvumxdgcQwZOWj2BGfD3n/Y=#sec-execution-contexts">JS 执行上下文</a></p>
<p>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。</p>
<blockquote>
<p>执行上下文类型分为：</p>
</blockquote>
<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li>eval 函数执行上下文(不被推荐)</li>
</ul>
<p>执行上下文创建过程中，需要做以下几件事:</p>
<ol>
<li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。</li>
<li>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。</li>
<li>确定 this 的值，即 ResolveThisBinding</li>
</ol>
<p><strong>作用域</strong></p>
<p><strong>作用域</strong>负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。—— 摘录自《你不知道的 JavaScript》(上卷)</p>
<p>作用域有两种工作模型：词法作用域和动态作用域，JS 采用的是<strong>词法作用域</strong>工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。(<code>with</code> 和 <code>eval</code> 能够修改词法作用域，但是不推荐使用，对此不做特别说明)</p>
<blockquote>
<p>作用域分为：</p>
</blockquote>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域</li>
</ul>
<p><strong>JS 执行上下文栈(后面简称执行栈)</strong></p>
<p>执行栈，也叫做调用栈，具有 <strong>LIFO</strong> (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。</p>
<blockquote>
<p>规则如下：</p>
</blockquote>
<ul>
<li>首次运行 JavaScript 代码的时候,会创建一个全局执行的上下文并 Push 到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 Push 当前执行栈的栈顶。</li>
<li>当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中 Pop 出，上下文的控制权将移动到当前执行栈的下一个执行上下文。</li>
</ul>
<p>以一段代码具体说明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;fun3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fun3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure>

<p><code>Global Execution Context</code> (即全局执行上下文)首先入栈，过程如下：</p>
<p><img src="http://static.zxinc520.com/blog/20190925/KgyYmKIHz7fx.png?imageslim" alt="mark"></p>
<p><strong>作用域链</strong></p>
<p>作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。</p>
<h3 id="8-什么是-BFC？BFC-的布局规则是什么？如何创建-BFC？-2019-09-25"><a href="#8-什么是-BFC？BFC-的布局规则是什么？如何创建-BFC？-2019-09-25" class="headerlink" title="8. 什么是 BFC？BFC 的布局规则是什么？如何创建 BFC？(2019-09-25)"></a>8. 什么是 BFC？BFC 的布局规则是什么？如何创建 BFC？(2019-09-25)</h3><blockquote>
<p>什么是 BFC</p>
<p>BFC 是 Block Formatting Context 的缩写，即块格式化上下文。我们来看一下 CSS2.1 规范中对 BFC 的说明</p>
<p>浮动、绝对定位的元素、非块级盒子的块容器（如 inline-blocks、table-cells 和 table-captions），以及<code>overflow</code>的值不为<code>visible</code>（该值已传播到视区时除外）为其内容建立新的块格式上下文。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#block-formatting">BFC 布局规则</a></p>
<ul>
<li>BFC 内，盒子依次垂直排列。</li>
<li>BFC 内，两个盒子的垂直距离由 <code>margin</code> 属性决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠【符合合并原则的 margin 合并后是使用大的 margin】</li>
<li>BFC 内，每个盒子的左外边缘接触内部盒子的左边缘（对于从右到左的格式，右边缘接触）。即使在存在浮动的情况下也是如此。除非创建新的 BFC。</li>
<li>BFC 的区域不会与 float box 重叠。</li>
<li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li>计算 BFC 的高度时，浮动元素也参与计算。</li>
</ul>
<p><strong>如何创建 BFC</strong></p>
<ul>
<li>根元素</li>
<li>浮动元素（float 属性不为 none）</li>
<li>position 为 absolute 或 relative</li>
<li>overflow 不为 visible 的块元素</li>
<li>display 为 inline-block, table-cell, table-caption</li>
</ul>
<p><strong>BFC 的应用</strong></p>
<ol>
<li>防止 margin 重叠</li>
</ol>
<p>根据 BFC 规则，同一个 BFC 内的两个两个相邻 Box 的 <code>margin</code> 会发生重叠，因此我们可以在 div 外面再嵌套一层容器，并且触发该容器生成一个 BFC，这样 <code>&lt;div class=&quot;a&quot;&gt;&lt;/div&gt;</code> 就会属于两个 BFC，自然也就不会再发生 <code>margin</code> 重叠</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.a</span>&#123;</span></span><br><span class="line">        height: 100px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        margin: 50px;</span><br><span class="line">        background: pink;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">overflow</span>: <span class="selector-tag">auto</span>; <span class="comment">/*触发生成BFC*/</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>清除内部浮动</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.a</span>&#123;</span></span><br><span class="line">        height: 100px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        margin: 10px;</span><br><span class="line">        background: pink;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span>&#123;</span></span><br><span class="line">        width: 120px;</span><br><span class="line"><span class="css">        <span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;<span class="comment">/*触发生成BFC*/</span></span></span><br><span class="line">        border: 2px solid black;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>container 的高度没有被撑开，如果我们希望 container 的高度能够包含浮动元素，那么可以创建一个新的 BFC，因为根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算。</p>
<ol start="3">
<li>自适应多栏布局</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body&#123;</span><br><span class="line">        width: 500px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.a</span>&#123;</span></span><br><span class="line">        height: 150px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        background: pink;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.b</span>&#123;</span></span><br><span class="line">        height: 200px;</span><br><span class="line"><span class="css">        <span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>; <span class="comment">/*触发生成BFC*/</span></span></span><br><span class="line">        background: blue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190925/zIMIHi7uVOq6.png?imageslim" alt="mark"></p>
<blockquote>
<p>加了 <code>overflow: hidden;</code> 触发生成 BFC</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190925/BFiWOckmwL9V.png?imageslim" alt="mark"></p>
<h3 id="9-let、const、var-的区别有哪些？-2019-09-26"><a href="#9-let、const、var-的区别有哪些？-2019-09-26" class="headerlink" title="9. let、const、var 的区别有哪些？(2019-09-26)"></a>9. let、const、var 的区别有哪些？(2019-09-26)</h3><p><img src="http://static.zxinc520.com/blog/20190926/0imlOVJDQTTd.png?imageslim" alt="mark"></p>
<ol>
<li>let/const 定义的变量不会出现变量提升，而 var 定义的变量会提升。</li>
<li>相同作用域中，let 和 const 不允许重复声明，var 允许重复声明。</li>
<li>cosnt 声明变量时必须设置初始值</li>
<li>const 声明一个只读的常量，这个常量不可改变</li>
<li>let/const 声明的变量仅在块级作用域中有效。而 var 声明的变量在块级作用域外仍能访问到。</li>
<li>顶层作用域中 var 声明的变量挂在 window 上(浏览器环境)</li>
<li>let/const 有暂时性死区的问题，即 let/const 声明的变量，在定义之前都是不可用的。如果使用会抛出错误。</li>
</ol>
<h3 id="10-深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？-2019-09-27"><a href="#10-深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？-2019-09-27" class="headerlink" title="10. 深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？(2019-09-27)"></a>10. 深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？(2019-09-27)</h3><blockquote>
<p>深拷贝和浅拷贝是针对复杂数据类型来说的。</p>
</blockquote>
<p><strong>深拷贝</strong></p>
<blockquote>
<p>深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</p>
</blockquote>
<p><strong>浅拷贝</strong></p>
<blockquote>
<p>浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。</p>
</blockquote>
<p>可以使用 <code>for in</code>、 <code>Object.assign</code>、 扩展运算符 <code>...</code> 、<code>Array.prototype.slice()</code>、<code>Array.prototype.concat()</code> 等，例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="keyword">let</span> obj3 = &#123; ...obj &#125;;</span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">obj.hobbies.push(<span class="string">&quot;coding&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123; name: &#x27;Jack&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3); <span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看出浅拷贝只最第一层属性进行了拷贝，当第一层的属性值是基本数据类型时，新的对象和原对象互不影响，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性值其指向的是同一块内存地址。来看一下使用 <code>for in</code> 实现浅拷贝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  newObj[key] = obj[key];</span><br><span class="line">  <span class="comment">//这一步不需要多说吧，复杂数据类型栈中存的是对应的地址，因此赋值操作，相当于两个属性值指向同一个内存空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newObj);</span><br><span class="line"><span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18, hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27; ] &#125;</span></span><br><span class="line">obj.age = <span class="number">20</span>;</span><br><span class="line">obj.hobbies.pop();</span><br><span class="line"><span class="built_in">console</span>.log(newObj);</span><br><span class="line"><span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18, hobbies: [ &#x27;reading&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>深拷贝实现</strong></p>
<blockquote>
<p>深拷贝最简单的实现是: <code>JSON.parse(JSON.stringify(obj))</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">//newObj和obj互不影响</span></span><br><span class="line">obj.hobbies.push(<span class="string">&quot;coding&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18, hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>JSON.parse(JSON.stringify(obj))</code> 是最简单的实现方式，但是有一点缺陷：</p>
<ol>
<li>对象的属性值是函数时，无法拷贝。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(sayHi);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18, hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原型链上的属性无法获取</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Super.prototype.location = <span class="string">&quot;NanJing&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age, hobbies</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Super();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Child(<span class="string">&quot;Yvette&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.location); <span class="comment">//NanJing</span></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.location); <span class="comment">//undefined;原型链上的属性无法获取</span></span><br></pre></td></tr></table></figure>

<p>3.不能正确的处理 Date 类型的数据</p>
<p>4.不能处理 RegExp</p>
<p>5.会忽略 symbol</p>
<p>6.会忽略 undefined</p>
<blockquote>
<p>2.实现一个 deepClone 函数</p>
</blockquote>
<ol>
<li>如果是基本数据类型，直接返回</li>
<li>如果是 <code>RegExp</code> 或者 <code>Date</code> 类型，返回对应类型</li>
<li>如果是复杂数据类型，递归。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//递归拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">//如果不是复杂数据类型，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果obj是数组，那么 obj.constructor 是 [Function: Array]</span></span><br><span class="line"><span class="comment">   * 如果obj是对象，那么 obj.constructor 是 [Function: Object]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">let</span> t = <span class="keyword">new</span> obj.constructor();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">//如果 obj[key] 是复杂数据类型，递归</span></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">//是否是自身的属性</span></span><br><span class="line">      t[key] = deepClone(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Super.prototype.location = <span class="string">&quot;NanJing&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age, hobbies</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.hobbies = hobbies;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Super();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Child(<span class="string">&quot;Yvette&quot;</span>, <span class="number">18</span>, [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>]);</span><br><span class="line">obj.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.location); <span class="comment">//NanJing</span></span><br><span class="line"><span class="keyword">let</span> newObj = deepClone(obj);</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.location); <span class="comment">//NanJing 可以获取到原型链上的属性</span></span><br><span class="line">newObj.sayHi(); <span class="comment">//hi 函数属性拷贝正常</span></span><br></pre></td></tr></table></figure>

<h2 id="【Step-By-Step】一周面试题深入解析-周刊-03"><a href="#【Step-By-Step】一周面试题深入解析-周刊-03" class="headerlink" title="【Step-By-Step】一周面试题深入解析 / 周刊 03"></a>【Step-By-Step】一周面试题深入解析 / 周刊 03</h2><blockquote>
<p>本周面试题一览:</p>
</blockquote>
<ul>
<li>什么是 XSS 攻击，XSS 攻击可以分为哪几类？我们如何防范 XSS 攻击？</li>
<li>如何隐藏页面中的某个元素？</li>
<li>浏览器事件代理机制的原理是什么？</li>
<li>setTimeout 倒计时为什么会出现误差？</li>
</ul>
<h3 id="11-什么是-XSS-攻击，XSS-攻击可以分为哪几类？我们如何防范-XSS-攻击？（2019-09-28）"><a href="#11-什么是-XSS-攻击，XSS-攻击可以分为哪几类？我们如何防范-XSS-攻击？（2019-09-28）" class="headerlink" title="11. 什么是 XSS 攻击，XSS 攻击可以分为哪几类？我们如何防范 XSS 攻击？（2019-09-28）"></a>11. 什么是 XSS 攻击，XSS 攻击可以分为哪几类？我们如何防范 XSS 攻击？（2019-09-28）</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Blog/issues/33">源地址</a></p>
</blockquote>
<p><strong>1. XSS 攻击</strong></p>
<p>XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。</p>
<p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击者定义的请求。</p>
<p><strong>XSS 分类</strong></p>
<p>根据攻击的来源，XSS 攻击可以分为存储型(持久性)、反射型(非持久型)和 DOM 型三种。下面我们来详细了解一下这三种 XSS 攻击：</p>
<blockquote>
<p>1.1 反射型 XSS</p>
</blockquote>
<p>当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web 服务器将注入脚本，比如一个错误信息，搜索结果等，未进行过滤直接返回到用户的浏览器上。</p>
<blockquote>
<p>反射型 XSS 的攻击步骤：</p>
</blockquote>
<ol>
<li>攻击者构造出特殊的 <code>URL</code>，其中包含恶意代码。</li>
<li>用户打开带有恶意代码的 <code>URL</code> 时，网站服务端将恶意代码从 <code>URL</code> 中取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p>反射型 XSS 漏洞常见于通过 <code>URL</code> 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 <code>URL</code> 才能生效，攻击者往往会结合多种手段诱导用户点击。</p>
<p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p>
<p>如果不希望被前端拿到 cookie，后端可以设置 <code>httpOnly</code> (不过这不是 <code>XSS攻击</code> 的解决方案，只能降低受损范围)</p>
<blockquote>
<p>如何防范反射型 XSS 攻击</p>
</blockquote>
<p><strong>对字符串进行编码。</strong></p>
<p>对 url 的查询参数进行转义后再输出到页面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&quot;/welcome&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//对查询参数进行编码，避免反射型 XSS攻击</span></span><br><span class="line">  res.send(<span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(req.query.type)&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.2 DOM 型 XSS</p>
</blockquote>
<p>DOM 型 XSS 攻击，实际上就是前端 <code>JavaScript</code> 代码不够严谨，把不可信的内容插入到了页面。在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>.appendChild</code>、<code>document.write()</code>等 API 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 <code>.innerText</code>、<code>.textContent</code>、<code>.setAttribute()</code> 等。</p>
<blockquote>
<p>DOM 型 XSS 的攻击步骤：</p>
</blockquote>
<ol>
<li>攻击者构造出特殊数据，其中包含恶意代码。</li>
<li>用户浏览器执行了恶意代码。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<blockquote>
<p>如何防范 DOM 型 XSS 攻击</p>
</blockquote>
<p>防范 DOM 型 XSS 攻击的核心就是对输入内容进行转义(DOM 中的内联事件监听器和链接跳转都能把字符串作为代码运行，需要对其内容进行检查)。</p>
<p>1.对于<code>url</code>链接(例如图片的<code>src</code>属性)，那么直接使用 <code>encodeURIComponent</code> 来转义。</p>
<p>2.非<code>url</code>，我们可以这样进行编码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeHtml</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">    .replace(<span class="regexp">/&quot;/g</span>, <span class="string">&quot;&amp;quot;&quot;</span>)</span><br><span class="line">    .replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&quot;&amp;apos;&quot;</span>)</span><br><span class="line">    .replace(<span class="regexp">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>)</span><br><span class="line">    .replace(<span class="regexp">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞。</p>
<blockquote>
<p>1.3 存储型 XSS</p>
</blockquote>
<p>恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和 DOM 型 XSS 更大。存储型 XSS 攻击的原因仍然是没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出</p>
<blockquote>
<p>存储型 XSS 的攻击步骤：</p>
</blockquote>
<ol>
<li>攻击者将恶意代码提交到目标网站的数据库中。</li>
<li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>
</ol>
<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>
<blockquote>
<p>如何防范存储型 XSS 攻击：</p>
</blockquote>
<ol>
<li>前端数据传递给服务器之前，先转义/过滤(防范不了抓包修改数据的情况)</li>
<li>服务器接收到数据，在存储到数据库之前，进行转义/过滤</li>
<li>前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤</li>
</ol>
<p><strong>除了谨慎的转义，我们还需要其他一些手段来防范 XSS 攻击:</strong></p>
<p><strong>1.Content Security Policy</strong></p>
<p>在服务端使用 HTTP 的 <code>Content-Security-Policy</code> 头部来指定策略，或者在前端设置 <code>meta</code> 标签。</p>
<p>例如下面的配置只允许加载同域下的资源：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src <span class="string">&#x27;self&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;form-action &#x27;self&#x27;;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>前端和服务端设置 CSP 的效果相同，但是<code>meta</code>无法使用<code>report</code></p>
<p>严格的 CSP 在 XSS 的防范中可以起到以下的作用：</p>
<ol>
<li>禁止加载外域代码，防止复杂的攻击逻辑。</li>
<li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。</li>
<li>禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。</li>
<li>禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。</li>
<li>合理使用上报可以及时发现 XSS，利于尽快修复问题。</li>
</ol>
<p><strong>2.输入内容长度控制</strong></p>
<p>对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。</p>
<p><strong>3.输入内容限制</strong></p>
<p>对于部分输入，可以限定不能包含特殊字符或者仅能输入数字等。</p>
<p><strong>4.其他安全措施</strong></p>
<ul>
<li>HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。</li>
<li>验证码：防止脚本冒充用户提交危险操作。</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/18">点击查看更多</a></p>
</blockquote>
<h3 id="12-如何隐藏页面中的某个元素？（2019-09-29）"><a href="#12-如何隐藏页面中的某个元素？（2019-09-29）" class="headerlink" title="12.如何隐藏页面中的某个元素？（2019-09-29）"></a>12.如何隐藏页面中的某个元素？（2019-09-29）</h3><p><strong>隐藏类型：</strong></p>
<p>屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类：</p>
<ul>
<li>完全隐藏：元素从渲染树中消失，不占据空间。</li>
<li>视觉上的隐藏：屏幕中不可见，占据空间。</li>
<li>语义上的隐藏：读屏软件不可读，但正常占据空。</li>
</ul>
<p>完全隐藏：</p>
<ol>
<li><code>display</code> 属性(不占据空间)</li>
</ol>
<p>HTML5 新增属性，相当于 <code>display: none</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hidden</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>hidden 属性 (不占据空间)</li>
</ol>
<p>视觉上的隐藏：</p>
<p><strong>利用 <code>position</code> 和 盒模型 将元素移出可视区范围</strong></p>
<ol>
<li><p>设置 <code>posoition</code> 为 <code>absolute</code> 或 <code>fixed</code>，� 通过设置 <code>top</code>、<code>left</code> 等值，将其移出可视区域。(可视区域不占位)</p>
</li>
<li><p>设置 <code>position</code> 为 <code>relative</code>，通过设置 <code>top</code>、<code>left</code> 等值，将其移出可视区域。（可视区域占位）；如希望其在可视区域不占位置，需同时设置 <code>height: 0</code>;</p>
</li>
<li><p>设置 margin 值，将其移出可视区域范围（可视区域占位）；如果希望其在可视区域不占位，需同时设置 <code>height: 0</code>;</p>
</li>
</ol>
<p><strong>利用 transfrom</strong></p>
<ol>
<li>缩放</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>移动 <code>translateX</code>, <code>translateY</code></li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(<span class="selector-tag">-99999px</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>旋转 <code>rotate</code></li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotateY</span>(90<span class="selector-tag">deg</span>);</span><br></pre></td></tr></table></figure>

<p><strong>设置其大小为 0</strong></p>
<ol>
<li>宽高为 0，字体大小为 0</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">height</span>: 0;</span><br><span class="line"><span class="selector-tag">width</span>: 0;</span><br><span class="line"><span class="selector-tag">font-size</span>: 0;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>宽高为 0，超出隐藏</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">height</span>: 0;</span><br><span class="line"><span class="selector-tag">width</span>: 0;</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure>

<p>设置透明度为 0</p>
<p><code>visibility</code>属性</p>
<p>层级覆盖，<code>z-index</code> 属性</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br><span class="line"><span class="selector-tag">z-index</span>: <span class="selector-tag">-999</span>;</span><br></pre></td></tr></table></figure>

<p>再设置一个层级较高的元素覆盖在此元素上。</p>
<p>clip-path 裁剪</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">clip-path</span>: <span class="selector-tag">polygon</span>(0 0, 0 0, 0 0, 0 0);</span><br></pre></td></tr></table></figure>

<h3 id="13-浏览器事件代理机制的原理是什么？（2019-09-30）"><a href="#13-浏览器事件代理机制的原理是什么？（2019-09-30）" class="headerlink" title="13.浏览器事件代理机制的原理是什么？（2019-09-30）"></a>13.浏览器事件代理机制的原理是什么？（2019-09-30）</h3><p><strong>事件代理机制的原理</strong></p>
<p>事件代理又称为事件委托，在祖先级 DOM 元素绑定一个事件，当触发子孙级 DOM 元素的事件时，利用事件冒泡的原理来触发绑定在祖先级 DOM 的事件。因为事件会从目标元素一层层冒泡至 document 对象。</p>
<p><strong>为什么要事件代理？</strong></p>
<ol>
<li>添加到页面上的事件数量会影响页面的运行性能，如果添加的事件过多，会导致网页的性能下降。采用事件代理的方式，可以大大减少注册事件的个数。</li>
<li>事件代理的当时，某个子孙元素是动态增加的，不需要再次对其进行事件绑定。</li>
<li>不用担心某个注册了事件的 DOM 元素被移除后，可能无法回收其事件处理程序，我们只要把事件处理程序委托给更高层级的元素，就可以避免此问题。</li>
<li>允许给一个事件注册多个监听。</li>
<li>提供了一种更精细的手段控制 <code>listener</code> 的触发阶段(可以选择捕获或者是冒泡)。</li>
<li>对任何 <code>DOM</code> 元素都是有效的，而不仅仅是对 <code>HTML</code> 元素有效。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener">addEventListener</a> :</p>
<p>addEventListener 接受 3 个参数，分别是要处理的事件名、实现了 EventListener 接口的对象或者是一个函数、一个对象/一个布尔值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener[, options]);</span><br><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>options(对象) | 可选</strong></p>
<ul>
<li>capture: <code>Boolean</code>。true 表示在捕获阶段触发，false 表示在冒泡阶段触发。默认是 false。</li>
<li>once:<code>Boolean</code>。true 表示 listener 在添加之后最多只调用一次，listener 会在其被调用之后自动移除。默认是 false。</li>
<li>passive: <code>Boolean</code>。true 表示 listener 永远不会调用 <code>preventDefault()</code>。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。默认是 false。</li>
</ul>
<p><strong>useCapture(Boolean) | 可选</strong></p>
<p><code>useCapture</code> 默认为 false。表示冒泡阶段调用事件处理程序，若设置为 true，表示在捕获阶段调用事件处理程序。</p>
<blockquote>
<p>如将页面中的所有 click 事件都代理到 document 上:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获阶段调用调用事件处理程序，eventPhase是 1;</span></span><br><span class="line"><span class="comment">     * 处于目标，eventPhase是2</span></span><br><span class="line"><span class="comment">     * 冒泡阶段调用事件处理程序，eventPhase是 3；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.eventPhase);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>与 <code>addEventListener</code> 相对应的是 <code>removeEventListener</code>,用于移除事件监听。</p>
<h3 id="14-setTimeout-倒计时为什么会出现误差？-（2019-10-08）"><a href="#14-setTimeout-倒计时为什么会出现误差？-（2019-10-08）" class="headerlink" title="14. setTimeout 倒计时为什么会出现误差？ （2019-10-08）"></a>14. setTimeout 倒计时为什么会出现误差？ （2019-10-08）</h3><p><code>setTimeout</code> 只能保证延时或间隔不小于设定的时间。因为它实际上只是将回调添加到了宏任务队列中，但是如果主线程上有任务还没有执行完成，它必须要等待。</p>
<p>如果你对前面这句话不是非常理解，那么有必要了解一下 JS 的运行机制。</p>
<p><strong>JS 的运行机制</strong></p>
<p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</p>
<p>（2）主线程之外，还存在”任务队列”(task queue)。</p>
<p>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p>
<p>（4）主线程不断重复上面的第三步。</p>
<p>如 <code>setTimeout(()=&gt;&#123;callback();&#125;, 1000)</code> ，即表示在 1s 之后将 <code>callback</code> 放到宏任务队列中，当 1s 的时间到达时，如果主线程上有其它任务在执行，那么 <code>callback</code> 就必须要等待，另外 <code>callback</code> 的执行也需要时间，因此 <code>setTimeout</code> 的时间间隔是有误差的，它只能保证延时不小于设置的时间。</p>
<p><strong>如何减少 <code>setTimeout</code> 的误差</strong></p>
<p>我们只能减少执行多次的 <code>setTimeout</code> 的误差，例如倒计时功能。</p>
<p>倒计时的时间通常都是从服务端获取的。造成误差的原因：</p>
<p>1.没有考虑误差时间（函数执行的时间/其它代码的阻塞）</p>
<p>2.没有考虑浏览器的“休眠”</p>
<p>完全消除 <code>setTimeout</code>的误差是不可能的，但是我们减少 <code>setTimeout</code> 的误差。通过对下一次任务的调用时间进行修正，来减少误差。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> countdown = <span class="number">5000</span>; <span class="comment">//服务器返回的倒计时时间</span></span><br><span class="line"><span class="keyword">let</span> interval = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">let</span> timer = <span class="built_in">setTimeout</span>(countDownStart, interval); <span class="comment">//首次执行</span></span><br><span class="line"><span class="comment">//定时器测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countDownStart</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="keyword">const</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">const</span> nextInterval = interval - offset; <span class="comment">//修正后的延时时间</span></span><br><span class="line">  <span class="keyword">if</span> (nextInterval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    nextInterval = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  countdown -= interval;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&quot;误差：&quot;</span> +</span><br><span class="line">      offset +</span><br><span class="line">      <span class="string">&quot;ms，下一次执行：&quot;</span> +</span><br><span class="line">      nextInterval +</span><br><span class="line">      <span class="string">&quot;ms后，离活动开始还有：&quot;</span> +</span><br><span class="line">      countdown +</span><br><span class="line">      <span class="string">&quot;ms&quot;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (countdown &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(countDownStart, nextInterval);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前页面是不可见的，那么倒计时会出现大于 100ms 的误差时间。因此在页面显示时，应该重新从服务端获取剩余时间进行倒计时。当然，为了更好的性能，当倒计时不可见(Tab 页切换/倒计时内容不在可视区时)，可以选择停止倒计时。</p>
<p>为此，我们可以监听 <code>visibityChange</code> 事件进行处理。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/21">点击查看更多</a></p>
</blockquote>
<h2 id="【Step-By-Step】一周面试题深入解析-周刊-04"><a href="#【Step-By-Step】一周面试题深入解析-周刊-04" class="headerlink" title="【Step-By-Step】一周面试题深入解析 / 周刊 04"></a>【Step-By-Step】一周面试题深入解析 / 周刊 04</h2><blockquote>
<p>本周面试题一览:</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Blog/issues/34">什么是闭包？闭包的作用是什么？</a></li>
<li>实现 Promise.all 方法</li>
<li>异步加载 js 脚本的方法有哪些？</li>
<li>请实现一个 flattenDeep 函数，把嵌套的数组扁平化</li>
<li>可迭代对象有什么特点？</li>
</ul>
<h3 id="15-什么是闭包？闭包的作用是什么？-（2019-10-09）"><a href="#15-什么是闭包？闭包的作用是什么？-（2019-10-09）" class="headerlink" title="15. 什么是闭包？闭包的作用是什么？ （2019-10-09）"></a>15. 什么是闭包？闭包的作用是什么？ （2019-10-09）</h3><p><strong>什么是闭包？</strong></p>
<p>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包最常用的方式就是在一个函数内部创建另一个函数。</p>
<p><strong>闭包的作用：</strong></p>
<ol>
<li>能够访问函数定义时所在的词法作用域(阻止其被回收)。</li>
<li>私有化变量</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">10</span>; <span class="comment">//私有变量</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getX: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = base();</span><br><span class="line"><span class="built_in">console</span>.log(obj.getX()); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>模拟块级作用域</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建模块</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;Yvette&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">20</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    sayName,</span><br><span class="line">    sayAge,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> info = coolModule();</span><br><span class="line">info.sayName(); <span class="comment">//&#x27;Yvette&#x27;</span></span><br></pre></td></tr></table></figure>

<p>模块模式具有两个必备的条件(来自《你不知道的 JavaScript》)</p>
<ul>
<li>必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)</li>
<li>封闭函数必须返回至少<strong>一个</strong>内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li>
</ul>
<p>闭包的缺点</p>
<p>闭包会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p>
<h3 id="16-实现-Promise-all-方法-（2019-10-10）"><a href="#16-实现-Promise-all-方法-（2019-10-10）" class="headerlink" title="16. 实现 Promise.all 方法 （2019-10-10）"></a>16. 实现 Promise.all 方法 （2019-10-10）</h3><p>在实现 Promise.all 方法之前，我们首先要知道 Promise.all 的功能和特点，因为在清楚了 Promise.all 功能和特点的情况下，我们才能进一步去写实现。</p>
<p><strong>Promise.all 功能</strong></p>
<p><code>Promise.all(iterable)</code> 返回一个新的 Promise 实例。此实例在 <code>iterable</code> 参数内所有的 <code>promise</code> 都 <code>fulfilled</code> 或者参数中不包含 <code>promise</code> 时，状态变成 <code>fulfilled</code>；如果参数中 <code>promise</code> 有一个失败<code>rejected</code>，此实例回调失败，失败原因的是第一个失败 <code>promise</code> 的返回结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>p 的状态由 p1,p2,p3 决定，分成以下；两种情况：</p>
<p>（1）只有 p1、p2、p3 的状态都变成 <code>fulfilled</code>，p 的状态才会变成 <code>fulfilled</code>，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</p>
<p>（2）只要 p1、p2、p3 之中有一个被 <code>rejected</code>，p 的状态就变成 <code>rejected</code>，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</p>
<p><strong>Promise.all 的特点</strong></p>
<blockquote>
<p>Promise.all 的返回值是一个 promise 实例</p>
</blockquote>
<ul>
<li>如果传入的参数为空的可迭代对象，<code>Promise.all</code> 会 <strong>同步</strong> 返回一个已完成状态的 <code>promise</code></li>
<li>如果传入的参数中不包含任何 promise,<code>Promise.all</code> 会 <strong>异步</strong> 返回一个已完成状态的 <code>promise</code></li>
<li>其它情况下，<code>Promise.all</code> 返回一个 <strong>处理中（pending）</strong> 状态的 <code>promise</code>.</li>
</ul>
<blockquote>
<p>Promise.all 返回的 promise 的状态</p>
</blockquote>
<ul>
<li>如果传入的参数中的 promise 都变成完成状态，<code>Promise.all</code> 返回的 <code>promise</code> 异步地变为完成。</li>
<li>如果传入的参数中，有一个 <code>promise</code> 失败，<code>Promise.all</code> 异步地将失败的那个结果给失败状态的回调函数，而不管其它 <code>promise</code> 是否完成</li>
<li>在任何情况下，<code>Promise.all</code> 返回的 <code>promise</code> 的完成状态的结果都是一个数组</li>
</ul>
<p><strong>Promise.all 实现</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//Array.from 将可迭代对象转换成数组</span></span><br><span class="line">    promises = <span class="built_in">Array</span>.from(promises);</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve([]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> result = [];</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        <span class="comment">//考虑到 i 可能是 thenable 对象也可能是普通值</span></span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i]).then(</span><br><span class="line">          (data) =&gt; &#123;</span><br><span class="line">            result[i] = data;</span><br><span class="line">            <span class="keyword">if</span> (++index === promises.length) &#123;</span><br><span class="line">              <span class="comment">//所有的 promises 状态都是 fulfilled，promise.all返回的实例才变成 fulfilled 态</span></span><br><span class="line">              resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          (err) =&gt; &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="17-异步加载-js-脚本的方法有哪些？-（2019-10-11）"><a href="#17-异步加载-js-脚本的方法有哪些？-（2019-10-11）" class="headerlink" title="17. 异步加载 js 脚本的方法有哪些？ （2019-10-11）"></a>17. 异步加载 js 脚本的方法有哪些？ （2019-10-11）</h3><ol>
<li><code>&lt;script&gt;</code> 标签中增加 <code>async</code>(html5) 或者 <code>defer</code>(html4) 属性,脚本就会异步加载。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;../XXX.js&quot;</span> defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>defer</code> 和 <code>async</code> 的区别在于：</p>
<ul>
<li><code>defer</code> 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），在 window.onload 之前执行；</li>
<li><code>async</code> 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。</li>
<li>如果有多个 <code>defer</code> 脚本，会按照它们在页面出现的顺序加载</li>
<li>多个 <code>async</code> 脚本不能保证加载顺序</li>
</ul>
<ol start="2">
<li>动态创建 <code>script</code> 标签</li>
</ol>
<p>动态创建的 <code>script</code> ，设置 <code>src</code> 并不会开始下载，而是要添加到文档中，JS 文件才会开始下载。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.src = <span class="string">&quot;XXX.js&quot;</span>;</span><br><span class="line"><span class="comment">// 添加到html文件中才会开始下载</span></span><br><span class="line"><span class="built_in">document</span>.body.append(script);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>XHR 异步加载 JS</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;js/xxx.js&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">eval</span>(xhr.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="18-请实现一个-flattenDeep-函数，把嵌套的数组扁平化-（2019-10-13）"><a href="#18-请实现一个-flattenDeep-函数，把嵌套的数组扁平化-（2019-10-13）" class="headerlink" title="18. 请实现一个 flattenDeep 函数，把嵌套的数组扁平化 （2019-10-13）"></a>18. 请实现一个 flattenDeep 函数，把嵌套的数组扁平化 （2019-10-13）</h3><p><strong>解析：</strong></p>
<ol>
<li>利用 <code>Array.prototype.flat</code></li>
</ol>
<p>ES6 为数组实例新增了 <code>flat</code> 方法，用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数组没有影响。</p>
<p><code>flat</code> 默认只会 “拉平” 一层，如果想要 “拉平” 多层的嵌套数组，需要给 <code>flat</code> 传递一个整数，表示想要拉平的层数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDeep</span>(<span class="params">arr, deepLength</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.flat(deepLength);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flattenDeep([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]], <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDeep</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return arr.join(&#x27;,&#x27;).split(&#x27;,&#x27;).map(Number);</span></span><br><span class="line">  <span class="keyword">return</span> arr.toString().split(<span class="string">&quot;,&quot;</span>).map(<span class="built_in">Number</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flattenDeep([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]]));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用 reduce 和 concat:</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDeep</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(</span><br><span class="line">    (acc, val) =&gt;</span><br><span class="line">      <span class="built_in">Array</span>.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flattenDeep([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]]));</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 stack 无限反嵌套多层嵌套数组</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDeep</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [...input];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="comment">// 使用 pop 从 stack 中取出并移除值</span></span><br><span class="line">    <span class="keyword">const</span> next = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(next)) &#123;</span><br><span class="line">      <span class="comment">// 使用 push 送回内层数组中的元素，不会改动原始输入 original input</span></span><br><span class="line">      stack.push(...next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.push(next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用 reverse 恢复原数组的顺序</span></span><br><span class="line">  <span class="keyword">return</span> res.reverse();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flattenDeep([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]]));</span><br></pre></td></tr></table></figure>

<h3 id="19-可迭代对象有什么特点-（2019-10-14）"><a href="#19-可迭代对象有什么特点-（2019-10-14）" class="headerlink" title="19. 可迭代对象有什么特点 （2019-10-14）"></a>19. 可迭代对象有什么特点 （2019-10-14）</h3><p>ES6 规定，默认的 <code>Iterator</code> 接口部署在数据结构的 <code>Symbol.iterator</code> 属性，换个角度，也可以认为，一个数据结构只要具有 <code>Symbol.iterator</code> 属性(<code>Symbol.iterator</code> 方法对应的是遍历器生成函数，返回的是一个遍历器对象)，那么就可以其认为是可迭代的。</p>
<p><strong>可迭代对象的特点</strong></p>
<ul>
<li>具有 <code>Symbol.iterator</code> 属性，<code>Symbol.iterator()</code> 返回的是一个遍历器对象</li>
<li>可以使用 <code>for ... of</code> 进行循环</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> iter = array[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">//&#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">//&#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">//&#123; value: 3, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>原生具有 <code>Iterator</code> 接口的数据结构：</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<h4 id="自定义一个可迭代对象"><a href="#自定义一个可迭代对象" class="headerlink" title="自定义一个可迭代对象"></a>自定义一个可迭代对象</h4><p>上面我们说，一个对象只有具有正确的 <code>Symbol.iterator</code> 属性，那么其就是可迭代的，因此，我们可以通过给对象新增 <code>Symbol.iterator</code> 使其可迭代</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  job: <span class="string">&quot;engineer&quot;</span>,</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(self);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; keys.length; index++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> self[keys[index]]; <span class="comment">//yield表达式仅能使用在 Generator 函数中</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">//Yvette 18 engineer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="【Step-By-Step】高频面试题深入解析-周刊-05-本周面试题一览"><a href="#【Step-By-Step】高频面试题深入解析-周刊-05-本周面试题一览" class="headerlink" title="【Step-By-Step】高频面试题深入解析 / 周刊 05 本周面试题一览:"></a>【Step-By-Step】高频面试题深入解析 / 周刊 05 本周面试题一览:</h2><blockquote>
<p>本周面试题一览:</p>
<p>####</p>
</blockquote>
<ul>
<li>实现 Promise.race 方法</li>
<li>JSONP 原理及简单实现</li>
<li>实现一个数组去重的方法</li>
<li>清楚浮动的方法有哪些</li>
<li>编写一个通用的柯里化函数 currying</li>
</ul>
<h3 id="20-实现-Promise-race-方法（2019-10-16）"><a href="#20-实现-Promise-race-方法（2019-10-16）" class="headerlink" title="20. 实现 Promise.race 方法（2019-10-16）"></a>20. 实现 Promise.race 方法（2019-10-16）</h3><p>在实现 <code>Promise.race</code> 方法之前，我们首先要知道 <code>Promise.race</code> 的功能和特点，因为在清楚了 <code>Promise.race</code> 功能和特点的情况下，我们才能进一步去写实现。</p>
<p><strong>Promise.race 功能</strong></p>
<p><code>Promise.race(iterable)</code> 返回一个 promise，一旦 <code>iterable</code> 中的一个 <code>promise</code> 状态是 <code>fulfilled</code> / <code>rejected</code> ，那么 <code>Promise.race</code> 返回的 <code>promise</code> 状态是 <code>fulfilled</code> / <code>rejected</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 <code>Promise</code> 实例的返回值，就传递给 p 的回调函数。</p>
<p><strong>Promise.race 的特点</strong></p>
<blockquote>
<p>Promise.race 的返回值是一个 promise 实例</p>
</blockquote>
<ul>
<li>如果传入的参数为空的可迭代对象，那么 <code>Promise.race</code> 返回的 <code>promise</code> 永远是 <code>pending</code> 态</li>
<li>如果传入的参数中不包含任何 <code>promise</code>，<code>Promise.race</code> 会返回一个处理中（pending）的 <code>promise</code></li>
<li>如果 <code>iterable</code> 包含一个或多个非 <code>promise</code> 值或已经解决的 promise，则 <code>Promise.race</code> 将解析为 <code>iterable</code> 中找到的第一个值。</li>
</ul>
<p><strong>Promise.race 的实现</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//promises传入的是可迭代对象(省略参数合法性判断)</span></span><br><span class="line">  promises = <span class="built_in">Array</span>.from(promises); <span class="comment">//将可迭代对象转换为数组</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//空的可迭代对象;</span></span><br><span class="line">      <span class="comment">//用于在pending态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i])</span><br><span class="line">          .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="21-JSONP-原理及简单实现-2019-10-17"><a href="#21-JSONP-原理及简单实现-2019-10-17" class="headerlink" title="21. JSONP 原理及简单实现 (2019-10-17)"></a>21. JSONP 原理及简单实现 (2019-10-17)</h3><p>尽管浏览器有同源策略，但是 <code>&lt;script&gt;</code> 标签的 <code>src</code> 属性不会被同源策略所约束，可以获取任意服务器上的脚本并执行。<code>jsonp</code> 通过插入 <code>script</code> 标签的方式来实现跨域，参数只能通过 <code>url</code> 传入，仅能支持 <code>get</code> 请求。</p>
<p><strong>实现原理:</strong></p>
<ul>
<li>Step1: 创建 callback 方法</li>
<li>Step2: 插入 script 标签</li>
<li>Step3: 后台接受到请求，解析前端传过去的 callback 方法，返回该方法的调用，并且数据作为参数传入该方法</li>
<li>Step4: 前端执行服务端返回的方法调用</li>
</ul>
<p><strong>jsonp 源码实现</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">&#123; url, params, callback &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//创建script标签</span></span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">    <span class="comment">//将回调函数挂在 window 上</span></span><br><span class="line">    <span class="built_in">window</span>[callback] = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      resolve(data);</span><br><span class="line">      <span class="comment">//代码执行后，删除插入的script标签</span></span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(script);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//回调函数加在请求地址上</span></span><br><span class="line">    params = &#123; ...params, callback &#125;; <span class="comment">//wb=b&amp;callback=show</span></span><br><span class="line">    <span class="keyword">let</span> arrs = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      arrs.push(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arrs.join(<span class="string">&quot;&amp;&quot;</span>)&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: <span class="string">&quot;http://localhost:3000/show&quot;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">  &#125;,</span><br><span class="line">  callback: <span class="string">&quot;show&quot;</span>,</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>服务端代码(node):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//express启动一个后台服务</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/show&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; callback &#125; = req.query; <span class="comment">//获取传来的callback函数名，callback是key</span></span><br><span class="line">  res.send(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;Hello!&#x27;)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="22、实现一个数组去重的方法-2019-10-18"><a href="#22、实现一个数组去重的方法-2019-10-18" class="headerlink" title="22、实现一个数组去重的方法 (2019-10-18)"></a>22、实现一个数组去重的方法 (2019-10-18)</h3><ol>
<li>法 1: 利用 ES6 新增数据类型 <code>Set </code> ：[…new Set(arry)</li>
<li>利用 <code>indexOf</code> <code>includes</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">arry</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arry.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.indexOf(arry[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">//如 result 中没有 arry[i],则添加到数组中</span></span><br><span class="line">      result.push(arry[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>利用 <code>reduce</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">arry</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arry.reduce(</span><br><span class="line">    (prev, cur) =&gt; (prev.includes(cur) ? prev : [...prev, cur]),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>利用 <code>Map</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">arry</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arry.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(arry[i])) &#123;</span><br><span class="line">      map.set(arry[i], <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map.set(arry[i], <span class="literal">false</span>);</span><br><span class="line">      result.push(arry[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23、清除浮动的方法有哪些？-2019-10-20"><a href="#23、清除浮动的方法有哪些？-2019-10-20" class="headerlink" title="23、清除浮动的方法有哪些？ (2019-10-20)"></a>23、清除浮动的方法有哪些？ (2019-10-20)</h3><p><strong>解析：</strong></p>
<p>总体来说就两点吧：</p>
<ol>
<li>利用 clear 元素</li>
<li>利用 BFC 布局规则</li>
</ol>
<h3 id="24-编写一个通用的柯里化函数-currying-2019-10-20"><a href="#24-编写一个通用的柯里化函数-currying-2019-10-20" class="headerlink" title="24. 编写一个通用的柯里化函数 currying (2019-10-20)"></a>24. 编写一个通用的柯里化函数 currying (2019-10-20)</h3><p>在开始之前，我们首先需要搞清楚函数<a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/42">柯里化</a>的概念。</p>
<blockquote>
<p>curry 的这种用途可以理解为：参数复用。本质上是降低通用性，提高适用性。</p>
</blockquote>
<p>函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currying = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span></span><br><span class="line">  args.length &lt; fn.length</span><br><span class="line">    ? <span class="comment">//参数长度不足时，重新柯里化该函数，等待接受新参数</span></span><br><span class="line">      (...arguments) =&gt; currying(fn, ...args, ...arguments)</span><br><span class="line">    : <span class="comment">//参数长度满足时，执行函数</span></span><br><span class="line">      fn(...args);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumFn</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = currying(sumFn);</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">5</span>)); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>)(<span class="number">3</span>, <span class="number">5</span>)); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>, <span class="number">3</span>)(<span class="number">5</span>)); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数柯里化的主要作用：</p>
</blockquote>
<ul>
<li>参数复用</li>
<li>提前返回 – 返回接受余下的参数且返回结果的新函数</li>
<li>延迟执行 – 返回新函数，等待执行</li>
</ul>
<h2 id="【Step-By-Step】高频面试题深入解析-周刊-06"><a href="#【Step-By-Step】高频面试题深入解析-周刊-06" class="headerlink" title="【Step-By-Step】高频面试题深入解析 / 周刊 06"></a>【Step-By-Step】高频面试题深入解析 / 周刊 06</h2><blockquote>
<p>本周面试题一览:</p>
</blockquote>
<ul>
<li>原型链继承的基本思路是什么？有什么优缺点？</li>
<li>借用构造函数和组合继承基本思路是什么？有什么优缺点？</li>
<li>原型式继承的基本思路是什么？有什么优缺点？</li>
<li>寄生式继承的基本思路是什么？有什么优缺点？</li>
<li>寄生组合式继承的基本思路是什么？有什么优缺点？</li>
</ul>
<p>本周是继承专题，在开始之前，需要先了解构造函数、原型和原型链的相关知识。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>构造函数和普通函数的区别仅在于调用它们的方式不同，任何函数，只要通过 <code>new</code> 操作符来调用，那它就可以作为构造函数；任何函数，如果不通过 <code>new</code> 操作符来调用，那么它就是一个普通函数。</p>
<p>实例拥有 <code>constructor(构造函数)</code> 属性，该属性返回创建实例对象的构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Yvette = <span class="keyword">new</span> Person(<span class="string">&quot;刘小夕&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Yvette.constructor === Person); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>有一点需要说明的是，除了基本数据类型的 <code>constructor</code> 外( <code>null</code> 和 <code>undefined</code> 无 <code>constructor</code> 属性)，<code>constructor</code> 属性是可以被重写的。因此检测对象类型时，<code>instanceof</code> 操作符比 <code>contsrutor</code> 更可靠一些。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> Yvette = <span class="keyword">new</span> Person(<span class="string">&quot;刘小夕&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Yvette.constructor); <span class="comment">//[Function: Person]</span></span><br><span class="line">Yvette.constructor = SuperType;</span><br><span class="line"><span class="built_in">console</span>.log(Yvette.constructor); <span class="comment">//[Function: SuperType]</span></span><br></pre></td></tr></table></figure>

<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>我们创建的每个函数都有 <code>prototype</code> 属性，这个属性指向函数的原型对象。原型对象的<strong>用途</strong>是包含可以由特定类型的所有实例共享的属性和方法。</p>
<p>在默认情况下，所有原型对象都会自动获得一个 <code>constructor</code> 属性，这个属性包含一个指向 <code>prototype</code> 属性所在函数的指针。</p>
<p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针，指向构造函数的原型对象(可以通过实例的 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/34183746"><code>__proto__</code></a> 来访问构造函数的原型对象)。 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/34183746">参考</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f.prototype.sayhi = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> f();</span><br><span class="line"><span class="built_in">console</span>.log(f.prototype); <span class="comment">//f &#123; sayhi: [Function] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.prototype.constructor); <span class="comment">//[Function: f]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__); <span class="comment">//f &#123; sayhi: [Function] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.__proto__); <span class="comment">//[Function]</span></span><br></pre></td></tr></table></figure>

<p>总结： 1.对象有属性<strong>proto</strong>,指向该对象的构造函数的原型对象。 2.方法除了有属性<strong>proto</strong>,还有属性 prototype，prototype 指向该方法的原型对象。</p>
<p>讲完啦，欢迎各种批评指正完善探讨，共同进步~</p>
<p><img src="https://camo.githubusercontent.com/16602b6909621ce63a882221389c062c4d032256/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f7075626c69632f7265736f757263652f66343537303163633431303530346537316462626362643838363165386430632f786d6c6e6f74652f5745425245534f5552434534366564343366333030363430353439383465356332346466373930393962312f3239353432"></p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>简单回顾一下构造函数、原型和实例的关系：</p>
<p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个可以执行原型对象的内部指针(可以通过 <code>__proto</code> 访问)。</p>
<p>假如我们让原型对象等于另一个类型的实例，那么此时原型对象包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。加入另一个原型又是另一个类型的实例，那么上述关系仍然成立，如此层层递进，就构成了实例与原型的链条，这就是原型链的基本概念</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&quot;animal&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getType = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.type);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SimType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">SimType.prototype = <span class="keyword">new</span> SubType();</span><br><span class="line">SimType.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SimType(<span class="string">&quot;刘小夕&quot;</span>);</span><br><span class="line">instance.getType(); <span class="comment">//animal</span></span><br></pre></td></tr></table></figure>

<p><img src="https://camo.githubusercontent.com/bb69ed50e52bf2d899a093cbe685074f28cacc0f/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f7075626c69632f7265736f757263652f66343537303163633431303530346537316462626362643838363165386430632f786d6c6e6f74652f5745425245534f5552434565333233613738316338613737653239363833373531643965333236653139342f3239353434"></p>
<p>调用 <code>instance.getType()</code> 会调用以下的搜索步骤:</p>
<ol>
<li>搜索 <code>instance</code> 实例</li>
<li>搜索 <code>SimType.prototype</code></li>
<li>搜索 <code>SubType.prototype</code></li>
<li>搜索 <code>SuperType.prototype</code>，找到了 <code>getType</code> 方法</li>
</ol>
<p>在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链的末端才会停下来。</p>
<p>所有引用类型都继承了 <code>Object</code>，这个继承也是通过原型链实现的。如果在 <code>SuperType.prototype</code> 还没有找到 <code>getType</code>，就会到 <code>Object.prototype</code>中找(图中少画了一环)。</p>
<h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>原型链继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<p>如 <code>SubType.prototype = new SuperType()</code>;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;Yvette&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(SubType.prototype.constructor) //[Function: SuperType]</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.getName()); <span class="comment">//&#x27;Yvette&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>可以看出 <code>colors</code> 属性会被所有的实例共享(instance1、instance2、…)。</p>
<blockquote>
<p>缺点：</p>
</blockquote>
<ol>
<li>通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享。</li>
<li>在创建子类型的实例时，没有办法在不影响所有对象实例的情况下给超类型的构造函数中传递参数。</li>
</ol>
<h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><p><strong>借用构造函数</strong>的技术，其基本思想为:</p>
<p>在子类型的构造函数中调用超类型构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> intance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;zc&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(intance1.name); <span class="comment">//zc</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>优点:</p>
</blockquote>
<ol>
<li>可以向超类传递参数</li>
<li>解决了原型中包含引用类型值被所有实例共享的问题</li>
</ol>
<blockquote>
<p>缺点:</p>
</blockquote>
<ol>
<li>方法都在构造函数中定义，函数复用无从谈起，另外超类型原型中定义的方法对于子类型而言都是不可见的。</li>
</ol>
<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>组合继承指的是将原型链和借用构造函数技术组合到一块，从而发挥二者之长的一种继承模式。基本思路：</p>
<p>使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// console.log(SuperType)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuberType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuberType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SuberType.prototype.constructor = SuberType;</span><br><span class="line">SuberType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SuberType(<span class="string">&quot;Yvette&quot;</span>, <span class="number">20</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27; ]</span></span><br><span class="line">instance1.sayName(); <span class="comment">//Yvette</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SuberType(<span class="string">&quot;Jack&quot;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ]</span></span><br><span class="line">instance2.sayName(); <span class="comment">//Jack</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>缺点:</p>
</blockquote>
<ul>
<li>无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</li>
</ul>
<blockquote>
<p>优点:</p>
</blockquote>
<ul>
<li>可以向超类传递参数</li>
<li>每个实例都有自己的属性</li>
<li>实现了函数复用</li>
</ul>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b5dcf8351882519790c9a2e">浅拷贝与深拷贝</a></p>
</blockquote>
<p>原型继承的基本思想：</p>
<p>借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>object()</code> 函数内部，先穿甲一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例，从本质上讲，<code>object()</code> 对传入的对象执行了一次浅拷贝。</p>
<p>ECMAScript5 通过新增 <code>Object.create()</code>方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象(可以覆盖原型对象上的同名属性)，在传入一个参数的情况下，<code>Object.create()</code> 和 <code>object()</code> 方法的行为相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="built_in">Object</span>.create(person);</span><br><span class="line">person1.name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">person1.hobbies.push(<span class="string">&quot;coding&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person);</span><br><span class="line">person2.name = <span class="string">&quot;Echo&quot;</span>;</span><br><span class="line">person2.hobbies.push(<span class="string">&quot;running&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.hobbies); <span class="comment">//[ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27;, &#x27;running&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hobbies); <span class="comment">//[ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27;, &#x27;running&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>在没有必要创建构造函数，仅让一个对象与另一个对象保持相似的情况下，原型式继承是可以胜任的。</p>
<blockquote>
<p>缺点:</p>
</blockquote>
<p>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。</p>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//以某种方式增强这个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = createAnother(person);</span><br><span class="line">person2.sayHi(); <span class="comment">//hi</span></span><br></pre></td></tr></table></figure>

<p>基于 <code>person</code> 返回了一个新对象 -—— <code>person2</code>，新对象不仅具有 <code>person</code> 的所有属性和方法，而且还有自己的 <code>sayHi()</code> 方法。在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。</p>
<blockquote>
<p>缺点：</p>
</blockquote>
<ul>
<li>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。</li>
<li>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。</li>
</ul>
<h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，基本思路：</p>
<p>不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">  prototype.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">  subType.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一步：创建超类型原型的一个副本</li>
<li>第二步：为创建的副本添加 <code>constructor</code> 属性</li>
<li>第三步：将新创建的对象赋值给子类型的原型</li>
</ul>
<p>至此，我们就可以通过调用 <code>inheritPrototype</code> 来替换为子类型原型赋值的语句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...code</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuberType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SuberType, SuperType);</span><br><span class="line"><span class="comment">//...code</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>优点:</p>
</blockquote>
<p>只调用了一次超类构造函数，效率更高。避免在<code>SuberType.prototype</code>上面创建不必要的、多余的属性，与其同时，原型链还能保持不变。</p>
<p>因此寄生组合继承是引用类型最理性的继承范式。</p>
<h4 id="ES6-继承"><a href="#ES6-继承" class="headerlink" title="ES6 继承"></a>ES6 继承</h4><p><code>Class</code> 可以通过 extends 关键字实现继承，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age) &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age, name) &#123;</span><br><span class="line">    <span class="built_in">super</span>(age); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType(<span class="number">22</span>, <span class="string">&quot;刘小夕&quot;</span>);</span><br><span class="line">instance.getAge(); <span class="comment">//22</span></span><br></pre></td></tr></table></figure>

<p>对于 ES6 的 <code>class</code> 需要做以下几点说明：</p>
<ol>
<li>类的数据类型就是函数，类本身就指向构造函数。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> SuperType); <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(SuperType === SuperType.prototype.constructor); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>类的内部所有定义的方法，都是不可枚举的。(ES5 原型上的方法默认是可枚举的)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(SuperType.prototype);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>constructor</code> 方法是类的默认方法，通过 <code>new</code> 命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code> 方法，如果没有显式定义，一个空的 <code>constructor</code> 方法会被默认添加。</li>
<li><code>Class</code> 不能像构造函数那样直接调用，会抛出错误。</li>
</ol>
<p>使用 <code>extends</code> 关键字实现继承，有一点需要特别说明：</p>
<ul>
<li>子类必须在 <code>constructor</code> 中调用 <code>super</code> 方法，否则新建实例时会报错。如果没有子类没有定义 <code>constructor</code> 方法，那么这个方法会被默认添加。在子类的构造函数中，只有调用 <code>super</code> 之后，才能使用 <code>this</code>关键字，否则报错。这是因为子类实例的构建，基于父类实例，只有 super 方法才能调用父类实例。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="built_in">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="【Step-By-Step】高频面试题深入解析-周刊-07"><a href="#【Step-By-Step】高频面试题深入解析-周刊-07" class="headerlink" title="【Step-By-Step】高频面试题深入解析 / 周刊 07"></a>【Step-By-Step】高频面试题深入解析 / 周刊 07</h2><blockquote>
<p>本周面试题一览:</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/39">实现一个 JSON.stringify</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/40">实现一个 JSON.parse</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/41">实现一个观察者模式</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/42">使用 CSS 让一个元素水平垂直居中有哪些方式</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/43">ES6 模块和 CommonJS 模块有哪些差异？</a></li>
</ul>
<h3 id="1-实现一个-JSON-stringify-（2019-10-27）"><a href="#1-实现一个-JSON-stringify-（2019-10-27）" class="headerlink" title="1. 实现一个 JSON.stringify （2019-10-27）"></a>1. 实现一个 <code>JSON.stringify</code> （2019-10-27）</h3><p><code>JSON.stringify([, replacer [, space])</code> 方法是将一个 JavaScript 值(对象或者数组)转换为一个 JSON 字符串。此处模拟实现，不考虑可选的第二个参数 <code>replacer</code> 和第三个参数 <code>space</code>，如果对这两个参数的作用还不了解，建议阅读 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">MDN</a> 文档。</p>
<blockquote>
<p><code>JSON.stringify()</code> 将值转换成对应的 <code>JSON</code> 格式:</p>
</blockquote>
<p>1、基本数据类型：</p>
<ul>
<li>undefined 转换之后仍是 undefined(类型也是 <code>undefined</code>)</li>
<li>boolean 值转换之后是字符串 <code>&quot;false&quot;/&quot;true&quot;</code></li>
<li>number 类型(除了 <code>NaN</code> 和 <code>Infinity</code>)转换之后是字符串类型的数值</li>
<li>symbol 转换之后是 <code>undefined</code></li>
<li>null 转换之后是字符串 <code>&quot;null&quot;</code></li>
<li>string 转换之后仍是 string</li>
<li><code>NaN</code> 和 <code>Infinity</code> 转换之后是字符串 <code>&quot;null&quot;</code></li>
</ul>
<p>2、如果是函数类型</p>
<ul>
<li>转换之后是 <code>undefined</code></li>
</ul>
<p>3、如果是对象类型(非函数)</p>
<ul>
<li>如果有 <code>toJSON()</code> 方法，那么序列化 <code>toJSON()</code> 的返回值。</li>
<li>如果是一个数组<ul>
<li>如果属性值中出现了 <code>undefined</code>、任意的函数以及 <code>symbol</code>，转换成字符串 <code>&quot;null&quot;</code></li>
</ul>
</li>
<li>如果是 <code>RegExp</code> 对象。<br>返回 <code>&#123;&#125;</code> (类型是 string)</li>
<li>如果是 <code>Date</code> 对象，返回 <code>Date</code> 的 <code>toJSON</code> 字符串值</li>
<li>如果是普通对象；<ul>
<li>如果属性值中出现了 <code>undefined</code>、任意的函数以及 symbol 值，忽略。</li>
<li>所有以 <code>symbol</code> 为属性键的属性都会被完全忽略掉。</li>
</ul>
</li>
</ul>
<p>4、对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。</p>
<blockquote>
<p>模拟实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonStringify</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dataType = <span class="keyword">typeof</span> data;</span><br><span class="line">  <span class="keyword">if</span> (dataType !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = data;</span><br><span class="line">    <span class="comment">//data 可能是 string/number/null/undefined/boolean</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(data) || data === <span class="literal">Infinity</span>) &#123;</span><br><span class="line">      <span class="comment">//NaN 和 Infinity 序列化返回 &quot;null&quot;</span></span><br><span class="line">      result = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      dataType === <span class="string">&quot;function&quot;</span> ||</span><br><span class="line">      dataType === <span class="string">&quot;undefined&quot;</span> ||</span><br><span class="line">      dataType === <span class="string">&quot;symbol&quot;</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">//function 、undefined 、symbol 序列化返回 undefined</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataType === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      result = <span class="string">&#x27;&quot;&#x27;</span> + data + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//boolean 返回 String()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(result);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataType === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.toJSON &amp;&amp; <span class="keyword">typeof</span> data.toJSON === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> jsonStringify(data.toJSON());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> result = [];</span><br><span class="line">      <span class="comment">//如果是数组</span></span><br><span class="line">      <span class="comment">//toJSON 方法可以存在于原型链中</span></span><br><span class="line">      data.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          <span class="keyword">typeof</span> item === <span class="string">&quot;undefined&quot;</span> ||</span><br><span class="line">          <span class="keyword">typeof</span> item === <span class="string">&quot;function&quot;</span> ||</span><br><span class="line">          <span class="keyword">typeof</span> item === <span class="string">&quot;symbol&quot;</span></span><br><span class="line">        ) &#123;</span><br><span class="line">          result[index] = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          result[index] = jsonStringify(item);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      result = <span class="string">&quot;[&quot;</span> + result + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> result.replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//普通对象</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 循环引用抛错(暂未检测，循环引用时，堆栈溢出)</span></span><br><span class="line"><span class="comment">       * symbol key 忽略</span></span><br><span class="line"><span class="comment">       * undefined、函数、symbol 为属性值，被忽略</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">let</span> result = [];</span><br><span class="line">      <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&quot;symbol&quot;</span>) &#123;</span><br><span class="line">          <span class="comment">//key 如果是symbol对象，忽略</span></span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            data[item] !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">            <span class="keyword">typeof</span> data[item] !== <span class="string">&quot;function&quot;</span> &amp;&amp;</span><br><span class="line">            <span class="keyword">typeof</span> data[item] !== <span class="string">&quot;symbol&quot;</span></span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="comment">//键值如果是 undefined、函数、symbol 为属性值，忽略</span></span><br><span class="line">            result.push(<span class="string">&#x27;&quot;&#x27;</span> + item + <span class="string">&#x27;&quot;&#x27;</span> + <span class="string">&quot;:&quot;</span> + jsonStringify(data[item]));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> (<span class="string">&quot;&#123;&quot;</span> + result + <span class="string">&quot;&#125;&quot;</span>).replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-实现一个-JSON-parse-（2019-10-28）"><a href="#2-实现一个-JSON-parse-（2019-10-28）" class="headerlink" title="2. 实现一个 JSON.parse  （2019-10-28）"></a>2. 实现一个 <code>JSON.parse </code> （2019-10-28）</h3><p><code>JSON.parse(JSON.parse(text[, reviver])</code> 方法用来解析 JSON 字符串，构造由字符串描述的 JavaScript 值或对象。提供可选的 reviver 函数用以在返回之前对所得到的对象执行变换。此处模拟实现，不考虑可选的第二个参数 <code>reviver</code> ，如果对这个参数的作用还不了解，建议阅读 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">MDN</a> 文档。</p>
<p><strong>第一种方式 eval</strong></p>
<p>最简单，最直观的方式就是调用 <code>eval</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;小姐姐&quot;, &quot;age&quot;:20&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> + json + <span class="string">&quot;)&quot;</span>); <span class="comment">// obj 就是 json 反序列化之后得到的对象</span></span><br></pre></td></tr></table></figure>

<p>直接调用 <code>eval</code> 存在 <code>XSS</code> 漏洞，数据中可能不是 <code>json</code> 数据，而是可执行的 <code>JavaScript</code> 代码。因此，在调用 <code>eval</code> 之前，需要对数据进行校验。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rx_one = <span class="regexp">/^[\],:&#123;&#125;\s]*$/</span>;</span><br><span class="line"><span class="keyword">var</span> rx_two = <span class="regexp">/\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_three = <span class="regexp">/&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_four = <span class="regexp">/(?:^|:|,)(?:\s*\[)+/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  rx_one.test(</span><br><span class="line">    json.replace(rx_two, <span class="string">&quot;@&quot;</span>).replace(rx_three, <span class="string">&quot;]&quot;</span>).replace(rx_four, <span class="string">&quot;&quot;</span>)</span><br><span class="line">  )</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> + json + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JSON</code> 是 JS 的子集，可以直接交给 <code>eval</code> 运行。</p>
<p><strong>第二种方式 <code>new Function</code></strong></p>
<p><code>Function</code> 与 <code>eval</code> 有相同的字符串参数特性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;小姐姐&quot;, &quot;age&quot;:20&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;return &quot;</span> + json)();</span><br></pre></td></tr></table></figure>

<h3 id="3-实现一个观察者模式-（2019-10-29）"><a href="#3-实现一个观察者模式-（2019-10-29）" class="headerlink" title="3. 实现一个观察者模式 （2019-10-29）"></a>3. 实现一个观察者模式 （2019-10-29）</h3><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯。</p>
<p>观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有一家猎人工会，其中每个猎人都具有发布任务(publish)，订阅任务(subscribe)的功能</span></span><br><span class="line"><span class="comment">//他们都有一个订阅列表来记录谁订阅了自己</span></span><br><span class="line"><span class="comment">//定义一个猎人类</span></span><br><span class="line"><span class="comment">//包括姓名，级别，订阅列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hunter</span>(<span class="params">name, level</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.level = level;</span><br><span class="line">  <span class="built_in">this</span>.list = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Hunter.prototype.publish = <span class="function"><span class="keyword">function</span> (<span class="params">money</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.level + <span class="string">&quot;猎人&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;寻求帮助&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.list.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">    item(money);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Hunter.prototype.subscribe = <span class="function"><span class="keyword">function</span> (<span class="params">targrt, fn</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.level + <span class="string">&quot;猎人&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;订阅了&quot;</span> + targrt.name);</span><br><span class="line">  targrt.list.push(fn);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//猎人工会走来了几个猎人</span></span><br><span class="line"><span class="keyword">let</span> hunterMing = <span class="keyword">new</span> Hunter(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;黄金&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hunterJin = <span class="keyword">new</span> Hunter(<span class="string">&quot;小金&quot;</span>, <span class="string">&quot;白银&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hunterZhang = <span class="keyword">new</span> Hunter(<span class="string">&quot;小张&quot;</span>, <span class="string">&quot;黄金&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hunterPeter = <span class="keyword">new</span> Hunter(<span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;青铜&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Peter等级较低，可能需要帮助，所以小明，小金，小张都订阅了Peter</span></span><br><span class="line">hunterMing.subscribe(hunterPeter, <span class="function"><span class="keyword">function</span> (<span class="params">money</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&quot;小明表示：&quot;</span> + (money &gt; <span class="number">200</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;暂时很忙，不能&quot;</span>) + <span class="string">&quot;给予帮助&quot;</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line">hunterJin.subscribe(hunterPeter, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;小金表示：给予帮助&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">hunterZhang.subscribe(hunterPeter, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;小张表示：给予帮助&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Peter遇到困难，赏金198寻求帮助</span></span><br><span class="line">hunterPeter.publish(<span class="number">198</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//猎人们(观察者)关联他们感兴趣的猎人(目标对象)，如Peter，当Peter有困难时，会自动通知给他们（观察者）</span></span><br></pre></td></tr></table></figure>

<h3 id="5-ES6-模块和-CommonJS-模块有哪些差异？（2019-10-30）"><a href="#5-ES6-模块和-CommonJS-模块有哪些差异？（2019-10-30）" class="headerlink" title="5. ES6 模块和 CommonJS 模块有哪些差异？（2019-10-30）"></a>5. ES6 模块和 <code>CommonJS</code> 模块有哪些差异？（2019-10-30）</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Blog/issues/38">参考</a></p>
</blockquote>
<ol>
<li><code>CommonJS</code> 模块是运行时加载，ES6 模块是编译时输出接口。</li>
</ol>
<ul>
<li>ES6 模块在编译时，就能确定模块的依赖关系，以及输入和输出的变量。ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>
<li><code>CommonJS</code> 加载的是一个对象，该对象只有在脚本运行完才会生成。</li>
</ul>
<ol start="2">
<li><code>CommonJS</code> 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
</ol>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- `CommonJS` 输出的是一个值的拷贝(注意基本数据类型/复杂数据类型)</span><br><span class="line"></span><br><span class="line">- ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>ES6 模块自动采用严格模式，无论模块头部是否写了 <code>&quot;use strict&quot;;</code></li>
<li>require 可以做动态加载，<code>import</code> 语句做不到，<code>import</code> 语句必须位于顶层作用域中。</li>
<li>ES6 模块的输入变量是只读的，不能对其进行重新赋值</li>
<li>当使用 require 命令加载某个模块时，就会运行整个模块的代码。</li>
<li>当使用 require 命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%89%9B%E4%BA%BA%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">牛人面试题</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-ComplexityAnalysis"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/09/11/ComplexityAnalysis/"
    >面试中的复杂度分析</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/09/11/ComplexityAnalysis/" class="article-date">
  <time datetime="2019-09-11T11:56:35.000Z" itemprop="datePublished">2019-09-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/">玩转算法面试</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="面试中的复杂度分析"><a href="#面试中的复杂度分析" class="headerlink" title="面试中的复杂度分析"></a>面试中的复杂度分析</h1><blockquote>
<p>很多同学一提起复杂度分析就头疼，马上想起了《算法导论》中复杂的数学推导。但其实在一般的企业面试中，对复杂度的分析要求并没有那么高，但也是绕不过去的坎儿。在这一章，和大家介绍一下，面试中需要掌握的复杂度分析。…</p>
</blockquote>
<h2 id="2-1-究竟什么是大-O（Big-O）"><a href="#2-1-究竟什么是大-O（Big-O）" class="headerlink" title="2-1 究竟什么是大 O（Big O）"></a>2-1 究竟什么是大 O（Big O）</h2><h4 id="大-O？"><a href="#大-O？" class="headerlink" title="大 O？"></a>大 O？</h4><ul>
<li>n 表示数据规模</li>
<li>O（f(n)）表示运行算法所需要执行的指令数，和 f(n) 成正比</li>
</ul>
<h4 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h4><ul>
<li>二分查找法 O(logn) — 所需执行指令数 ：a * logn</li>
<li>寻找 数组中的最大/最小值 O(n) — 所需执行指令数 ：b * n</li>
<li>归并排序算法 O(nlogn) — 所需执行指令数 ：c * nlogn</li>
<li>选择排序法 O(n^2) — 所需执行指令数 ：d * n^2</li>
</ul>
<h3 id="到底什么是-Big-O？"><a href="#到底什么是-Big-O？" class="headerlink" title="到底什么是 Big O？"></a>到底什么是 Big O？</h3><p><img src="http://static.zxinc520.com/blog/20190909/61aLQ2wE8prQ.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190909/2PO7UfwEDOpW.png?imageslim" alt="mark"></p>
<p><strong>在学术界</strong>，严格来讲，O(f(n)) 表示算法执行的上界</p>
<p>归并排序算法的时间复杂度是 O(nlogn)的，同时也是 O（n^2）</p>
<p><strong>在业界</strong>，我们就使用 O 来表示算法执行的最低上界</p>
<p>我们一般不会说归并排序是 O(n^2)的</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>O（nlogn + n）= O （nlogn）</li>
<li>O（nlogn + n^2）=O（n^2）</li>
</ul>
<h4 id="无法判断"><a href="#无法判断" class="headerlink" title="无法判断"></a>无法判断</h4><ul>
<li><p>O（AlogA + B） – A 与 B 无法确定</p>
</li>
<li><p>O（AlogA + B ^2）</p>
</li>
<li><p>对邻接表实现的图进行遍历</p>
<ul>
<li>时间复杂度：O（ V + E ）</li>
</ul>
</li>
</ul>
<h3 id="一个时间复杂度的问题"><a href="#一个时间复杂度的问题" class="headerlink" title="一个时间复杂度的问题"></a>一个时间复杂度的问题</h3><p>有一个字符串数组，将数组中的每一个字符串按照字母序排序；之后再将整个字符串数组按照字典序排序。整个操作的时间复杂度？</p>
<p><img src="http://static.zxinc520.com/blog/20190909/8cfiXUHkirne.png?imageslim" alt="mark"></p>
<p>正确解答：</p>
<ul>
<li>假设最长的字符串长度为 s ；数组中有 n 个字符串</li>
<li>对每个字符串排序：O（slogs）</li>
<li>将数组中的每一个字符串按照字母序排序：O（n * slog(s) ）</li>
<li>将整个字符串数组按照字典序排序：O（s * nlog(n) ）</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190909/Q5nKtKe1dCi7.png?imageslim" alt="mark"></p>
<h3 id="算法复杂度在有些情况是用例相关的"><a href="#算法复杂度在有些情况是用例相关的" class="headerlink" title="算法复杂度在有些情况是用例相关的"></a>算法复杂度在有些情况是用例相关的</h3><ul>
<li><p>插入排序 O（n ^ 2）</p>
<ul>
<li>最差情况：O（n ^ 2）</li>
<li>最好情况：O（n）</li>
<li>平均情况：O（n ^ 2）</li>
</ul>
</li>
<li><p>快速排序算法 O （nlogn）</p>
<ul>
<li>最差情况：O（n ^ 2）</li>
<li>最好情况：O（ nlogn ）</li>
<li>平均情况：O（ nlogn ）</li>
</ul>
</li>
</ul>
<h2 id="2-2-对数据规模有一个概念"><a href="#2-2-对数据规模有一个概念" class="headerlink" title="2-2 对数据规模有一个概念"></a>2-2 对数据规模有一个概念</h2><h3 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h3><p>对 10 ^ 5 的数据进行选择排序，结果计算机假死？</p>
<ul>
<li>如果要想在 1s 之内解决问题：<ul>
<li>O（n ^ 2）的算法可以处理大约 10 ^ 4 级别的数据</li>
<li>O（ n ）的算法可以处理大约 10 ^ 8 级别的数据</li>
<li>O（ nlogn ）的算法可以处理大约 10 ^7 级别的数据</li>
</ul>
</li>
</ul>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul>
<li>多开一个辅助的数组：O（n）</li>
<li>多开一个辅助的二维数组：O（n ^ 2）</li>
<li>多开常数空间：O（1）</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190909/7uFcA2L2OHhI.png?imageslim" alt="mark"></p>
<h2 id="2-3-简单的复杂度分析"><a href="#2-3-简单的复杂度分析" class="headerlink" title="2-3 简单的复杂度分析"></a>2-3 简单的复杂度分析</h2><h3 id="O（1）："><a href="#O（1）：" class="headerlink" title="O（1）："></a>O（1）：</h3><p><img src="http://static.zxinc520.com/blog/20190909/wmyLLvW5hvGh.png?imageslim" alt="mark"></p>
<h3 id="O（-n-）："><a href="#O（-n-）：" class="headerlink" title="O（ n ）："></a>O（ n ）：</h3><p><img src="http://static.zxinc520.com/blog/20190909/R4zqgJ9zJqqs.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190909/fujJT4N78Ybh.png?imageslim" alt="mark"></p>
<p>1/2 *n 次 swap 操作也是：O(n) 。</p>
<h3 id="O（n-2）-选择排序"><a href="#O（n-2）-选择排序" class="headerlink" title="O（n ^ 2）: ( 选择排序 )"></a>O（n ^ 2）: ( 选择排序 )</h3><p><img src="http://static.zxinc520.com/blog/20190909/HPtrTeSx6DsB.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190909/rh5JcB9dA8ux.png?imageslim" alt="mark"></p>
<p>并不是所有双重循环都是 O（n ^ 2）：例如 【因为里面的循环次数是固定的 】</p>
<p><img src="http://static.zxinc520.com/blog/20190909/Vs0lBjzBPEi9.png?imageslim" alt="mark"></p>
<p>下面算法是 O（logn）级别的： 【 自增并不是每次都加 1 】</p>
<p><img src="http://static.zxinc520.com/blog/20190909/QJC2YLSAOdAk.png?imageslim" alt="mark"></p>
<p>下面算法是 O（ sqrt (n) ）【 判断 n 是不是 一个素数】</p>
<p><img src="http://static.zxinc520.com/blog/20190909/QeClcFN8EsWa.png?imageslim" alt="mark"></p>
<h3 id="O（logn）：（-二分查找法-）"><a href="#O（logn）：（-二分查找法-）" class="headerlink" title="O（logn）：（ 二分查找法 ）"></a>O（logn）：（ 二分查找法 ）</h3><p><img src="http://static.zxinc520.com/blog/20190909/HCC3KITFnmlL.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190909/Y18HXPKRMICe.png?imageslim" alt="mark"></p>
<h4 id="整形转成字符串"><a href="#整形转成字符串" class="headerlink" title="整形转成字符串"></a>整形转成字符串</h4><p><img src="http://static.zxinc520.com/blog/20190909/gDCAKNS0NtKo.png?imageslim" alt="mark"></p>
<h3 id="log-以-2-为底-和-以-10-为底有区别吗"><a href="#log-以-2-为底-和-以-10-为底有区别吗" class="headerlink" title="log 以 2 为底 和 以 10 为底有区别吗"></a>log 以 2 为底 和 以 10 为底有区别吗</h3><p><img src="http://static.zxinc520.com/blog/20190909/hhkkzyo7uTJM.png?imageslim" alt="mark"></p>
<h2 id="2-4-亲自试验自己算法的时间复杂度"><a href="#2-4-亲自试验自己算法的时间复杂度" class="headerlink" title="2-4 亲自试验自己算法的时间复杂度"></a>2-4 亲自试验自己算法的时间复杂度</h2><h3 id="复杂度实验"><a href="#复杂度实验" class="headerlink" title="复杂度实验"></a>复杂度实验</h3><p>实验，观察趋势</p>
<p>每次 将数据规模提高两倍，看时间的变化</p>
<h2 id="2-5-递归算法的复杂度分析"><a href="#2-5-递归算法的复杂度分析" class="headerlink" title="2-5 递归算法的复杂度分析"></a>2-5 递归算法的复杂度分析</h2><blockquote>
<p>不是有递归的函数就一定是 O（ nlogn ）！</p>
</blockquote>
<h3 id="递归中进行一次递归调用的复杂度分析"><a href="#递归中进行一次递归调用的复杂度分析" class="headerlink" title="递归中进行一次递归调用的复杂度分析"></a>递归中进行一次递归调用的复杂度分析</h3><p>二分法使用递归：</p>
<p><img src="http://static.zxinc520.com/blog/20190911/Vrm1PVyknLyf.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190911/HKc9QUhHzufd.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190911/Mrr5oypWBxGk.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190911/1hAzDU4ifP7w.png?imageslim" alt="mark"></p>
<p>引申：上述 函数增加求 负次幂？</p>
<h3 id="递归中进行多次递归调用"><a href="#递归中进行多次递归调用" class="headerlink" title="递归中进行多次递归调用"></a>递归中进行多次递归调用</h3><p><img src="http://static.zxinc520.com/blog/20190911/DmVGKhPNOvil.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190911/vlrGbmrXl4uo.png?imageslim" alt="mark"></p>
<p>深度不一样，并不是所有 多次递归调用 的时间复杂度 为：O（2 ^ n）</p>
<p><img src="http://static.zxinc520.com/blog/20190911/copG1I1hd0ya.png?imageslim" alt="mark"></p>
<h4 id="递归函数的时间复杂度"><a href="#递归函数的时间复杂度" class="headerlink" title="递归函数的时间复杂度"></a>递归函数的时间复杂度</h4><p>查阅 <strong>主定理</strong> （面试一般不考察）</p>
<h2 id="2-6-均摊时间复杂度分析（Amortized-Time-Analysis）"><a href="#2-6-均摊时间复杂度分析（Amortized-Time-Analysis）" class="headerlink" title="2-6 均摊时间复杂度分析（Amortized Time Analysis）"></a>2-6 均摊时间复杂度分析（Amortized Time Analysis）</h2><p><img src="http://static.zxinc520.com/blog/20190911/lH5rYQsGwqtN.png?imageslim" alt="mark"></p>
<h2 id="2-7-避免复杂度的震荡"><a href="#2-7-避免复杂度的震荡" class="headerlink" title="2-7 避免复杂度的震荡"></a>2-7 避免复杂度的震荡</h2><p><img src="http://static.zxinc520.com/blog/20190911/glngyIU8g3Mi.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190911/AFsH4CLIkIE3.png?imageslim" alt="mark"></p>
<h3 id="复杂度的震荡的解决方案"><a href="#复杂度的震荡的解决方案" class="headerlink" title="复杂度的震荡的解决方案"></a>复杂度的震荡的解决方案</h3><p><img src="http://static.zxinc520.com/blog/20190911/hwAvgAw9rUM1.png?imageslim" alt="mark"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/" rel="tag">复杂度分析</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7-O%EF%BC%9F/" rel="tag">大 O？</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/" rel="tag">算法面试</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-AlgorithmForTheInterview01"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/09/09/AlgorithmForTheInterview01/"
    >算法面试到底是什么鬼</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/09/09/AlgorithmForTheInterview01/" class="article-date">
  <time datetime="2019-09-09T02:43:24.000Z" itemprop="datePublished">2019-09-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/">玩转算法面试</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="算法面试到底是什么鬼"><a href="#算法面试到底是什么鬼" class="headerlink" title="算法面试到底是什么鬼?"></a>算法面试到底是什么鬼?</h1><blockquote>
<p>玩转算法面试 从真题到思维全面提升算法思维</p>
<p>为了面试，更为了提升你的算法思维</p>
<p>一提起算法面试，很多同学就会心有余悸。可其实，大多数企业的算法面试，并没有那么可怕。并不是一定要啃完整本《算法导论》，才能玩儿转算法面试；也并不是只有 ACM 参赛选手，才能笑傲算法面试。恰恰相反，大多数算法面试关注的算法思维，其实很基础。在这一章，和大家聊一聊，算法面试，到底是什么鬼？…</p>
</blockquote>
<h2 id="1-1-算法面试不仅仅是正确的回答问题"><a href="#1-1-算法面试不仅仅是正确的回答问题" class="headerlink" title="1-1 算法面试不仅仅是正确的回答问题"></a>1-1 算法面试不仅仅是正确的回答问题</h2><h4 id="算法面试是什么？"><a href="#算法面试是什么？" class="headerlink" title="算法面试是什么？"></a>算法面试是什么？</h4><ul>
<li>让大家在面对面试中的算法问题时，有一个合理的思考路径<ul>
<li>不代表能够“正确”回答每一个算法问题，但是合理的思考方向其实更重要，这也是正确完成算法面试问题的前提</li>
<li>算法面试优秀不意味着技术面试优秀</li>
<li>技术面试优秀不意味着能够拿到 Offer</li>
</ul>
</li>
</ul>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><h4 id="问题：对一组数据进行排序"><a href="#问题：对一组数据进行排序" class="headerlink" title="问题：对一组数据进行排序"></a>问题：对一组数据进行排序</h4><p>不假思索思考方向：</p>
<ul>
<li>快速排序算法 O（nlogn）</li>
</ul>
<p><strong>正确的方式</strong>是：应该和面试官探讨（ <strong>思考路径</strong> ）：</p>
<ul>
<li>这组数据有什么样的特征？<ul>
<li>有没有可能包含有大量重复的元素？</li>
<li>如果有这种可能的话，三路快排是更好的选择。</li>
</ul>
</li>
<li>这组数据有什么样的特征？<ul>
<li>是否大部分数据距离它正确的位置很近？是否近乎有序？</li>
<li>如果是这样的话，插入排序是更好的选择</li>
</ul>
</li>
<li>这组数据有什么样的特征？<ul>
<li>是否数据的取值范围非常有限？比如对学生成绩排序</li>
<li>如果是这样的话，计数排序是更好的选择</li>
</ul>
</li>
<li>对排序有什么额外的要求？<ul>
<li>是否需要稳定排序？</li>
<li>如果是的话，归并排序是更好的选择</li>
</ul>
</li>
<li>数据的存储状况是怎么样的？<ul>
<li>是否是使用链表存储的？</li>
<li>如果是的话，归并排序是更好的选择</li>
</ul>
</li>
<li>数据的存储状态是怎样的？<ul>
<li>数据的大小是否可以装载在内存里？</li>
<li>数据量很大，或者内存很小，不足以装载在内存里，需要使用外排序算法</li>
</ul>
</li>
</ul>
<h2 id="1-2-什么是“正确”的回答一个算法问题"><a href="#1-2-什么是“正确”的回答一个算法问题" class="headerlink" title="1-2 什么是“正确”的回答一个算法问题"></a>1-2 什么是“正确”的回答一个算法问题</h2><p><strong>正确</strong> 还包含对问题的独到见解；优化；代码规范；容错性</p>
<p>如果是 非常难的问题，对你的竞争对手来说，也是难的。</p>
<p>关键在于你所表达出的解决问题的思路</p>
<p>甚至通过表达解题思路的方向，得出结论：这个问题的解决方案，应该在哪一个领域，我可以通过查阅或者进一步学习解决问题</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul>
<li>项目经历 和 项目中遇到的实际问题</li>
<li>你遇到的印象最深的 bug 是什么？</li>
<li>面向对象</li>
<li>设计模式</li>
<li>网络相关；安全相关；内存相关；并发相关</li>
<li>系统设计；scalability</li>
</ul>
<p>技术面试只是面试的一部分。面试不仅仅是考察你的技术水平，还是了解你的过去以及形成的思考行为方式</p>
<p>关于过去：参与项目至关重要</p>
<h4 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h4><ul>
<li>本科生<ul>
<li>毕业设计</li>
<li>其它课程设计(大作业，大一点的程序设计等等)</li>
</ul>
</li>
<li>如何找到项目？<ul>
<li>实习</li>
<li>参与实战课程学习<ul>
<li>慕课网</li>
<li>Coursera</li>
</ul>
</li>
</ul>
</li>
<li>创建自己的项目<ul>
<li>自己做小应用：计划表；备忘录；播放器…</li>
<li>自己解决小问题：爬虫；数据分析；词频统计</li>
<li>“不是项目” 的项目：一本优秀的技术书籍的代码整理等…</li>
<li>分享：自己的技术博客；github 等等…</li>
</ul>
</li>
</ul>
<h4 id="行为类问题"><a href="#行为类问题" class="headerlink" title="行为类问题"></a>行为类问题</h4><p>通过过去了解你的思考行为方式？</p>
<ul>
<li>遇到的最大的挑战？</li>
<li>犯过的错误？</li>
<li>遭遇的失败？</li>
<li>最享受的工作内容？</li>
<li>遇到冲突的处理方式？</li>
<li>做的最与众不同的事儿？</li>
</ul>
<h4 id="准备好合适的问题问面试官"><a href="#准备好合适的问题问面试官" class="headerlink" title="准备好合适的问题问面试官"></a>准备好合适的问题问面试官</h4><ul>
<li>整个小组的大概运行模式是怎样的？</li>
<li>整个项目的后续规划是如何的？</li>
<li>这个产品中的某个问题是如何解决的？</li>
<li>为什么会选择某些技术？标准？</li>
<li>我对某个技术很感兴趣，在你的小组中我会有怎样的机会深入这种技术？</li>
</ul>
<p><strong>算法面试仍然是非常重要的一部分</strong></p>
<h2 id="1-3-如何准备算法面试"><a href="#1-3-如何准备算法面试" class="headerlink" title="1-3 如何准备算法面试"></a>1-3 如何准备算法面试</h2><p>准备面试 和 准备算法面试 是两个概念</p>
<p>算法面试 ，只是面试中的一个环节</p>
<h2 id="算法面试并没有那么难"><a href="#算法面试并没有那么难" class="headerlink" title="算法面试并没有那么难"></a>算法面试并没有那么难</h2><ul>
<li>远远不需要啃完一本 《算法导论》<ul>
<li>过于强调理论证明</li>
</ul>
</li>
<li>高级数据结构 和 算法面试提及的概率很低<ul>
<li>红黑树</li>
<li>计算几何</li>
<li>B - Tree</li>
<li>数论</li>
<li>斐波那契堆</li>
<li>FFT</li>
</ul>
</li>
</ul>
<p><strong>算法面试远远不需要达到信息学竞赛的水平</strong> 。</p>
<p><img src="http://static.zxinc520.com/blog/20190908/CNmOn2PupuUn.png?imageslim" alt="mark"></p>
<h3 id="算法面试的准备范围"><a href="#算法面试的准备范围" class="headerlink" title="算法面试的准备范围"></a>算法面试的准备范围</h3><ul>
<li>不要轻视基础算法 和 数据结构，而只关注 “有意思” 的题目</li>
</ul>
<p>重点关注：</p>
<ul>
<li>各种排序算法</li>
<li>基础数据结构和算法的实现：如堆、二叉树、图….</li>
<li>基础数据结构的使用：如链表、栈、队列、哈希表、图、Trie、并查集…</li>
<li>基础算法：深度优先、广度优先、二分查找、递归…</li>
<li>基本算法思想：递归、分治、回溯搜索、贪心、动态规划…</li>
</ul>
<h3 id="选择合适的-OJ"><a href="#选择合适的-OJ" class="headerlink" title="选择合适的 OJ"></a>选择合适的 OJ</h3><blockquote>
<p>OJ：online judge</p>
<p>在线判题系统</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190908/iW0zhuflnMIs.png?imageslim" alt="mark"></p>
<h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/">LeetCode</a> （ 源于真实的面试问题 ）</li>
<li><a target="_blank" rel="noopener" href="https://www.hackerrank.com/">HackerRank</a> （ 对问题分类很详细 ，更难一点，辅助作用）</li>
</ul>
<p><strong>注意</strong>： 在学习和实践做题之间，要掌握平衡</p>
<h2 id="1-4-解决算法面试问题的整体思路"><a href="#1-4-解决算法面试问题的整体思路" class="headerlink" title="1-4 解决算法面试问题的整体思路"></a>1-4 解决算法面试问题的整体思路</h2><h3 id="注意题目中的条件"><a href="#注意题目中的条件" class="headerlink" title="注意题目中的条件"></a>注意题目中的条件</h3><ul>
<li>给定一个有序数组…<ul>
<li><strong>有序</strong>： 是不是可以使用二分查找法</li>
</ul>
</li>
<li>有一些题目中的条件本质是暗示：<ul>
<li>设计一个 O（nlogn）的算法<ul>
<li>分治法</li>
</ul>
</li>
<li>无需考虑额外的空间<ul>
<li>开辟额外的空间</li>
</ul>
</li>
<li>数据规模大概是 10000<ul>
<li>O（n 的二次方）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="当没有思路的时候"><a href="#当没有思路的时候" class="headerlink" title="当没有思路的时候"></a>当没有思路的时候</h3><ul>
<li>自己给自己几个简单的测试用例，试验一下</li>
<li>不要忽视暴力解法。暴力解法通常是思考的起点</li>
</ul>
<h4 id="不要忽视暴力法"><a href="#不要忽视暴力法" class="headerlink" title="不要忽视暴力法"></a>不要忽视暴力法</h4><p><img src="http://static.zxinc520.com/blog/20190908/4H4HSG2k68nE.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190908/DTm490pyX7Vm.png?imageslim" alt="mark"></p>
<h2 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h2><h3 id="无头绪的思路"><a href="#无头绪的思路" class="headerlink" title="无头绪的思路"></a>无头绪的思路</h3><ul>
<li>遍历常见的算法思路</li>
<li>遍历常见的数据结构</li>
<li>空间 和 时间的 交换 （ 哈希表 ）</li>
<li>预处理信息 （ 排序 ）</li>
<li>在瓶颈处寻找答案：O（nlogn）+ O（n ∧ 2）；O（n∧3）</li>
</ul>
<h3 id="实际编写问题"><a href="#实际编写问题" class="headerlink" title="实际编写问题"></a>实际编写问题</h3><ul>
<li>极端条件的判断<ul>
<li>数组为空？字符串为空？数量为 0? 指针为 NULL ？</li>
</ul>
</li>
<li>变量名</li>
<li>模块化，复用性</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/" rel="tag">算法面试</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-ReactTheory"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/09/07/ReactTheory/"
    >组件化和 React</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/09/07/ReactTheory/" class="article-date">
  <time datetime="2019-09-07T14:32:45.000Z" itemprop="datePublished">2019-09-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a> / <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/React/">React</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="组件化和-React"><a href="#组件化和-React" class="headerlink" title="组件化和 React"></a>组件化和 React</h1><blockquote>
<p>本章先带领学生做一个 React 的实例，熟悉 React 开发环境、以及 <strong>组件化</strong> 的概念。然后，通过实例来讲解 React 的 <strong>实现原理</strong>，包括 <strong>JSX 的本质</strong> 、<strong>虚拟 DOM 和 JSX 的结合</strong>、以及 <strong>setState</strong> 。最后，<strong>对比 vue 和 React</strong> ，分析两者的异同。</p>
<p>组件化和 React 高级面试知识点</p>
<p>Think great thoughts and you will be great!</p>
<p>心怀伟大的理想，你将会变得伟大。</p>
</blockquote>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>是否做过 React 开发？</li>
<li>React 以及组件化的一些核心概念</li>
<li>实现流程</li>
</ul>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul>
<li>说一下对组件化的理解</li>
<li>JSX 本质是什么？</li>
<li>JSX 和 vdom 的关系？</li>
<li>说一下 setState 的过程</li>
<li>阐述一下对 React 和 Vue 的 认识</li>
</ul>
<h4 id="回顾-React"><a href="#回顾-React" class="headerlink" title="回顾 React"></a>回顾 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/">React</a></h4><ol>
<li><p>创建一个基本的 React 应用</p>
<p><a target="_blank" rel="noopener" href="https://github.com/facebookincubator/create-react-app">Create React App</a> 是一个用于<strong>学习 React</strong> 的舒适环境，也是用 React 创建<strong>新的单页应用</strong>的最佳方式。</p>
<p>它会配置你的开发环境，以便使你能够使用最新的 JavaScript 特性，提供良好的开发体验，并为生产环境优化你的应用程序。你需要在你的机器上安装 Node &gt;= 8.10 和 npm &gt;= 5.6。要创建项目，请执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
</li>
<li><p>用 React 实现 <strong>to-do-list</strong> ：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      list: [],</span><br><span class="line">      title: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> list = <span class="built_in">this</span>.state.list;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">&quot;text&quot;</span></span><br><span class="line">          value=&#123;<span class="built_in">this</span>.state.title&#125;</span><br><span class="line">          onChange=&#123;<span class="built_in">this</span>.changeHandle.bind(<span class="built_in">this</span>)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.clickHandle.bind(<span class="built_in">this</span>)&#125;&gt;Submit&lt;/button&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span> &#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">          &#125;)&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeHandle(e) &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      title: e.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addTitle(title) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentList = <span class="built_in">this</span>.state.list;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      list: currentList.concat(title),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.list);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clickHandle(e) &#123;</span><br><span class="line">    <span class="keyword">const</span> title = <span class="built_in">this</span>.state.title;</span><br><span class="line">    <span class="built_in">this</span>.addTitle(title);</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      title: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Todo;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190907/GRlG7LRoeKp7.gif" alt="mark"></p>
<h2 id="7-1-说一下对组件化的理解"><a href="#7-1-说一下对组件化的理解" class="headerlink" title="7-1 说一下对组件化的理解"></a>7-1 说一下对组件化的理解</h2><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>组件的 <strong>封装</strong></li>
<li>组件的 <strong>复用</strong></li>
</ul>
<h4 id="组件的封装"><a href="#组件的封装" class="headerlink" title="组件的封装"></a>组件的封装</h4><ul>
<li>视图</li>
<li>数据</li>
<li>变化逻辑 （ 数据驱动视图变化 ）</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190907/m1BCsjY31wOd.png?imageslim" alt="mark"></p>
<h4 id="组件的-复用"><a href="#组件的-复用" class="headerlink" title="组件的 复用"></a>组件的 复用</h4><ul>
<li>props 传递</li>
<li>复用</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190907/dSD9f5yFTKYD.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190907/dig0u7rhRuJi.png?imageslim" alt="mark"></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><ul>
<li>说一下对组件化的理解？<ul>
<li>组件的封装：封装视图、数据、变化逻辑</li>
<li>组件的复用：props 传递、复用</li>
</ul>
</li>
</ul>
<h2 id="7-2-JSX-本质是什么"><a href="#7-2-JSX-本质是什么" class="headerlink" title="7-2 JSX 本质是什么"></a>7-2 JSX 本质是什么</h2><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>JSX 语法</li>
<li>JSX 解析成 JS</li>
<li>独立的标准</li>
</ul>
<h4 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h4><ul>
<li>html 形式</li>
<li>引入 JS 变量和表达式</li>
<li>if … else …</li>
<li>循环</li>
<li>style 和 className</li>
<li>事件</li>
</ul>
<h4 id="提出疑问"><a href="#提出疑问" class="headerlink" title="提出疑问"></a>提出疑问</h4><ul>
<li>JSX 语法根本无法被浏览器所解析</li>
<li>那么它如何在浏览器运行</li>
</ul>
<h4 id="JSX-解析"><a href="#JSX-解析" class="headerlink" title="JSX 解析"></a>JSX 解析</h4><ul>
<li>JSX 其实是语法糖</li>
<li>开发环境会将 JSX 编译成 JS 代码</li>
<li>JSX 的写法 大大降低了学习成本和 编码工作量</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190907/Xy8TYGeoHcWC.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190907/yjXVnlK8oLfk.png?imageslim" alt="mark"></p>
<h4 id="JSX-独立的标准"><a href="#JSX-独立的标准" class="headerlink" title="JSX 独立的标准"></a>JSX 独立的标准</h4><ul>
<li>JSX 是 React 引入的，但不是 React 独有的</li>
<li>React 已经将它作为一个独立的标准开放，其它项目也可用</li>
<li>React.createElement 是可以自定义修改的</li>
<li>说明：本身功能已经完备；和其它标准兼容和扩展性没问题</li>
</ul>
<h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>JSX 本质是什么？<ul>
<li>JSX 语法（标签、JS 表达式、判断、循环、事件绑定）</li>
<li>JSX 本质就是语法糖，需被解析成 JS 才能运行</li>
<li>JSX 是独立的标准，可被其它项目使用</li>
</ul>
</li>
</ul>
<h2 id="7-3-JSX-和-vdom-的关系"><a href="#7-3-JSX-和-vdom-的关系" class="headerlink" title="7-3 JSX 和 vdom 的关系"></a>7-3 JSX 和 vdom 的关系</h2><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>分析：为何需要 vdom</li>
<li>React.createElement 和 h</li>
<li>何时 patch？</li>
<li>自定义组件的解析</li>
</ul>
<h4 id="为何需要-vdom"><a href="#为何需要-vdom" class="headerlink" title="为何需要 vdom"></a>为何需要 vdom</h4><ul>
<li>vdom 是 React 初次推广开来的，结合 JSX</li>
<li>JSX 就是模板，最终要渲染成 html</li>
<li>初次渲染 + 修改 state 后的 re-render</li>
<li>正好 符合 vdom 的应用场景</li>
</ul>
<h4 id="回顾-vdom"><a href="#回顾-vdom" class="headerlink" title="回顾 vdom"></a>回顾 <a target="_blank" rel="noopener" href="http://www.zxinc520.com/lcj/%225d63a1bce9920a5ce05e2c3b%22">vdom</a></h4><ul>
<li>vdom 如何应用，核心 API 是 什么？<ul>
<li>如何使用？ 可用 snabbdom 的 用法 来 举例</li>
<li>核心 函数 ：h 函数，patch 函数</li>
</ul>
</li>
</ul>
<p><strong>核心 API</strong> ：</p>
<ul>
<li>h（’&lt;标签名&gt;’，{ … 属性 … }，[… 子元素 …]）</li>
<li>h（’&lt;标签名&gt;’，{ … 属性 … }，[ ‘….’]）</li>
<li>patch（container，vnode）</li>
<li>patch（vnode，newVnode）</li>
</ul>
<h4 id="React-createElement-和-h"><a href="#React-createElement-和-h" class="headerlink" title="React.createElement 和 h"></a>React.createElement 和 h</h4><p><img src="http://static.zxinc520.com/blog/20190907/hro0P4sQFQug.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190907/3N0XehWXEtQa.png?imageslim" alt="mark"></p>
<h4 id="何时-patch"><a href="#何时-patch" class="headerlink" title="何时 patch"></a>何时 patch</h4><ul>
<li>初次渲染 - ReactDOM.render (&lt; App /&gt;,container)</li>
<li>会触发 patch (container,vnode)</li>
<li>re-render - setState</li>
<li>会触发 patch (vnode,newVnode)</li>
</ul>
<h4 id="自定义组件的解析"><a href="#自定义组件的解析" class="headerlink" title="自定义组件的解析"></a>自定义组件的解析</h4><ul>
<li>‘div’ - 直接渲染 &lt; div&gt; 即可，vdom 可以做到</li>
<li>Input 和 List ，是自定义组件 （class），vdom 默认不认识</li>
<li>因此 Input 和 List 定义的时候 必须声明 render 函数</li>
<li>根据 props 初始化实例，然后执行实例的 render 函数</li>
<li>render 函数返回的还是 vnode 对象</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190907/q3iTc0PViQbi.png?imageslim" alt="mark"></p>
<h3 id="问题解答-1"><a href="#问题解答-1" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>为何需要 vdom：JSX 需要渲染成 html，数据驱动视图</li>
<li>React.createElement 和 h ，都生成 vnode</li>
<li>何时 patch：ReactDOM.render(…) 和 setState</li>
<li>自定义组件的解析：初始化实例，然后执行 render</li>
</ul>
<h2 id="7-4-说一下-setState-的过程"><a href="#7-4-说一下-setState-的过程" class="headerlink" title="7-4 说一下 setState 的过程"></a>7-4 说一下 setState 的过程</h2><h3 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>setState 的异步</li>
<li>vue 修改属性也是 异步</li>
<li>setState 的过程</li>
</ul>
<h4 id="setState-的异步"><a href="#setState-的异步" class="headerlink" title="setState 的异步"></a>setState 的异步</h4><p><img src="http://static.zxinc520.com/blog/20190907/z8fAo7IMaYcs.png?imageslim" alt="mark"></p>
<h4 id="setState-为何需要异步？"><a href="#setState-为何需要异步？" class="headerlink" title="setState 为何需要异步？"></a>setState 为何需要异步？</h4><ul>
<li>可能会一次执行 多次 setState</li>
<li>你无法规定、限制用户如何使用 setState</li>
<li>没必要每次 setState 都重新渲染，考虑性能</li>
<li>即便是每次重新渲染，用户也看不到中间的效果</li>
<li>只看到最后的结果即可</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190907/0E8yvUnt3JOn.png?imageslim" alt="mark"></p>
<h4 id="vue-修改属性也是异步"><a href="#vue-修改属性也是异步" class="headerlink" title="vue 修改属性也是异步"></a>vue 修改属性也是异步</h4><ul>
<li>效果、原因和 setState 一样</li>
<li>对比记忆，印象深刻</li>
</ul>
<h4 id="vue-的整个实现流程"><a href="#vue-的整个实现流程" class="headerlink" title="vue 的整个实现流程"></a>vue 的整个实现流程</h4><ul>
<li>第一步：解析模板成 render 函数</li>
<li>第二步：响应式开始监听</li>
<li>第三步：首次渲染，显示页面，且绑定依赖</li>
<li>第四步：data 属性变化（ <strong>异步</strong> ），触发 rerender</li>
</ul>
<h5 id="data-属性变化"><a href="#data-属性变化" class="headerlink" title="data 属性变化"></a>data 属性变化</h5><ul>
<li>修改属性，被响应式 的 set 监听到</li>
<li>set 中执行 updataComponent （ <strong>异步</strong> ）</li>
<li>updataComponent 重新执行 vm.render()</li>
<li>生成的 vnode 和 prevVnode，通过 patch 进行比较</li>
<li>渲染到 html 中</li>
</ul>
<h4 id="setState-的过程"><a href="#setState-的过程" class="headerlink" title="setState 的过程"></a>setState 的过程</h4><ul>
<li>每个组件实例，都有 renderComponent 方法</li>
<li>执行 renderComponent 会重新执行实例的 render</li>
<li>render 函数返回 newVnode，然后拿到 preVnode</li>
<li>执行 patch （preVnode，newVnode）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* renderComponent方法 大致模拟*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  renderComponent() &#123;</span><br><span class="line">    <span class="keyword">const</span> preVnode = <span class="built_in">this</span>._vnode;</span><br><span class="line">    <span class="keyword">const</span> newVnode = <span class="built_in">this</span>.render();</span><br><span class="line">    patch(preVnode, newVnode);</span><br><span class="line">    <span class="built_in">this</span>._vnode = newVnode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题解答-2"><a href="#问题解答-2" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>setState 的异步：效果、原因</li>
<li>vue 修改属性也是异步：效果、原因</li>
<li>setState 的过程：最终走到 patch(preVnode, newVnode)</li>
</ul>
<h1 id="7-5-总结"><a href="#7-5-总结" class="headerlink" title="7-5 总结"></a>7-5 总结</h1><ul>
<li><p>说一下对组件化的理解？</p>
<ul>
<li>组件的封装：封装视图、数据、变化逻辑</li>
<li>组件的复用：props 传递、复用</li>
</ul>
</li>
<li><p>JSX 本质是什么？</p>
<ul>
<li>JSX 语法（标签、JS 表达式、判断、循环、事件绑定）</li>
<li>JSX 本质就是语法糖，需被解析成 JS 才能运行</li>
<li>JSX 是独立的标准，可被其它项目使用</li>
</ul>
</li>
<li><p>JSX 和 vdom 的关系？</p>
<ul>
<li>为何需要 vdom：JSX 需要渲染成 html，数据驱动视图</li>
<li>React.createElement 和 h ，都生成 vnode</li>
<li>何时 patch：ReactDOM.render(…) 和 setState</li>
<li>自定义组件的解析：初始化实例，然后执行 render</li>
</ul>
</li>
<li><p>说一下 setState 的过程</p>
<ul>
<li>setState 的异步：效果、原因</li>
<li>vue 修改属性也是异步：效果、原因</li>
<li>setState 的过程：最终走到 patch(preVnode, newVnode)</li>
</ul>
</li>
</ul>
<h2 id="7-6-React-Vs-vue"><a href="#7-6-React-Vs-vue" class="headerlink" title="7-6 React Vs vue"></a>7-6 React Vs vue</h2><h3 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>两者的本质区别</li>
<li>看模板和组件化的区别</li>
<li>两者共同点</li>
<li>总结问题的答案</li>
</ul>
<h4 id="两者的本质区别"><a href="#两者的本质区别" class="headerlink" title="两者的本质区别"></a>两者的本质区别</h4><ul>
<li>vue - 本质是 MVVM 框架，由 MVC 发展而来</li>
<li>React - 本质是前端组件化框架，有后端组件化发展而来</li>
</ul>
<h4 id="模板的区别"><a href="#模板的区别" class="headerlink" title="模板的区别"></a>模板的区别</h4><ul>
<li>vue - 使用模板 （ 最初由 angular 提出）</li>
<li>React - 使用 JSX</li>
<li>**模板语法 **上，我更倾向于 JSX</li>
<li><strong>模板分离</strong> 上，我更加倾向于 vue</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190907/3TJdcbF6Ud41.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190907/oPnkXYam0Ovp.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190907/O7ONMqnOcIxs.png?imageslim" alt="mark"></p>
<ul>
<li>模板应该 和 JS 逻辑分离</li>
<li>回顾 ”开放封闭原则“</li>
</ul>
<h4 id="组件化的区别"><a href="#组件化的区别" class="headerlink" title="组件化的区别"></a>组件化的区别</h4><ul>
<li>React 本身就是组件化，没有组件化就不是 React</li>
<li>vue 也支持组件化，不过是在 MVVM 上的扩展</li>
<li>查阅 vue 组件化的文档，洋洋洒洒很多（ 侧面反映 ）</li>
<li>对于组件化，我更倾向于 React，做的彻底而清晰</li>
</ul>
<h4 id="两者的共同点"><a href="#两者的共同点" class="headerlink" title="两者的共同点"></a>两者的共同点</h4><ul>
<li>都支持组件化</li>
<li>都是数据驱动视图</li>
</ul>
<h3 id="问题解答-3"><a href="#问题解答-3" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>阐述一下对 React 和 Vue 的 认识<ul>
<li>国内使用，首推 vue。文档更易读、易学、社区够大</li>
<li>如果团队水平较高，推荐使用 React。组件化 和 JSX</li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-VueTheory"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/09/05/VueTheory/"
    >MVVM 和 vue</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/09/05/VueTheory/" class="article-date">
  <time datetime="2019-09-05T09:07:39.000Z" itemprop="datePublished">2019-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a> / <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/Vue/">Vue</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="MVVM-和-vue"><a href="#MVVM-和-vue" class="headerlink" title="MVVM 和 vue"></a>MVVM 和 vue</h1><blockquote>
<p>本章首先介绍了 <strong>jQuery 开发方式和框架开发方式的区别</strong> ，引导学生进入框架开发的思路转变。然后通过 MVC 模式引入 <strong>MVVM</strong> ，在两者比较让学生更快熟悉 MVVM 。最后结合实例，详细讲解 vue 的 <strong>实现原理</strong> ，包括 <strong>响应式</strong>、<strong>模板解析</strong>、<strong>渲染</strong> 这三大要素。…</p>
<p>高级面试：<strong>vue 知识点</strong></p>
<p>放弃该放弃的是无奈，放弃不该放弃的是无能，不放弃该放弃的是无知，不放弃不该放弃的是执著！</p>
<p>It is helpless to give up the waiver. It is incompetence to give up what should not be given up. It is ignorance that does not give up the waiver. It is attachment that does not give up and should not give up!</p>
</blockquote>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>如何 理解 MVVM</li>
<li>如何 实现 MVVM</li>
<li>是否解读过 vue 源码</li>
</ul>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul>
<li>说一下 使用 jQuery 和 使用框架的区别</li>
<li>说一下 对 MVVM 的理解</li>
<li>vue 中如何实现 <strong>响应式</strong></li>
<li>vue 中如何解析 <strong>模板</strong></li>
<li>vue 的 整个实现流程</li>
</ul>
<h2 id="使用-jQuery-和-使用框架的区别"><a href="#使用-jQuery-和-使用框架的区别" class="headerlink" title="使用 jQuery 和 使用框架的区别"></a>使用 jQuery 和 使用框架的区别</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>jQuery 实现 todo-list</li>
<li>vue 实现 todo-list</li>
<li>jQuery 和 框架的区别</li>
</ul>
<h4 id="jQuery-实现-todo-list"><a href="#jQuery-实现-todo-list" class="headerlink" title="jQuery 实现 todo-list"></a>jQuery 实现 todo-list</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txt-title&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn-submit&quot;</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul-list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> $txtTitle = $(<span class="string">&quot;#txt-title&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> $ulList = $(<span class="string">&quot;#ul-list&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> $btnSubmit = $(<span class="string">&quot;#btn-submit&quot;</span>);</span></span><br><span class="line"><span class="javascript">      $btnSubmit.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> title = $txtTitle.val();</span></span><br><span class="line">        if (!title) &#123;</span><br><span class="line"><span class="javascript">          <span class="keyword">return</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> $li = $(<span class="string">`&lt;li&gt;<span class="subst">$&#123;title&#125;</span>&lt;/li&gt;`</span>);</span></span><br><span class="line">        $ulList.append($li);</span><br><span class="line"><span class="javascript">        $txtTitle.val(<span class="string">&quot;&quot;</span>);</span></span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190902/BaCUCHQ12jJW.gif" alt="mark"></p>
<h4 id="vue-实现-todo-list"><a href="#vue-实现-todo-list" class="headerlink" title="vue 实现 todo-list"></a>vue 实现 todo-list</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;title&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">          title: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line">          list: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">          add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.list.push(<span class="built_in">this</span>.title);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.title = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190903/sQq0jR7s1E7E.gif" alt="mark"></p>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><ul>
<li><strong>数据</strong> 和 <strong>视图</strong> 的分离</li>
<li>以数据驱动视图</li>
</ul>
<h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>说一下 使用 jQuery 和 使用框架的区别 ？<ul>
<li><strong>数据</strong> 和 <strong>视图</strong> 的分离，<u>解耦</u>（ <em>开放封闭原则</em> ）</li>
<li>以数据驱动视图，只关心数据变化，DOM 操作被封装</li>
</ul>
</li>
</ul>
<h2 id="说一下-对-MVVM-的理解"><a href="#说一下-对-MVVM-的理解" class="headerlink" title="说一下 对 MVVM 的理解"></a>说一下 对 MVVM 的理解</h2><blockquote>
<p>目前前端框架中，最为出色的要属 Vue 和 React 了，这俩个框架的核心理念都<strong>是数据驱动页面渲染</strong>，同时他们都是 MVVM 模式的框架，<strong>MVVM 模式</strong> 中的 M 还是固定表示 Modal，V 还是表死 View，这俩个基本都是不会发生变化，一个页面必然需要数据和渲染俩个部分，那么变化的是如何将 Modal 渲染到 View 的过程变了，在 MVVM 模式中，将 View 和 Modal 绑定在一起，只要 Modal 发生了变化，View 就会自动更新，不需要我们认为的再去写如何操作 DOM 更新的过程了</p>
</blockquote>
<h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>MVC</li>
<li>MVVM</li>
<li>关于 ViewModel</li>
</ul>
<h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><ul>
<li>M -Model 数据</li>
<li>V - View 视图、界面</li>
<li>C - Controller 控制器 、逻辑处理</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190903/k21xefObaEwr.png?imageslim" alt="mark"></p>
<p><strong>MVC</strong>模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。</p>
<p>在前端的 <strong>MVC 模式</strong> 中，M 还是表示 Modal 层，负责与后台交互数据，V 表示 View，负责页面上 DOM 的渲染，C 表示绑定在 DOM 元素上的事件，当 Controllor 中的事件被调用，会去调用 Modal 中的数据，然后交给 View 重新渲染数据</p>
<h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><ul>
<li>M - Model 模型、数据</li>
<li>V - View 视图、模板（ 视图和模板是分离的 ）</li>
<li>ViewModel - <strong>连接</strong> Model 和 View</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190903/23g0MdeUf9sw.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190903/1qFclAqzYLGt.png?imageslim" alt="mark"></p>
<h4 id="关于-ViewModel"><a href="#关于-ViewModel" class="headerlink" title="关于 ViewModel"></a>关于 ViewModel</h4><ul>
<li>MVVM 不算是一种创新</li>
<li>但其中的 ViewModel 确实是一种创新</li>
<li>真正 结合前端场景应用的创建</li>
</ul>
<h3 id="问题解答-1"><a href="#问题解答-1" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>说一下 对 MVVM 的理解<ul>
<li>MVVM - Model View ViewModel</li>
<li>三者之间的联系。以及如何对应到各段代码</li>
<li>ViewModel 的理解，联系 View 和 Model</li>
</ul>
</li>
</ul>
<h1 id="MVVM-框架的三大要素"><a href="#MVVM-框架的三大要素" class="headerlink" title="MVVM 框架的三大要素"></a>MVVM 框架的三大要素</h1><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li>再次分析 demo</li>
<li>三要素总结</li>
</ul>
<h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><ul>
<li>响应式：vue 如何监听到 data 的每个属性变化？</li>
<li>模板引擎：vue 的模板如何被解析，指令如何处理？</li>
<li>渲染：vue 的模板如何被渲染成 html？以及渲染过程</li>
</ul>
<h2 id="vue-中如何实现响应式"><a href="#vue-中如何实现响应式" class="headerlink" title="vue 中如何实现响应式"></a>vue 中如何实现响应式</h2><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>什么是响应式？</li>
<li>Object.defineProperty</li>
<li>模拟</li>
</ul>
<h4 id="什么是响应式？"><a href="#什么是响应式？" class="headerlink" title="什么是响应式？"></a>什么是响应式？</h4><ul>
<li>修改 data 属性后，vue 立刻监听到</li>
<li>data 属性被代理到 vm 上</li>
<li>演示</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line"><span class="javascript">          age: <span class="string">&quot;18&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190904/h1SkefYXlHkn.gif" alt="mark"></p>
<h4 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h4><blockquote>
<p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p>
<p><strong>语法</strong> ：Object.defineProperty(obj, prop, descriptor)</p>
<p><strong>参数</strong> ：</p>
<p><u>Object.defineProperty(obj, prop, descriptor)</u></p>
<p><strong>obj</strong> ：要在其上定义属性的对象。</p>
<p><strong>prop</strong> ：要定义或修改的属性的名称。</p>
<p><strong>descriptor</strong> ：将被定义或修改的属性描述符。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">//获取属性的时候，如何监听到？</span></span><br><span class="line">obj.age = <span class="number">26</span>; <span class="comment">//赋值属性的时候，如何监听到？</span></span><br></pre></td></tr></table></figure>

<p><em>Object.defineProperty：</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;get&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;set&quot;</span>);</span><br><span class="line">    name = newVal;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.name);</span><br><span class="line">obj.name = <span class="string">&quot;list&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h3><blockquote>
<p>模拟实现 Vue 如何监听 data</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如何监听data</span></span><br><span class="line"><span class="comment">var vm=new Vue(&#123;</span></span><br><span class="line"><span class="comment">    el:&#x27;张三&#x27;,</span></span><br><span class="line"><span class="comment">    data:&#123;</span></span><br><span class="line"><span class="comment">        name:&#x27;张三&#x27;,</span></span><br><span class="line"><span class="comment">        age:20</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟实现</span></span><br><span class="line"><span class="keyword">var</span> vm = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">  price: <span class="number">100</span>,</span><br><span class="line">  name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> key, value;</span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> data) &#123;</span><br><span class="line">  <span class="comment">//命中闭包。新建一个函数，保证 key 的独立的作用域</span></span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(vm, key, &#123;</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;get&quot;</span>); <span class="comment">//监听</span></span><br><span class="line">        <span class="keyword">return</span> data[key];</span><br><span class="line">      &#125;,</span><br><span class="line">      set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;set&quot;</span>); <span class="comment">//监听</span></span><br><span class="line">        data[key] = newVal;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190904/P570ewmXOdNX.gif" alt="mark"></p>
<h3 id="问题解答-2"><a href="#问题解答-2" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>什么是响应式？<ul>
<li>关键是理解 Object.defineProperty</li>
<li>将 data 的属性代理到 vm 上</li>
</ul>
</li>
</ul>
<h2 id="vue-中如何解析模板"><a href="#vue-中如何解析模板" class="headerlink" title="vue 中如何解析模板"></a>vue 中如何解析模板</h2><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>模板是什么？</li>
<li>render 函数</li>
<li>render 函数 与 vdom</li>
</ul>
<h4 id="模板是什么？"><a href="#模板是什么？" class="headerlink" title="模板是什么？"></a>模板是什么？</h4><ul>
<li><p>本质：字符串</p>
</li>
<li><p>有逻辑，如 v-if 、v-for 等</p>
</li>
<li><p>与 html 格式很像，但有很大区别</p>
</li>
<li><p>最终还要转换为 html 来显示</p>
</li>
<li><p><strong>模板最终必须转化成 JS 代码</strong> ，因为：</p>
<ul>
<li>有逻辑（v-if、v-for），必须用 JS 才能实现 （ 图灵完备 ）</li>
<li>转换成 html 渲染页面，必须用 JS 才能实现</li>
<li>因此，模板最重要转换成 一个 JS 函数 （render 函数）</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;title&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="render-函数-with-的用法"><a href="#render-函数-with-的用法" class="headerlink" title="render 函数 - with 的用法"></a>render 函数 - with 的用法</h4><blockquote>
<p>with 的用法 — <strong>自己开发的代码尽量不要使用！</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  getAddress: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用 with</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(obj.name);</span><br><span class="line">  alert(obj.age);</span><br><span class="line">  obj.getAddress();</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  getAddress: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 with</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span> (obj) &#123;</span><br><span class="line">    alert(obj.name);</span><br><span class="line">    alert(obj.age);</span><br><span class="line">    getAddress();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure>

<h4 id="render-函数"><a href="#render-函数" class="headerlink" title="render 函数"></a>render 函数</h4><p><img src="http://static.zxinc520.com/blog/20190905/igfqtojmzQ4H.png?imageslim" alt="mark"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>模板中所有信息都包含在了 render 函数中</li>
<li>this 即 vm</li>
<li>price 即 this.price 即 vm.price ，即 data 中的 price</li>
<li>_c 即 this. _c 即 vm. _c</li>
</ul>
<h4 id="render-函数剖析"><a href="#render-函数剖析" class="headerlink" title="render 函数剖析"></a>render 函数剖析</h4><ul>
<li>从哪里可以看到 render 函数？</li>
<li>复杂一点的例子，render 函数是什么样子的？</li>
<li>v- if 、v-for 、v-on 都是怎么处理的？</li>
</ul>
<h4 id="看一下-todo-list-demo-的-render-函数"><a href="#看一下-todo-list-demo-的-render-函数" class="headerlink" title="看一下 todo-list demo 的 render 函数"></a>看一下 todo-list demo 的 render 函数</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;title&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _c(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">id</span>: <span class="string">&quot;app&quot;</span> &#125; &#125;, [</span><br><span class="line">    _c(<span class="string">&quot;div&quot;</span>, [</span><br><span class="line">      _c(<span class="string">&quot;input&quot;</span>, &#123;</span><br><span class="line">        directives: [</span><br><span class="line">          &#123;</span><br><span class="line">            name: <span class="string">&quot;model&quot;</span>,</span><br><span class="line">            rawName: <span class="string">&quot;v-model&quot;</span>,</span><br><span class="line">            value: title,</span><br><span class="line">            expression: <span class="string">&quot;title&quot;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">        attrs: &#123; <span class="attr">type</span>: <span class="string">&quot;text&quot;</span> &#125;,</span><br><span class="line">        domProps: &#123; <span class="attr">value</span>: title &#125;,</span><br><span class="line">        on: &#123;</span><br><span class="line">          input: <span class="function"><span class="keyword">function</span> (<span class="params">$event</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ($event.target.composing) <span class="keyword">return</span>;</span><br><span class="line">            title = $event.target.value;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">      _v(<span class="string">&quot; &quot;</span>),</span><br><span class="line">      _c(<span class="string">&quot;button&quot;</span>, &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: add &#125; &#125;, [_v(<span class="string">&quot;submit&quot;</span>)]),</span><br><span class="line">    ]),</span><br><span class="line">    _v(<span class="string">&quot; &quot;</span>),</span><br><span class="line">    _c(</span><br><span class="line">      <span class="string">&quot;ul&quot;</span>,</span><br><span class="line">      _l(list, <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _c(<span class="string">&quot;li&quot;</span>, [_v(_s(item))]);</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">    ),</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据 todo-list demo 的 render 函数</li>
<li>v- model 是怎么实现的？</li>
<li>v-on :click 是怎么实现的？</li>
<li>v- for 是怎么实现的？</li>
</ul>
<h4 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    vue2.0 开始支持预编译</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    开发环境 ：写模板</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    编译打包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    生产环境：JS</span></span><br><span class="line"><span class="comment">    --------------------------------------------</span></span><br><span class="line"><span class="comment">    React 组件化</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    JSX 模板</span></span><br><span class="line"><span class="comment">    编译 ： -&gt; JS 代码</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><ul>
<li><p>已经解决了 模板中 “逻辑” （v-for、v-if ）的问题</p>
</li>
<li><p>还剩下模板生成 html 问题</p>
</li>
<li><p>另外，vm._c 是什么？ render 函数 返回了什么？</p>
</li>
</ul>
<h5 id="先复习一下-vdom-的知识"><a href="#先复习一下-vdom-的知识" class="headerlink" title="先复习一下 vdom 的知识"></a>先复习一下 vdom 的知识</h5><blockquote>
<p>可参考 <a target="_blank" rel="noopener" href="http://zxinc520.com/lcj/%225d63a1bce9920a5ce05e2c3b%22">vdom 篇</a></p>
</blockquote>
<p>vdom 的如何应用，核心 API 是什么？</p>
<ul>
<li>介绍 <a target="_blank" rel="noopener" href="https://github.com/snabbdom/snabbdom">snabbdom</a></li>
<li>重做 之前的 demo</li>
<li>核心 API</li>
</ul>
<h5 id="render-函数和-vdom"><a href="#render-函数和-vdom" class="headerlink" title="render 函数和 vdom"></a>render 函数和 vdom</h5><p><img src="http://static.zxinc520.com/blog/20190905/ldxxH0zJ4t3s.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190905/MykHq1vOBFyL.png?imageslim" alt="mark"></p>
<ul>
<li>updataComponent 中实现了 vdom 的 patch</li>
<li>页面首次渲染执行 updataComponent</li>
<li>data 中每次修改属性，执行 updataComponent</li>
</ul>
<h3 id="问题解答-3"><a href="#问题解答-3" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>vue 中如何解析 <strong>模板</strong><ul>
<li>模板：字符串，有逻辑，嵌入 JS 变量……</li>
<li>模板必须转换成 JS 代码（有逻辑，渲染 html，JS 变量）</li>
<li>render 函数是什么样子的</li>
<li>render 函数执行是返回 vnode</li>
<li>updataComponent</li>
</ul>
</li>
</ul>
<h1 id="vue-的整个实现流程"><a href="#vue-的整个实现流程" class="headerlink" title="vue 的整个实现流程"></a>vue 的整个实现流程</h1><h3 id="整个实现流程"><a href="#整个实现流程" class="headerlink" title="整个实现流程"></a>整个实现流程</h3><ul>
<li><p>第一步：解析模板成 render 函数</p>
<ul>
<li>with 的用法</li>
<li>模板中的所有信息都被 render 函数 包含</li>
<li>模板中用到的 data 中的属性，都变成了 JS 变量</li>
<li>模板中的 v-model、v-for、v-on 都变成了 JS 逻辑</li>
<li>render 函数返回 vnode</li>
</ul>
</li>
<li><p>第二步：响应式开始监听</p>
<ul>
<li>Object.defineProperty</li>
<li>将 data 的属性代理到 vm 上</li>
</ul>
</li>
<li><p>第三步：首次渲染，显示页面，且绑定依赖</p>
<ul>
<li>初次渲染，执行 updataComponent ，执行 vm.render()</li>
<li>执行 render 函数，会访问到 vm.list 和 vm.title</li>
<li>会被响应式的 get 方法监听到 （后面详细讲）</li>
<li>执行 updataComponent ，会被 vdom 的 patch 方法</li>
<li>patch 将 vnode 渲染成 DOM ，初次渲染完成</li>
</ul>
<hr>
<ul>
<li>为何要监听 get，直接监听 set 不行吗？</li>
<li>data 中有很多属性，有些被用到，有些可能不被用到</li>
<li>被用到的会走到 get ，不被用到的 不会走到 get</li>
<li>未走到 get 中的属性，set 的时候我们也无需关心</li>
<li><strong>避免不必要的重复渲染</strong></li>
</ul>
</li>
<li><p>第四步：data 属性变化，触发 rerender</p>
<ul>
<li>修改属性，被响应式 的 set 监听到</li>
<li>set 中执行 updataComponent</li>
<li>updataComponent 重新执行 vm.render()</li>
<li>生成的 vnode 和 prevVnode，通过 patch 进行比较</li>
</ul>
</li>
</ul>
<h3 id="问题解答-4"><a href="#问题解答-4" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>vue 的整个实现流程？<ul>
<li>第一步：解析模板成 render 函数</li>
<li>第二步：响应式开始监听</li>
<li>第三步：首次渲染，显示页面，且绑定依赖</li>
<li>第四步：data 属性变化，触发 rerender</li>
</ul>
</li>
</ul>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>说一下 使用 jQuery 和 使用框架的区别</p>
<ul>
<li><strong>数据</strong> 和 <strong>视图</strong> 的分离，<u>解耦</u>（ <em>开放封闭原则</em> ）</li>
<li>以数据驱动视图，只关心数据变化，DOM 操作被封装</li>
</ul>
</li>
<li><p>什么是 MVVM ？</p>
<ul>
<li><p>MVVM - Model View ViewModel</p>
</li>
<li><p>三者之间的联系。以及如何对应到各段代码</p>
</li>
<li><p>ViewModel 的理解，联系 View 和 Model</p>
</li>
</ul>
</li>
</ul>
<h3 id="三要素-1"><a href="#三要素-1" class="headerlink" title="三要素"></a>三要素</h3><ul>
<li><p>响应式：vue 如何监听到 data 的每个属性变化？</p>
</li>
<li><p>模板引擎：vue 的模板如何被解析，指令如何处理？</p>
</li>
<li><p>渲染：vue 的模板如何被渲染成 html？以及渲染过程？</p>
</li>
<li><p>Vue 如何实现响应式？</p>
<ul>
<li>关键是理解 Object.defineProperty</li>
<li>将 data 的属性代理到 vm 上</li>
</ul>
</li>
<li><p>vue 中如何解析 <strong>模板</strong> ？</p>
<ul>
<li>模板：字符串，有逻辑，嵌入 JS 变量……</li>
<li>模板必须转换成 JS 代码（有逻辑，渲染 html，JS 变量）</li>
<li>render 函数是什么样子的</li>
<li>render 函数执行是返回 vnode</li>
<li>updataComponent</li>
</ul>
</li>
<li><p>vue 的整个实现流程？</p>
<ul>
<li>第一步：解析模板成 render 函数</li>
<li>第二步：响应式开始监听</li>
<li>第三步：首次渲染，显示页面，且绑定依赖</li>
<li>第四步：data 属性变化，触发 rerender</li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MVVM/" rel="tag">MVVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E3%80%81%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90%E3%80%81%E6%B8%B2%E6%9F%93/" rel="tag">响应式、模板解析、渲染</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-WeChatUp"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/09/05/WeChatUp/"
    >微信小程序笔记上</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/09/05/WeChatUp/" class="article-date">
  <time datetime="2019-09-05T09:07:39.000Z" itemprop="datePublished">2019-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a> / <a class="article-category-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E7%AF%87/">微信小程序上篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="微信小程序笔记上"><a href="#微信小程序笔记上" class="headerlink" title="微信小程序笔记上"></a>微信小程序笔记上</h1><blockquote>
<p>微信小程序学习笔记上</p>
<p>初步接触小程序</p>
<p>基础内容介绍</p>
<p>开发者文档</p>
<p>app.js 全局生命周期函数</p>
<p>WXML 数据绑定</p>
<p>通过 wx.request 请求数据</p>
<p>微信小程序里列表渲染</p>
<p>页面相关事件处理函数</p>
<p>True mastery of any skill takes a lifetime.</p>
<p>对任何技能的掌握都需要一生的刻苦操练。</p>
</blockquote>
<h1 id="小程序简介"><a href="#小程序简介" class="headerlink" title="小程序简介"></a>小程序简介</h1><blockquote>
<p>小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</p>
<p>微信小程序使用了前端技术栈 JavaScript/WXML/WXSS。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/quickstart/basic/introduction.html">相关介绍</a></p>
<p><strong>微信小程序使用了前端技术栈 JavaScript/WXML/WXSS。但和常规的前端开发又有一些区别：</strong> <a target="_blank" rel="noopener" href="https://juejin.im/entry/581db98fa0bb9f0058abffea">可以参考</a></p>
<ol>
<li><strong>JavaScript</strong>: 微信小程序的 JavaScript 运行环境即不是 Browser 也不是 Node.js。它运行在微信 App 的上下文中，不能操作 Browser context 下的 DOM，也不能通过 N*ode.js 相关接口访问操作系统 API。所以，严格意义来讲，微信小程序并不是 Html5，虽然开发过程和用到的技术栈和 Html5 是相通的。</li>
<li><strong>WXML：</strong>作为微信小程序的展示层，并不是使用 Html，而是自己发明的基于 XML 语法的描述。</li>
<li><strong>WXSS：</strong>用来修饰展示层的样式。官方的描述是 “ WXSS (WeiXin Style Sheets) 是一套样式语言，用于描述 WXML 的组件样式。WXSS 用来决定 WXML 的组件应该怎么显示。” “我们的 WXSS 具有 CSS 大部分特性…我们对 CSS 进行了扩充以及修改。”基于 CSS2 还是 CSS3？大部分是哪些部分？是否支持 CSS3 里的动画？不得而知。</li>
</ol>
<h4 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h4><p><img src="http://static.zxinc520.com/blog/20190514/yTqqYeB2UoIS.png?imageslim" alt="mark"></p>
<ol>
<li><code>app.js</code>做为小程序的入口，里面有个 App 实例，每个小程序只会有一个 App 实例，小程序启动以后触发 onLaunch 函数执行，获取用户信息</li>
<li><code>app.json</code>是小程序的所有全局配置，<code>pages</code>字段放置所有页面的路径，<code>window</code>字段定义所有页面的顶部背景颜色，文字颜色 详细配置请<a href="https://link.juejin.im/?target=https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html">戳这里 👇</a></li>
<li><code>app.wxss</code>文件就是页面公用的样式，仅支持部分 css 选择器</li>
<li><code>wxml</code>就是我们的 HTML 文件，常用标签为 <code>view</code> 、<code>text</code> 等，没有所谓的<code>div</code>、<code>span</code>、<code>p</code>一类的标签了，我们习惯称它们为组件</li>
</ol>
<hr>
<blockquote>
<p><strong>设计理念：</strong></p>
<p>小程序内部可以理解成一个 mvvm 的框架，分为逻辑层和视图层，逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。</p>
</blockquote>
<hr>
<p><img src="http://static.zxinc520.com/blog/20190514/U6eXvlL8evmQ.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190514/m4UDxEkFa1ae.png?imageslim" alt="mark"></p>
<h2 id="开始上手"><a href="#开始上手" class="headerlink" title="开始上手"></a>开始上手</h2><blockquote>
<p><strong>开始正式学习</strong></p>
<p>基础学习部分</p>
</blockquote>
<h3 id="加载一张图片"><a href="#加载一张图片" class="headerlink" title="加载一张图片"></a>加载一张图片</h3><p><img src="http://static.zxinc520.com/blog/20190514/GnYuPkAo16G5.png?imageslim" alt="mark"></p>
<p>_简单使用样式_：</p>
<p><img src="http://static.zxinc520.com/blog/20190514/gvNQzg8BaF74.png?imageslim" alt="mark"></p>
<h2 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h2><blockquote>
<p>WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。</p>
<p>WXSS 用来决定 WXML 的组件应该怎么显示。 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html">可以参考官网</a></p>
</blockquote>
<p>为了适应广大的前端开发者，WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。</p>
<p>与 CSS 相比，WXSS 扩展的特性有：</p>
<ul>
<li>尺寸单位</li>
<li>样式导入</li>
</ul>
<h2 id="尺寸单位"><a href="#尺寸单位" class="headerlink" title="尺寸单位"></a>尺寸单位</h2><p>​ <strong>rpx</strong>（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。如在 iPhone6 上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px = 750 物理像素，1rpx = 0.5px = 1 物理像素</p>
<p><img src="http://static.zxinc520.com/blog/20190514/57Wa2m8PEEyp.png?imageslim" alt="mark"></p>
<p><strong>建议：</strong> 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。</p>
<p><strong>注意：</strong> 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。</p>
<h2 id="全局样式与局部样式"><a href="#全局样式与局部样式" class="headerlink" title="全局样式与局部样式"></a>全局样式与局部样式</h2><p>定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。</p>
<h2 id="开发者文档"><a href="#开发者文档" class="headerlink" title="开发者文档"></a>开发者文档</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/image.html">开发者文档</a></p>
<p><strong>不会</strong> 或 <strong>忘了</strong> 就查文档！</p>
</blockquote>
<h3 id="image"><a href="#image" class="headerlink" title="image:"></a>image:</h3><p>​ <strong>解决图片缩放问题：</strong></p>
<ul>
<li>mode （ 常用下面 2 个属性值缩放图片 ）<ul>
<li>aspectFit：缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。</li>
<li>aspectFill：缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。</li>
</ul>
</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190520/XC3RPCh4fJdY.png?imageslim" alt="mark"></p>
<h3 id="swiper"><a href="#swiper" class="headerlink" title="swiper"></a>swiper</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html">看开发者文档</a></p>
<p>轮播组件：调用相应的标签及参数设置</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190520/PgOdEdCQrqvp.gif" alt="mark"></p>
<h2 id="解读-app-json"><a href="#解读-app-json" class="headerlink" title="解读 app.json"></a>解读 app.json</h2><blockquote>
<p>小程序根目录下的 <code>app.json</code> 文件用来对微信小程序进行全局配置。文件内容为一个 JSON 对象，有以下属性：</p>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html">可以参考官网</a></p>
</blockquote>
<h3 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h3><blockquote>
<p>用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对于位置的 <code>.json</code>, <code>.js</code>, <code>.wxml</code>, <code>.wxss</code> 四个文件进行处理。</p>
</blockquote>
<h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><blockquote>
<p>用于设置小程序的状态栏、导航条、标题、窗口背景色。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;window&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;navigationBarBackgroundColor&quot;</span>: <span class="string">&quot;#ffffff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;navigationBarTextStyle&quot;</span>: <span class="string">&quot;black&quot;</span>,</span><br><span class="line">    <span class="string">&quot;navigationBarTitleText&quot;</span>: <span class="string">&quot;微信接口功能演示&quot;</span>,</span><br><span class="line">    <span class="string">&quot;backgroundColor&quot;</span>: <span class="string">&quot;#eeeeee&quot;</span>,</span><br><span class="line">    <span class="string">&quot;backgroundTextStyle&quot;</span>: <span class="string">&quot;light&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tabBar"><a href="#tabBar" class="headerlink" title="tabBar"></a>tabBar</h3><blockquote>
<p>如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;tabBar&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#333&quot;</span>,</span><br><span class="line">   <span class="string">&quot;selectedColor&quot;</span>: <span class="string">&quot;#f30&quot;</span>,</span><br><span class="line">   <span class="string">&quot;list&quot;</span>: [&#123;</span><br><span class="line">     <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">     <span class="string">&quot;text&quot;</span>: <span class="string">&quot;首页&quot;</span>,</span><br><span class="line">     <span class="string">&quot;iconPath&quot;</span>: <span class="string">&quot;assets/tabs/icon1.png&quot;</span>,</span><br><span class="line">     <span class="string">&quot;selectedIconPath&quot;</span>: <span class="string">&quot;assets/tabs/icon1.png&quot;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;pages/message/message&quot;</span>,</span><br><span class="line">     <span class="string">&quot;text&quot;</span>: <span class="string">&quot;消息&quot;</span>,</span><br><span class="line">     <span class="string">&quot;iconPath&quot;</span>: <span class="string">&quot;assets/tabs/icon1.png&quot;</span>,</span><br><span class="line">     <span class="string">&quot;selectedIconPath&quot;</span>: <span class="string">&quot;assets/tabs/icon1.png&quot;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">     <span class="string">&quot;text&quot;</span>: <span class="string">&quot;个人中心&quot;</span>,</span><br><span class="line">     <span class="string">&quot;iconPath&quot;</span>: <span class="string">&quot;assets/tabs/icon1.png&quot;</span>,</span><br><span class="line">     <span class="string">&quot;selectedIconPath&quot;</span>: <span class="string">&quot;assets/tabs/icon1.png&quot;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">     <span class="string">&quot;text&quot;</span>: <span class="string">&quot;综合&quot;</span>,</span><br><span class="line">     <span class="string">&quot;iconPath&quot;</span>: <span class="string">&quot;assets/tabs/icon1.png&quot;</span>,</span><br><span class="line">     <span class="string">&quot;selectedIconPath&quot;</span>: <span class="string">&quot;assets/tabs/icon1.png&quot;</span></span><br><span class="line">   &#125;]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190521/OCDT2PNCaB4Y.png?imageslim" alt="mark"></p>
<p><em>等等等… 不了解就看文档！</em></p>
<p><strong>注意： 所以看开发者文档很重要！</strong></p>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html">点一下就可以看了，别懒！</a></p>
<h2 id="app-js-全局生命周期函数"><a href="#app-js-全局生命周期函数" class="headerlink" title="app.js 全局生命周期函数"></a>app.js 全局生命周期函数</h2><blockquote>
<p>app.js 全局生命周期函数</p>
</blockquote>
<p><em>在 app.js 文件中</em> ， 定义了一些生命周期方法 ， onLaunch，onShow，onHide，onError，以及任意开发者添加的函数或者数据（通过 this 可以访问）</p>
<p><strong>以下是各个生命周期方法作用和描述：</strong></p>
<ol>
<li><strong>onLaunch 生命周期函数</strong> –监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）</li>
<li><strong>onShow 生命周期函数</strong>–监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShow</li>
<li><strong>onHide 生命周期函数</strong>–监听小程序隐藏 当小程序从前台进入后台，会触发 onHide</li>
<li><strong>onError 错误监听函数</strong> 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息</li>
</ol>
<p>其他 Any 开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问</p>
<p><em>index.js:</em> （个人感觉 和 <strong>Vue</strong> 真的好像，如果熟悉 Vue 的话，这理解起来应该没有难度。）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//获取应用实例</span></span><br><span class="line"><span class="keyword">const</span> app = getApp();</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    motto: <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">    listarr: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）</span></span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span> (<span class="params">option</span>) </span>&#123;</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: <span class="string">&quot;https://www.baifubao.com/callback&quot;</span>,</span><br><span class="line">      success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">          listarr: res.statusCode,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注意：着重关注 onLoad 函数，因为使用最频繁！</strong></p>
<h2 id="WXML-数据绑定"><a href="#WXML-数据绑定" class="headerlink" title="WXML 数据绑定"></a>WXML 数据绑定</h2><blockquote>
<p>WXML 中的动态数据均来自对应 Page 的 data。</p>
</blockquote>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&quot;Hello World!&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190526/Dr9a1AITnQo7.png?imageslim" alt="mark"></p>
<h4 id="特别注意："><a href="#特别注意：" class="headerlink" title="特别注意："></a>特别注意：</h4><ol>
<li>花括号和引号之间不能有空格</li>
<li>不能直接写 checked=“false”，其计算结果是一个字符串，转成 boolean 类型后转为真值。</li>
</ol>
<h2 id="通过-wx-request-请求数据"><a href="#通过-wx-request-请求数据" class="headerlink" title="通过 wx.request 请求数据"></a>通过 wx.request 请求数据</h2><blockquote>
<p>通过 wx.request 请求数据</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">  url: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  data: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  header: &#123;&#125;,</span><br><span class="line">  method: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  dataType: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">  responseType: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;,</span><br><span class="line">  fail: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;&#125;,</span><br><span class="line">  complete: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190527/x00Ledvp9GT7.png?imageslim" alt="mark"></p>
<p><strong>setData</strong>：接受 <u>wx.request</u> 请求的数据，赋值给 Page 里面的 data（然后通过插值表达式渲染到页面）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//获取应用实例</span></span><br><span class="line"><span class="keyword">const</span> app = getApp();</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    motto: <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">    listarr: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span> (<span class="params">option</span>) </span>&#123;</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: <span class="string">&quot;https://www.baifubao.com/callback&quot;</span>,</span><br><span class="line">      success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">          listarr: res.statusCode,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="微信小程序里列表渲染"><a href="#微信小程序里列表渲染" class="headerlink" title="微信小程序里列表渲染"></a>微信小程序里列表渲染</h2><blockquote>
<h3 id="wx-for"><a href="#wx-for" class="headerlink" title="wx:for"></a>wx:for</h3><p>在组件上使用 <code>wx:for</code> 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。</p>
<p>默认数组的当前项的下标变量名默认为 <code>index</code>，数组当前项的变量名默认为 <code>item</code></p>
</blockquote>
<p><em>类比于 Vue：</em></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example-1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span>&#123;&#123; item.message &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>微信小程序里面：</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:<span class="keyword">for</span>=<span class="string">&quot;&#123;&#123;array&#125;&#125;&quot;</span>&gt;&#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    array: [</span><br><span class="line">      &#123;</span><br><span class="line">        message: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        message: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="wx-key"><a href="#wx-key" class="headerlink" title="wx:key"></a>wx:key</h4><p>​ <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/list.html">可以参考</a></p>
<p>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/input.html">``</a> 中的输入内容，<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/switch.html">``</a>的选中状态），需要使用 <code>wx:key</code> 来指定列表中项目的唯一的标识符。</p>
<ol>
<li>字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。</li>
<li>保留关键字 <code>*this</code> 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：</li>
</ol>
<p>当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</p>
<p><strong>如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">switch</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;objectArray&#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;unique&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: block;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123;item.id&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">switch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;switch&quot;</span>&gt;</span>Switch<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;addToFront&quot;</span>&gt;</span>Add to the front<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">switch</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;numberArray&#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;*this&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: block;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123;item&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">switch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;addNumberToFront&quot;</span>&gt;</span>Add to the front<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    objectArray: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">unique</span>: <span class="string">&quot;unique_5&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">unique</span>: <span class="string">&quot;unique_4&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">unique</span>: <span class="string">&quot;unique_3&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">unique</span>: <span class="string">&quot;unique_2&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">unique</span>: <span class="string">&quot;unique_1&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">0</span>, <span class="attr">unique</span>: <span class="string">&quot;unique_0&quot;</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">    numberArray: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="页面相关事件处理函数"><a href="#页面相关事件处理函数" class="headerlink" title="页面相关事件处理函数"></a>页面相关事件处理函数</h2><blockquote>
<p>页面相关事件处理函数（<strong>下拉刷新</strong>，<strong>滑到底部加载更多</strong>等）</p>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/ui/pull-down-refresh/wx.startPullDownRefresh.html">可以参考</a></p>
</blockquote>
<p><strong>下拉事件和触底事件</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//页面相关事件处理函数---监听用户下拉动作</span></span><br><span class="line">   onPullDownRefresh:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;下拉！&#x27;</span>)</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="comment">//页面上拉触底事件的处理函数</span></span><br><span class="line">   onReachBottom:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;上拉&#x27;</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/ui/navigation-bar/wx.showNavigationBarLoading.html">可以参考官方文档</a></p>
<p>js 文件</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">函数 API</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">wx.showNavigationBarLoading(Object object)</td>
<td align="center">在当前页面显示导航条加载动画</td>
</tr>
<tr>
<td align="center">wx.setNavigationBarTitle(Object object)</td>
<td align="center">动态设置当前页面的标题</td>
</tr>
<tr>
<td align="center">wx.setNavigationBarColor(Object object)</td>
<td align="center">设置页面导航条颜色</td>
</tr>
<tr>
<td align="center">wx.hideNavigationBarLoading(Object object)</td>
<td align="center">在当前页面隐藏导航条加载动画</td>
</tr>
</tbody></table>
<p><img src="http://static.zxinc520.com/blog/20190603/DXIDRjESGUHv.gif" alt="mark"></p>
<h2 id="界面交互"><a href="#界面交互" class="headerlink" title="界面交互"></a>界面交互</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showToast.html">参考官方文档</a></p>
</blockquote>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wx.showToast(&#123;</span><br><span class="line">  title: <span class="string">&quot;成功w&quot;</span>,</span><br><span class="line">  icon: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">  duration: <span class="number">2000</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190603/fRajsw7UWlQc.gif" alt="mark"></p>
<h2 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h2><blockquote>
<p>下拉刷新( <strong>配合</strong> 页面<em>相关事件处理函数</em>—监听用户下拉动作)</p>
</blockquote>
<p><strong>index.json:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;enablePullDownRefresh&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;backgroundTextStyle&quot;</span>: <span class="string">&quot;dark&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>index.js:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//页面相关事件处理函数---监听用户下拉动作</span></span><br><span class="line"> onPullDownRefresh:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;下拉！&#x27;</span>)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190603/bHEJTM3fLLsC.gif" alt="mark"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-WeChatUp02"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/09/05/WeChatUp02/"
    >微信小程序笔记下</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/09/05/WeChatUp02/" class="article-date">
  <time datetime="2019-09-05T09:07:39.000Z" itemprop="datePublished">2019-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a> / <a class="article-category-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8B%E7%AF%87/">微信小程序下篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="微信小程序笔记下"><a href="#微信小程序笔记下" class="headerlink" title="微信小程序笔记下"></a>微信小程序笔记下</h1><blockquote>
<p>微信小程序笔记下</p>
<p>input</p>
<p>color 属性</p>
<p>bindchange</p>
<p>wxs 页面脚本</p>
<p>微信小程序事件 <strong>冒泡 ** 和 事件</strong>传参**</p>
<p>服务号、订阅号</p>
<p>sdk</p>
</blockquote>
<h2 id="微信小程序组件"><a href="#微信小程序组件" class="headerlink" title="微信小程序组件"></a>微信小程序组件</h2><h3 id="表单组件"><a href="#表单组件" class="headerlink" title="表单组件"></a>表单组件</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><blockquote>
<p>输入框。该组件是<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/native-component.html">原生组件</a>，使用时请注意相关限制</p>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/input.html">可以参考</a></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 输入框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&#x27;text&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;password&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&#x27;password&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;number&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&#x27;number&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;idcard&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&#x27;idcard&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;digit&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&#x27;digit&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 单选框 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">radio-group</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">radio</span>&gt;</span>单选框<span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">radio</span>&gt;</span>单选框<span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">radio-group</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 多选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">checkbox-group</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">checkbox</span>&gt;</span>多选框<span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">checkbox</span>&gt;</span>多选框<span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">checkbox</span>&gt;</span>多选框<span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">checkbox-group</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190605/iBUB5P8LKOTz.png?imageslim" alt="mark"></p>
<h3 id="改变颜色"><a href="#改变颜色" class="headerlink" title="改变颜色"></a>改变颜色</h3><blockquote>
<p><strong>color 属性</strong></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">radio-group</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">radio</span> <span class="attr">color</span>=<span class="string">&quot;#f30&quot;</span>&gt;</span>单选框<span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">radio</span>&gt;</span>单选框<span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">radio-group</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 多选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">checkbox-group</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">checkbox</span> <span class="attr">color</span>=<span class="string">&quot;#f30&quot;</span>&gt;</span>多选框<span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">checkbox</span>&gt;</span>多选框<span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">checkbox</span>&gt;</span>多选框<span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">checkbox-group</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190605/0lbNety1l8Nr.gif" alt="mark"></p>
<ul>
<li>checked：默认选中</li>
<li>disabled: 禁用</li>
</ul>
<h3 id="bindchange"><a href="#bindchange" class="headerlink" title="bindchange"></a>bindchange</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/checkbox-group.html">checkbox-group</a>中选中项发生改变时触发 change 事件，detail = {value:[选中的 checkbox 的 value 的数组]}</p>
<p><strong>单选框</strong> 和 <strong>复选框</strong> 都能用！</p>
</blockquote>
<p><strong>例如：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">radio-group</span> =<span class="string">&quot;radiobindchangefun&quot;</span> <span class="attr">data-index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">radio</span> <span class="attr">color</span>=<span class="string">&quot;#f30&quot;</span> <span class="attr">value</span>=<span class="string">&quot;nan&quot;</span>&gt;</span>单选框<span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">radio</span> <span class="attr">value</span>=<span class="string">&quot;nv&quot;</span>&gt;</span>单选框<span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">radio-group</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>index.js：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">radiobindchangefun(e)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.detail.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190605/HhwLwtgLFk7s.gif" alt="mark"></p>
<h2 id="wxs-页面脚本"><a href="#wxs-页面脚本" class="headerlink" title="wxs 页面脚本"></a>wxs 页面脚本</h2><blockquote>
<p>WXS（WeiXin Script）是小程序的一套脚本语言，结合 <code>WXML</code>，可以构建出页面的结构。</p>
<p>WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript 一致。</p>
<p><strong>用的相对不多</strong></p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/01wxs-module.html">WXS 模块</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/02variate.html">变量</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/03annotation.html">注释</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/04operator.html">运算符</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/05statement.html">语句</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/06datatype.html">数据类型</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/07basiclibrary.html">基础类库</a></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">wxs</span> <span class="attr">module</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span><br><span class="line">  var sum=function(a,b)&#123; return a+b; &#125; module.exports.sum=sum</span><br><span class="line"><span class="tag">&lt;/<span class="name">wxs</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;foo.sum(1,2)&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190605/sEHFhCJgcSTT.png?imageslim" alt="mark"></p>
<h2 id="微信小程序事件冒泡和事件传参"><a href="#微信小程序事件冒泡和事件传参" class="headerlink" title="微信小程序事件冒泡和事件传参"></a>微信小程序事件冒泡和事件传参</h2><blockquote>
<p>微信小程序事件冒泡和事件传参</p>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html">参考</a></p>
</blockquote>
<h3 id="事件绑定和冒泡"><a href="#事件绑定和冒泡" class="headerlink" title="事件绑定和冒泡"></a>事件绑定和冒泡</h3><p>事件绑定的写法同组件的属性，以 key、value 的形式。</p>
<ul>
<li>key 以<code>bind</code>或<code>catch</code>开头，然后跟上事件的类型，如<code>bindtap</code>、<code>catchtouchstart</code>。自基础库版本 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.5.0</a> 起，在非<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/native-component.html">原生组件</a>中，<code>bind</code>和<code>catch</code>后可以紧跟一个冒号，其含义不变，如<code>bind:tap</code>、<code>catch:touchstart</code>。</li>
<li>value 是一个字符串，需要在对应的 Page 中定义同名的函数。不然当触发事件的时候会报错。</li>
</ul>
<p><code>bind</code>事件绑定<strong>不会阻止</strong>冒泡事件向上冒泡，<code>catch</code>事件绑定<strong>可以阻止</strong>冒泡事件向上冒泡。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;ClickFatherEvent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span> <span class="attr">catchtap</span>=<span class="string">&quot;ClickSonEvent&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190610/iYPyQKFs0uUh.gif" alt="mark"></p>
<h3 id="事件传参"><a href="#事件传参" class="headerlink" title="事件传参"></a>事件传参</h3><blockquote>
<p>自定义属性传参 ( <strong>data-index=”1”</strong> )</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;ClickFatherEvent&quot;</span> <span class="attr">data-index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span> <span class="attr">catchtap</span>=<span class="string">&quot;ClickSonEvent&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClickFatherEvent(event)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;father&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(event.currentTarget.dataset.index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190611/QGePjx2yA28Q.gif" alt="mark"></p>
<h2 id="服务号"><a href="#服务号" class="headerlink" title="服务号"></a>服务号</h2><blockquote>
<p>服务号：为企业和组织提供更强大的业务服务与用户管理能力，主要偏向服务类交互（功能类似 12315，114，银行，提供绑定信息，服务交互的）；</p>
<p>适用人群：媒体、企业、政府或其他组织。</p>
<p>群发次数：服务号 1 个月（按自然月）内可发送 4 条群发消息。</p>
<p><a target="_blank" rel="noopener" href="https://kf.qq.com/faq/120911VrYVrA150918fMZ77R.html?scene_id=kf3386">可以参考</a></p>
</blockquote>
<h2 id="订阅号"><a href="#订阅号" class="headerlink" title="订阅号"></a>订阅号</h2><blockquote>
<h1 id="什么是订阅号？"><a href="#什么是订阅号？" class="headerlink" title="什么是订阅号？"></a>什么是订阅号？</h1><p>订阅号：为媒体和个人提供一种新的信息传播方式，主要功能是在微信侧给用户传达资讯；（功能类似报纸杂志，提供新闻信息或娱乐趣事）</p>
<p>适用人群：个人、媒体、企业、政府或其他组织。</p>
<p>群发次数：订阅号（认证用户、非认证用户）1 天内可群发 1 条消息。</p>
</blockquote>
<p><strong>温馨提示：</strong></p>
<ol>
<li>如果想用公众平台简单发发消息，做宣传推广服务，建议可选择订阅号；</li>
<li>如果想用公众平台进行商品销售，建议可选择服务号，后续可认证再申请微信支付商户；</li>
</ol>
<h2 id="sdk"><a href="#sdk" class="headerlink" title="sdk"></a>sdk</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85">软件开发工具包</a>（缩写：<strong>SDK</strong>、外语全称：<strong>Software Development Kit）</strong>一般都是一些<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88/836275">软件工程师</a>为特定的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%8C%85/10508451">软件包</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/1471931">软件框架</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%A1%AC%E4%BB%B6/479446">硬件</a>平台、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192">操作系统</a>等建立应用软件时的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/10464557">开发工具</a>的集合。 [1]</p>
<p>软件开发工具包括广义上指<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BE%85%E5%8A%A9/1045139">辅助</a>开发某一类软件的相关文档、范例和工具的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88/73081">集合</a>。</p>
<p>软件开发工具包是一些被软件工程师用于为特定的软件包、软件框架、硬件平台、操作系统等创建应用软件的开发工具的集合，一般而言 SDK 即开发 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Windows">Windows</a> 平台下的应用程序所使用的 SDK。它可以简单的为某个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/2317999">程序设计语言</a>提供<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3/10418844">应用程序接口</a> <strong>API</strong>的一些文件，但也可能包括能与某种<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/186978">嵌入式系统</a>通讯的复杂的硬件。一般的工具包括用于调试和其他用途的实用工具。SDK 还经常包括示例代码、支持性的技术注解或者其他的为基本参考资料澄清疑点的支持文档。</p>
<p>为了鼓励开发者使用其系统或者语言，许多 SDK 是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%8D%E8%B4%B9/131326">免费</a>提供的。<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88/836275">软件工程师</a>通常从目标系统开发者那里获得软件开发包，也可以直接从互联网下载，有时也被作为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%90%A5%E9%94%80%E6%89%8B%E6%AE%B5">营销手段</a>。例如，营销公司会免费提供构建 SDK 以鼓励人们使用它，从而会吸引更多人由于能免费为其编程而购买其构件。</p>
<p>SDK 可能附带了使其不能在不兼容的许可证下开发软件的许可证。例如产品供应商提供一个专有的 SDK 可能与自由软件开发抵触。<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/GPL">GPL</a> 能使 SDK 与专有软件开发近乎不兼容。<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/LGPL">LGPL</a> 下的 SDK 则没有这个问题。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/SDK/7815680">可参考官方解释</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421141115">微信 JS-SDK 说明文档</a></p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-hybrid"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/08/29/hybrid/"
    >hybrid</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/08/29/hybrid/" class="article-date">
  <time datetime="2019-08-29T07:53:28.000Z" itemprop="datePublished">2019-08-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B7%B7%E5%90%88APP/">混合APP</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="hybrid"><a href="#hybrid" class="headerlink" title="hybrid"></a>hybrid</h1><blockquote>
<p>本章主要介绍 hybrid 的原理和应用。hybrid 基础部分要讲解 file 协议、webview、更新上线流程；另外，通过 h5 和 hybrid 的对比，来了解两者的异同和使用场景；最后讲解前端 JS 和客户端的通讯，包括通讯原理和 JS-bridge 的代码封装。…</p>
<p>社会主流 <strong>大前端</strong> 的概念。</p>
<p><strong>知识点</strong></p>
<p>6-1 hybrid 是什么？ 为何用 hybrid ？</p>
<p>6-2 hybrid 更新上线流程</p>
<p>6-3 hybrid 和 h5 的 主要区别？</p>
<p>6-4 前端 JS 和 客户端 如何通讯？</p>
<p>The greatest test of courage on earth is to bear defeat without losing heart.</p>
<p>世界上对勇气的最大考验是忍受失败而不丧失信心。</p>
</blockquote>
<h3 id="hybrid-1"><a href="#hybrid-1" class="headerlink" title="hybrid"></a>hybrid</h3><ul>
<li>移动端占大部分流量，已经远远超过 PC</li>
<li>一线互联网公司都有自己的 App</li>
<li>这些 App 中有很大比例的前端代码 ( 不要惊讶 )</li>
<li>拿微信举例，你每天浏览微信的内容，多少是前端？</li>
</ul>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>hybrid 是什么？ 为何用 hybrid ？</li>
<li>介绍一下 hybrid 更新 和上线的流程？</li>
<li>hybrid 和 h5 的 主要区别？</li>
<li>前端 JS 和 客户端 如何通讯？</li>
</ul>
<h2 id="6-1-hybrid-是什么？-为何用-hybrid-？"><a href="#6-1-hybrid-是什么？-为何用-hybrid-？" class="headerlink" title="6-1 hybrid 是什么？ 为何用 hybrid ？"></a>6-1 hybrid 是什么？ 为何用 hybrid ？</h2><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>hybrid 文字解释</li>
<li>存在价值，为何用 hybrid ？</li>
<li>webview</li>
<li>file：//协议</li>
<li>hybrid 实现流程</li>
</ul>
<h4 id="hybrid-文字解释"><a href="#hybrid-文字解释" class="headerlink" title="hybrid 文字解释"></a>hybrid 文字解释</h4><ul>
<li>hybrid 即 “混合” ，即 前端 和客户端的混合开发</li>
<li>需前端开发人员 和 客户端开发人员配合完成</li>
<li>某些环节也可能涉及到 server 端</li>
<li>注意：不要以为自己是前端就可以不理会客户端的知识</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190829/no77eoeMXoEi.png?imageslim" alt="mark"></p>
<h4 id="hybrid-存在价值"><a href="#hybrid-存在价值" class="headerlink" title="hybrid 存在价值"></a>hybrid 存在价值</h4><ul>
<li>可以快速迭代更新【关键】（无需 app 审核，思考为何？–&gt; 前端部分能够快速更新上线）</li>
<li>体验流畅 （ 和 NA 的体验基本类似 ）</li>
<li>减少开发和沟通成本，双端公用一套代码</li>
</ul>
<h4 id="webview"><a href="#webview" class="headerlink" title="webview"></a>webview</h4><ul>
<li>是 App 中的一个组件（app 可以有 webview，也可以没有）</li>
<li>用于加载 h5 页面，即一个小型的浏览器 内核</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190829/I797MG2jf2xe.png?imageslim" alt="mark"></p>
<h4 id="file-协议"><a href="#file-协议" class="headerlink" title="file 协议"></a>file 协议</h4><ul>
<li>其实在一开始接触 html 开发，就已经使用了 file 协议</li>
<li>只不过你当时没有 “协议” “标准” 等这些概念</li>
<li>再次强调 “协议” “标准” 的重要性 ！！！</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190829/kyXpWyLb4oVR.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190829/cxJ86AeO2374.png?imageslim" alt="mark"></p>
<p><em>两者的区别：</em></p>
<ul>
<li>file 协议：本地文件，快</li>
<li>http(s) 协议：网络加载，慢</li>
</ul>
<h4 id="hybrid-具体实现"><a href="#hybrid-具体实现" class="headerlink" title="hybrid 具体实现"></a>hybrid 具体实现</h4><ul>
<li>不是所有的场景都适合使用 hybrid</li>
<li>使用 <strong>NA</strong> ：体验要求极致，变化不频繁（ 如头条的首页 ）</li>
<li>使用 <strong>hybrid</strong> ：体验要求高，变化频繁（ 如头条的新闻详情页 ）</li>
<li>使用 <strong>h5</strong> ：体验无要求，不常用（如举报、反馈等页面）</li>
</ul>
<p><strong>具体实现</strong>：</p>
<ul>
<li>前端 做好静态页面（html css js），将文件交给客户端</li>
<li>客户端拿到前端静态页面，以文件形式储存在 app 中</li>
<li>客户端 在一个 webview 中</li>
<li>使用 file 协议 加载静态页面</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190829/RIR0zOPUN22I.png?imageslim" alt="mark"></p>
<h4 id="具体实现-–-遗留问题："><a href="#具体实现-–-遗留问题：" class="headerlink" title="具体实现 – 遗留问题："></a>具体实现 – 遗留问题：</h4><ul>
<li>app 发布之后，静态文件如何实时更新？</li>
<li>静态页面如何获取内容？</li>
</ul>
<h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>hybrid 是什么？ 为何用 hybrid ？<ul>
<li>hybrid 即 “混合” ，即 前端 和客户端的混合开发</li>
<li>hybrid 存在的核心意义在于快速迭代，无需审核</li>
<li>hybrid 实现流程（图），以及 webview 和 file 协议</li>
</ul>
</li>
</ul>
<h2 id="6-2-hybrid-更新上线流程"><a href="#6-2-hybrid-更新上线流程" class="headerlink" title="6-2 hybrid 更新上线流程"></a>6-2 hybrid 更新上线流程</h2><ul>
<li>回顾 hybrid 实现流程</li>
<li>思考 （目的，实现途径）</li>
<li>更新流程</li>
</ul>
<h4 id="回顾-hybrid-实现流程"><a href="#回顾-hybrid-实现流程" class="headerlink" title="回顾 hybrid 实现流程"></a>回顾 hybrid 实现流程</h4><p><img src="http://static.zxinc520.com/blog/20190829/aeHMDopqsrCy.png?imageslim" alt="mark"></p>
<h4 id="思考-（目的，实现途径）"><a href="#思考-（目的，实现途径）" class="headerlink" title="思考 （目的，实现途径）"></a>思考 （目的，实现途径）</h4><p><img src="http://static.zxinc520.com/blog/20190829/wCDenA4EGmC8.png?imageslim" alt="mark"></p>
<ul>
<li>要替换每个客户端的静态文件</li>
<li>只能客户端来做（客户端是我们开发的）</li>
<li>客户端去 server 下载最新的静态文件</li>
<li>我们维护 server 的静态文件</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190829/H6H3arUgJB6d.png?imageslim" alt="mark"></p>
<p><em>完整流程：</em></p>
<ul>
<li>分版本，有版本号，如 201803211015</li>
<li>将静态 文件压缩成 zip 包，上传到服务器</li>
<li>客户端每次启动，都去服务端检查版本号</li>
<li>如果服务端本版本号大于客户端版本号，就去下载最新的 zip 包</li>
<li>下载完之后解压包，然后将现有的文件覆盖</li>
</ul>
<h3 id="问题解答-1"><a href="#问题解答-1" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>介绍一下 hybrid 更新 和上线的流程？<ul>
<li>掌握流程图</li>
<li>要点 1：服务端的版本和 zip 包维护</li>
<li>要点 2：更新 zip 包之前，先对比版本号</li>
<li>要点 3：zip 下载解压和覆盖</li>
</ul>
</li>
</ul>
<h2 id="6-3hybrid-和-h5-的-主要区别？"><a href="#6-3hybrid-和-h5-的-主要区别？" class="headerlink" title="6-3hybrid 和 h5 的 主要区别？"></a>6-3hybrid 和 h5 的 主要区别？</h2><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>优点</li>
<li>缺点</li>
<li>适用的场景</li>
</ul>
<h4 id="hybrid-优点"><a href="#hybrid-优点" class="headerlink" title="hybrid 优点"></a>hybrid 优点</h4><ul>
<li>体验更好，跟 NA 体验基本一致</li>
<li>可快速迭代，无需 app 审核 【关键】</li>
</ul>
<h4 id="hybrid-缺点"><a href="#hybrid-缺点" class="headerlink" title="hybrid 缺点"></a>hybrid 缺点</h4><ul>
<li>开发成本高。联调，测试，查 bug 都比较麻烦</li>
<li>运维成本高。参考此前讲过的更新上线的流程</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>hybrid ：产品的稳定功能，体验要求高，迭代频繁</li>
<li>h5：单次的运营活动（如 xx 红包）或 不常用功能（反馈、举报页面等）</li>
</ul>
<h3 id="问题解答-2"><a href="#问题解答-2" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>hybrid 和 h5 的 主要区别？<ul>
<li>优点：体验好，可快速迭代</li>
<li>缺点：开发成本高，运维成本高</li>
<li>适用的场景：hybrid 适合产品型，h5 适合 运行型</li>
</ul>
</li>
</ul>
<h2 id="6-4-前端-JS-和-客户端-如何通讯？"><a href="#6-4-前端-JS-和-客户端-如何通讯？" class="headerlink" title="6-4 前端 JS 和 客户端 如何通讯？"></a>6-4 前端 JS 和 客户端 如何通讯？</h2><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>回顾 之前遗留的问题</li>
<li>JS 和 客户端通讯的基本形式</li>
<li>schema 协议简介和使用</li>
<li>schema 使用的封装</li>
<li>内置上线</li>
</ul>
<h4 id="之前遗留的问题"><a href="#之前遗留的问题" class="headerlink" title="之前遗留的问题"></a>之前遗留的问题</h4><ul>
<li>新闻详情页适用于 hybrid，前端如何 获取新闻内容 ？<ul>
<li>不能用 ajax （http(s)协议）获取。第一： 跨域 ，第二 ：速度慢</li>
<li>客户端获取新闻内容，然后 JS 通讯拿到内容，再渲染</li>
</ul>
</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190829/MIj2ETWq9QH1.png?imageslim" alt="mark"></p>
<p><em>JS 和 客户端通讯的基本形式</em> ：</p>
<ul>
<li>JS 访问客户端能力，传递参数 和 回调函数</li>
<li>客户端 通过 回调函数 返回内容</li>
</ul>
<h4 id="schema-协议简介和使用"><a href="#schema-协议简介和使用" class="headerlink" title="schema 协议简介和使用"></a>schema 协议简介和使用</h4><ul>
<li>之前介绍了 http(s) 和 file 协议</li>
<li>schema 协议 ——前端和客户端通讯的约定</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190829/w3OphLjO8erc.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190829/QpzXgisk6E3y.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190829/RjgtefgjYzXH.png?imageslim" alt="mark"></p>
<h4 id="模拟扫一扫前后端通讯"><a href="#模拟扫一扫前后端通讯" class="headerlink" title="模拟扫一扫前后端通讯"></a>模拟扫一扫前后端通讯</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>扫一扫<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">invokeScan</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>[<span class="string">&quot;_invoke_scan_callback_&quot;</span>] = <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span><br><span class="line">          alert(result);</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span></span><br><span class="line"><span class="javascript">        iframe.style.display = <span class="string">&quot;none&quot;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// iframe.src = &#x27;weixin://dl/scan&#x27;  //重要</span></span></span><br><span class="line">        iframe.src =</span><br><span class="line"><span class="javascript">          <span class="string">&quot;weixin://dl/scan?k1=v1&amp;k2=v2&amp;k3=v3&amp;callback=_invoke_scan_callback_&quot;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span></span><br><span class="line">        body.appendChild(iframe);</span><br><span class="line"><span class="javascript">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">          body.removeChild(iframe);</span><br><span class="line"><span class="javascript">          iframe = <span class="literal">null</span>;</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        invokeScan();</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="schema-使用的封装"><a href="#schema-使用的封装" class="headerlink" title="schema 使用的封装"></a>schema 使用的封装</h4><p><img src="http://static.zxinc520.com/blog/20190829/jcvC6T5SH3Pm.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190829/fW8NCvLoYRAg.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190829/5Yhq6r9uLr7X.png?imageslim" alt="mark"></p>
<h4 id="schema-封装代码"><a href="#schema-封装代码" class="headerlink" title="schema 封装代码"></a>schema 封装代码</h4><p><em>schema 使用的封装</em> ：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span>扫一扫<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span>&gt;</span>分享<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;invoke.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//调用扫一扫</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn1&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.invoke.scan(&#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//调用分享</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn2&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.invoke.share(</span></span><br><span class="line">          &#123;</span><br><span class="line"><span class="javascript">            title: <span class="string">&quot;xxx&quot;</span>,</span></span><br><span class="line"><span class="javascript">            content: <span class="string">&quot;yyy&quot;</span>,</span></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="javascript">          <span class="function"><span class="keyword">function</span> (<span class="params">relust</span>) </span>&#123;</span></span><br><span class="line">            if (relust.error === 0) &#123;</span><br><span class="line"><span class="javascript">              alert(<span class="string">&quot;分享成功&quot;</span>);</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">              alert(relust.message);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>invoke.js</em> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// invoke.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//调用 schema 的封装</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_invoke</span>(<span class="params">action, data, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//拼装 schema 协议</span></span><br><span class="line">    <span class="keyword">var</span> schema = <span class="string">&quot;myapp://utils/&quot;</span> + action;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拼接参数</span></span><br><span class="line">    schema += <span class="string">&quot;?a=a&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> key;</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.hasOwnProperty(key)) &#123;</span><br><span class="line">        schema += <span class="string">&quot;&amp;&quot;</span> + key + data[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理 callback</span></span><br><span class="line">    <span class="keyword">var</span> callbackName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      callbackName = callback;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      callbackName = action + <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="built_in">window</span>[callbackName] = callback;</span><br><span class="line">    &#125;</span><br><span class="line">    schema += <span class="string">&quot;callback=callbackName&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发</span></span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">    iframe.style.display = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">    iframe.src = schema; <span class="comment">//重要</span></span><br><span class="line">    <span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span><br><span class="line">    body.appendChild(iframe);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      body.removeChild(iframe);</span><br><span class="line">      iframe = <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//暴露到全局变量</span></span><br><span class="line">  <span class="built_in">window</span>.invoke = &#123;</span><br><span class="line">    share: <span class="function"><span class="keyword">function</span> (<span class="params">data, callback</span>) </span>&#123;</span><br><span class="line">      _invoke(<span class="string">&quot;share&quot;</span>, data, callback);</span><br><span class="line">    &#125;,</span><br><span class="line">    scan: <span class="function"><span class="keyword">function</span> (<span class="params">data, callback</span>) </span>&#123;</span><br><span class="line">      _invoke(<span class="string">&quot;scan&quot;</span>, data, callback);</span><br><span class="line">    &#125;,</span><br><span class="line">    login: <span class="function"><span class="keyword">function</span> (<span class="params">data, callback</span>) </span>&#123;</span><br><span class="line">      _invoke(<span class="string">&quot;login&quot;</span>, data, callback);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<h3 id="问题解答-3"><a href="#问题解答-3" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>前端 JS 和 客户端 如何通讯？<ul>
<li>通讯的基本形式：调用能力，传递参数，监听回调</li>
<li>对 schema 协议的理解和使用 （这个协议可理解为 ：定义了前端和客户端 通信的一个标准）</li>
<li>调用 schema 代码的封装</li>
<li>内置上线的好处：更快、更安全</li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hybrid/" rel="tag">hybrid</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-asynchronization"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/08/14/asynchronization/"
    >异步</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/08/14/asynchronization/" class="article-date">
  <time datetime="2019-08-14T07:30:31.000Z" itemprop="datePublished">2019-08-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JS/">JS</a> / <a class="article-category-link" href="/categories/JS/JS-%E4%B8%89%E5%BA%A7%E5%A4%A7%E5%B1%B1/">JS 三座大山</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><blockquote>
<p>本章全面讲解了 JS 异步的知识点。先从<strong>原理开始</strong> ，讲解什么是 <strong>单线程</strong>、什么是 <strong>event loop</strong> ；然后讲解 jQuery 中解决 <strong>异步的 Deferred</strong> 以及 jQuery 初次展示出来的 <strong>Promise 的用法</strong>；最后再讲解 ES6 中 <strong>Promise 的用法和标准</strong> 。</p>
<p><strong>基础篇请看</strong> ：<a target="_blank" rel="noopener" href="http://zxinc520.com/lcj/%225d2eeda9d797f0309cf6ab02%22">异步和单线程</a></p>
</blockquote>
<h2 id="异步-1"><a href="#异步-1" class="headerlink" title="异步"></a>异步</h2><blockquote>
<p>高级面试</p>
</blockquote>
<ul>
<li>《<a target="_blank" rel="noopener" href="http://zxinc520.com/lcj/%225d2eeda9d797f0309cf6ab02%22">前端 JS 面试技巧</a>》讲到异步的基础</li>
<li>高级面试会问到更多的内容</li>
<li>如 event-loop Promise Async/Await 等</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>什么是单线程，和异步有什么关系？ <a target="_blank" rel="noopener" href="http://zxinc520.com/lcj/%225d2eeda9d797f0309cf6ab02%22">参考 </a></li>
<li>什么是 event-loop？</li>
<li>是否用过 jQuery 的 Deferred</li>
<li>Promise 的基本使用和原理</li>
<li>介绍一下 async/await（ES7）（和 Promise 的区别、联系）</li>
<li>总结一下当前 JS 解决异步的方案</li>
</ul>
<h2 id="4-1-单线程和异步"><a href="#4-1-单线程和异步" class="headerlink" title="4-1 单线程和异步"></a>4-1 单线程和异步</h2><blockquote>
<p><a target="_blank" rel="noopener" href="http://zxinc520.com/lcj/%225d2eeda9d797f0309cf6ab02%22">单线程和异步基础篇 </a></p>
</blockquote>
<ul>
<li>为什么是单线程？<ul>
<li>原因 - 避免 DOM 渲染冲突<ul>
<li>浏览器需要渲染 DOM</li>
<li>JS 可以修改 DOM 结构</li>
<li>JS 执行的时候，浏览器 DOM 渲染会暂停</li>
<li>两段 JS 也不能同时执行 （ 都修改 DOM 就冲突了）</li>
<li>webworker 支持多线程 ，但是不能 访问 DOM</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>单线程的解决方案</strong> ： <strong>异步</strong></p>
<p><em>暴露出的问题</em> ：</p>
<ul>
<li>问题一：没按照书写方式执行，可读性差</li>
<li>问题二：callback 中不容易模块化</li>
</ul>
<h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>什么是单线程，和异步有什么关系？<ul>
<li>单线程就是同时只做一件事，两段 JS 不能同时 执行</li>
<li>原因就是 为了避免 DOM 渲染的冲突</li>
<li>异步是一种 “无奈” 的解决方案，虽然有很多问题</li>
</ul>
</li>
</ul>
<p><strong>承上启下：</strong></p>
<ul>
<li>单线程 - 同时间只能做一件事</li>
<li>原因 - 避免 DOM 渲染冲突</li>
<li>解决方案 - 异步</li>
<li>异步的实现方式 - event loop</li>
</ul>
<h2 id="4-2-什么是-event-loop"><a href="#4-2-什么是-event-loop" class="headerlink" title="4-2 什么是 event-loop"></a>4-2 什么是 event-loop</h2><blockquote>
<p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">再谈 Event Loop</a></p>
</blockquote>
<h3 id="文字解释"><a href="#文字解释" class="headerlink" title="文字解释"></a>文字解释</h3><blockquote>
<p>event-loop</p>
</blockquote>
<ul>
<li>事件轮询， JS 实现异步 的具体解决方案</li>
<li>同步代码，直接执行</li>
<li>异步函数先放在 异步队列 中</li>
<li>待同步函数执行完毕，轮询执行 异步队列 的函数</li>
</ul>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p><em>示例一：</em></p>
<p><img src="http://static.zxinc520.com/blog/20190813/mxsAJyrO4cLE.png?imageslim" alt="mark"></p>
<p><em>示例二：</em></p>
<p><img src="http://static.zxinc520.com/blog/20190813/kftHfWYaHL80.png?imageslim" alt="mark"></p>
<p><em>示例三：</em></p>
<p><img src="http://static.zxinc520.com/blog/20190813/j3lPm5VCfcSB.png?imageslim" alt="mark"></p>
<p><strong>上图有 2 种结果</strong>：(a 是在 ajax 请求成功时放入异步队列，所以时间不确定)</p>
<ol>
<li>d -&gt; c -&gt; a -&gt; b</li>
<li>d -&gt; c -&gt; b -&gt; a</li>
</ol>
<h3 id="问题解答-1"><a href="#问题解答-1" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>什么是 event-loop？<ul>
<li>事件轮询， JS 实现异步 的具体解决方案</li>
<li>什么是异步队列，何时被放入 异步队列</li>
<li>轮询的过程</li>
</ul>
</li>
</ul>
<h2 id="4-3-jQuery-的-Deferred"><a href="#4-3-jQuery-的-Deferred" class="headerlink" title="4-3 jQuery 的 Deferred"></a>4-3 jQuery 的 Deferred</h2><blockquote>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html">jQuery 的 deferred 对象详解</a></p>
<p>jQuery 1.5.0 版本开始引入的一个新功能—-<a target="_blank" rel="noopener" href="http://api.jquery.com/category/deferred-object/">deferred 对象</a>。</p>
<p>针对的读者是那些已经具备 jQuery 使用经验的开发者。如果你想了解 jQuery 的基本用法，请阅读 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/">阮一峰</a> 编写的<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html">《jQuery 设计思想》</a>和<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2011/08/jquery_best_practices.html">《jQuery 最佳实践》</a>。</p>
</blockquote>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>jQuery 1.5 的变化</li>
<li>使用 jQuery Deferred</li>
<li>初步引入 Promise 概念</li>
</ul>
<p><strong>注意</strong> ：不要以为所有的网站 都是 vue 和 React 开发的</p>
<h4 id="jQuery-1-5-之前"><a href="#jQuery-1-5-之前" class="headerlink" title="jQuery 1.5 之前"></a>jQuery 1.5 之前</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = $.ajax(&#123;</span><br><span class="line">  url: <span class="string">&quot;data.json&quot;</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success1&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success2&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success3&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ajax); <span class="comment">//返回一个 XHR 对象</span></span><br></pre></td></tr></table></figure>

<h4 id="jQuery-1-5-之后"><a href="#jQuery-1-5-之后" class="headerlink" title="jQuery 1.5 之后"></a>jQuery 1.5 之后</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = $.ajax(<span class="string">&quot;data.json&quot;</span>);</span><br><span class="line">ajax</span><br><span class="line">  .done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success 1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .fail(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success 2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ajax); <span class="comment">//返回一个 deferred 对象</span></span><br></pre></td></tr></table></figure>

<h4 id="jQuery-1-5-的变化"><a href="#jQuery-1-5-的变化" class="headerlink" title="jQuery 1.5 的变化"></a>jQuery 1.5 的变化</h4><ul>
<li>无法改变 JS 异步和单线程的本质</li>
<li>只能从写法上杜绝 callback 这种形式</li>
<li>它是一种语法糖形式，但是解耦了代码</li>
<li>很好的体现：<strong>开放封闭原则</strong></li>
</ul>
<h3 id="使用-jQuery-Deferred"><a href="#使用-jQuery-Deferred" class="headerlink" title="使用 jQuery Deferred"></a>使用 jQuery Deferred</h3><blockquote>
<p>使用 jQuery Deferred</p>
<p>对比 说明</p>
</blockquote>
<p><em>未使用情况：</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给出一段非常简单的异步操作代码，使用 setTimeout 函数</span></span><br><span class="line"><span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> task = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;执行完成&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">setTimeout</span>(task, <span class="number">2000</span>);</span><br><span class="line">&#125;;</span><br><span class="line">wait();</span><br><span class="line"><span class="comment">// 新增需求：要在执行完成之后进行某些特别复杂的操作，代码可能会很多，而且分好几个步骤</span></span><br></pre></td></tr></table></figure>

<p>_使用 jQuery Deferred_：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitHandle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dtd = $.Deferred(); <span class="comment">//创建一个 Deferred 对象</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span> (<span class="params">dtd</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//要求传入一个 Deferred 对象</span></span><br><span class="line">    <span class="keyword">var</span> task = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;执行完成&quot;</span>);</span><br><span class="line">      dtd.resolve(); <span class="comment">//表示异步任务已经完成</span></span><br><span class="line">      <span class="comment">// dtd.reject()  //表示异步任务失败或出错</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">setTimeout</span>(task, <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> dtd; <span class="comment">// 要求返回 Deferred 对象</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意，这里一定要有返回值</span></span><br><span class="line">  <span class="keyword">return</span> wait(dtd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区别于promise，好像不能链式调用</span></span><br><span class="line"><span class="keyword">var</span> w = waitHandle();</span><br><span class="line">w.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;ok 1&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;err 1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">w.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;ok 2&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;error 2&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有 w.done w.fail</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>总结，dtd 的 API 可分成两类，用意不同</li>
<li>第一类：dtd.resolve dtd.reject</li>
<li>第二类：dtd.then dtd.done dtd.fail</li>
<li>这两类应该分开，否则后果很严重</li>
</ul>
<h3 id="问题解答-2"><a href="#问题解答-2" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li><p>是否用过 jQuery 的 Deferred</p>
<ul>
<li>可以 jQuery 1.5 对 ajax 的改变举例</li>
<li>说明如何简单的封装，使用 Deferred</li>
<li>说明 ES6 promise 和 Deferred 的区别</li>
</ul>
</li>
</ul>
<p><strong>想要深入理解它，就需要知道它的前世今生。</strong></p>
<h2 id="4-4-Promise"><a href="#4-4-Promise" class="headerlink" title="4-4 Promise"></a>4-4 Promise</h2><blockquote>
<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>
<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p><a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/promise">ECMAScript 6 Promise 对象</a></p>
<p><strong>基础语法</strong> 请参考我的另一篇博客： <a target="_blank" rel="noopener" href="http://zxinc520.com/lcj/%225cbb3bf05733fa0a66088c80%22">Promise 详细分析</a></p>
</blockquote>
<p><code>Promise</code><strong>对象有以下两个特点</strong>。</p>
<ol>
<li>对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ol>
<p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p>
<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>
<p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<p>如果某些事件不断地反复发生，一般来说，使用 <a target="_blank" rel="noopener" href="https://nodejs.org/api/stream.html">Stream</a> 模式是比部署<code>Promise</code>更好的选择。</p>
<h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(img);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject();</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = src;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> src =</span><br><span class="line">  <span class="string">&quot;https://edu-image.nosdn.127.net/B34DC36428D2D51B8EF5EE2C83CE9BF2.png?imageView&amp;thumbnail=241y34&amp;quality=100&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = loadImg(src);</span><br><span class="line"></span><br><span class="line"><span class="comment">//规定 ： then 只接受一个参数，最后统一用 catch 捕获异常</span></span><br><span class="line">result</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">img</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(img.width);</span><br><span class="line">    <span class="keyword">return</span> img;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">img</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(img.height);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">ex</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 最后统一 catch</span></span><br><span class="line">    <span class="built_in">console</span>.log(ex);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Promise-all-amp-Promise-race"><a href="#Promise-all-amp-Promise-race" class="headerlink" title="Promise.all &amp; Promise.race"></a>Promise.all &amp; Promise.race</h3><blockquote>
<p><strong>Promise.all</strong> 可以将多个 Promise 实例包装成一个新的 Promise 实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被 reject 失败状态的值。</p>
<p><strong>Promse.race</strong> 就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7e60fc1be1b2">理解和使用 Promise.all 和 Promise.race</a></p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190814/LoF987DaE10r.png?imageslim" alt="mark"></p>
<p><em>演示</em> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(img);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject();</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = src;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> src1 =</span><br><span class="line">  <span class="string">&quot;https://edu-image.nosdn.127.net/B34DC36428D2D51B8EF5EE2C83CE9BF2.png?imageView&amp;thumbnail=241y34&amp;quality=100&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> src2 = <span class="string">&quot;https://www.imooc.com/static/img/index/logo.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = loadImg(src1);</span><br><span class="line"><span class="keyword">var</span> result2 = loadImg(src2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([result1, result2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">datas</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(datas[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(datas[<span class="number">1</span>]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//谁快谁先执行</span></span><br><span class="line"><span class="built_in">Promise</span>.race([result1, result2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">datas</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(datas);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Promise.all 的执行结果</strong> ：</p>
<p><img src="http://static.zxinc520.com/blog/20190814/ITqccL9zhyE0.png?imageslim" alt="mark"></p>
<p><strong>Promise.race 的执行结果</strong> ：</p>
<p><img src="http://static.zxinc520.com/blog/20190814/PP76XFiW0S3V.png?imageslim" alt="mark"></p>
<h3 id="promise-标准"><a href="#promise-标准" class="headerlink" title="promise 标准"></a>promise 标准</h3><ul>
<li>关于 “标准” 的闲谈</li>
<li>状态变化</li>
<li>then</li>
</ul>
<h4 id="关于-“标准”-的闲谈"><a href="#关于-“标准”-的闲谈" class="headerlink" title="关于 “标准” 的闲谈"></a>关于 “标准” 的闲谈</h4><ul>
<li>任何技术推广使用都需要一套标准来支撑</li>
<li>如 html js css http 等，无规矩不成方圆</li>
<li>任何不符合标准的东西，终将会被用户抛弃</li>
<li>不要挑战标准，不要自造标准</li>
</ul>
<h4 id="状态变化"><a href="#状态变化" class="headerlink" title="状态变化"></a>状态变化</h4><ul>
<li>三种状态：pending fulfilled rejected</li>
<li>初始状态：pending</li>
<li><strong>成功</strong>：pending 变成 fulfilled ，<strong>失败</strong>：pending 变成 rejected</li>
<li>状态变化不可逆</li>
</ul>
<h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><ul>
<li><p>Promise 实例必须实现 then 这个方法</p>
</li>
<li><p>then() 必须可以接受两个函数作为参数</p>
</li>
<li><p>then() 返回的必须是一个 Promise 实例</p>
<p><img src="http://static.zxinc520.com/blog/20190814/p2zjIfnNkjIp.png?imageslim" alt="mark"></p>
</li>
</ul>
<h3 id="问题解答-3"><a href="#问题解答-3" class="headerlink" title="问题解答"></a>问题解答</h3><p><strong>问题：Promise 的基本使用和原理？</strong></p>
<ul>
<li>基本语法 （复习）</li>
<li>如何异常捕获 （ error 和 reject 都要考虑）</li>
<li>多个串联 - 链式执行的好处</li>
<li>Promise.all 和 Promise.race</li>
<li>Promise 标准 - 状态变化，then 函数</li>
</ul>
<h2 id="4-5-async-await"><a href="#4-5-async-await" class="headerlink" title="4-5 async/await"></a>4-5 async/await</h2><blockquote>
<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>
<p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>
<p><a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/">ECMAScript 6 入门</a> <a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/async">async 函数</a></p>
</blockquote>
<ul>
<li>then 只是将 callback 拆分了</li>
<li>async/await 是最直接的同步写法</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190815/B2MsvoDMkq7B.png?imageslim" alt="mark"></p>
<p><strong>最直接的同步写法：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> load = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">await</span> loadImg(src1);</span><br><span class="line">  <span class="built_in">console</span>.log(result1);</span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">await</span> loadImg(src2);</span><br><span class="line">  <span class="built_in">console</span>.log(result2);</span><br><span class="line">&#125;;</span><br><span class="line">load();</span><br></pre></td></tr></table></figure>

<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul>
<li>使用 await，函数必须用 async 标识</li>
<li>await 后面跟的是一个 Promise 实例</li>
<li>需要 babel-polyfill</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(img);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject();</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = src;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> src1 =</span><br><span class="line">  <span class="string">&quot;https://edu-image.nosdn.127.net/B34DC36428D2D51B8EF5EE2C83CE9BF2.png?imageView&amp;thumbnail=241y34&amp;quality=100&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> src2 = <span class="string">&quot;https://www.imooc.com/static/img/index/logo.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> load = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">await</span> loadImg(src1);</span><br><span class="line">  <span class="built_in">console</span>.log(result1);</span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">await</span> loadImg(src2);</span><br><span class="line">  <span class="built_in">console</span>.log(result2);</span><br><span class="line">&#125;;</span><br><span class="line">load();</span><br></pre></td></tr></table></figure>

<h3 id="问题解答-4"><a href="#问题解答-4" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>介绍一下 async/await（ES7）（和 Promise 的区别、联系）<ul>
<li>基本语法</li>
<li>使用了 Promise，并没有和 Promise 冲突</li>
<li>完全是同步的写法，再也没有回调函数</li>
<li>但是：改变不了 JS 单线程、异步的本质</li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS-%E4%B8%89%E5%BA%A7%E5%A4%A7%E5%B1%B1/" rel="tag">JS 三座大山</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Promise/" rel="tag">Promise</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/event-loop/" rel="tag">event loop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%BA%BF%E7%A8%8B/" rel="tag">单线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5%E7%9A%84-Deferred/" rel="tag">异步的 Deferred</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> zhou chen
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="琛"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://zxinc520.com">个人博客</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友情链接</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="http://static.zxinc520.com/blog/20190512/p4IWzLUrorWK.jpg?imageslim">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="http://static.zxinc520.com/blog/20190512/pGHOMdDF79sb.jpg?imageslim">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>


<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>