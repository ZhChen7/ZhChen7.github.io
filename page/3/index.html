<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="博客，学习网站，hexo，周琛，周琛的个人博客" />
   
  <meta name="description" content="周琛的博客" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     周琛的博客
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.png" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="琛" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/ZhChen7"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">琛</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['学习', '学习使我快乐', '快乐，开心～'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-getOfferSinglethreadedandasynchronous"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/23/getOfferSinglethreadedandasynchronous/"
    >单线程和异步</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/03/23/getOfferSinglethreadedandasynchronous/" class="article-date">
  <time datetime="2020-03-23T09:18:21.000Z" itemprop="datePublished">2020-03-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JS/">JS</a> / <a class="article-category-link" href="/categories/JS/JS-%E4%B8%89%E5%BA%A7%E5%A4%A7%E5%B1%B1/">JS 三座大山</a> / <a class="article-category-link" href="/categories/Offer/">Offer</a> / <a class="article-category-link" href="/categories/Offer/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/">字节跳动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="专题总结：单线程和异步"><a href="#专题总结：单线程和异步" class="headerlink" title="专题总结：单线程和异步"></a>专题总结：单线程和异步</h2><blockquote>
<p>拿到 字节跳动实习生 offer 总结</p>
<p>回馈分享一波自己的知识点总结</p>
</blockquote>
<blockquote>
<p>希望读者依此构建自己的知识树（思维导图）</p>
<p>偷懒一下：可参考我自己总结思维导图 : <a target="_blank" rel="noopener" href="https://github.com/ZhChen7/Interview-mind-map">点这里</a></p>
<p>附带：高频面试题积累文档。 来自于（学长、牛客网等平台）</p>
<p>自己开发的博客地址：<a target="_blank" rel="noopener" href="http://zxinc520.com/">zxinc520.com</a></p>
<p>github 地址: <a target="_blank" rel="noopener" href="https://github.com/ZhChen7">点击</a></p>
</blockquote>
<blockquote>
<p>此篇 js - 【单线程和异步】 知识点： 全部弄懂了，面试很容易。</p>
</blockquote>
<h2 id="一、单线程和异步"><a href="#一、单线程和异步" class="headerlink" title="一、单线程和异步"></a>一、单线程和异步</h2><h3 id="1-1、同步-vs-异步"><a href="#1-1、同步-vs-异步" class="headerlink" title="1.1、同步 vs 异步"></a>1.1、同步 vs 异步</h3><ul>
<li>同步是什么？<ul>
<li>简单来说：一定要等任务执行完了，得到结果，才执行下一个任务。</li>
<li>指某段程序执行时会阻塞其它程序执行，其表现形式为程序的执行顺序依赖程序本身的书写顺序</li>
</ul>
</li>
<li>异步是什么？<ul>
<li>指某段程序执行时不会阻塞其它程序执行，其表现形式为程序的执行顺序不依赖程序本身的书写顺序</li>
<li>实现方式：event loop【事件轮询】</li>
</ul>
</li>
</ul>
<h3 id="1-2、异步和单线程"><a href="#1-2、异步和单线程" class="headerlink" title="1.2、异步和单线程"></a>1.2、异步和单线程</h3><ul>
<li><p>单线程</p>
<ul>
<li>是什么？单线程就是同时只做一件事，两段 JS 不能同时 执行</li>
<li>为什么是单线程？<ul>
<li>避免 DOM 渲染的冲突<ol>
<li>浏览器需要渲染 DOM</li>
<li>JS 可以修改 DOM 结构</li>
<li>JS 执行的时候，浏览器 DOM 渲染会暂停</li>
<li>两段 JS 也不能同时执行（都修改 DOM 就冲突了）</li>
<li>webworker 支持多线程，但是不能访问 DOM</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>单线程的解决方案 ？</p>
<ul>
<li>异步<ul>
<li>异步暴露出的问题<ol>
<li>没按照书写方式执行，可读性差</li>
<li>callback 中不容易模块化</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>event loop</p>
<ul>
<li>是什么？</li>
<li>事件轮询， JS 实现异步 的具体解决方案</li>
<li>具体<ul>
<li>同步代码，直接执行</li>
<li>异步函数先放在 异步队列 中</li>
<li>待同步函数执行完毕，轮询执行 异步队列 的函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-3、宏队列和微队列"><a href="#1-3、宏队列和微队列" class="headerlink" title="1.3、宏队列和微队列"></a>1.3、宏队列和微队列</h3><blockquote>
<p><code>macrotask</code>（宏任务） 和 <code>microtask</code>（微任务）</p>
<p>面试常考题【promise 回调函数和定时器任务的顺序问题】</p>
</blockquote>
<ul>
<li><p>宏任务：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">script(整体代码)</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line"><span class="built_in">setInterval</span></span><br><span class="line">I/O</span><br><span class="line">UI交互事件</span><br><span class="line">postMessage</span><br><span class="line">MessageChannel</span><br><span class="line">setImmediate(Node.js 环境)</span><br></pre></td></tr></table></figure>
</li>
<li><p>微任务</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.then</span><br><span class="line"><span class="built_in">Object</span>.observe</span><br><span class="line">MutaionObserver</span><br><span class="line">process.nextTick(Node.js 环境)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>执行机制：</p>
<ol>
<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>
<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>
<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>
<li>当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染</li>
<li>渲染完毕后，JS 引擎线程继续，开始下一个宏任务（从宏任务队列中获取）</li>
</ol>
<h4 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1 end&quot;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;settimeout&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"><span class="comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4、前端异步的场景"><a href="#1-4、前端异步的场景" class="headerlink" title="1.4、前端异步的场景"></a>1.4、前端异步的场景</h3><ul>
<li>简单来说：所有的 “ 等待情况” 都需要异步</li>
<li>定时任务：setTimeout，setInterval</li>
<li>网络请求：ajax 请求，动态 &lt;_img_ &gt; 加载</li>
<li>事件绑定</li>
</ul>
<h3 id="1-5、Web-Worker"><a href="#1-5、Web-Worker" class="headerlink" title="1.5、Web Worker"></a>1.5、Web Worker</h3><blockquote>
<p>就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p>
</blockquote>
<h3 id="1-6、模块化发展历程"><a href="#1-6、模块化发展历程" class="headerlink" title="1.6、模块化发展历程"></a>1.6、模块化发展历程</h3><blockquote>
<p>可从 IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module、&lt;_script type=”module”_ &gt; 这几个角度考虑。</p>
<p><strong>作用</strong> ：模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。</p>
</blockquote>
<ol>
<li><p>IIFE</p>
<ul>
<li><p>使用自执行函数来编写模块化</p>
</li>
<li><p>特点：</p>
<p>在一个单独的函数作用域中执行代码，避免变量冲突。</p>
</li>
</ul>
</li>
<li><p>AMD</p>
<ul>
<li><p>使用 requireJS 来编写模块化</p>
</li>
<li><p>特点：依赖必须提前声明好</p>
</li>
<li><p>简单实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">&quot;./index.js&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// code 就是index.js 返回的内容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>CMD</p>
<ul>
<li><p>使用 seaJS 来编写模块化</p>
</li>
<li><p>特点：支持动态引入依赖文件</p>
</li>
<li><p>简单实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> indexCode = <span class="built_in">require</span>(<span class="string">&quot;./index.js&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>CommonJS</p>
<ul>
<li>nodejs 中自带的模块化</li>
<li>var fs = require(‘fs’);</li>
</ul>
</li>
<li><p>UMD</p>
<ul>
<li>兼容 AMD，CommonJS 模块化语法</li>
</ul>
</li>
<li><p>webpack(require.ensure)</p>
<ul>
<li>webpack 2.x 版本中的代码分割</li>
</ul>
</li>
<li><p>ES Modules</p>
<ul>
<li>ES6 引入的模块化，支持 import 来引入另一个 js</li>
<li>import a from ‘a’;</li>
</ul>
</li>
</ol>
<h4 id="1-6-1、AMD-与-CMD-的比较"><a href="#1-6-1、AMD-与-CMD-的比较" class="headerlink" title="1.6.1、AMD 与 CMD 的比较"></a>1.6.1、AMD 与 CMD 的比较</h4><ul>
<li><p>定义</p>
<p>AMD 和 CMD 都是用于浏览器端的模块规范</p>
</li>
<li><p>AMD</p>
<ul>
<li>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出</li>
<li>其主要内容就是定义了 define 函数该如何书写，只要你按照这个规范书写模块和依赖，require.js 就能正确的进行解析。</li>
</ul>
</li>
<li><p>CMD</p>
<ul>
<li>CMD 其实就是 SeaJS 在推广过程中对模块定义的规范化产出</li>
<li>主要内容就是描述该如何定义模块，如何引入模块，如何导出模块，只要你按照这个规范书写代码，sea.js 就能正确的进行解析</li>
</ul>
</li>
<li><p>AMD 与 CMD 的区别</p>
<ol>
<li>AMD 推崇依赖前置，CMD 推崇依赖就近</li>
<li>AMD 是提前执行，CMD 是延迟执行。</li>
</ol>
</li>
</ul>
<h4 id="1-6-2、CommonJS-与-AMD-的比较"><a href="#1-6-2、CommonJS-与-AMD-的比较" class="headerlink" title="1.6.2、CommonJS 与 AMD 的比较"></a>1.6.2、CommonJS 与 AMD 的比较</h4><blockquote>
<p>在服务器端比如 node，采用的则是 CommonJS 规范。</p>
<p>AMD 和 CMD 都是用于浏览器端的模块规范</p>
</blockquote>
<ol>
<li><p>CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。</p>
</li>
<li><p>AMD 规范则是非同步加载模块，允许指定回调函数。</p>
<p>由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。</p>
</li>
<li><p>但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。</p>
</li>
</ol>
<h4 id="16-3、ES6-与-CommonJS-的比较"><a href="#16-3、ES6-与-CommonJS-的比较" class="headerlink" title="16.3、ES6 与 CommonJS 的比较"></a>16.3、ES6 与 CommonJS 的比较</h4><blockquote>
<p>注意！浏览器加载 ES6 模块，也使用 &lt;_script_ &gt; 标签，但是要加入 type=”module” 属性。</p>
</blockquote>
<ol>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</li>
</ol>
<h3 id="1-7、async-和-defer"><a href="#1-7、async-和-defer" class="headerlink" title="1.7、async 和 defer"></a>1.7、async 和 defer</h3><ul>
<li><p>共同点</p>
<p>两者都会并行下载，不会影响页面的解析。</p>
</li>
<li><p>defer：defer 会按照顺序在 DOMContentLoaded 前按照页面出现顺序依次执行。</p>
</li>
<li><p>async ：async 则是下载完立即执行</p>
</li>
<li><p>具体解析【剖析】</p>
<ul>
<li><p>先来看一个普通的 script 标签。&lt;_script src=”a.js”&gt;</script_ ></p>
<ul>
<li><p>浏览器会做如下处理：</p>
<p>1、停止解析 document.</p>
<p>2、请求 a.js</p>
<p>3、执行 a.js 中的脚本</p>
<p>4、继续解析 document</p>
</li>
</ul>
</li>
<li><pre><code class="js">&lt;script src=&quot;d.js&quot; defer&gt;&lt;/script&gt;
&lt;script src=&quot;e.js&quot; defer&gt;&lt;/script&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  不阻止解析 document， 并行下载 d.js, e.js</span><br><span class="line"></span><br><span class="line">  即使下载完 d.js, e.js 仍继续解析 document</span><br><span class="line"></span><br><span class="line">  按照页面中出现的顺序，在其他同步脚本执行后，DOMContentLoaded 事件前 依次执行 d.js, e.js。</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;js</span><br><span class="line">  &lt;script src&#x3D;&quot;b.js&quot; async&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;c.js&quot; async&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

不阻止解析 document, 并行下载 b.js, c.js

当脚本下载完后立即执行。（两者执行顺序不确定，执行阶段不确定，可能在 DOMContentLoaded 事件前或者后 ）
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="async-和-defer-总结"><a href="#async-和-defer-总结" class="headerlink" title="async 和 defer 总结"></a>async 和 defer 总结</h4><ul>
<li><p>两者都不会阻止 document 的解析</p>
</li>
<li><p>defer 会在 DOMContentLoaded 前依次执行 （可以利用这两点哦！）</p>
</li>
<li><p>async 则是下载完立即执行，不一定是在 DOMContentLoaded 前</p>
</li>
<li><p>async 因为顺序无关，所以很适合像 Google Analytics 这样的无依赖脚本</p>
</li>
</ul>
<h3 id="1-8、异步编程-6-种解决方案"><a href="#1-8、异步编程-6-种解决方案" class="headerlink" title="1.8、异步编程 6 种解决方案"></a>1.8、异步编程 6 种解决方案</h3><ol>
<li><p>回调函数（Callback）</p>
<ul>
<li><p>回调函数是异步操作最基本的方法</p>
</li>
<li><p>ajax(url, () =&gt; {</p>
<p>​ // 处理逻辑</p>
<p>})</p>
</li>
<li><p>缺点</p>
<ul>
<li>容易写出回调地狱（Callback hell）</li>
<li>不能使用 try catch 捕获错误，不能直接 return</li>
</ul>
</li>
</ul>
</li>
<li><p>事件监听</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.on(<span class="string">&quot;done&quot;</span>, f2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布订阅</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.subscribe(<span class="string">&quot;done&quot;</span>, f2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise</p>
<ul>
<li><p>是什么？</p>
<ul>
<li>promise 是目前 JS 异步编程的主流解决方案，遵循 Promises/A+ 方案。Promise 用于异步操作，表示一个还未完成但是预期会完成的操作。</li>
<li>Promise 是 ES6 引入的一个新的对象，他的主要作用是用来解决 JS 异步机制里，回调机制产生的“回调地狱”。它并不是什么突破性的 API，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用。</li>
</ul>
</li>
<li><p>剖析</p>
<ul>
<li><p>promise 本身相当于一个状态机，拥有三种状态</p>
<ul>
<li>pending</li>
<li>fulfilled</li>
<li>rejected</li>
</ul>
<p>一个 promise 对象初始化时的状态是 pending，调用了 resolve 后会将 promise 的状态扭转为 fulfilled，调用 reject 后会将 promise 的状态扭转为 rejected，这两种扭转一旦发生便不能再扭转该 promise 到其他状态。</p>
</li>
</ul>
</li>
<li><p>Promise 如何使用</p>
<p>构造一个 promise 对象，并将要执行的异步函数传入到 promise 的参数中执行，并且在异步执行结束后调用 resolve( ) 函数，就可以在 promise 的 then 方法中获取到异步函数的执行结果</p>
</li>
<li><p>Promise 原型上的方法</p>
<ol>
<li>Promise.prototype.then(onFulfilled, onRejected)</li>
<li>Promise.prototype.catch(onRejected)</li>
<li>Promise.prototype.finally(onFinally)</li>
</ol>
</li>
<li><p>Promise 静态方法</p>
<ol>
<li><p>Promise.all()</p>
<p>Promise.all 接收一个 promise 对象数组作为参数，只有全部的 promise 都已经变为 fulfilled 状态后才会继续后面的处理</p>
</li>
<li><p>Promise.race()</p>
<p>这个函数会在 promises 中第一个 promise 的状态扭转后就开始后面的处理（fulfilled、rejected 均可）</p>
</li>
<li><p>Promise.resolve()</p>
</li>
<li><p>Promise.reject()</p>
</li>
</ol>
</li>
<li><p>优点</p>
<p>将异步操作以同步操作的流程表达出来，promise 链式调用，更好地解决了层层嵌套的回调地狱</p>
</li>
<li><p>缺点</p>
<ol>
<li>不能取消执行。</li>
<li>无法获取当前执行的进度信息（比如，要在用户界面展示进度条）。</li>
<li>外部无法捕捉 Promise 内部抛出的错误</li>
</ol>
</li>
</ul>
</li>
<li><p>generator 函数</p>
<ul>
<li><p>是什么</p>
<ul>
<li>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</li>
<li>如果说 JavaScript 是 ECMAScript 标准的一种具体实现、Iterator 遍历器是 Iterator 的具体实现，那么 Generator 函数可以说是 Iterator 接口的具体实现方式。</li>
<li>Generator 函数可以通过配合 Thunk 函数更轻松更优雅的实现异步编程和控制流管理</li>
</ul>
</li>
<li><p>描述</p>
<ul>
<li>执行 Generator 函数会返回一个遍历器对象，每一次 Generator 函数里面的 yield 都相当一次遍历器对象的 next()方法，并且可以通过 next(value)方法传入自定义的 value,来改变 Generator 函数的行为。</li>
</ul>
</li>
<li><p>能封装异步任务的根本原因</p>
<ul>
<li>最大特点就是可以交出函数的执行权（即暂停执行）。Generator 函数可以暂停执行和恢复执行</li>
</ul>
</li>
<li><p>两个特征</p>
<ul>
<li>function 关键字与函数名之间有一个星号</li>
<li>函数体内部使用 yield 表达式，定义不同的内部状态（yield 在英语里的意思就是“产出”）。</li>
</ul>
</li>
<li><p>过程</p>
<p>Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）</p>
</li>
<li><p>Generator 及其异步方面的应用</p>
<ul>
<li>Generator 函数将 JavaScript 异步编程带入了一个全新的阶段</li>
</ul>
</li>
<li><p>总结</p>
<p>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值；done 属性是一个布尔值，表示是否遍历结束。</p>
</li>
<li><p>demo</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&quot;node-fetch&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">&quot;https://api.github.com/users/github&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>async 和 await</p>
<ul>
<li><p>含义</p>
<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>
</li>
<li><p>是什么？</p>
<ul>
<li>一句话，它就是 Generator 函数的语法糖。</li>
<li>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。</li>
<li>async 函数可以理解为内置自动执行器的 Generator 函数语法糖，它配合 ES6 的 Promise 近乎完美的实现了异步编程解决方案。</li>
</ul>
</li>
<li><p>相对于 Promise，优势体现在</p>
<ol>
<li>处理 then 的调用链，能够更清晰准确的写出代码</li>
<li>并且也能优雅地解决回调地狱问题</li>
</ol>
</li>
<li><p>相对 Generator 函数，体现在以下 4 点</p>
<ol>
<li>内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行</li>
<li>更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果</li>
<li>更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）</li>
<li>返回值是 Promise。async 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用 then 方法指定下一步的操作。</li>
</ol>
</li>
<li><p>缺点</p>
<p>当然 async/await 函数也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise.all 的方式。</p>
</li>
</ul>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>JS 异步编程进化史：callback -&gt; promise -&gt; generator -&gt; async + await</li>
<li>async/await 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里</li>
<li>async/await 可以说是异步终极解决方案了</li>
</ol>
<h2 id="二、相关面试问题"><a href="#二、相关面试问题" class="headerlink" title="二、相关面试问题"></a>二、相关面试问题</h2><ol>
<li><p>什么是单线程，和异步有什么关系？</p>
<ul>
<li>单线程就是同时只做一件事，两段 JS 不能同时 执行</li>
<li>原因就是 为了避免 DOM 渲染的冲突</li>
<li>异步是一种 “无奈” 的解决方案，虽然有很多问题</li>
</ul>
</li>
<li><p>是否用过 jQuery 的 Deferred</p>
<ul>
<li><p>步骤</p>
<p>可以 jQuery 1.5 对 ajax 的改变举例</p>
<p>说明如何简单的封装，使用 Deferred</p>
<p>说明 ES6 promise 和 Deferred 的区别</p>
</li>
<li><p>jQuery 1.5 的变化</p>
<ul>
<li><p>无法改变 JS 异步和单线程的本质</p>
</li>
<li><p>只能从写法上杜绝 callback 这种形式</p>
</li>
<li><p>它是一种语法糖形式，但是解耦了代码</p>
</li>
<li><p>很好的体现：开放封闭原则</p>
</li>
<li><p>ajax 为例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = $.ajax(<span class="string">&quot;data.json&quot;</span>);</span><br><span class="line">ajax</span><br><span class="line">  .done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success 1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .fail(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success 2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ajax); <span class="comment">//返回一个 deferred 对象</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使用 jQuery Deferred</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitHandle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dtd = $.Deferred(); <span class="comment">//创建一个 Deferred 对象</span></span><br><span class="line">  <span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span> (<span class="params">dtd</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//要求传入一个 Deferred 对象</span></span><br><span class="line">    <span class="keyword">var</span> task = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;执行完成&quot;</span>);</span><br><span class="line">      dtd.resolve(); <span class="comment">//表示异步任务已经完成</span></span><br><span class="line">      <span class="comment">// dtd.reject()  //表示异步任务失败或出错</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">setTimeout</span>(task, <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> dtd; <span class="comment">// 要求返回 Deferred 对象</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 注意，这里一定要有返回值</span></span><br><span class="line">  <span class="keyword">return</span> wait(dtd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS-%E4%B8%89%E5%BA%A7%E5%A4%A7%E5%B1%B1/" rel="tag">JS 三座大山</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/" rel="tag">面试全面总结</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-getOfferhtml2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/23/getOfferhtml2/"
    >html 面试考点全面总结下篇</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/03/23/getOfferhtml2/" class="article-date">
  <time datetime="2020-03-23T09:18:21.000Z" itemprop="datePublished">2020-03-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Offer/">Offer</a> / <a class="article-category-link" href="/categories/Offer/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/">字节跳动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="html-面试考点全面总结下篇"><a href="#html-面试考点全面总结下篇" class="headerlink" title="html 面试考点全面总结下篇"></a>html 面试考点全面总结下篇</h2><blockquote>
<p>拿到 字节跳动实习生 offer 总结</p>
<p>回馈分享一波自己的知识点总结</p>
</blockquote>
<blockquote>
<p>希望读者依此构建自己的知识树（思维导图）</p>
<p>偷懒一下：可参考我自己总结思维导图 : <a target="_blank" rel="noopener" href="https://github.com/ZhChen7/Interview-mind-map">点这里</a></p>
<p>附带：高频面试题积累文档。 来自于（学长、牛客网等平台）</p>
<p>自己开发的博客地址：<a target="_blank" rel="noopener" href="http://zxinc520.com/">zxinc520.com</a></p>
<p>github 地址: <a target="_blank" rel="noopener" href="https://github.com/ZhChen7">点击</a></p>
</blockquote>
<blockquote>
<p>此篇 html 共总结 22 大知识点： 全部弄懂了，面试很容易。</p>
</blockquote>
<h3 id="11、label-标签"><a href="#11、label-标签" class="headerlink" title="11、label 标签"></a>11、label 标签</h3><blockquote>
<p>作用：用于定义表单控件的关系，点击时自动将焦点移至相关联的控件。</p>
</blockquote>
<h4 id="两个有用属性"><a href="#两个有用属性" class="headerlink" title="两个有用属性"></a>两个有用属性</h4><ul>
<li>for<ul>
<li>关联相关控件</li>
<li>通过控件 id 关联</li>
</ul>
</li>
<li>accessKey ：设置访问快捷键 例如：accesskey=”h”</li>
</ul>
<blockquote>
<p><strong>注意</strong> ：该标签不能为 a 和 button 标签的后代</p>
</blockquote>
<h3 id="12、link-与-import"><a href="#12、link-与-import" class="headerlink" title="12、link 与 @import"></a>12、link 与 @import</h3><blockquote>
<p>link ：建议使用</p>
<p>@import ：慎用 【会造成 “无样式内容闪烁”】</p>
</blockquote>
<h4 id="link-与-import-区别"><a href="#link-与-import-区别" class="headerlink" title="link 与 @import 区别"></a>link 与 @import 区别</h4><ol>
<li>从属和作用<ul>
<li>link 是 HTML 提供的标签<ul>
<li>可以加载 css</li>
<li>可以定义 rel 等属性（rel 属性规定当前文档与被链接文档之间的关系。） 【技巧：这里引申到 预加载知识：可以关注 Resource Hint 标准 — <strong>页面加载性能利器</strong>】</li>
</ul>
</li>
<li>@import 是 css 提供的语法<ul>
<li>只有导入样式表的作用</li>
</ul>
</li>
</ul>
</li>
<li>加载顺序<ul>
<li>link 在页面加载时 css 同时被加载</li>
<li>@import 引入的 css 需要等页面加载后再加载</li>
</ul>
</li>
<li>兼容性问题<ul>
<li>link 是 HTML 提供的语法，没有兼容性问题</li>
<li>@import 是 css2.1 提供的语法，ie5 以上才兼容</li>
</ul>
</li>
<li>DOM 可控性<ul>
<li>js 可以通过插入 link 标签来改变样式</li>
<li>js 不可以通过 @import 去引入新的 css 文件来改变样式</li>
</ul>
</li>
</ol>
<h3 id="13、target"><a href="#13、target" class="headerlink" title="13、target"></a>13、target</h3><blockquote>
<p>属性作用：指定所连接的页面在浏览器窗口中的打开方式</p>
</blockquote>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul>
<li>_self（默认值）：在当前窗口打开</li>
<li>_blank： 在新窗口中打开</li>
<li>_parent ： 在父级窗口打开</li>
<li>_top ： 在顶级窗口打开</li>
</ul>
<h3 id="14、部分标签-属性区别"><a href="#14、部分标签-属性区别" class="headerlink" title="14、部分标签/属性区别"></a>14、部分标签/属性区别</h3><h4 id="标签区别"><a href="#标签区别" class="headerlink" title="标签区别"></a>标签区别</h4><ul>
<li>title 和 h1<ul>
<li>title ：只表示是个标题</li>
<li>h1-h7<ul>
<li>表示层次明确的标题</li>
<li>对页面信息的抓取有帮助</li>
</ul>
</li>
</ul>
</li>
<li>b 与 strong<ul>
<li>b：展示为粗体</li>
<li>strong<ul>
<li>标明重点内容，有语气加强的含义 u</li>
<li>使用阅读设备时，会重读</li>
</ul>
</li>
</ul>
</li>
<li>i 与 em<ul>
<li>i：展示为斜体</li>
<li>em：表示强调的文本</li>
</ul>
</li>
</ul>
<h4 id="属性区别"><a href="#属性区别" class="headerlink" title="属性区别"></a>属性区别</h4><ul>
<li>src 与 href<ul>
<li>src：引入 ; 将指定资源应用到文档内.</li>
<li>href：引用 ; 建立与当前文档之间的链接.</li>
</ul>
</li>
<li>【img】title 和 alt<ul>
<li>title<ul>
<li>全局属性</li>
<li>提供关于元素的额外信息</li>
<li>鼠标移至显示</li>
</ul>
</li>
<li>alt<ul>
<li>用于图片无法加载时显示</li>
<li>web Quality（无障碍）易访问的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="15、Shadow-DOM（影子-DOM）"><a href="#15、Shadow-DOM（影子-DOM）" class="headerlink" title="15、Shadow DOM（影子 DOM）"></a>15、Shadow DOM（影子 DOM）</h3><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><blockquote>
<p>浏览器的一种能力 ：渲染时插入独立的 DOM 树</p>
</blockquote>
<h4 id="特点？"><a href="#特点？" class="headerlink" title="特点？"></a>特点？</h4><ul>
<li>与原始 DOM 完全隔离</li>
<li>具有自己的元素和样式</li>
</ul>
<h4 id="作用？"><a href="#作用？" class="headerlink" title="作用？"></a>作用？</h4><ul>
<li>封装需要隔离外部的文档细节/组件</li>
<li>防止开发人员随意修改样式</li>
</ul>
<h4 id="使用方式？"><a href="#使用方式？" class="headerlink" title="使用方式？"></a>使用方式？</h4><ul>
<li>Node1.attachShadow(Node2)</li>
<li>Node2.innerHTML = ….</li>
</ul>
<h3 id="16、浏览器的数据存储方式有哪些"><a href="#16、浏览器的数据存储方式有哪些" class="headerlink" title="16、浏览器的数据存储方式有哪些"></a>16、浏览器的数据存储方式有哪些</h3><blockquote>
<p>分为三类来讲：</p>
<p>cookie 、localStorage 和 sessionStorage 、userData。</p>
</blockquote>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><blockquote>
<p>h5 之前，存储主要用 cookies，缺点是在请求头上带着数据，导致流量增加。大小限制 4k</p>
</blockquote>
<h5 id="创建目的"><a href="#创建目的" class="headerlink" title="创建目的"></a>创建目的</h5><ul>
<li>为了保持 HTTP 的状态</li>
<li>为了识别用户信息而储存在本地上的数据</li>
</ul>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>可储存大小为 4k</li>
<li>储存个数有限制（各浏览器不同）</li>
<li>有效时间在设置的 cookie 过期时间之前一直有效</li>
</ol>
<h4 id="localStorage-和-sessionStorage"><a href="#localStorage-和-sessionStorage" class="headerlink" title="localStorage 和 sessionStorage"></a>localStorage 和 sessionStorage</h4><blockquote>
<p>创建目的：便于客户端储存数据</p>
</blockquote>
<h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h5><ul>
<li>都由 HTML5 Web Storage API 提供</li>
<li>在本地保存</li>
<li>可储存大小 5M 以上</li>
</ul>
<h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5><ul>
<li>有效时间不同<ul>
<li>localStorage（以键值对(Key-Value)的方式存储）<ul>
<li>储存持久数据</li>
<li>浏览器关闭后数据不丢失除非主动清除数据</li>
</ul>
</li>
<li>sessionStorage<ul>
<li>数据在当前浏览器关闭后自动删除</li>
</ul>
</li>
</ul>
</li>
<li>作用域不同<ul>
<li>localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。</li>
<li>sessionStorage 不在不同的浏览器页面中共享，即使是同一个页面</li>
</ul>
</li>
</ul>
<blockquote>
<p>安全性：需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的，因为它们保存在本地容易被篡改，使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。所以千万不要用它们存储你系统中的敏感数据。</p>
</blockquote>
<h4 id="userData"><a href="#userData" class="headerlink" title="userData"></a>userData</h4><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul>
<li>IE 专属 ：早期 IE 浏览器用来本地储存数据用的</li>
<li>以文件的形式保存在磁盘上 ：持久化储存方式</li>
<li>可以设置失效日期</li>
<li>可储存大小 1MB 左右</li>
</ul>
<blockquote>
<p>注意：使用 IE 条件注释来避免其它浏览器载入上述代码 &lt;_!–[if IE]&gt;&lt;[end If]–_ &gt;</p>
</blockquote>
<h3 id="17、如何实现标签页面的通信"><a href="#17、如何实现标签页面的通信" class="headerlink" title="17、如何实现标签页面的通信"></a>17、如何实现标签页面的通信</h3><ol>
<li><p>方法一 ：使用 localStorage</p>
<ul>
<li><p>使用 localStorage.setItem(key,value) 添加内容</p>
</li>
<li><p>使用 Storage 事件监听添加、修改、删除的动作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onstorage = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(e)&#125;</span><br><span class="line"><span class="comment">// 或者这样</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;storage&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(e)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>方法二：使用 cookie+setInterval</p>
<ul>
<li>将要传递的信息储存在 cookie 中</li>
<li>每隔一定时间读取 cookie 信息，获取要传递的信息</li>
<li><strong>具体描述</strong> ：1、在页面 A 设置一个使用 setInterval 定时器不断刷新，检查 Cookies 的值是否发生变化，如果变化就进行刷新的操作。 2、由于 Cookies 是在同域可读的，所以在页面 B 审核的时候改变 Cookies 的值，页面 A 自然是可以拿到的。这样做确实可以实现我想要的功能，但是这样的方法相当浪费资源。虽然在这个性能过盛的时代，浪费不浪费也感觉不出来，但是这种实现方案，确实不够优雅。</li>
</ul>
</li>
<li><p>方法三 ：websocket 通讯（HTML5）</p>
<ul>
<li>定义：WebSocket 是 HTML5 新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。</li>
<li>WebSocket 连接必须由浏览器发起，特点<ul>
<li>建立在 TCP 协议之上，服务器端的实现比较容易。</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
<li>数据格式比较轻量，性能开销小，通信高效。</li>
<li>可以发送文本，也可以发送二进制数据。</li>
<li>没有同源限制，客户端可以与任意服务器通信。</li>
<li>协议标识符是 ws（如果加密，则为 wss），服务器网址就是</li>
</ul>
</li>
</ul>
</li>
<li><p>SharedWorker（html5 浏览器的新特性 SharedWorker）</p>
<ul>
<li>本质还是单线程，只是利用了浏览器不同 JS 引擎</li>
<li>必须在服务器上才跑得动</li>
<li>IE 未兼容</li>
</ul>
</li>
</ol>
<h3 id="18、谈谈-cookie-和-session-的区别"><a href="#18、谈谈-cookie-和-session-的区别" class="headerlink" title="18、谈谈 cookie 和 session 的区别"></a>18、谈谈 cookie 和 session 的区别</h3><blockquote>
<p>共同点：记录用户状态</p>
</blockquote>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><h5 id="cookie-1"><a href="#cookie-1" class="headerlink" title="cookie"></a>cookie</h5><ul>
<li><p>什么是 Cookie？</p>
<p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
</li>
<li><p>采用的是在客户端保持状态的方案 ： 即运行在客户端</p>
</li>
<li><p>有大小限制，存储个数有限</p>
</li>
<li><p>有安全隐患 ：通过某些手法可以篡改本地储存的信息来欺骗客户端</p>
</li>
<li><p>支持跨域名访问</p>
</li>
</ul>
<h5 id="session"><a href="#session" class="headerlink" title="session"></a>session</h5><ul>
<li><p>什么是 Session？</p>
<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
</li>
<li><p>采用的是在服务端保持状态的方案： 即运行在服务端</p>
</li>
<li><p>没有大小限制和服务器内存大小有关</p>
</li>
<li><p>过多会增加服务器压力</p>
</li>
<li><p>仅在他所在的域名内有效</p>
</li>
</ul>
<h4 id="cookie-和-session-流程介绍"><a href="#cookie-和-session-流程介绍" class="headerlink" title="cookie 和 session 流程介绍"></a>cookie 和 session 流程介绍</h4><blockquote>
<p>1、用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>
<p>2、当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>
<p>3、根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p>
</blockquote>
<h4 id="18-1、既然服务端是根据-Cookie-中的信息判断用户是否登录，那么如果浏览器中禁止了-Cookie，如何保障整个机制的正常运转"><a href="#18-1、既然服务端是根据-Cookie-中的信息判断用户是否登录，那么如果浏览器中禁止了-Cookie，如何保障整个机制的正常运转" class="headerlink" title="18.1、既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转"></a>18.1、既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转</h4><ul>
<li><p>第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 xxx?SessionID=123456…。</p>
</li>
<li><p>第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。</p>
<p>Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。</p>
<p>当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。</p>
</li>
</ul>
<h4 id="18-2、如何考虑分布式-Session-问题？"><a href="#18-2、如何考虑分布式-Session-问题？" class="headerlink" title="18.2、如何考虑分布式 Session 问题？"></a>18.2、如何考虑分布式 Session 问题？</h4><ul>
<li>在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。</li>
<li>分布式 Session 一般会有以下几种解决方案<ul>
<li>Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</li>
<li>Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</li>
<li>共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。</li>
</ul>
</li>
</ul>
<h4 id="18-3、cookie-和-session-各自优势"><a href="#18-3、cookie-和-session-各自优势" class="headerlink" title="18.3、cookie 和 session 各自优势"></a>18.3、cookie 和 session 各自优势</h4><h5 id="cookie-2"><a href="#cookie-2" class="headerlink" title="cookie"></a>cookie</h5><ul>
<li>极高的扩展性和可用性</li>
<li>不需要使用大量服务器资源</li>
<li>简单性 Cookie 是一种基于文本的轻量结构，包含简单的键值对，结构简单。</li>
</ul>
<h5 id="session-1"><a href="#session-1" class="headerlink" title="session"></a>session</h5><ul>
<li>易于读写</li>
<li>易于站点的用户化</li>
</ul>
<h4 id="18-4：cookie-和-session-常见攻击方式及解决方案"><a href="#18-4：cookie-和-session-常见攻击方式及解决方案" class="headerlink" title="18.4：cookie 和 session 常见攻击方式及解决方案"></a>18.4：cookie 和 session 常见攻击方式及解决方案</h4><h5 id="cookie-3"><a href="#cookie-3" class="headerlink" title="cookie"></a>cookie</h5><ul>
<li>具体<ul>
<li>直接访问 Cookie 文件查找想要的机密文件</li>
<li>进行 Cookie 信息传递时被截取</li>
<li>攻击者伪造 Cookie 信息，客户端获取后进行操作</li>
</ul>
</li>
<li>解决方案<ul>
<li>不要早 Cookie 中保存敏感信息</li>
<li>不要早 Cookie 中保存没有经过加密的或者容易被解密的敏感信息</li>
<li>对从客户端获取得的 Cookie 信息进行严格校验</li>
</ul>
</li>
</ul>
<h5 id="session-2"><a href="#session-2" class="headerlink" title="session"></a>session</h5><ul>
<li>具体<ul>
<li>会话劫持（通过获取用户 Session ID 后，使用该 Session ID 登录目标账号）</li>
<li>会话固定（诱骗受害者使用攻击者指定的会话标识 Session ID 的攻击手段）</li>
</ul>
</li>
<li>解决方案<ul>
<li>使用 User-Agent 检测请求的一致性，设置 HttpOnly，可以防止客户端脚本访问这个 Cookie，从而有效的防止 XSS 攻击；关闭透明化 Session ID；更改 Session 名称</li>
<li>用户登录时生成新的 Session ID</li>
</ul>
</li>
</ul>
<h3 id="19、谈谈对-WebSocket-的认识"><a href="#19、谈谈对-WebSocket-的认识" class="headerlink" title="19、谈谈对 WebSocket 的认识"></a>19、谈谈对 WebSocket 的认识</h3><blockquote>
<p>创建原因：HTTP 协议只能由客户端发起 单向连接</p>
</blockquote>
<h4 id="19-1、是什么？"><a href="#19-1、是什么？" class="headerlink" title="19.1、是什么？"></a>19.1、是什么？</h4><ul>
<li>HTML5 中的协议，支持持久连接</li>
<li>WebSocket 是基于 HTTP 协议的 ： 借用了 Http 协议来完成一部分握手</li>
<li>是真正意义上的双向绑定</li>
</ul>
<h4 id="19-2、WebSocket-区别-http-协议"><a href="#19-2、WebSocket-区别-http-协议" class="headerlink" title="19.2、WebSocket 区别 http 协议"></a>19.2、WebSocket 区别 http 协议</h4><ul>
<li>http 协议 不支持持久性连接</li>
<li>HTTP1.1 中出现 keep-alive，合并多个 http 请求</li>
<li>HTTP 的生命周期通过 Request 来界定 ： 一个 Request 对应一个 Response</li>
<li>Response 是被动的，不能主动发起</li>
</ul>
<h4 id="19-3、如何模拟双向通信"><a href="#19-3、如何模拟双向通信" class="headerlink" title="19.3、如何模拟双向通信"></a>19.3、如何模拟双向通信</h4><ul>
<li>短轮询<ul>
<li>客户端定时向服务器发送 Ajax 请求，服务器接到请求后马上返回响应信息并关闭连接。</li>
<li>优点 ： 后端编写容易</li>
<li>缺点 ： 请求中大半是无用，浪费宽带和服务器资源</li>
<li>适用 ： 小型应用</li>
</ul>
</li>
<li>长轮询<ul>
<li>客户端向服务器发送 Ajax 请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。</li>
<li>优点 ：在无消息的情况下不会频繁的请求，耗费资源小</li>
<li>缺点<ul>
<li>服务器 hold 连接会消耗资源</li>
<li>返回数据顺序无保证，难于管理维护</li>
</ul>
</li>
</ul>
</li>
<li>长连接<ul>
<li>在页面嵌入一个隐藏 iframe，将这个隐藏 iframe 的 src 属性设为对一个长连接的请求或是采用 xhr 请求，服务器端就能源源不断的往客户端输入数据</li>
<li>优点<ul>
<li>消息及时到达，不发无用请求</li>
<li>管理起来也相对方便</li>
</ul>
</li>
<li>缺点：服务器维护一个长连接会增加开销</li>
</ul>
</li>
</ul>
<h3 id="20、渲染-了解网页渲染流程与优化技巧"><a href="#20、渲染-了解网页渲染流程与优化技巧" class="headerlink" title="20、渲染 | 了解网页渲染流程与优化技巧"></a>20、渲染 | 了解网页渲染流程与优化技巧</h3><h4 id="20-1、生成网页步骤"><a href="#20-1、生成网页步骤" class="headerlink" title="20.1、生成网页步骤"></a>20.1、生成网页步骤</h4><ul>
<li>HTML 代码转成 DOM（Document Object Model）： 解析 HTML 生成</li>
<li>CSS 代码转化成 CSSOM（CSS Object Model）： 解析 CSS 生成</li>
<li>结合 DOM 和 CSSOM 生成一颗渲染树： 包含每个节点的视觉信息</li>
<li>生成布局（layout）： 将所有渲染树的所有节点进行平面合成</li>
<li>将布局绘制（paint）在屏幕上</li>
</ul>
<h4 id="20-2、重新渲染-（重排【回流】和重绘）"><a href="#20-2、重新渲染-（重排【回流】和重绘）" class="headerlink" title="20.2、重新渲染 （重排【回流】和重绘）"></a>20.2、重新渲染 （重排【回流】和重绘）</h4><h5 id="重排（回流）"><a href="#重排（回流）" class="headerlink" title="重排（回流）"></a>重排（回流）</h5><blockquote>
<p>重新生成布局</p>
</blockquote>
<h5 id="布局改了就一定会重排"><a href="#布局改了就一定会重排" class="headerlink" title="布局改了就一定会重排"></a>布局改了就一定会重排</h5><ol>
<li>添加或删除可见的 DOM 元素</li>
<li>元素位置改变</li>
<li>元素尺寸改变——边距、填充、边框、宽度和高度</li>
<li>内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；</li>
<li>页面渲染器初始化</li>
<li>浏览器窗口尺寸改变——resize 事件发生时；</li>
</ol>
<blockquote>
<p>重排一定需要重绘</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = document.body.style;</span><br><span class="line">s.padding = &quot;2px&quot;; // 回流+重绘</span><br><span class="line">s.border = &quot;1px solid red&quot;; // 再一次 回流+重绘</span><br><span class="line">s.color = &quot;blue&quot;; // 重绘</span><br><span class="line">s.backgroundColor = &quot;#ccc&quot;; // 重绘</span><br><span class="line">s.fontSize = &quot;14px&quot;; // 再一次 回流+重绘</span><br><span class="line">document.body.appendChild(document.createTextNode(&#x27;abc!&#x27;));// 添加node，再一次 回流+重绘</span><br></pre></td></tr></table></figure>

<h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><blockquote>
<p>只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫称为重绘。</p>
</blockquote>
<h4 id="重新渲染出现情况"><a href="#重新渲染出现情况" class="headerlink" title="重新渲染出现情况"></a>重新渲染出现情况</h4><ul>
<li>修改 DOM</li>
<li>修改样式表</li>
<li>用户事件<ul>
<li>鼠标悬停</li>
<li>页面滚动</li>
<li>输入框输入文字</li>
<li>改变窗口等</li>
</ul>
</li>
</ul>
<h3 id="21、性能优化技巧"><a href="#21、性能优化技巧" class="headerlink" title="21、性能优化技巧"></a>21、性能优化技巧</h3><blockquote>
<p>回答性能优化问题时：分两层阐述：</p>
<p>1、底层：重排【回流】和重绘层级 — 下面针对此层</p>
<p>2、应用层（雅虎军规 35 条）— 在性能优化专题会仔细分析。</p>
</blockquote>
<h4 id="21-1、减少重新渲染频率"><a href="#21-1、减少重新渲染频率" class="headerlink" title="21.1、减少重新渲染频率"></a>21.1、减少重新渲染频率</h4><ol>
<li><p>DOM 的多个读/写操作应该放在一起。</p>
<ul>
<li>不要两个读操作之间，加入一个写操作</li>
</ul>
</li>
<li><p>如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候又要重排</p>
</li>
<li><p>不要一条条地改变样式</p>
<ul>
<li>通过改变 class，csstext，一次改变样式</li>
</ul>
</li>
<li><p>尽量使用离线 DOM，而不是真实的网页 DOM，来改变元素样式</p>
<ul>
<li><p>例如</p>
<ul>
<li><p>操作 Document Fragment 对象</p>
</li>
<li><p>cloneNode 克隆节点操作后替换</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用虚拟 DOM 的脚本库，比如 React，vue 等</p>
</li>
<li><p>很新颖（嘻嘻）</p>
</li>
</ol>
<ul>
<li>设为 dispaly：none（需要一次重排和重绘）后进行 n 次操作，最后再恢复显示（需要一次重排和重绘）</li>
<li>用两次重新渲染，取代了可能 n（可能是个大树）次的重新渲染</li>
<li>只有在必要的时候，才将元素的 display 属性为可见</li>
<li>visibility:hidden 的元素只对重绘有影响，不影响重排</li>
<li>隐藏后不可见的元素读写不影响重排和重绘</li>
</ul>
<ol start="7">
<li><p>使用调整重新渲染的方法 ： 可以大幅度提高网页性能</p>
<ul>
<li>使用 window.requestAnimationFrame()方法<ul>
<li>作用：将某些代码放到下一次重新渲染时执行</li>
<li>适用<ul>
<li>页面滚动事件的监听函数</li>
<li>网页动画</li>
</ul>
</li>
</ul>
</li>
<li>使用 window.requestdleCallback()方法<ul>
<li>暂时就 Chrome 支持</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="21-2、减少渲染成本"><a href="#21-2、减少渲染成本" class="headerlink" title="21.2、减少渲染成本"></a>21.2、减少渲染成本</h4><ul>
<li><p>position 属性为 absolute 或 fixed 的元素，重排的开销会比较小</p>
<p>因为它们脱离文档，不用考虑他们对其他元素的影响，所以用 absolute，而少用 float</p>
</li>
</ul>
<h3 id="22、HTML5-概括"><a href="#22、HTML5-概括" class="headerlink" title="22、HTML5 概括"></a>22、HTML5 概括</h3><blockquote>
<p>HTML（超文本标记语言 HyperText Markup Language）的最新本版本</p>
</blockquote>
<h4 id="新增特性"><a href="#新增特性" class="headerlink" title="新增特性"></a>新增特性</h4><ol>
<li><p>语义化元素 推荐使用</p>
</li>
<li><p>新的通讯方式</p>
<ul>
<li>WebSockets</li>
<li>重新绘制界面 布局没改，样式改了，需要重绘，不一定重排</li>
</ul>
</li>
<li><p>缓存</p>
<ul>
<li>应用程序缓存<ul>
<li>使用方式<ul>
<li>&lt;_html manifest=”demo.appcache”_ &gt;</li>
<li>manifest 文件的建议的文件扩展名是：”.appcache”</li>
</ul>
</li>
<li>优点<ul>
<li>离线浏览 - 用户可在应用离线时使用它们</li>
<li>更快速度 - 已缓存资源加载得更快</li>
<li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li>
</ul>
</li>
</ul>
</li>
<li>浏览器缓存<ul>
<li>Web Storage<ul>
<li>localStorage</li>
<li>sessionStorage</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>多媒体</p>
<ul>
<li>audio</li>
<li>video</li>
</ul>
</li>
<li><p>3D &amp; 图像</p>
<ul>
<li>canvas</li>
<li>WebGL：用 canvas 元素中的 API 实现 3D 图像功能</li>
<li>svg ：基于 XML 直接嵌入到 HTML 中的矢量图形格式</li>
</ul>
</li>
<li><p>性能 &amp; 集成</p>
<ul>
<li><p>Web workers</p>
<p>Web Worker 是为了解决 JavaScript 在浏览器环境中没有多线程的问题。正常形况下，浏览器执行某段程序的时候会阻塞直到运行结束后在恢复到正常状态，而 HTML5 的 Web Worker 就是为了解决这个问题，提升程序的执行效率。 所以 Web Worker 的最佳使用场景是执行一些开销较大的数据处理或计算任务。</p>
</li>
<li><p>web worker 的创建</p>
<ul>
<li>worker 是一个对象，通过构造函数 Worker 创建，参数就是一个 js 文件的路径；文件中的 js 代码将运行在主线程之外的 worker 线程；</li>
<li>例如：var myWorker = new Worker(‘worker.js’);</li>
</ul>
</li>
<li><p>History API ：允许对浏览器历史记录进行操作</p>
</li>
<li><p>XMLHttpRequest Level 2(（XHR）对象可以与服务器交互。)</p>
<p>新版本功能：</p>
<ul>
<li>可以设置 HTTP 请求的时限</li>
<li>可以使用 FormData 对象管理表单数据。</li>
<li>可以上传文件。</li>
<li>可以请求不同域名下的数据（跨域请求）</li>
<li>可以获取服务器端的二进制数据</li>
<li>可以获得数据传输的进度信息</li>
</ul>
<p>老版本的缺点：</p>
<ul>
<li>只支持文本数据的传送，无法用来读取和上传二进制文件。</li>
<li>传送和接收数据时，没有进度信息，只能提示有没有完成。</li>
<li>受到”同域限制”（Same Origin Policy），只能向同一域名的服务器请求数据。</li>
</ul>
</li>
<li><p>contentEditable</p>
<ul>
<li>让元素的区域可编辑</li>
<li>已标准化</li>
</ul>
</li>
<li><p>requestAnimationFrame ： 允许控制动画渲染以获得更优性能</p>
</li>
<li><p>拖放 API draggable 属性、拖放事件(dragstart、drag、dragenter、dragleave、dragover、drap、dragend)、dataTransfer 对象</p>
</li>
<li><p>全屏 API</p>
</li>
<li><p>在线和离线事件</p>
</li>
</ul>
</li>
<li><p>设备访问</p>
<ul>
<li>carnera ：能够操作计算机的摄像头</li>
<li>地理位置定位 Geolocation</li>
<li>触控事件</li>
<li>检测设备方向 ：横向还是竖向</li>
</ul>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/" rel="tag">面试全面总结</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-getOfferhtml1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/23/getOfferhtml1/"
    >html 面试考点全面总结上篇</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/03/23/getOfferhtml1/" class="article-date">
  <time datetime="2020-03-23T09:14:53.000Z" itemprop="datePublished">2020-03-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Offer/">Offer</a> / <a class="article-category-link" href="/categories/Offer/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/">字节跳动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="html-面试考点全面总结上篇"><a href="#html-面试考点全面总结上篇" class="headerlink" title="html 面试考点全面总结上篇"></a>html 面试考点全面总结上篇</h2><blockquote>
<p>拿到 字节跳动实习生 offer 总结</p>
<p>回馈分享一波自己的知识点总结</p>
</blockquote>
<blockquote>
<p>希望读者依此构建自己的知识树（思维导图）</p>
<p>偷懒一下：可参考我自己总结思维导图 : <a target="_blank" rel="noopener" href="https://github.com/ZhChen7/Interview-mind-map">点这里</a></p>
<p>附带：高频面试题积累文档。 来自于（学长、牛客网等平台）</p>
<p>自己开发的博客地址：<a target="_blank" rel="noopener" href="http://zxinc520.com/">zxinc520.com</a></p>
<p>github 地址: <a target="_blank" rel="noopener" href="https://github.com/ZhChen7">点击</a></p>
</blockquote>
<blockquote>
<p>此篇 html 共总结 22 大知识点： 全部弄懂了，面试很容易。</p>
</blockquote>
<h3 id="1、浏览器页面由哪三层构成"><a href="#1、浏览器页面由哪三层构成" class="headerlink" title="1、浏览器页面由哪三层构成"></a>1、浏览器页面由哪三层构成</h3><ul>
<li>结构层<ul>
<li>HTML</li>
<li>构建文件结构</li>
</ul>
</li>
<li>表示层<ul>
<li>css</li>
<li>设置文档呈现效果</li>
</ul>
</li>
<li>行为层<ul>
<li>JS 和 DOM 脚本</li>
<li>实现文档的行为</li>
</ul>
</li>
</ul>
<h3 id="2、语义化-谈谈-html5-语义化"><a href="#2、语义化-谈谈-html5-语义化" class="headerlink" title="2、语义化 | 谈谈 html5 语义化"></a>2、语义化 | 谈谈 html5 语义化</h3><h4 id="2-1、什么是语义化？"><a href="#2-1、什么是语义化？" class="headerlink" title="2.1、什么是语义化？"></a>2.1、什么是语义化？</h4><p>HTML5 的语义化指的是合理使用语义化的标签来创建页面结构，如 header,footer,nav，从标签上即可以直观的知道这个标签的作用，而不是滥用 div。</p>
<h4 id="2-2、语义化的优点有"><a href="#2-2、语义化的优点有" class="headerlink" title="2.2、语义化的优点有"></a>2.2、语义化的优点有</h4><ol>
<li>代码结构清晰，易于阅读，利于开发和维护</li>
<li>提高用户体验，在样式加载失败时，页面结构清晰</li>
<li>方便其他设备解析（如屏幕阅读器）根据语义渲染网页。</li>
<li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</li>
</ol>
<h4 id="2-3、常用语义化标签有哪些"><a href="#2-3、常用语义化标签有哪些" class="headerlink" title="2.3、常用语义化标签有哪些"></a>2.3、常用语义化标签有哪些</h4><blockquote>
<p>article | aside | nav | section | header | footer</p>
</blockquote>
<h3 id="3、HTML5-元素分类"><a href="#3、HTML5-元素分类" class="headerlink" title="3、HTML5 元素分类"></a>3、HTML5 元素分类</h3><ol>
<li>结构性元素<ul>
<li>section：在 web 页面应用中，该元素也可以用于区域章节表述；</li>
<li>header：页面主题上的头部，注意区别于 head 元素；</li>
<li>footer：页面的底部（页脚）；</li>
<li>nav：是专门用于菜单导航、链接导航的元素，是 navigator 的缩写；</li>
<li>article：用于表示一篇文章的主题部分，一般为文字集中显示的区域；</li>
</ul>
</li>
<li>级块性元素<ul>
<li>aside：用以表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容；</li>
<li>figure：是对多个元素进行组合并展示的元素，通常与 figcaption 联合使用；</li>
<li>code：表示一段代码块；</li>
<li>dialog：用于表达人与人之间的对话，该元素还包括 dt 和 dd 这两个组合元素，他们常常同时使用。dt 用于表示说话者，而 dd 用来表示说话者的内容。</li>
</ul>
</li>
<li>行内语义性元素<ul>
<li>meter：表示特定范围内的数值，可用于工资、数量、百分比等；</li>
<li>time：表示时间值；</li>
<li>progress：用来表示进度条，可通过对其 max、min、step 等属性进行控制，完成对进度的表示和监视；</li>
<li>video：视频元素，用于支持和实现视频（含视频流）文件的直接播放，支持缓冲预载和多种视频媒体格式；</li>
<li>audio：音频元素，用于支持和实现音频（音频流）文件的直接播放，支持缓冲预载和多种音频媒体格式；</li>
</ul>
</li>
<li>交互性元素<ul>
<li>details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来；</li>
<li>datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新；</li>
<li>menu：主要用于交互菜单；</li>
<li>command：用来处理命令按钮。</li>
</ul>
</li>
</ol>
<h3 id="4、常见空元素"><a href="#4、常见空元素" class="headerlink" title="4、常见空元素"></a>4、常见空元素</h3><p><strong>含义</strong> ：没有元素内容标记的内容【也称自闭合元素】</p>
<p>常用的空元素：</p>
<meta> <br> <hr> <input> <img> <link>

<h3 id="5、表单增强-新增的-input-类型及属性"><a href="#5、表单增强-新增的-input-类型及属性" class="headerlink" title="5、表单增强 | 新增的 input 类型及属性"></a>5、表单增强 | 新增的 input 类型及属性</h3><h4 id="5-1、新类型"><a href="#5-1、新类型" class="headerlink" title="5.1、新类型"></a>5.1、新类型</h4><ul>
<li>color ：用于指定颜色的控件</li>
<li>number：用于输入浮点数的控件</li>
<li>tel：用于输入电话号码的控件；换行会被自动从输入的值中移除 A，但不会执行其他语法。可以使用属性，比如 pattern 和 maxlength 来约束控件输入的值。恰当的时候，可以应用 :valid 和 :invalid CSS 伪类。</li>
<li>email：用于编辑 e-mail 的字段。 合适的时候可以使用 :valid 和 :invalid CSS 伪类。</li>
<li>url ：用于编辑 URL 的字段</li>
<li>range ：用于输入不精确值控件</li>
<li>search ：用于输入搜索字符串的单行文本字段。换行会被从输入的值中自动移除。</li>
<li>与时间相关<ul>
<li>date ： 用于输入日期的控件（年，月，日，不包括时间）</li>
<li>time ： 用于输入不含时区的时间控件</li>
<li>datatime 【已弃用】 ： 用于输入日期和时间的控件（小时，分钟， 秒，基于 UTC 时区的一小部分。 此功能已从 WHATWG HTML 中删除。</li>
<li>datetime-local ： 用于输入日期时间控件，不包含时区</li>
<li>month ： 用于输入年月的控件，不带时区</li>
<li>week ： 用于输入一个由星期-年组成的日期，日期不包括时</li>
</ul>
</li>
</ul>
<h4 id="5-2、新属性"><a href="#5-2、新属性" class="headerlink" title="5.2、新属性"></a>5.2、新属性</h4><ul>
<li><p>placeholder</p>
</li>
<li><p>required 必填项</p>
</li>
<li><p>list 属性规定输入域的 datalist。datalist 是输入域的选项列表</p>
</li>
<li><p>pattern 定义正则</p>
</li>
<li><p>autofocus 属性规定在页面加载时，域自动地获得焦点。</p>
</li>
<li><p>readonly 该字段只读，不能修改</p>
</li>
<li><p>autocomplete 属性规定 form 或 input 域应该拥有自动完成功能。</p>
</li>
<li><p>min/max / step</p>
<ul>
<li><p>min、max 和 step 属性用于为包含数字或日期的 input 类型规定限定（约束）。</p>
<p>max 属性规定输入域所允许的最大值。</p>
<p>min 属性规定输入域所允许的最小值。</p>
<p>step 属性为输入域规定合法的数字间隔（如果 step=”3”，则合法的数是 -3,0,3,6 等）。</p>
</li>
</ul>
</li>
</ul>
<h3 id="6、认识-SVG"><a href="#6、认识-SVG" class="headerlink" title="6、认识 SVG"></a>6、认识 SVG</h3><p><strong>含义</strong> ：可缩放矢量图形（Scalable Vector Graphics，SVG），是一种用于描述基于二维的矢量图形的，基于 XML 的标记语言。</p>
<p><strong>关键词</strong>：【基于 XML】【矢量】 【图像格式】</p>
<p><strong>特点</strong>：</p>
<ul>
<li>矢量<ul>
<li>可以任意缩放</li>
<li>不会破坏图像的清晰度和细节</li>
<li>边缘清晰，适用任何分辨率</li>
</ul>
</li>
<li>文本独立 文字独立于图像</li>
<li>文件小 下载快</li>
<li>颜色控制</li>
</ul>
<h4 id="6-1、SVG-与-HTML5-的-canvas-各有什么优点，哪个更有前途？"><a href="#6-1、SVG-与-HTML5-的-canvas-各有什么优点，哪个更有前途？" class="headerlink" title="6.1、SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途？"></a>6.1、SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途？</h4><blockquote>
<p>Canvas 是使用 JavaScript 程序绘图(动态生成)，SVG 是使用 XML 文档描述来绘图。<br>从这点来看：SVG 更适合用来做动态交互，而且 SVG 绘图很容易编辑，只需要增加或移除相应的元素就可以了。<br>同时 SVG 是基于矢量的，所有它能够很好的处理图形大小的改变。Canvas 是基于位图的图像，它不能够改变大小，只能缩放显示；所以说 Canvas 更适合用来实现类似于 Flash 能做的事情(当然现在 Canvas 与 Flash 相比还有一些不够完善的地方)。<br>关于最后一点二者谁更有前途：从上面我们可以知道二者是有不同用途的，作为一个开发者，你应该做的是理解应用程序的具体需求并选择正确的技术来实现它。</p>
</blockquote>
<h3 id="7、浏览器内核"><a href="#7、浏览器内核" class="headerlink" title="7、浏览器内核"></a>7、浏览器内核</h3><h4 id="7-1、认识内核"><a href="#7-1、认识内核" class="headerlink" title="7.1、认识内核"></a>7.1、认识内核</h4><ul>
<li>渲染引擎 ：渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息</li>
<li>JS 引擎<ul>
<li>解析和执行 JavaScript 来实现网页的动态效果</li>
<li>引擎越来越独立，内核就倾向于只指渲染引擎</li>
</ul>
</li>
</ul>
<h4 id="7-2、主流浏览器所用的内核"><a href="#7-2、主流浏览器所用的内核" class="headerlink" title="7.2、主流浏览器所用的内核"></a>7.2、主流浏览器所用的内核</h4><ul>
<li>IE 浏览器 Trident 内核</li>
<li>谷歌浏览器（chrome）<ul>
<li>Webkit（之前使用）</li>
<li>blink 内核</li>
</ul>
</li>
<li>Opera 浏览器<ul>
<li>blink 内核</li>
<li>Presto 内核（之前使用）<ul>
<li>渲染速度的优化达到了极致</li>
<li>牺牲了兼容性</li>
</ul>
</li>
</ul>
</li>
<li>火狐浏览器（Firefox）<ul>
<li>Gecko 内核 ： 代码完全公开，可开发程度很高</li>
</ul>
</li>
<li>Safari 浏览器 ：苹果公司 webkit 内核</li>
<li>国产浏览器<ul>
<li>双内核（一个负责兼容，一个负责速度）</li>
<li>常用<ul>
<li>Trident + webkit</li>
<li>Trident + blink</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8、WEB-标准以及-W3C"><a href="#8、WEB-标准以及-W3C" class="headerlink" title="8、WEB 标准以及 W3C"></a>8、WEB 标准以及 W3C</h3><h4 id="8-1、web-标准"><a href="#8-1、web-标准" class="headerlink" title="8.1、web 标准"></a>8.1、web 标准</h4><blockquote>
<p>分为结构、表现、行为</p>
</blockquote>
<h5 id="web-标准是什么？"><a href="#web-标准是什么？" class="headerlink" title="web 标准是什么？"></a>web 标准是什么？</h5><blockquote>
<p>一系列标准的集合：</p>
</blockquote>
<ul>
<li>结构化标准语言</li>
<li>表现标准语言</li>
<li>行为标准语言</li>
</ul>
<h5 id="web-标准诞生原因？"><a href="#web-标准诞生原因？" class="headerlink" title="web 标准诞生原因？"></a>web 标准诞生原因？</h5><blockquote>
<p>为了解决因浏览器版本不同、软硬件设备不同导致的需多版本开发的问题。</p>
</blockquote>
<h4 id="8-2、W3C"><a href="#8-2、W3C" class="headerlink" title="8.2、W3C"></a>8.2、W3C</h4><blockquote>
<p>W3C 对 web 标准提出规范化要求</p>
</blockquote>
<h5 id="一：结构要求："><a href="#一：结构要求：" class="headerlink" title="一：结构要求："></a>一：结构要求：</h5><ul>
<li>遵循的好处<ul>
<li>提升搜索引擎对页面的抓取效率</li>
<li>对 SEO 很有帮助</li>
</ul>
</li>
<li>具体<ul>
<li>标签字母要小写</li>
<li>标签要闭合</li>
<li>标签不允许随便嵌套</li>
</ul>
</li>
</ul>
<h5 id="二：表现与行为要求："><a href="#二：表现与行为要求：" class="headerlink" title="二：表现与行为要求："></a>二：表现与行为要求：</h5><ul>
<li>遵循的好处<ul>
<li>使用户浏览者更方便的阅读</li>
<li>使网页开发者之间更好的交流</li>
</ul>
</li>
<li>具体<ul>
<li>尽量使用外链 css 样式表和 js 脚本：提高页面渲染速度</li>
<li>页面尽量少用行间样式表 ： 使结构和表现分离</li>
<li>标签 id 和 class 等属性名要见文知义</li>
</ul>
</li>
</ul>
<h3 id="9、Doctype（DTD）"><a href="#9、Doctype（DTD）" class="headerlink" title="9、Doctype（DTD）"></a>9、Doctype（DTD）</h3><blockquote>
<p>作用 ： 声明文档的类型风格</p>
<p>告诉浏览器采用何种渲染模式解析页面</p>
</blockquote>
<h4 id="9-1、渲染模式"><a href="#9-1、渲染模式" class="headerlink" title="9.1、渲染模式"></a>9.1、渲染模式</h4><ul>
<li>怪异模式（兼容模式、混杂模式）<ul>
<li>服务于旧式规则</li>
<li>页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</li>
</ul>
</li>
<li>标准模式（严格模式）<ul>
<li>服务于标准规则</li>
<li>标准模式的排版 和 JS 运作模式都是以该浏览器支持的最高标准运行</li>
</ul>
</li>
<li>近似标准模式<ul>
<li>基本是标准模型</li>
<li>有一些是自己的调整</li>
</ul>
</li>
</ul>
<p><strong>意义</strong>：严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。</p>
<h4 id="9-2、标准模式和混杂模式的区别？"><a href="#9-2、标准模式和混杂模式的区别？" class="headerlink" title="9.2、标准模式和混杂模式的区别？"></a>9.2、标准模式和混杂模式的区别？</h4><ul>
<li><p><strong>盒模型的处理差异：</strong>标准 CSS 盒模型的宽度和高度等于内容区的高度和宽度，不包含内边距和边框，而 IE6 之前的浏览器实现的盒模型的宽高计算方式是包含内边距和边框的。因此，对于 IE，怪异模式和标准模式下的盒模型宽高计算方式是不一样的；</p>
</li>
<li><p><strong>行内元素的垂直对齐：</strong>很多早期的浏览器对齐图片至包含它们的盒子的下边框，虽然 CSS 的规范要求它们被对齐至盒内文本的基线。标准模式下，基于 Gecko 的浏览器将会对齐至基线，而在 quirks 模式下它们会对齐至底部。最直接的例子就是图片的显示。在标准模式下，图片并不是与父元素的下边框对齐的，如果仔细观察，你会发现图片与父元素下边框之间存在一点小空隙。那是因为标准模式下，图片是基线对齐的。而怪异模式下，则不存在这个问题。具体请看这篇文章 <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/">CSS 深入理解 vertical-align 和 line-height 的基友关系</a>。</p>
</li>
</ul>
<h4 id="9-3、标准模式和严格模式的区别？"><a href="#9-3、标准模式和严格模式的区别？" class="headerlink" title="9.3、标准模式和严格模式的区别？"></a>9.3、标准模式和严格模式的区别？</h4><p>严格模式主要有以下限制：</p>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用 with 语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀 0 表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量 delete prop，会报错，只能删除属性 delete global[prop]</li>
<li>eval 不会在它的外层作用域引入变量</li>
<li>eval 和 arguments 不能被重新赋值</li>
<li>arguments 不会自动反映函数参数的变化</li>
<li>不能使用 arguments.callee</li>
<li>不能使用 arguments.caller</li>
<li>禁止 this 指向全局对象</li>
<li>不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈</li>
</ul>
<h3 id="10、meta-标签"><a href="#10、meta-标签" class="headerlink" title="10、meta 标签"></a>10、meta 标签</h3><blockquote>
<p>&lt;_meta_ &gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。</p>
</blockquote>
<h4 id="10-1、四个属性"><a href="#10-1、四个属性" class="headerlink" title="10.1、四个属性"></a>10.1、四个属性</h4><ul>
<li>http-equiv 【重要关键词】<ul>
<li>content-type<ul>
<li>定义字符编码</li>
<li>不推荐使用 改用 charset 属性</li>
</ul>
</li>
<li>refresh：指定以秒为单位，执行重载和重定向</li>
</ul>
</li>
<li>name 【 重要关键词】<ul>
<li>application-name：应用程序名称</li>
<li>keywords ： keywords 用来告诉搜索引擎你网页的关键字是什么</li>
<li>author ： 当前页的作者名</li>
<li>viewport<ul>
<li>设置浏览器视口</li>
<li>重要关键字<ul>
<li>width ： 视口宽度</li>
<li>*-scale （initial-scale）： 缩放相关</li>
<li>user-scalable ： 是否可以手动缩放</li>
<li>例如：&lt;_meta name=”viewport” content=”width=device-width, initial-scale=1, maximum-scale=1”_ &gt;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>description description 用来告诉搜索引擎你的网站主要内容</li>
<li>content ：具体描述 、不能单独存在</li>
<li>charset（HTML5）：推荐使用 utf-8 简化了不同脚本对文件中字符的处理</li>
</ul>
<h4 id="10-2、meta-标签的作用"><a href="#10-2、meta-标签的作用" class="headerlink" title="10.2、meta 标签的作用"></a>10.2、meta 标签的作用</h4><ol>
<li><p>搜索引擎优化（SEO）</p>
</li>
<li><p>定义页面使用语言</p>
</li>
<li><p>自动刷新并指向新的页面</p>
</li>
<li><p>实现网页转换时的动态效果</p>
</li>
<li><p>控制页面缓冲</p>
</li>
<li><p>网页定级评价</p>
</li>
<li><p>控制网页显示的窗口</p>
</li>
</ol>
<p>######</p>
<p>######</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/" rel="tag">面试全面总结</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-regular_expression"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/10/regular_expression/"
    >正则表达式</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/10/10/regular_expression/" class="article-date">
  <time datetime="2019-10-10T06:19:47.000Z" itemprop="datePublished">2019-10-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><blockquote>
<p>正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象。这些模式被用于 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp"><code>RegExp</code></a> 的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>exec</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"><code>test</code></a> 方法, 以及 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String"><code>String</code></a> 的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code>match</code></a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll"><code>matchAll</code></a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><code>replace</code></a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search"><code>search</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split"><code>split</code></a> 方法。本章介绍 JavaScript <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式</a>。</p>
</blockquote>
<p>辅助正则可视化网站：<a target="_blank" rel="noopener" href="https://regexper.com/">https://regexper.com/</a></p>
<p><strong>使用正则表达式的方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>exec</code></a></td>
<td>一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组（未匹配到则返回 null）。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"><code>test</code></a></td>
<td>一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或 false。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code>match</code></a></td>
<td>一个在字符串中执行查找匹配的 String 方法，它返回一个数组，在未匹配到时会返回 null。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll"><code>matchAll</code></a></td>
<td>一个在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器（iterator）。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search"><code>search</code></a></td>
<td>一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回-1。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><code>replace</code></a></td>
<td>一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split"><code>split</code></a></td>
<td>一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 <code>String</code> 方法。</td>
</tr>
</tbody></table>
<h2 id="REGEXP-对象"><a href="#REGEXP-对象" class="headerlink" title="REGEXP 对象"></a>REGEXP 对象</h2><ul>
<li>JavaScript 通过内置函数对象 RegExp 支持正则表达式</li>
<li>有两种方法实例化 RegExp 对象<ul>
<li>字面量</li>
<li>构造函数</li>
</ul>
</li>
</ul>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\bis\b/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;he is dog ,he love she how are you is&quot;</span>.replace(reg, <span class="string">&quot;IS&quot;</span>));</span><br><span class="line"><span class="comment">// he IS dog ,he love she how are you IS</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;\\bis\\b&quot;</span>, <span class="string">&quot;g&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;he is dog ,he love she how are you is&quot;</span>.replace(reg, <span class="string">&quot;IS&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// he IS dog ,he love she how are you IS</span></span><br></pre></td></tr></table></figure>

<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>在 JavaScript 中，<strong>正则表达式标志</strong>：</p>
<ul>
<li><p><code>i</code></p>
<p>不区分大小写搜索。</p>
</li>
<li><p><code>g</code></p>
<p>全局搜索。</p>
</li>
<li><p><code>m</code></p>
<p>多行搜索。</p>
</li>
<li><p><code>u</code></p>
<p>使用 unicode 码的模式进行匹配。</p>
</li>
<li><p><code>y</code></p>
<p>执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用 y 标志。</p>
</li>
<li><p><code>s</code></p>
<p>允许 <code>.</code> 匹配换行符。</p>
</li>
</ul>
<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><ul>
<li>正则表达式由两种基本字符类型组成：<ul>
<li>原义文本字符</li>
<li>元字符</li>
</ul>
</li>
<li>元字符是在正则表达式中有特殊含义的非字母字符</li>
</ul>
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>将下一个字符标记为特殊字符或字面值。例如，n 匹配字符 _n_，而 \n 匹配换行符。序列 \ 匹配 \，而 ( 匹配 (。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入的开始部分。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入的结束部分。</td>
</tr>
<tr>
<td>*</td>
<td>零次或更多次匹配前面的字符。例如，zo* 匹配 <em>z</em> 或 <em>zoo\</em>。</td>
</tr>
<tr>
<td>+</td>
<td>一次或更多次匹配前面的字符。例如，zo+ 匹配 _zoo_，但是不匹配 _z_。</td>
</tr>
<tr>
<td>?</td>
<td>零次或一次匹配前面的字符。例如，a?ve? 匹配 <em>never</em> 中的 _ve_。</td>
</tr>
<tr>
<td>.</td>
<td>匹配任何单个字符，但换行符除外。</td>
</tr>
<tr>
<td>(pattern)</td>
<td>匹配模式并记住匹配项。通过使用以下代码，匹配的子串可以检索自生成的匹配项集合：Item [0]…[n]。要匹配圆括号字符 ( )，请使用 ( 或 )。</td>
</tr>
<tr>
<td>x|y</td>
<td>匹配 x 或 y。 例如，z|wood 匹配 <em>z</em> 或 <em>wood_。(z|w)oo 匹配 _zoo</em> 或 _wood_。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。精确匹配 n 次。例如，o{2} 不匹配 <em>Bob</em> 中的 <em>o_，但是匹配 _foooood</em> 中的前两个 _o_。</td>
</tr>
<tr>
<td>{n,}</td>
<td>在此表达式中，n 是一个非负整数。至少 n 次匹配前面的字符。例如，o{2,} 不匹配 <em>Bob</em> 中的 <em>o_，但是匹配 _foooood</em> 中的所有 _o_。o{1,} 表达式等效于 o+，o{0,} 等效于 o*。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 变量是非负整数。至少 n 次且至多 m 次匹配前面的字符。例如，o{1,3} 匹配 <em>fooooood</em> 中的前三个 _o_。o{0,1} 表达式等效于 o?。</td>
</tr>
<tr>
<td>[xyz]</td>
<td>一个字符集。匹配任意一个包含的字符。例如，[abc] 匹配 <em>plain</em> 中的 _a_。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>一个否定字符集。匹配任何未包含的字符。例如，[^abc] 匹配 <em>plain</em> 中的 _p_。</td>
</tr>
<tr>
<td>[a-z]</td>
<td>字符范围。匹配指定范围中的任何字符。例如，[a-z] 匹配英语字母中的任何小写的字母字符。</td>
</tr>
<tr>
<td>[^m-z]</td>
<td>一个否定字符范围。匹配未在指定范围中的任何字符。例如，[m-z] 匹配未在范围 <em>m</em> 到 <em>z</em> 之间的任何字符。</td>
</tr>
<tr>
<td>\A</td>
<td>仅匹配字符串的开头。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配某个单词边界，即，某个单词和空格之间的位置。例如，er\b 匹配 <em>never</em> 中的 <em>er_，但是不匹配 _verb</em> 中的 _er_。</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界。ea*r\B 表达式匹配 <em>never early</em> 中的 <em>ear\</em>。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字字符。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字字符。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配换页字符。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配换行符。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配回车字符。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空格，包括空白、制表符、换页字符等等。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空格字符。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配跳进字符。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配垂直跳进字符。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配任何单词字符，包括下划线。此表达式等效于 [A-Za-z0-9_]。</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任何非单词字符。此表达式等效于 [^a-za-z0-9__]。</td>
</tr>
<tr>
<td>\z</td>
<td>仅匹配字符串的结尾。</td>
</tr>
<tr>
<td>\Z</td>
<td>仅匹配字符串的结尾，或者结尾的换行符之前。</td>
</tr>
</tbody></table>
<p><strong>字符类：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a1b2c3d4&quot;</span>.replace(<span class="regexp">/[abc]/g</span>, <span class="string">&quot;X&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;X1X2X3d4&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a1b2c3d4&quot;</span>.replace(<span class="regexp">/[^abc]/g</span>, <span class="string">&quot;X&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;aXbXcXXX&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>范围类：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a1b2c3d4zcczx&quot;</span>.replace(<span class="regexp">/[a-z]/g</span>, <span class="string">&quot;Q&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;Q1Q2Q3Q4QQQQQ&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;a1b2c3d4zcczxAAAAAAA&quot;</span>.replace(<span class="regexp">/[a-zA-Z]/g</span>, <span class="string">&quot;Q&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;Q1Q2Q3Q4QQQQQQQQQQQQ&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;2016-09-12&quot;</span>.replace(<span class="regexp">/[0-9]/g</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;AAAA-AA-AA&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;2016-09-12&quot;</span>.replace(<span class="regexp">/[0-9-]/g</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;AAAAAAAAAA&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>预定义类：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20191009/FsMlDwV4Kfrh.png?imageslim" alt="mark"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配一个 ab + 数字 + 任意字符 的字符串</span></span><br><span class="line">ab\d.</span><br></pre></td></tr></table></figure>

<p><strong>边界：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20191009/UQyV6XeWDuqI.png?imageslim" alt="mark"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;this is a boy&quot;</span>.replace(<span class="regexp">/\bis\b/g</span>, <span class="string">&quot;IS&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;this IS a boy&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;@13@12331&quot;</span>.replace(<span class="regexp">/@./g</span>, <span class="string">&quot;Q&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;Q3Q2331&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;@13@12331&quot;</span>.replace(<span class="regexp">/^@./g</span>, <span class="string">&quot;Q&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;Q3@12331&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;@13@12331@&quot;</span>.replace(<span class="regexp">/.@$/g</span>, <span class="string">&quot;Q&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;@13@1233Q&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>量词：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20191009/KsjXw8IGYwJD.png?imageslim" alt="mark"></p>
<p><strong>贪婪模式：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;12345678&quot;</span>.replace(<span class="regexp">/\d&#123;3,6&#125;/g</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;a78&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>非贪婪模式：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;12345678&quot;</span>.replace(<span class="regexp">/\d&#123;3,6&#125;?/g</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;aa78&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>分组：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a1b2c3d4&quot;</span>.replace(<span class="regexp">/([a-zA-z]\d)&#123;3&#125;/g</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;Ad4&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>或：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;123456789122312&quot;</span>.replace(<span class="regexp">/(123|456)/g</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;AA789122312&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>反向引用：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;2019-10-09&quot;</span>.replace(<span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g</span>, <span class="string">&quot;$3/$2/$1&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;09/10/2019&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>前瞻：</strong></p>
<ul>
<li>正则表达式从文本头部向尾部开始解析，文本尾部方向，称为“前”</li>
<li><strong>前瞻</strong> 就是正则表达式匹配到规则的时候，向前检查是否符合断言，后顾/后瞻 方向相反</li>
<li>JavaScript 不支持 后顾</li>
<li>符合和不符合特定断言称为 <strong>肯定/正向</strong> 匹配 和 <strong>否定/负向</strong> 匹配</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20191009/VS8ezfIwVH95.png?imageslim" alt="mark"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a2*3&quot;</span>.replace(<span class="regexp">/\w(?=\d)/g</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;A2*3&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h3><ul>
<li>global：是否全文搜索，默认 false</li>
<li>ignore case：是否大小写敏感，默认是 false</li>
<li>multiline：多行搜索，默认值是 false</li>
<li>lastIndex: 是当前表达式匹配内容的最后一个字符的下一个位置</li>
<li>source：正则表达式的文本字符串</li>
</ul>
<h2 id="RegExp-prototype-test"><a href="#RegExp-prototype-test" class="headerlink" title="RegExp.prototype.test()"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test">RegExp.prototype.test()</a></h2><blockquote>
<p><code>test()</code> 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 <code>true</code> 或 <code>false</code>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/\w/</span>;</span><br><span class="line">reg1.test(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>注意：/g（全局匹配 ） 使用 test 方法，结果不稳定！</p>
<h2 id="RegExp-prototype-exec"><a href="#RegExp-prototype-exec" class="headerlink" title="RegExp.prototype.exec()"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec">RegExp.prototype.exec()</a></h2><blockquote>
<p><code>exec() </code>方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a>。</p>
<p>如果你只是为了判断是否匹配（true 或 false），可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"><code>RegExp.test()</code></a> 方法，或者 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search"><code>String.search()</code></a> 方法。</p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-virtualDOM"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/09/20/virtualDOM/"
    >虚拟DOM</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/09/20/virtualDOM/" class="article-date">
  <time datetime="2019-09-20T06:47:32.000Z" itemprop="datePublished">2019-09-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a> / <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/%E8%99%9A%E6%8B%9FDOM/">虚拟DOM</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h1><blockquote>
<p>本章分析了<strong>虚拟 DOM</strong> 的使用场景、<strong>常用 API</strong>、以及 <strong>diff 算法</strong> 的代码框架。通过学习和了解虚拟 DOM ，为后面的 vue 和 React 学习打好基础。</p>
<p><strong>知识点</strong></p>
<p>5-1 什么是 vdom，为何使用 vdom？</p>
<p>5-2 vdom 的如何应用，核心 API 是什么？</p>
<p>5-3 介绍 一下 diff 算法</p>
<p>Ignorance is the curse of God, knowledge the wing wherewith we fly to heaven.——William Shakespeare</p>
<p>无知乃是罪恶，知识乃是我们借以飞向天堂的翅膀。——莎士比亚</p>
</blockquote>
<h3 id="virtual-dom"><a href="#virtual-dom" class="headerlink" title="virtual dom"></a>virtual dom</h3><ul>
<li>vdom 是 vue 和 React 的核心，先讲哪个都绕不开它</li>
<li>vdom 比较独立，使用也比较简单</li>
<li>如果面试问到 vue 和 React 的实现，免不了问 vdom</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>vdom 是什么？为何会存在 vdom？</li>
<li>vdom 的如何应用，核心 API 是什么？</li>
<li>介绍一下 diff 算法</li>
</ul>
<h2 id="5-1-什么是-vdom，为何使用-vdom？"><a href="#5-1-什么是-vdom，为何使用-vdom？" class="headerlink" title="5-1 什么是 vdom，为何使用 vdom？"></a>5-1 什么是 vdom，为何使用 vdom？</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>什么是 vdom？</li>
<li>设计一个需求场景</li>
<li>用 jQuery 实现</li>
<li>遇到的问题</li>
</ul>
<h4 id="什么是-vdom？"><a href="#什么是-vdom？" class="headerlink" title="什么是 vdom？"></a>什么是 vdom？</h4><ul>
<li>virtual dom，虚拟 DOM</li>
<li>用 JS 模拟 DOM 结构</li>
<li>DOM 变化的对比，放在 JS 层来做 （ 图灵完备语言 ）</li>
<li>提高重绘性能</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">  &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item&quot;</span>&gt;Item <span class="number">1</span>&lt;/li&gt;</span><br><span class="line">  &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item&quot;</span>&gt;Item <span class="number">2</span>&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p><strong>用 JS 模拟 DOM</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vdom</span></span><br><span class="line">&#123;</span><br><span class="line">    tag:<span class="string">&#x27;ul&#x27;</span>,</span><br><span class="line">    attrs:&#123;</span><br><span class="line">        id:<span class="string">&#x27;list&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    children:[</span><br><span class="line">        &#123;</span><br><span class="line">            tag:<span class="string">&#x27;li&#x27;</span>,</span><br><span class="line">            attrs:&#123;<span class="attr">className</span>:<span class="string">&#x27;item&#x27;</span>&#125;,</span><br><span class="line">            children:[<span class="string">&#x27;Item 1&#x27;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            tag:<span class="string">&#x27;li&#x27;</span>,</span><br><span class="line">            attrs:&#123;<span class="attr">className</span>:<span class="string">&#x27;item&#x27;</span>&#125;,</span><br><span class="line">            children:[<span class="string">&#x27;Item 2&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="设计一个需求场景"><a href="#设计一个需求场景" class="headerlink" title="设计一个需求场景"></a>设计一个需求场景</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.将该数据展示成一个表格</span></span><br><span class="line"><span class="comment"> * 2.随便修改一个信息，表格也跟着修改</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    age: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">    address: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">    age: <span class="string">&quot;21&quot;</span>,</span><br><span class="line">    address: <span class="string">&quot;上海&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;王五&quot;</span>,</span><br><span class="line">    age: <span class="string">&quot;22&quot;</span>,</span><br><span class="line">    address: <span class="string">&quot;广州&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p><em>jQuery 实现</em> ：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn-change&quot;</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> data = [</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line"><span class="javascript">          age: <span class="string">&quot;20&quot;</span>,</span></span><br><span class="line"><span class="javascript">          address: <span class="string">&quot;北京&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;李四&quot;</span>,</span></span><br><span class="line"><span class="javascript">          age: <span class="string">&quot;21&quot;</span>,</span></span><br><span class="line"><span class="javascript">          address: <span class="string">&quot;上海&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;王五&quot;</span>,</span></span><br><span class="line"><span class="javascript">          age: <span class="string">&quot;22&quot;</span>,</span></span><br><span class="line"><span class="javascript">          address: <span class="string">&quot;广州&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">      ];</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//渲染函数</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> $container = $(<span class="string">&quot;#container&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//清空容器</span></span></span><br><span class="line"><span class="javascript">        $container.html(<span class="string">&quot;&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//拼接  table</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> $table = $(<span class="string">&quot;&lt;table&gt;&quot;</span>);</span></span><br><span class="line"><span class="handlebars"><span class="xml">        $table.append($(&quot;<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>name<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>age<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>address<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span>&quot;));</span></span></span><br><span class="line"><span class="javascript">        data.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span></span><br><span class="line">          $table.append(</span><br><span class="line"><span class="javascript">            $(</span></span><br><span class="line"><span class="handlebars"><span class="xml">              &quot;<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>&quot; +</span></span></span><br><span class="line">                item.name +</span><br><span class="line"><span class="handlebars"><span class="xml">                &quot;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>&quot; +</span></span></span><br><span class="line">                item.age +</span><br><span class="line"><span class="handlebars"><span class="xml">                &quot;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>&quot; +</span></span></span><br><span class="line">                item.address +</span><br><span class="line"><span class="handlebars"><span class="xml">                &quot;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span>&quot;</span></span></span><br><span class="line">            )</span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//渲染 到页面   jQuery放在这里：只有 一次DOM渲染，性能更好，但是 并不符合理想情况</span></span></span><br><span class="line">        $container.append($table);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      $(<span class="string">&quot;#btn-change&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        data[1].age = 30;</span><br><span class="line"><span class="javascript">        data[<span class="number">2</span>].address = <span class="string">&quot;深圳&quot;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//  re-render 再次渲染</span></span></span><br><span class="line">        render(data);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//页面加载完，立即执行</span></span></span><br><span class="line">      render(data);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190826/fnRWrTN8GFST.gif" alt="mark"></p>
<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ul>
<li>DOM 操作是 “昂贵”的，js <strong>运行效率高</strong></li>
<li>尽量减少 DOM 操作 ，而不是 “推倒重来”</li>
<li>项目越复杂 ，影响就越严重</li>
<li>vdom 即可解决这个问题</li>
</ul>
<h4 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h4><ul>
<li><p>vdom 是什么？为何会存在 vdom？</p>
<ul>
<li>virtual dom，虚拟 DOM</li>
<li>用 JS 模拟 DOM 结构</li>
<li>DOM 操作非常 “昂贵”</li>
<li>将 DOM 对比操作放在 JS 层，提高效率</li>
</ul>
</li>
<li><p>vdom 的如何应用，核心 API 是什么？</p>
<ul>
<li>介绍 <a target="_blank" rel="noopener" href="https://github.com/snabbdom/snabbdom">snabbdom</a></li>
<li>重做 之前的 demo</li>
<li>核心 API</li>
</ul>
</li>
</ul>
<h2 id="5-2-vdom-的如何应用，核心-API-是什么？"><a href="#5-2-vdom-的如何应用，核心-API-是什么？" class="headerlink" title="5-2 vdom 的如何应用，核心 API 是什么？"></a>5-2 vdom 的如何应用，核心 API 是什么？</h2><blockquote>
<p>介绍 snabbdom ：一个 vdom 实现库。</p>
</blockquote>
<h3 id="介绍-snabbdom"><a href="#介绍-snabbdom" class="headerlink" title="介绍 snabbdom"></a>介绍 snabbdom</h3><blockquote>
<p>虚拟 DOM 非常棒。它允许我们将应用程序的视图表示为其状态的函数。但现有的解决方案太过臃肿，太慢，缺乏功能，API 偏向于 OOP 和/或缺少我需要的功能。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/snabbdom/snabbdom">Snabbdom</a> 由一个非常简单，高性能和可扩展的核心组成，只有 ≈200SLOC。它提供了模块化架构，具有丰富的功能，可通过自定义模块进 为了保持核心简单，所有非必要功能都委托给模块。</p>
<p>你可以将 Snabbdom 塑造成你想要的任何东西！选择，选择和自定义所需的功能。或者，您可以使用默认扩展并获得具有高性能，小尺寸和下面列出的所有功能的虚拟 DOM 库。</p>
</blockquote>
<h4 id="介绍-snabbdom-h-函数"><a href="#介绍-snabbdom-h-函数" class="headerlink" title="介绍 snabbdom - h 函数"></a>介绍 snabbdom - h 函数</h4><p><img src="http://static.zxinc520.com/blog/20190826/DY84t1uJz1C3.png?imageslim" alt="mark"></p>
<h4 id="介绍-snabbdom-patch-函数"><a href="#介绍-snabbdom-patch-函数" class="headerlink" title="介绍 snabbdom -patch 函数"></a>介绍 snabbdom -patch 函数</h4><p><img src="http://static.zxinc520.com/blog/20190826/dbhW2mzgt6n3.png?imageslim" alt="mark"></p>
<h3 id="使用-snabbdom"><a href="#使用-snabbdom" class="headerlink" title="使用 snabbdom"></a>使用 snabbdom</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-class.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-props.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-style.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-eventlisteners.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/h.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> snabbdom = <span class="built_in">window</span>.snabbdom;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//定义 patch</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> patch = snabbdom.init([</span></span><br><span class="line">        snabbdom_class,</span><br><span class="line">        snabbdom_props,</span><br><span class="line">        snabbdom_style,</span><br><span class="line">        snabbdom_eventlisteners,</span><br><span class="line">      ]);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 定义 h</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> h = snabbdom.h;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//生成 vnode</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> vnode = h(<span class="string">&quot;ul#list&quot;</span>, &#123;&#125;, [</span></span><br><span class="line"><span class="javascript">        h(<span class="string">&quot;li.item&quot;</span>, &#123;&#125;, <span class="string">&quot;Item 1&quot;</span>),</span></span><br><span class="line"><span class="javascript">        h(<span class="string">&quot;li.item&quot;</span>, &#123;&#125;, <span class="string">&quot;Item 2&quot;</span>),</span></span><br><span class="line">      ]);</span><br><span class="line"></span><br><span class="line">      patch(container, vnode);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span></span></span><br><span class="line"><span class="javascript">        .getElementById(<span class="string">&quot;btn-change&quot;</span>)</span></span><br><span class="line"><span class="javascript">        .addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">//生成 newVnode</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> newVnode = h(<span class="string">&quot;ul#list&quot;</span>, &#123;&#125;, [</span></span><br><span class="line"><span class="javascript">            h(<span class="string">&quot;li.item&quot;</span>, &#123;&#125;, <span class="string">&quot;Item 1&quot;</span>),</span></span><br><span class="line"><span class="javascript">            h(<span class="string">&quot;li.item&quot;</span>, &#123;&#125;, <span class="string">&quot;Item B&quot;</span>),</span></span><br><span class="line"><span class="javascript">            h(<span class="string">&quot;li.item&quot;</span>, &#123;&#125;, <span class="string">&quot;Item 3&quot;</span>),</span></span><br><span class="line">          ]);</span><br><span class="line">          patch(vnode, newVnode);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190826/o5jyCvk0PiHc.gif" alt="mark"></p>
<h3 id="重做-之前的-demo"><a href="#重做-之前的-demo" class="headerlink" title="重做 之前的 demo"></a>重做 之前的 demo</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn-change&quot;</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-class.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-props.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-style.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-eventlisteners.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/h.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> snabbdom = <span class="built_in">window</span>.snabbdom;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//定义 patch</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> patch = snabbdom.init([</span></span><br><span class="line">        snabbdom_class,</span><br><span class="line">        snabbdom_props,</span><br><span class="line">        snabbdom_style,</span><br><span class="line">        snabbdom_eventlisteners,</span><br><span class="line">      ]);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 定义 h</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> h = snabbdom.h;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//原始数据</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> data = [</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line"><span class="javascript">          age: <span class="string">&quot;20&quot;</span>,</span></span><br><span class="line"><span class="javascript">          address: <span class="string">&quot;北京&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;李四&quot;</span>,</span></span><br><span class="line"><span class="javascript">          age: <span class="string">&quot;21&quot;</span>,</span></span><br><span class="line"><span class="javascript">          address: <span class="string">&quot;上海&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;王五&quot;</span>,</span></span><br><span class="line"><span class="javascript">          age: <span class="string">&quot;22&quot;</span>,</span></span><br><span class="line"><span class="javascript">          address: <span class="string">&quot;广州&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">      ];</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//把表也放在 data 中</span></span></span><br><span class="line">      data.unshift(&#123;</span><br><span class="line"><span class="javascript">        name: <span class="string">&quot;姓名&quot;</span>,</span></span><br><span class="line"><span class="javascript">        age: <span class="string">&quot;年龄&quot;</span>,</span></span><br><span class="line"><span class="javascript">        address: <span class="string">&quot;地址&quot;</span>,</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//渲染函数</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> vnode;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> newVnode = h(</span></span><br><span class="line"><span class="javascript">          <span class="string">&quot;table&quot;</span>,</span></span><br><span class="line">          &#123;&#125;,</span><br><span class="line"><span class="javascript">          data.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> tds = [];</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> i;</span></span><br><span class="line">            for (i in item) &#123;</span><br><span class="line">              if (item.hasOwnProperty(i)) &#123;</span><br><span class="line"><span class="javascript">                tds.push(h(<span class="string">&quot;td&quot;</span>, &#123;&#125;, item[i] + <span class="string">&quot;&quot;</span>));</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> h(<span class="string">&quot;tr&quot;</span>, &#123;&#125;, tds);</span></span><br><span class="line">          &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        if (vnode) &#123;</span><br><span class="line"><span class="javascript">          <span class="comment">// 再次渲染</span></span></span><br><span class="line">          patch(vnode, newVnode);</span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 初次渲染</span></span></span><br><span class="line">          patch(container, newVnode);</span><br><span class="line">        &#125;</span><br><span class="line">        vnode = newVnode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 初次渲染</span></span></span><br><span class="line">      render(data);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> btnChange = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn-change&quot;</span>);</span></span><br><span class="line"><span class="javascript">      btnChange.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        data[1].age = 30;</span><br><span class="line"><span class="javascript">        data[<span class="number">2</span>].address = <span class="string">&quot;深圳&quot;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//re-render</span></span></span><br><span class="line">        render(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190826/c9oXjl7n0ScN.gif" alt="mark"></p>
<h3 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h3><ul>
<li>h（’&lt;标签名&gt;’，{ … 属性 … }，[… 子元素 …]）</li>
<li>h（’&lt;标签名&gt;’，{ … 属性 … }，[ ‘….’]）</li>
<li>patch（container，vnode）</li>
<li>patch（vnode，newVnode）</li>
</ul>
<h3 id="问题解答-1"><a href="#问题解答-1" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>vdom 的如何应用，核心 API 是什么？<ul>
<li>如何使用？ 可用 snabbdom 的 用法 来 举例</li>
<li>核心 函数 ：h 函数，patch 函数</li>
</ul>
</li>
</ul>
<h2 id="5-3-介绍-一下-diff-算法"><a href="#5-3-介绍-一下-diff-算法" class="headerlink" title="5-3 介绍 一下 diff 算法"></a>5-3 介绍 一下 diff 算法</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul>
<li>什么是 diff 算法？</li>
<li>去繁就简</li>
<li>vdom 为何用 diff 算法 ？</li>
<li>diff 算法 的 实现流程</li>
</ul>
<h4 id="什么是-diff-算法"><a href="#什么是-diff-算法" class="headerlink" title="什么是 diff 算法"></a>什么是 diff 算法</h4><blockquote>
<p>diff 算法 一直在我们身边</p>
<p><u>并不是 Vue 和 React 创造出来的概念</u></p>
</blockquote>
<p><em>diff 算法命令演示</em> ：</p>
<ul>
<li>linux 系统下： <code>diff log1.txt log2.txt</code> ：比较 2 个文件的不同</li>
<li><code>git diff xxxx</code> 的示例 ： git 里面比较不同版本间的代码差异</li>
</ul>
<h4 id="去繁就简"><a href="#去繁就简" class="headerlink" title="去繁就简"></a>去繁就简</h4><ul>
<li>diff 算法非常复杂，实现难度很大，源码量很大</li>
<li>去繁就简，讲明白核心流程 ，不关心细节</li>
<li>面试官也大部分都不清楚细节，但是很关心核心流程</li>
<li>去繁就简之后，依然 具有很大挑战性，并不简单</li>
</ul>
<h4 id="vdom-为何用-diff-算法"><a href="#vdom-为何用-diff-算法" class="headerlink" title="vdom 为何用 diff 算法"></a>vdom 为何用 diff 算法</h4><ul>
<li>DOM 操作是 “昂贵”的，因此尽量减少 DOM 操作</li>
<li>找出本次 DOM 必须更新的节点来更新，其它的 不更新</li>
<li>这个 “ 找出 ” 的过程，就需要 diff 算法</li>
</ul>
<h3 id="diff-实现过程"><a href="#diff-实现过程" class="headerlink" title="diff 实现过程"></a>diff 实现过程</h3><ul>
<li>patch （container，vnode）</li>
<li>patch （vnode，newVnode）</li>
</ul>
<h4 id="patch-（container，vnode）"><a href="#patch-（container，vnode）" class="headerlink" title="patch （container，vnode）"></a>patch （container，vnode）</h4><p><img src="http://static.zxinc520.com/blog/20190826/EQNow2OMou5G.png?imageslim" alt="mark"></p>
<p><strong>核心：如何使用 左边的 JS 节点 生成 右侧 Dom 节点？</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190826/xcTxunRSOhnV.png?imageslim" alt="mark"></p>
<h4 id="patch-（vnode，newVnode）"><a href="#patch-（vnode，newVnode）" class="headerlink" title="patch （vnode，newVnode）"></a>patch （vnode，newVnode）</h4><blockquote>
<p>核心：**对比 **</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190826/3a4N2wzMJLaA.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190826/k1hdRameLCv5.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190826/hycgLD8H9RuC.png?imageslim" alt="mark"></p>
<h4 id="diff-实现过程-1"><a href="#diff-实现过程-1" class="headerlink" title="diff 实现过程"></a>diff 实现过程</h4><ul>
<li>patch （container，vnode）和 patch （vnode，newVnode）</li>
<li>createElment</li>
<li>updataChildren</li>
</ul>
<h3 id="问题解答-2"><a href="#问题解答-2" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>介绍一下 diff 算法？<ul>
<li>知道什么是 diff 算法，是 linux 的基础命令</li>
<li>vdom 中 应用 diff 算法目的： 是为了 找出需要更新的节点</li>
<li>diff 实现：patch （container，vnode）和 patch （vnode，newVnode）</li>
<li>核心 逻辑 ， createElment 和 updataChildren</li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%99%9A%E6%8B%9FDOM/" rel="tag">虚拟DOM</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-three-plus-one-a-day"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/09/20/three-plus-one-a-day/"
    >前端面试每日三加一</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/09/20/three-plus-one-a-day/" class="article-date">
  <time datetime="2019-09-20T06:47:32.000Z" itemprop="datePublished">2019-09-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%89%9B%E4%BA%BA%E9%9D%A2%E8%AF%95%E9%A2%98/">牛人面试题</a> / <a class="article-category-link" href="/categories/%E7%89%9B%E4%BA%BA%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%AF%8F%E6%97%A5%E4%B8%89%E5%8A%A0%E4%B8%80/">前端面试每日三加一</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="前端面试每日三加一"><a href="#前端面试每日三加一" class="headerlink" title="前端面试每日三加一"></a>前端面试每日三加一</h2><blockquote>
<p>待更新状态</p>
<p>今天 2019/12/24 ~ ✌</p>
<p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/aya001001/fe-interview/1054361">网页版标签分类</a></p>
</blockquote>
<h3 id="第-1-天-2019-09-19）"><a href="#第-1-天-2019-09-19）" class="headerlink" title="第 1 天 (2019.09.19）"></a>第 1 天 (2019.09.19）</h3><p><strong>总览</strong>：</p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/1">页面导入样式时，使用 link 和@import 有什么区别？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/2">圣杯布局和双飞翼布局的理解和区别，并用代码实现</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/3">用递归算法实现，数组长度为 5 且元素的随机数在 2-32 间不重复的值</a></li>
</ul>
<p>1、【html】：页面导入样式时，使用 link 和@import 有什么区别？</p>
<p><strong>解析</strong>：</p>
<p>区别：</p>
<ol>
<li>link 是 HTML 标签，<a target="_blank" rel="noopener" href="https://github.com/import">@import</a>是 css 提供的。</li>
<li>link 引入的样式页面加载时同时加载，<a target="_blank" rel="noopener" href="https://github.com/import">@import</a>引入的样式需等页面加载完成后再加载。</li>
<li>link 没有兼容性问题，<a target="_blank" rel="noopener" href="https://github.com/import">@import</a>不兼容 ie5 以下。</li>
<li>link 可以通过 js 操作 DOM 动态引入样式表改变样式，而<a target="_blank" rel="noopener" href="https://github.com/import">@import</a>不可以。</li>
</ol>
<p>2、【css】：圣杯布局和双飞翼布局的理解和区别，并用代码实现</p>
<p><strong>解析：</strong></p>
<p><strong>作用</strong>：圣杯布局和双飞翼布局解决的问题是一样的，就是两边顶宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。</p>
<p><strong>区别</strong>：两者都是为了不让左右俩不遮住 middle，经典圣杯布局通过父亲 padding 给左右俩腾位置从而不会遮住 middle 内容，而双飞翼是 middle 设置 margin，限制内部内容区域，从而左右俩遮的地方不会影响到 middle 内容</p>
<p>对于三栏布局，modern solution 是 flex box/ grid 布局，这两者可以轻松实现 mobile-friendly 的方案，也可以控制顺序，middle 依然可以先渲染，9012 年兼容性不错了，如果 APP 无视 IE，这是优选</p>
<p>3、【js】：用递归算法实现，数组长度为 5 且元素的随机数在 2-32 间不重复的值</p>
<p>这一题是起源题</p>
<p>描述：</p>
<p>这是一道大题目，把考点拆成了 4 个小项；需要侯选人用递归算法实现（限制 15 行代码以内实现；限制时间 10 分钟内完成）：</p>
<ol>
<li>生成一个长度为 5 的空数组 arr。</li>
<li>生成一个（2－32）之间的随机整数 rand。</li>
<li>把随机数 rand 插入到数组 arr 内，如果数组 arr 内已存在与 rand 相同的数字，则重新生成随机数 rand 并插入到 arr 内[需要使用递归实现，不能使用 for/while 等循环]</li>
<li>最终输出一个长度为 5，且内容不重复的数组 arr。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">AddRandom(arr, creatrandomnum());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AddRandom</span>(<span class="params">arr, randomnum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.indexOf(randomnum) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    arr[i] = randomnum;</span><br><span class="line">    i++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    randomnum = creatrandomnum();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    AddRandom(arr, randomnum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatrandomnum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (<span class="number">32</span> - <span class="number">2</span>) + <span class="number">2</span>); <span class="comment">//不含最大值，含最小值 [2-33)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点评：<br>知识点：递归、随机数<br>难点：1 颗星<br>这道题主要是想考递归的用法，同时顺带考了生成指定范围的随机数方法。</p>
<h3 id="第-2-天-2019-09-20"><a href="#第-2-天-2019-09-20" class="headerlink" title="第 2 天 (2019.09.20)"></a>第 2 天 (2019.09.20)</h3><p><strong>总览</strong> ：</p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/4">html 的元素有哪些（包含 H5）？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/5">CSS3 有哪些新增的特性？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/6">写一个方法去掉字符串中的空格</a></li>
</ul>
<p>1、【html】 html 的元素有哪些（包含 H5）？</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">行内元素：</span><br><span class="line">- a</span><br><span class="line">- b</span><br><span class="line">- span</span><br><span class="line">- strong</span><br><span class="line">- i</span><br><span class="line">- em</span><br><span class="line">- button</span><br><span class="line">- input</span><br><span class="line">- label</span><br><span class="line">- br</span><br><span class="line">- textarea</span><br><span class="line">- select</span><br><span class="line"></span><br><span class="line">块元素 ：</span><br><span class="line">- div</span><br><span class="line">- p</span><br><span class="line">- h1-h6</span><br><span class="line">- ol</span><br><span class="line">- ul</span><br><span class="line">- li</span><br><span class="line">- table</span><br><span class="line">- tbody</span><br><span class="line">- td</span><br><span class="line">- tr</span><br><span class="line">- thead</span><br><span class="line">- dl</span><br><span class="line">- dt</span><br><span class="line">- dd</span><br><span class="line"></span><br><span class="line">H5新增元素：</span><br><span class="line">- section</span><br><span class="line">- article</span><br><span class="line">- audio</span><br><span class="line">- video</span><br><span class="line">- hearder</span><br><span class="line">- footer</span><br><span class="line">- small</span><br></pre></td></tr></table></figure>

<p>2、【css】 CSS3 有哪些新增的特性？</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/entry/595f1e3c5188250d914dd53c">前端面试之 CSS3 新特性</a></p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">边框(<span class="selector-tag">borders</span>):</span><br><span class="line">    <span class="selector-tag">border-radius</span> 圆角</span><br><span class="line">    <span class="selector-tag">box-shadow</span> 盒阴影</span><br><span class="line">    <span class="selector-tag">border-image</span> 边框图像</span><br><span class="line">背景:</span><br><span class="line">    <span class="selector-tag">background-size</span> 背景图片的尺寸</span><br><span class="line">    <span class="selector-tag">background_origin</span> 背景图片的定位区域</span><br><span class="line">    <span class="selector-tag">background-clip</span> 背景图片的绘制区域</span><br><span class="line">渐变：</span><br><span class="line">    <span class="selector-tag">linear-gradient</span> 线性渐变</span><br><span class="line">    <span class="selector-tag">radial-gradient</span> 径向渐变</span><br><span class="line">文本效果;</span><br><span class="line">    <span class="selector-tag">word-break</span></span><br><span class="line">    <span class="selector-tag">word-wrap</span></span><br><span class="line">    <span class="selector-tag">text-overflow</span></span><br><span class="line">    <span class="selector-tag">text-shadow</span></span><br><span class="line">    <span class="selector-tag">text-wrap</span></span><br><span class="line">    <span class="selector-tag">text-outline</span></span><br><span class="line">    <span class="selector-tag">text-justify</span></span><br><span class="line">转换：</span><br><span class="line">2<span class="selector-tag">D</span>转换属性</span><br><span class="line">    <span class="selector-tag">transform</span></span><br><span class="line">    <span class="selector-tag">transform-origin</span></span><br><span class="line">2<span class="selector-tag">D</span>转换方法</span><br><span class="line">    <span class="selector-tag">translate</span>(<span class="selector-tag">x</span>,<span class="selector-tag">y</span>)</span><br><span class="line">    <span class="selector-tag">translateX</span>(<span class="selector-tag">n</span>)</span><br><span class="line">    <span class="selector-tag">translateY</span>(<span class="selector-tag">n</span>)</span><br><span class="line">    <span class="selector-tag">rotate</span>(<span class="selector-tag">angle</span>)</span><br><span class="line">    <span class="selector-tag">scale</span>(<span class="selector-tag">n</span>)</span><br><span class="line">    <span class="selector-tag">scaleX</span>(<span class="selector-tag">n</span>)</span><br><span class="line">    <span class="selector-tag">scaleY</span>(<span class="selector-tag">n</span>)</span><br><span class="line">    <span class="selector-tag">rotate</span>(<span class="selector-tag">angle</span>)</span><br><span class="line">    <span class="selector-tag">matrix</span>(<span class="selector-tag">n</span>,<span class="selector-tag">n</span>,<span class="selector-tag">n</span>,<span class="selector-tag">n</span>,<span class="selector-tag">n</span>,<span class="selector-tag">n</span>)</span><br><span class="line">3<span class="selector-tag">D</span>转换：</span><br><span class="line">*3<span class="selector-tag">D</span>转换属性：</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">transform</span></span><br><span class="line">    <span class="selector-tag">transform-origin</span></span><br><span class="line">    <span class="selector-tag">transform-style</span></span><br><span class="line">3<span class="selector-tag">D</span>转换方法</span><br><span class="line">    <span class="selector-tag">translate3d</span>(<span class="selector-tag">x</span>,<span class="selector-tag">y</span>,<span class="selector-tag">z</span>)</span><br><span class="line">    <span class="selector-tag">translateX</span>(<span class="selector-tag">x</span>)</span><br><span class="line">    <span class="selector-tag">translateY</span>(<span class="selector-tag">y</span>)</span><br><span class="line">    <span class="selector-tag">translateZ</span>(<span class="selector-tag">z</span>)</span><br><span class="line">    <span class="selector-tag">scale3d</span>(<span class="selector-tag">x</span>,<span class="selector-tag">y</span>,<span class="selector-tag">z</span>)</span><br><span class="line">    <span class="selector-tag">scaleX</span>(<span class="selector-tag">x</span>)</span><br><span class="line">    <span class="selector-tag">scaleY</span>(<span class="selector-tag">y</span>)</span><br><span class="line">    <span class="selector-tag">scaleZ</span>(<span class="selector-tag">z</span>)</span><br><span class="line">    <span class="selector-tag">rotate3d</span>(<span class="selector-tag">x</span>,<span class="selector-tag">y</span>,<span class="selector-tag">z</span>,<span class="selector-tag">angle</span>)</span><br><span class="line">    <span class="selector-tag">rotateX</span>(<span class="selector-tag">x</span>)</span><br><span class="line">    <span class="selector-tag">rotateY</span>(<span class="selector-tag">y</span>)</span><br><span class="line">    <span class="selector-tag">rotateZ</span>(<span class="selector-tag">z</span>)</span><br><span class="line">    <span class="selector-tag">perspective</span>(<span class="selector-tag">n</span>)</span><br><span class="line">过渡</span><br><span class="line">	<span class="selector-tag">transition</span></span><br><span class="line">动画</span><br><span class="line">	<span class="keyword">@Keyframes</span>规则</span><br><span class="line">	animation</span><br><span class="line">弹性盒子(flexbox)</span><br><span class="line">多媒体查询@media</span><br></pre></td></tr></table></figure>

<p>3、【js】 写一个方法去掉字符串中的空格</p>
<blockquote>
<p>写一个方法去掉字符串中的空格，要求传入不同的类型分别能去掉前、后、前后、中间的空格</p>
<p>知识点：正则表达式、数组的 API</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;  abc d e f  g &quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="regexp">/\s+/g</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> trimStr = str.replace(reg, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(trimStr);</span><br><span class="line">&#125;</span><br><span class="line">trim(str);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trim = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/\s*/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">str.replace(<span class="regexp">/\s*/g</span>, <span class="string">&quot;&quot;</span>); <span class="comment">//去除字符串内所有的空格</span></span><br><span class="line">str.replace(<span class="regexp">/^\s*|\s*$/g</span>, <span class="string">&quot;&quot;</span>); <span class="comment">//去除字符串内两头的空格</span></span><br><span class="line">str.replace(<span class="regexp">/^\s*/</span>, <span class="string">&quot;&quot;</span>); <span class="comment">//去除字符串内左侧的空格</span></span><br><span class="line">str.replace(<span class="regexp">/(\s*$)/g</span>, <span class="string">&quot;&quot;</span>); <span class="comment">//去除字符串内右侧的空格</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;  abc d e f  g &quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.split(<span class="string">&quot; &quot;</span>).join(<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="第-3-天-2019-09-21"><a href="#第-3-天-2019-09-21" class="headerlink" title="第 3 天 (2019.09.21)"></a>第 3 天 (2019.09.21)</h3><p><strong>总览</strong> ：</p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/7">HTML 全局属性(global attribute)有哪些（包含 H5）？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/8">在页面上隐藏元素的方法有哪些？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/9">去除字符串中最后一个指定的字符</a></li>
</ul>
<p>1、【html 】HTML 全局属性(global attribute)有哪些（包含 H5）？</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">全局属性：用于任何HTML5元素的属性</span><br><span class="line"></span><br><span class="line">    accesskey ：规定激活元素的快捷键；</span><br><span class="line">    class ：规定元素的一个或多个类名（引用样式表中的类）；</span><br><span class="line">    contenteditable ：规定元素内容是否可编辑；</span><br><span class="line">    contextmenu ：规定元素的上下文菜单。上下文菜单在用户点击元素时显示。</span><br><span class="line">    data-* ：用于存储页面或应用程序的私有定制数据。</span><br><span class="line">    dir ：规定元素中内容的文本方向。</span><br><span class="line">    draggable ：规定元素是否可拖动。</span><br><span class="line">    dropzone： 规定在拖动被拖动数据时是否进行复制、移动或链接。</span><br><span class="line">    hidden ： 样式上会导致元素不显示，但是不能用这个属性实现样式。</span><br><span class="line">    id 规定元素的唯一： id。</span><br><span class="line">    lang ：规定元素内容的语言。</span><br><span class="line">    spellcheck： 规定是否对元素进行拼写和语法检查。</span><br><span class="line">    style ：规定元素的CSS行内元素。</span><br><span class="line">    tabindex ：规定元素的tab键次序。</span><br><span class="line">    title： 规定有关元素的额外信息。</span><br><span class="line">    translate ：规定是否应该翻译元素内容。</span><br></pre></td></tr></table></figure>

<p>2、【css】： 在页面上隐藏元素的方法有哪些？</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">占位:</span><br><span class="line">    -visibility: hidden;</span><br><span class="line">    -margin-left: -100%;</span><br><span class="line">    -opacity: 0;</span><br><span class="line">    -transform: scale(0);</span><br><span class="line"></span><br><span class="line">不占位:</span><br><span class="line">    -display: none;</span><br><span class="line">    -width: 0; height: 0; overflow: hidden;</span><br><span class="line"></span><br><span class="line">仅对块内文本元素:</span><br><span class="line">    -text-indent: -9999px;</span><br><span class="line">    -font-size: 0;</span><br><span class="line"></span><br><span class="line"> 利用 position （absolute 的情况下）</span><br><span class="line">    left/right/top/bottom: 9999px/-9999px 让元素在视区外</span><br><span class="line">    z-index: -9999 放到最底层，同一位置可以让其他元素把这个给遮掉</span><br></pre></td></tr></table></figure>

<p>3、【js】去除字符串中最后一个指定的字符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetLaststr</span>(<span class="params">s, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> s != <span class="string">&quot;string&quot;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> index = s.lastIndexOf(target);</span><br><span class="line">  <span class="keyword">return</span> s.substring(<span class="number">0</span>, index) + s.substring(index + <span class="number">1</span>, s.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delLast</span>(<span class="params">str, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">    .split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .reverse()</span><br><span class="line">    .join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .replace(target, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    .split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .reverse()</span><br><span class="line">    .join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-4-天-2019-09-22"><a href="#第-4-天-2019-09-22" class="headerlink" title="第 4 天 (2019.09.22)"></a>第 4 天 (2019.09.22)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/10">HTML5 的文件离线储存怎么使用，工作原理是什么？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/11">CSS 选择器有哪些？哪些属性可以继承？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/12">写一个方法把下划线命名转成大驼峰命名</a></li>
</ul>
<p>1、【html】 HTML5 的文件离线储存怎么使用，工作原理是什么？</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000000732617">有趣的 HTML5：离线存储</a></p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">优点:</span><br><span class="line">没有网络时可以浏览,加快资源的加载速度,减少服务器负载</span><br><span class="line"></span><br><span class="line">使用:</span><br><span class="line">只需要在页面头部加入,然后创建manifest.appcache文件</span><br><span class="line"></span><br><span class="line">浏览器如何解析manifest</span><br><span class="line">    1.在线情况:浏览器发现html头部有manifest属性,他会请求manifest文件,如果是第一次访问,那么浏览器会根据manifest文件的内容下载相应的资源并且进行离线存储.如果已经访问过并存储,那么浏览器使用 离线的资源价值,然后对比新的文件,如果没有发生改变就不做任何操作,如果文件改变了,那么就会重新下载文件中的资源并进行离线存储</span><br><span class="line">    2.离线情况:浏览器就直接使用离线存储资源</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】CSS 选择器有哪些？哪些属性可以继承？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">选择器:</span><br><span class="line">    通配符,<span class="selector-tag">id</span>,<span class="selector-tag">class</span>,标签,后代选择器,子选择器,兄弟选择器,属性选择器,伪类选择器,伪元素选择器</span><br><span class="line"></span><br><span class="line">可继承的属性:</span><br><span class="line">    字体属性<span class="selector-pseudo">:font-size</span>,<span class="selector-tag">font-weight</span>,<span class="selector-tag">font-style</span>,<span class="selector-tag">font-family</span></span><br><span class="line">    文本属性<span class="selector-pseudo">:text-indent</span>,<span class="selector-tag">text-align</span>,<span class="selector-tag">line-height</span>,<span class="selector-tag">word-spacing</span>,<span class="selector-tag">letter-spacing</span>,<span class="selector-tag">color</span>,<span class="selector-tag">direction</span>,<span class="selector-tag">text-transform</span></span><br><span class="line">    元素可见性<span class="selector-pseudo">:visibility</span>,<span class="selector-tag">opacity</span></span><br><span class="line">    光标属性<span class="selector-pseudo">:cursor</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】 写一个方法把下划线命名转成大驼峰命名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeStr</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str.split(<span class="string">&quot;_&quot;</span>).length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  str.split(<span class="string">&quot;_&quot;</span>).reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b.substr(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + b.substr(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-5-天-2019-09-23"><a href="#第-5-天-2019-09-23" class="headerlink" title="第 5 天 (2019.09.23)"></a>第 5 天 (2019.09.23)</h3><p><strong>总览</strong> ：</p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/13">简述超链接 target 属性的取值和作用</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/14">CSS3 新增伪类有哪些并简要描述</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/15">写一个把字符串大小写切换的方法</a></li>
</ul>
<p>1、【html】 简述超链接 target 属性的取值和作用</p>
<p><code>a</code> 标签的 <code>target</code> 属性一共有四个值。</p>
<ul>
<li><p><code>_self</code></p>
<p>默认属性。在当前窗口或者框架中加载目标文档。</p>
</li>
<li><p><code>_blank</code></p>
<p>打开新的窗口或者新的标签页。在使用这个属性时，最好添加 <code>rel=&quot;noopener norefferrer&quot;</code> 属性，防止打开的新窗口对原窗口进行篡改。防止 <code>window.opener</code> API 的恶意行为。</p>
</li>
<li><p><code>_parent</code></p>
<p>在 <code>frame</code> 或者 <code>iframe</code> 中使用较多。在父级框架中载入目标文档，当 <code>a</code> 标签本身在顶层时，与 <code>_self</code> 相同。</p>
</li>
<li><p><code>_top</code></p>
<p>在 <code>frame</code> 或者 <code>iframe</code> 中使用较多。直接在顶层的框架中载入目标文档，加载整个窗口。</p>
</li>
</ul>
<p>2、【css】CSS3 新增伪类有哪些并简要描述</p>
<p>CSS3 中规定伪类使用一个 <code>:</code> 来表示；伪元素则使用 <code>::</code> 来表示。</p>
<p>CSS3 中新增的伪元素有以下这些:</p>
<ul>
<li><code>:first-child / :last-child</code> 表示子元素结构关系的</li>
<li><code>:nth-child() / nth-last-child()</code> 用来控制奇数、偶数行的（控制表单奇数、偶数行的样式）</li>
<li><code>:first-of-type / :last-of-type</code> 表示一组兄弟元素中其类型的第一个元素 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-of-type">MDN</a></li>
<li><code>:nth-of-type() / :nth-last-of-type()</code> 这个选择器匹配那些在相同兄弟节点中的位置与模式 an+b 匹配的相同元素` <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-of-type">MDN</a></li>
<li><code>:root</code> html 根元素</li>
<li><code>:not()</code> 否定选择器，用的比较多</li>
<li><code>:only-child</code> 只有一个子元素时才会生效</li>
<li><code>:empty</code> 选择连空格都没有的元素</li>
</ul>
<p>3、【js】写一个把字符串大小写切换的方法</p>
<p>正则表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">caseConvert</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/([a-z]*)([A-Z]*)/g</span>, <span class="function">(<span class="params">m, s1, s2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;s1.toUpperCase()&#125;</span><span class="subst">$&#123;s2.toLowerCase()&#125;</span>`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 toUpperCase() ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aBcDeFgH&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === item.toUpperCase()) &#123;</span><br><span class="line">    item = item.toLowerCase();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    item = item.toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">  arr.push(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newStr = arr.join(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="第-6-天-2019-09-24"><a href="#第-6-天-2019-09-24" class="headerlink" title="第 6 天 (2019.09.24)"></a>第 6 天 (2019.09.24)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/16">label 都有哪些作用？并举相应的例子说明</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/17">用 css 创建一个三角形，并简述原理</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/18">写一个去除制表符和换行符的方法</a></li>
</ul>
<p>1、【html】label 都有哪些作用？并举相应的例子说明</p>
<p><strong>解析</strong>:</p>
<ol>
<li>互相关联的机制</li>
</ol>
<p>表示用户界面中某个元素的说明<br>增加命中区域，屏幕阅读器可以读出标签。使使用辅助技术的用户更容易理解输入 哪些数据</p>
<ol start="2">
<li>利用<code>label</code>“模拟”<code>button</code>来解决不同浏览器原生<code>button</code>样式不同的问题</li>
<li>结合<code>checkbox</code>、<code>radio</code>表单元素实现纯 CSS 状态切换，这样的实例就太多了。比如控制 CSS 动画播放和停止。下面是一部分代码。<a target="_blank" rel="noopener" href="https://codepen.io/mts123/pen/EzqdbM">详细实例地址</a>*</li>
<li><code>input</code>的<code>focus</code>事件会触发锚点定位，我们可以利用<code>label</code>当触发器实现选项卡切换效果。下面代码选自张鑫旭《CSS 世界》</li>
</ol>
<p>2、【css】用 css 创建一个三角形，并简述原理</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、【js】写一个去除制表符和换行符的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = str.replace(<span class="regexp">/\t\n\v\r\f+/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-7-天-2019-09-25"><a href="#第-7-天-2019-09-25" class="headerlink" title="第 7 天 (2019.09.25)"></a>第 7 天 (2019.09.25)</h3><p><strong>总览</strong> ：</p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/19">iframe 框架都有哪些优缺点？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/20">简述你对 BFC 规范的理解</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/21">统计某一字符或字符串在另一个字符串中出现的次数</a></li>
</ul>
<p>1、【html】iframe 框架都有哪些优缺点？</p>
<p>iframe 是一种框架，也是一种很常见的网页嵌入方式</p>
<p><strong>iframe 的优点：</strong></p>
<p>1.iframe 能够原封不动的把嵌入的网页展现出来。</p>
<p>2.如果有多个网页引用 iframe，那么你只需要修改 iframe 的内容，就可以实现调用的每一个页面内容的更改，方便快捷。</p>
<p>3.网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用 iframe 来嵌套，可以增加代码的可重用。</p>
<p>4.如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由 iframe 来解决。</p>
<p><strong>iframe 的缺点</strong> ：</p>
<p>1.会产生很多页面，不容易管理。</p>
<p>2.iframe 框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。</p>
<p>3.代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理 iframe 中的内容，所以使用 iframe 会不利于搜索引擎优化。</p>
<p>4.很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。</p>
<p>5.iframe 框架页面会增加服务器的 http 请求，对于大型网站是不可取的。</p>
<p>分析了这么多，现在基本上都是用 Ajax 来代替 iframe，所以 iframe 已经渐渐的退出了前端开发</p>
<p>2.【css】简述你对 BFC 规范的理解</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5909db2fda2f60005d2093db">[布局概念] 关于 CSS-BFC 深入理解</a></p>
</blockquote>
<p><strong>块格式化上下文（Block Formatting Context，BFC）</strong> 是 Web 页面的可视化 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BFC：是CSS中的一个渲染机制，BFC就相当于一个盒子，内部的元素与外界的元素互不干扰。它不会影响外部的布局，外部的布局也不会影响到它。</span><br><span class="line"></span><br><span class="line">形成条件（任意一条）</span><br><span class="line">    float的值不是none</span><br><span class="line">    position 的值不是static或者relative</span><br><span class="line">    display的值是inline-block,table-cell,flex,table-caption或者inline-flex</span><br><span class="line">    overflow的值不是visible</span><br><span class="line"></span><br><span class="line">特性</span><br><span class="line">    内部的盒子会在垂直方向上一个接一个的放置</span><br><span class="line">    对于同一个BFC的俩个相邻的盒子的margin会发生重叠，与方向无关。</span><br><span class="line">    每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此</span><br><span class="line">    BFC的区域不会与float的元素区域重叠</span><br><span class="line">    计算BFC的高度时，浮动子元素也参与计算</span><br><span class="line">    BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】 统计某一字符或字符串在另一个字符串中出现的次数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strCount</span>(<span class="params">str, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (!target) <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">while</span>(str.match(target)) &#123;</span><br><span class="line">        str = str.replace(target, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-8-天-2019-09-26"><a href="#第-8-天-2019-09-26" class="headerlink" title="第 8 天 (2019.09.26)"></a>第 8 天 (2019.09.26)</h3><p>总览：</p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/22">简述下 html5 的离线储存原理，同时说明如何使用？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/23">清除浮动的方式有哪些及优缺点？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/24">写一个加密字符串的方法</a></li>
</ul>
<p>1、【html】 简述下 html5 的离线储存原理，同时说明如何使用？</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">原理：</span><br><span class="line">HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</span><br><span class="line">如何使用： ①　页面头部像下面一样加入一个manifest的属性。</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">&quot;cache.manifest&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">在cache.manifest文件的编写离线存储的资源。 CACHE MANIFEST #v0.1 CACHE:</span><br><span class="line">js/index.js css/index.css NETWORK: images/logo.png FALLBACK: *.html /404.html /*</span><br><span class="line">/ /404.html 或 /html/ /404.html 也可*/</span><br><span class="line">以#号开头的是注释，一般会在第二行写个版本号，用来在缓存的文件更新时，更新manifest以实现浏览器重新下载新的文件，可以是版本号，时间戳或md5码等。</span><br><span class="line">离线存储的 manifest一般由三个部分组成：</span><br><span class="line">①　CACHE：必选，表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</span><br><span class="line">②　NETWORK：可选，可以使用通配符，表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。</span><br><span class="line">③　FALLBACK：可选，表示如果访问第一个资源失败，那么就使用第二个资源来替换他，如/html/</span><br><span class="line">/404.html表示用 “404.html” 替代 /html/ 目录中的所有文件，/ /404.html表示用</span><br><span class="line">“404.html” 替代当前目录中的所有文件，*.html /404.html表示用 “404.html” 替代</span><br><span class="line">所有html文件。</span><br></pre></td></tr></table></figure>

<p>2、【css】清除浮动的方式有哪些及优缺点？</p>
<p>唠叨：</p>
<ul>
<li>在现在的实际工作当中我已经很少用浮动来布局了，真的很少，刚开始学习的时候用的还蛮多，现在 Flex 布局，标准文档流以及 定位 已经可以满足大部分的布局需求了。</li>
<li>浮动带来的问题是盒子塌陷问题，所以我们就来解决这个问题吧</li>
</ul>
<p><strong>解决方案</strong></p>
<ol>
<li>给外部盒子也添加浮动</li>
</ol>
<p>把外部盒子也从标准文档流中抽离，让它和孩子们见面。<br><strong>缺点</strong> ：可读性差，不易于维护（别人很难理解为什么要给父元素也添上 float），而且可能需要调整整个页面布局。</p>
<ol start="2">
<li>在外部盒子内最下方添上带 clear 属性的空盒子</li>
</ol>
<p>可以是 div 也可以是其它块级元素，把 <code>&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</code>放在盒内底部，用最下面的空盒子清除浮动，把盒子重新撑起来。<br><strong>缺点</strong>：引入了冗余元素</p>
<ol start="3">
<li>用 overflow:hidden 清除浮动 ，外层父元素使用 <code>overflow:hidden;</code> 属性触发 BFC，让内层的 <code>float</code> 不会影响外层的布局</li>
</ol>
<p>给外部盒子添上这个属性就好了，非常简单。<br><strong>缺点</strong> ：有可能造成溢出元素不可见，影响展示效果。</p>
<ol start="4">
<li>用 after 伪元素清除浮动 ( 比较常用的方式 )</li>
</ol>
<p>给外部盒子的 after 伪元素设置 clear 属性，再隐藏它<br>这其实是对空盒子方案的改进，一种纯 CSS 的解决方案，不用引入冗余元素。</p>
<p>3、【js】 简要描述下什么是回调函数并写一个例子出来</p>
<blockquote>
<p>回调是把一个函数作为参数传递给另一个函数，当该函数满足某个条件时触发该参数函数。<br>主要用于异步操作 例如网络请求 防止页面同步代码阻塞导致渲染线程停止</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longTask</span>(<span class="params">callback, timeout</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(callback, timeout);</span><br><span class="line">&#125;</span><br><span class="line">longTask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;回调任务被执行了&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;我是同步代码 不会阻塞我&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="第-9-天-2019-09-27"><a href="#第-9-天-2019-09-27" class="headerlink" title="第 9 天 (2019.09.27)"></a>第 9 天 (2019.09.27)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/25">浏览器内多个标签页之间的通信方式有哪些？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/26">简述下你理解的优雅降级和渐进增强</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/27">写一个判断数据类型的方法</a></li>
</ul>
<p>1、【html】浏览器内多个标签页之间的通信方式有哪些？</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5acdba01f265da23826e5633">实现多个标签页之间通信的几种方法</a></p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">完全答案：</span><br><span class="line">    WebSocket （可跨域）</span><br><span class="line">    postMessage（可跨域）</span><br><span class="line">    Worker之SharedWorker</span><br><span class="line">    Server-Sent Events</span><br><span class="line">    localStorage</span><br><span class="line">    BroadcastChannel</span><br><span class="line">    Cookies</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】 简述下你理解的优雅降级和渐进增强</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013818745">前端面试题-渐进增强和优雅降级</a></p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简介：渐进增强和优雅降级这两个概念是在 CSS3 出现之后火起来的。由于低级浏览器不支持 CSS3，但是 CSS3 特效太优秀不忍放弃，所以在高级浏览器中使用 CSS3，而在低级浏览器只保证最基本的功能。</span><br><span class="line"></span><br><span class="line">优雅降级：</span><br><span class="line">	先不考虑兼容，优先最新版本浏览器效果，之后再逐渐兼容低版本浏览器。</span><br><span class="line"></span><br><span class="line">渐进增强：</span><br><span class="line">    考虑兼容，以较低（多）浏览器效果为主，之后再逐渐增加对新版本浏览器的支持，以内容为主。也是多数公司所采用的方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】 写一个判断数据类型的方法</p>
<blockquote>
<p>考点：Object.prototype.toString 方法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> typeCheck = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> typeStr = <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line">  <span class="built_in">console</span>.log(typeStr);</span><br><span class="line">  <span class="keyword">return</span> typeStr.toLowerCase().slice(<span class="number">8</span>, typeStr.length - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第-10-天-2019-09-28"><a href="#第-10-天-2019-09-28" class="headerlink" title="第 10 天 (2019.09.28)"></a>第 10 天 (2019.09.28)</h3><p><strong>总览</strong> ：</p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/28">viewport 常见设置都有哪些？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/29">对比下 px、em、rem 有什么不同？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/30">简要描述下什么是回调函数并写一个例子出来</a></li>
</ul>
<p>1、【html】 viewport 常见设置都有哪些？</p>
<p><strong>解析</strong> ：</p>
<p>在移动端做开发时，必须要搞清楚 <code>viewport</code> 这一设置。</p>
<p><code>viewport</code> 就是视区窗口，也就是浏览器中显示网页的部分。PC 端上基本等于设备显示区域，但在移动端上 <code>viewport</code> 会超出设备的显示区域（即会有横向滚动条出现）。<br>设备默认的 <code>viewport</code> 在 980 - 1024 之间。</p>
<p>为了让移动端可以很好地显示页面，因此需要对 <code>viewport</code> 进行设置。相关的设置值如下：</p>
<p><img src="http://static.zxinc520.com/blog/20190928/QQxtaIhl4ArA.png?imageslim" alt="mark"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// width=device-width, initial-scale=1.0 是为了兼容不同浏览器</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、【css】 对比下 px、em、rem 有什么不同？</p>
<ul>
<li>px: 绝对固定的值，无论页面放大或者缩小都不会改变。</li>
<li>em: 相对父元素字体大小的倍数。如果父元素的字体为 <code>12px</code>，那么子元素 <code>1em</code> 就是 <code>24px</code>。由于是相对父级的倍数，所以多层嵌套时，倍数关系的计算会很头痛。</li>
<li>rem: 相对根元素字体大小的倍数。相对于 <code>html</code> 的字体大小，如果不做任何修改，浏览器默认字体大小为 <code>16px</code>。</li>
</ul>
<blockquote>
<p><strong>小技巧</strong></p>
</blockquote>
<p>如果为了方便计算 <code>rem</code>，可以设置 <code>font-size= 62.5%</code> 这样一来默认的字体就变成 <code>10px</code> 了。之后的 <code>rem</code> 就是以 <code>10</code> 为基准了。</p>
<p>3、【js】 简要描述下什么是回调函数并写一个例子出来</p>
<p>回调函数首先作为一个函数的参数传入，当这个函数执行后再执行的函数，往往会依赖前一个函数执行的结果。<br>在 <code>javascript</code> 中，对于 I/O、HTTP 请求等异步操作，为了控制执行的顺序就需要使用回调的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三个参数就是回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">param1, param2, ..., callback</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// To do some action</span></span><br><span class="line">  <span class="comment">// 往往会在最后调用 callback 并且传入操作过的参数</span></span><br><span class="line">  callback(cbParam1, cbParam2, ...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际调用的时候</span></span><br><span class="line">func1(param1, param2, ..., <span class="function">(<span class="params">cbParam1, cbParam2, ...</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// To do some action</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当有过个任务需要顺序执行时，如果采用回调函数的形式就会出现我们熟悉的“回调地狱”的情况。为了解决这个问题，在 ES6 中就有了 <code>Promise</code> 和 <code>async/await</code> 方法。<br>目前看来 <code>async/await</code> 在异步写法上较为优雅。</p>
<h3 id="第-11-天-2019-09-29"><a href="#第-11-天-2019-09-29" class="headerlink" title="第 11 天 (2019.09.29)"></a>第 11 天 (2019.09.29)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/31">你对标签语义化的理解是什么？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/32">css 常用的布局方式有哪些？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/33">简要描述下 JS 有哪些内置的对象</a></li>
</ul>
<p>1、【html】 你对标签语义化的理解是什么？</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">①去掉或者丢失样式的时候能够让页面呈现出清晰的结构；</span><br><span class="line"></span><br><span class="line">②有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</span><br><span class="line"></span><br><span class="line">③方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</span><br><span class="line"></span><br><span class="line">④便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】css 常用的布局方式有哪些？</p>
<ul>
<li><p>流式布局: 最基本的布局，就是顺着 html 像流水一样流下来</p>
</li>
<li><p>绝对定位: 利用 <code>position: absolute</code> 进行绝对定位的布局</p>
</li>
<li><p>float 布局: 最初用来解决多栏布局的问题。比如圣杯、双飞燕的布局都可以用 <code>float</code> 来实现</p>
</li>
<li><p>珊格布局: bootstrap 用的布局，把页面分为 24 分，通过 row 和 col 进行布局</p>
</li>
<li><p>flex 布局: css3 的布局可以非常灵活地进行布局和排版</p>
</li>
<li><p>grid 布局: 网格布局</p>
<p>3.【js】简要描述下 JS 有哪些内置的对象？</p>
</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000011467723">JS 所有内置对象属性和方法汇总</a></p>
</blockquote>
<p><strong>JavaScript 有 3 大对象，分别是本地对象、内置对象和宿主对象。</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">本地对象：这些引用类型在运行过程中需要通过new来创建所需的实例对象。</span><br><span class="line">包含：Object、Array、Date、RegExp、Function、Boolean、Number、String等。</span><br><span class="line"></span><br><span class="line">内置对象：内置对象是本地对象的子集。</span><br><span class="line">包含：Global和Math。</span><br><span class="line">ECMAScript5中增添了JSON这个存在于全局的内置对象。</span><br><span class="line"></span><br><span class="line">宿主对象：对于嵌入到网页中的JS来说，其宿主对象就是浏览器提供的对象，浏览器对象有很多，如Window和Document等。</span><br><span class="line">所有的DOM和BOM对象都属于宿主对象。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-12-天-2019-09-30"><a href="#第-12-天-2019-09-30" class="headerlink" title="第 12 天 (2019.09.30)"></a>第 12 天 (2019.09.30)</h3><p><strong>总览</strong> ：</p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/34">常见的浏览器内核都有哪些？并介绍下你对内核的理解</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/35">说说你对 css 盒子模型的理解</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/36">写一个获取当前 url 查询字符串中的参数的方法</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/37">网页应用从服务器主动推送到客户端有那些方式？</a></li>
</ul>
<p>1、【html】常见的浏览器内核都有哪些？并介绍下你对内核的理解</p>
<p><strong>常见的浏览器内核：</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Trident内核：IE，360，搜过浏览器；</span><br><span class="line">Gecko内核：Netscape6及以上版本，</span><br><span class="line">Presto内核：Opera</span><br><span class="line">Blink内核：Opera；</span><br><span class="line">Webkit内核：Safari，Chrome</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>介绍一下对浏览器内核的理解</strong></p>
<blockquote>
<p>主要分成两个部分：渲染引擎(Render Engine)和 JS 引擎。</p>
</blockquote>
<p><strong>渲染引擎</strong>：负责取得网页的内容(html,xml 和图像等)，整理讯息(例如假如 css)，以及计算网页的显示方式，然后输出到显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不同。所有网页浏览器、电子邮件客户端以及它需要编辑、显示网络内容的应用程序都需要内核。</p>
<p><strong>JS 引擎</strong>：解析和执行 JavaScript 来实现网页的动态效果。</p>
<p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向与只指渲染引擎。</p>
<p>2.【css】说说你对 css 盒子模型的理解？</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015235886">面试官：谈谈你对 CSS 盒模型的认识?（你确定会？）</a></p>
</blockquote>
<p>涉及知识点(层层递进):</p>
<blockquote>
<ol>
<li>基本概念：标准模型+ IE 模型(区别)</li>
<li>CSS 如何设置这两种模型</li>
<li>JS 如何设置获取盒子模型对应的宽和高</li>
<li>实例题(根据盒模型解释边距重叠)</li>
<li>BFC(边距重叠解决方案)</li>
</ol>
</blockquote>
<p><strong>1.基本概念：标准模型+IE 模型</strong></p>
<p>标准盒子模型：包括 margin,border,padding,content,<u>并且 content 部分不包括其他部分</u><br>IE 盒子模型：包括 margin,border,padding,content，<u>content 包含了 border 和 padding</u></p>
<p><strong>2.css 如何设置这两种模式</strong></p>
<p>标准盒模型：box-sizing:content-box<br>IE 盒模型：box-sizing:border-box</p>
<p><strong>3.js 如何设置获取盒子模型对应的宽和高</strong></p>
<ol>
<li>dom.style.width:</li>
</ol>
<blockquote>
<p>只能获取内联样式，因此是不准确的</p>
</blockquote>
<ol start="2">
<li>dom.currentStyle.width</li>
</ol>
<blockquote>
<p>与 window.getComputedStyle 方法功能相同，实现在旧版本的 IE 浏览器中<br>3）window.getComputedStyle(dom).width:<br>方法返回一个对象，该对象在应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有 CSS 属性值。因此输出是准确的<br>4）dom.getBoundingClientRect().width<br>返回一个 DOMRect 对象，这个对象是由该元素的 getClientRects()方法返回的一组矩形的集合。<br>DOMRect 对象包含了一组用于描述边框的只读属性–left,top,right,bottom,单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的。</p>
</blockquote>
<p>3、【js】 写一个获取当前 url 查询字符串中的参数的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	例如网址：http://zxinc520.com/?a=hello&amp;b=world</span></span><br><span class="line"><span class="comment">	window.location.search = &quot; ?a=hello&amp;b=world &quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">params</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> search = <span class="built_in">window</span>.location.search;</span><br><span class="line">  search = search.substr(<span class="number">1</span>, search.length);</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (!search) <span class="keyword">return</span> res;</span><br><span class="line">  search.split(<span class="string">&quot;&amp;&quot;</span>).map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [key, value] = item.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">    res[key] = <span class="built_in">decodeURIComponent</span>(value);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、【软技能】 网页应用从服务器主动推送到客户端有那些方式？</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. html5 websocket</span><br><span class="line">2. WebSocket 通过 Flash</span><br><span class="line">3. XHR长时间连接</span><br><span class="line">4. XHR Multipart Streaming</span><br><span class="line">5. 不可见的Iframe</span><br><span class="line">6. &lt;script&gt;标签的长时间连接(可跨域)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-13-天-2019-10-08"><a href="#第-13-天-2019-10-08" class="headerlink" title="第 13 天 (2019.10.08)"></a>第 13 天 (2019.10.08)</h3><p>总览：</p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/38">html5 中的 form 怎么关闭自动完成？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/39">::before 和:after 中单冒号和双冒号的区别是什么，这两个伪元素有什么作用？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/40">说说你对 javascript 的作用域的理解</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/41">http 都有哪些状态码？</a></li>
</ul>
<p>1、【html】 html5 中的 form 怎么关闭自动完成？</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h5新增的补全功能，菜鸟教程上写的比较含糊比较难懂；</span><br><span class="line">解释： 在部分浏览器上，foucs输入框可以把之前输入过的值自动填入，如果不想自动填入，可以关掉它；</span><br><span class="line">autocomplete=&quot;off&quot;</span><br><span class="line">默认是&quot;on&quot; 开启状态</span><br><span class="line"></span><br><span class="line">一般业务下不会调整这个自动完成，因为对产品来说简化用户操作，建议打开</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】::before 和:after 中单冒号和双冒号的区别是什么，这两个伪元素有什么作用？</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:表示伪类，是一种样式，比如:hover, :active等</span><br><span class="line">::表示伪元素，是具体的内容，比如::before是在元素前面插入内容，::after则是在元素后面插入内容，不过需要content配合，并且插入的内容是inline的。</span><br><span class="line">:before和:after其实还是表示伪元素，在css3中已经修订为::before和::after了，只是为了能兼容IE浏览器，所以也可以表示成:before和:after</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:: 和 : 是 CSS3 中为了区别伪类和伪元素所用的不同的写法。:: 表示伪元素，目前两种写法都被兼容。</span><br><span class="line">::before,::after 可以在一个 DOM 元素的前面和后面增加一个伪元素。可以用来清除浮动、为元素增加特殊效果（如前面有特殊符号等）。</span><br><span class="line">::before 和 ::after 默认添加的是 inlne 元素，通过 content 属性来设置展示的内容，并且必须要设置 content 属性。content 属性可以利用 attr 与元素的相关内容做联动。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】说说你对 javascript 的作用域的理解？</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、全局作用域。这个没啥说的，就是在顶层环境中申明的变量都是全局作用域，他们的属性其实都在window对象下面。</span><br><span class="line"></span><br><span class="line">2、函数作用域。在函数内部定义的变量都是函数作用域，只能在函数中访问到，当然也可以通过闭包来访问。除此之外，在其他地方是没法访问函数内部的变量的。</span><br><span class="line">局部作用域。es6中新增的特性，弥补了以前只能使用匿名及时运行函数来创建局部变量的缺陷。使用很简单，直接用let来申明变量就行。也可以使用const来申明变量，表明这是常数。</span><br><span class="line"></span><br><span class="line">3、作用域链。要说清这个，需要首先明白javascript的代码运行过程。假设现在有个函数funcA，在该函数内部申明了一个局部变量a，在函数内部又定义了一个函数funcB，在函数B中申明了变量b。如下：</span><br><span class="line">    function funcA () &#123;</span><br><span class="line">    let a;</span><br><span class="line">    function funcB () &#123;</span><br><span class="line">    let b;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">当进入funcA时，这时候会把变量a压入当前的作用域A中，并且将作用域A入栈，当进入funcB时，则会把变量b压入当前的作用域B中，并且将作用域B入栈，那么这时候栈中就有了作用域A和作用域B，当在funcB中查找某个变量时，会先从当前的作用域B中查找，如果没有的话，那么就根据栈中的作用域依次往上查找，这就是作用域链。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4、【软技能】http 都有哪些状态码？</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">200 成功</span><br><span class="line">301 重定向</span><br><span class="line">304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</span><br><span class="line">400 (错误请求) 服务器不理解请求的语法。</span><br><span class="line">403 (禁止) 服务器拒绝请求。</span><br><span class="line">404 (未找到) 服务器找不到请求的网页。</span><br><span class="line">500 (服务器内部错误) 服务器遇到错误，无法完成请求。</span><br><span class="line">501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</span><br><span class="line">502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。</span><br><span class="line">503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。</span><br><span class="line">504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</span><br><span class="line">505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。</span><br><span class="line"></span><br><span class="line">常见状态码：</span><br><span class="line">    2xx 成功</span><br><span class="line">    3xx 重定向</span><br><span class="line">    4xx 未找到资源</span><br><span class="line">    5xx 服务器异常</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-14-天-2019-10-09"><a href="#第-14-天-2019-10-09" class="headerlink" title="第 14 天 (2019.10.09)"></a>第 14 天 (2019.10.09)</h3><p><strong>总览</strong> ：</p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/42">为什么 HTML5 只需要写&lt;_!DOCTYPE HTML_ &gt;就可以？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/43">position:fixed;在 ios 下无效该怎么办？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/44">什么是闭包？优缺点分别是什么？</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/45">你最喜欢用哪些编辑器？喜欢它的理由是什么？</a></li>
</ul>
<p>1、【html】为什么 HTML5 只需要写&lt;_!DOCTYPE HTML_ &gt;就可以？</p>
<p><strong>解析</strong>：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE&gt;只是一个说明，用来告诉浏览器当前的html页面是用什么版本的html写的。</span><br><span class="line">html4.01的&lt;!DOCTYPE&gt;引用了DTD（document type define），因为html4.01是基于SGML的，而它引用的DTD指明了html的规则，从而浏览器能正确的渲染页面。而html5不是基于SGML所以不需要引用DTD。</span><br><span class="line"></span><br><span class="line">翻译一下：SGML，即一般标准标记语言，是一个用于定义文档标记语言标准的集合。</span><br><span class="line">总结一下：因为html4是基于SGML这个标记语言的集合，既然是集合说明里面有各种的标准，那么DTD就是指出了当前html文件是用的是哪个SGML规则。</span><br><span class="line">html5不存在这个问题，所以只需要简单的声明浏览器就可以正确渲染页面啦</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】 position:fixed;在 ios 下无效该怎么办？</p>
<p>当采用 <code>fixed</code> 做吸底、吸顶布局时，如果触发键盘弹出事件则 <code>fixed</code> 属性会失效，布局就会被扰乱。其原因解释如下：</p>
<blockquote>
<p>软键盘唤起后，页面的 fixed 元素将失效（即无法浮动，也可以理解为变成了 absolute 定位），所以当页面超过一屏且滚动时，失效的 fixed 元素就会跟随滚动了。</p>
</blockquote>
<p>第三方库 <code>isScroll.js</code> 可以解决此问题。</p>
<p>3、【js】 什么是闭包？优缺点分别是什么？</p>
<p><strong>解析</strong> ：</p>
<p>闭包是可以访问另一个函数作用域的函数。由于 <code>javascript</code> 的特性，外层的函数无法访问内部函数的变量；而内部函数可以访问外部函数的变量（即作用域链）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 这个函数就是个闭包，可以访问外层 a 函数的变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> b + c + d;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = a();</span><br><span class="line"><span class="built_in">console</span>.log(e());</span><br></pre></td></tr></table></figure>

<p>因此，使用闭包可以隐藏变量以及防止变量被篡改和作用域的污染，从而实现封装。<br>而缺点就是由于保留了作用域链，会增加内存的开销。因此需要注意内存的使用，并且防止内存泄露的问题。</p>
<p>4、【软技能】 你最喜欢用哪些编辑器？喜欢它的理由是什么？</p>
<p>解析：</p>
<p>webstorm ： 喜欢它不需要理由！</p>
<h3 id="第-15-天-2019-10-10"><a href="#第-15-天-2019-10-10" class="headerlink" title="第 15 天 (2019.10.10)"></a>第 15 天 (2019.10.10)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/46">title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/47">style 标签写在 body 前和 body 后的区别是什么？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/48">写一个数组去重的方法（支持多维数组）</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/49">对于加班你是怎么看的？</a></li>
</ul>
<p>1、【html】title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">关于 title 和 h1，title 是网页的标题。主要面向的对象是搜索引擎和通过搜索结果过来的人（面向外人，可以理解为报纸首页的标题）。而 h1 是网页内部的标题，是给已经进到页面的人看的（可以理解为报纸某个版面的大标题）。从人类的语境上来理解，两者并没有差别。</span><br><span class="line"></span><br><span class="line">b 与 strong 的效果人眼上是无法区分的。在语义上，b 仅表示加粗既装饰用，我们应该使用 CSS 而不应该使用 b；而 strong 则表示被包围的内容很重要，是语气上的感觉。对于搜索引擎来说，会把 b 和 strong 视为同一含义。因此我们在使用上需要注意。</span><br><span class="line"></span><br><span class="line">i 与 em 的区别类似 b 和 strong 的区别。i 用于斜体展示，我们应该使用 CSS 而不应该使用 i；而 em 则是对内容的强调，但程度没有 strong 那么高。同样，对搜索引擎来说，两者是没有区别的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】style 标签写在 body 前和 body 后的区别是什么？</p>
<blockquote>
<p>参考文章：<br><a target="_blank" rel="noopener" href="https://softwareengineering.stackexchange.com/questions/224422/will-it-be-a-wrong-idea-to-have-style-in-body">Will it be a wrong idea to have in &lt;_body_ &gt;?</a> &gt; <a target="_blank" rel="noopener" href="https://www.w3.org/TR/html52/document-metadata.html#the-style-element">W3C The style element</a> &gt; <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xianyulaodi/p/5198603.html">什么是 FOUC？如何避免 FOUC？</a> &gt; <a target="_blank" rel="noopener" href="https://bitsofco.de/understanding-the-critical-rendering-path/">Understanding the Critical Rendering Path</a></p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在 HTML4 的时候，不应该把 style 放到 body 中间。</span><br><span class="line"></span><br><span class="line">浏览器在渲染页面时 DOM 和 CSSOM 是并行的，然后两者结合形成 Render Tree 显示页面。从直觉上来说，style 写在 body 前不会对 DOM 的渲染进行阻塞；而写在 body 内会对 DOM 渲染进行阻塞。会产生 FOUC（Flash of Unstyled Content) 的现象，既一瞬间的白屏或者样式的突然变化（原因是 Render Tree 重新生成了）。</span><br><span class="line"></span><br><span class="line">不过 W3C 在 HTML5.2 的定义中对于 style 标签的使用的定义中是允许将 style 放到 body 中的。</span><br><span class="line"></span><br><span class="line">Contexts in which this element can be used:</span><br><span class="line">Where metadata content is expected.</span><br><span class="line">In a noscript element that is a child of a head element.</span><br><span class="line">In the body, where flow content is expected.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】写一个数组去重的方法（支持多维数组）</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5adc8e396fb9a07aa0479725">5 种方法实现数组扁平化</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5aed6110518825671b026bed">7 种方法实现数组去重</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.toString().split(<span class="string">&quot;,&quot;</span>).map(<span class="built_in">Number</span>))));</span><br><span class="line"><span class="comment">// [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</span></span><br></pre></td></tr></table></figure>

<p>4、【软技能】对于加班你是怎么看的？</p>
<ol>
<li>首先，始终要以工作效率为首要目标，不能出现为了加班而故意降低白天的工作效率。</li>
<li>其次，在保证了白天的工作效率以后，如果确实需要加班，则可以适度的加班，但不能超过 10 点，不然肯定影响第二天的效率。</li>
</ol>
<h3 id="第-16-天-2019-10-11"><a href="#第-16-天-2019-10-11" class="headerlink" title="第 16 天 (2019.10.11)"></a>第 16 天 (2019.10.11)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/50">元素的 alt 和 title 有什么区别？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/51">请描述 margin 边界叠加是什么及解决方案</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/52">返回到顶部的方法有哪些？把其中一个方法出来</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/53">你在的公司有没有做代码审查（CodeReview）？如果有是怎么做的？如果没有你觉得应该怎么做才更好？</a></li>
</ul>
<p>1、【html】元素的 alt 和 title 有什么区别？</p>
<p><strong>ALT 属性：</strong></p>
<p>最常见用在 <code>&lt;img&gt;</code> 标签上，那我们先来看下 <code>&lt;img&gt;</code> 标签的 <code>alt</code> 属性。</p>
<p><code>alt</code> 属性是一个必需的属性，它规定在图像无法显示时的替代文本。</p>
<p>假设由于下列原因用户无法查看图像，<code>alt</code> 属性可以为图像提供替代的信息：</p>
<ul>
<li>网速太慢</li>
<li><code>src</code> 属性中的错误</li>
<li>浏览器禁用图像</li>
<li>用户使用的是屏幕阅读器</li>
</ul>
<p>&lt;_img_ &gt;  标签的  alt  属性指定了替代文本，用于在图像无法显示或者用户禁用图像显示时，代替图像显示在浏览器中的内容</p>
<p>**TITLE 属性： **</p>
<p><code>title</code> 属性规定关于元素的额外信息。</p>
<p>这些信息通常会在鼠标移到元素上时显示一段工具提示文本（tooltip text）。</p>
<p>提示：<code>title</code> 属性常与 <code>form</code> 以及 <code>a</code> 元素一同使用，以提供关于输入格式和链接目标的信息。同时它也是 <code>abbr</code> 和 <code>acronym</code> 元素的必需属性。当然 <code>title</code> 属性是比较广泛使用的，可以用在除了<code>base</code>，<code>basefont</code>，<code>head</code>，<code>html</code>，<code>meta</code>，<code>param</code>，<code>script</code> 和 <code>title</code> 之外的所有标签。但是并不是必须的。</p>
<p><code>title</code> 属性有一个很好的用途，即为链接添加描述性文字，特别是当连接本身并不是十分清楚的表达了链接的目的。这样就使得访问者知道那些链接将会带他们到什么地方，他们就不会加载一个可能完全不感兴趣的页面。另外一个潜在的应用就是为图像提供额外的说明信息，比如日期或者其他非本质的信息。</p>
<p>2、【css】请描述 margin 边界叠加是什么及解决方案</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1，使用padding代替，但是父盒子要减去相应的高度</span><br><span class="line">2，使用boder（透明）代替（不推荐，不符合书写规范，如果父盒子子盒子时有颜色的不好处理）</span><br><span class="line">3，给父盒子设置overflow：hidden(如果有移除元素无法使用)</span><br><span class="line">4，给父盒子设置1px的padding</span><br><span class="line">5，给父盒子设置1px的透明border，高度减1px</span><br><span class="line">6，子盒子使用定位position</span><br><span class="line">7，子盒子浮动, 但是居中比较难以控制</span><br><span class="line">8，给子盒子设置display: inline-block;</span><br><span class="line">9，子盒子上面放一个table标签</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】 返回到顶部的方法有哪些？把其中一个方法写出来</p>
<ol>
<li>锚点</li>
</ol>
<p>使用锚点链接是一种简单的返回顶部的功能实现。该实现主要在页面顶部放置一个指定名称的锚点链接，然后在页面下方放置一个返回到该锚点的链接，用户点击该链接即可返回到该锚点所在的顶部位置</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;topAnchor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#topAnchor&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>scrollTop</li>
</ol>
<p>scrollTop 属性表示被隐藏在内容区域上方的像素数。元素未滚动时，scrollTop 的值为 0，如果元素被垂直滚动了，scrollTop 的值大于 0，且表示元素上方不可见内容的像素宽度</p>
<p>由于 scrollTop 是可写的，可以利用 scrollTop 来实现回到顶部的功能</p>
<p>[注意]关于页面的 scrollTop 的兼容问题详细内容<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaohuochai/p/5831640.html#anchor4">移步至此</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollTop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.scrollTop = <span class="built_in">document</span>.documentElement.scrollTop = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">btn.onclick = scrollTop;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/scrollTo">scrollTo()</a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/scroll">window.scroll()</a></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置滚动行为改为平滑的滚动</span></span><br><span class="line"><span class="built_in">window</span>.scrollTo(&#123;</span><br><span class="line">  top: <span class="number">1000</span>,</span><br><span class="line">  behavior: <span class="string">&quot;smooth&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.scroll(&#123;</span><br><span class="line">  top: <span class="number">100</span>,</span><br><span class="line">  left: <span class="number">100</span>,</span><br><span class="line">  behavior: <span class="string">&quot;smooth&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/scrollBy">Window.scrollBy()</a></li>
</ol>
<blockquote>
<p>在窗口中按指定的偏移量滚动文档。</p>
</blockquote>
<p>向下滚动一页：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.scrollBy(<span class="number">0</span>, <span class="built_in">window</span>.innerHeight);</span><br></pre></td></tr></table></figure>

<p>向上滚动一页：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.scrollBy(<span class="number">0</span>, -<span class="built_in">window</span>.innerHeight);</span><br></pre></td></tr></table></figure>

<p>使用 options：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.scrollBy(&#123;</span><br><span class="line">  top: <span class="number">100</span>,</span><br><span class="line">  left: <span class="number">100</span>,</span><br><span class="line">  behavior: <span class="string">&quot;smooth&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>4.【软技能】你在的公司有没有做代码审查（CodeReview）？如果有是怎么做的？如果没有你觉得应该怎么做才更好？</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、有独立的代码审查部门，定期发送邮件给相关人员，里面有本部门全部项目的代码质量统计，在代码过差时依次向上级发通知</span><br><span class="line">2、依据每个组内风格，有的组在每次合并生产环境都会review</span><br><span class="line">3、总的来说代码审查是好事，但如果出现咸鱼池塘以及产品流程不规范导致迭代需求过多而不合理，会造成很多困扰，自身也可能流于形式，一定要结合实际情况来看</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-17-天-2019-10-13"><a href="#第-17-天-2019-10-13" class="headerlink" title="第 17 天 (2019.10.13)"></a>第 17 天 (2019.10.13)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/54">你认为 table 的作用和优缺点是什么呢？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/55">解释下 CSS sprites 的原理和优缺点分别是什么？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/56">typeof(‘abc’)和 typeof ‘abc’都是 string, 那么 typeof 是操作符还是函数？</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/57">说说你对 SVN 和 GIT 的理解和区别</a></li>
</ul>
<p>1、【html】你认为 table 的作用和优缺点是什么呢？</p>
<p><strong>解析：</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点：样式简单，构建方便，兼容良好</span><br><span class="line">缺点：在于会多处非常多的 DOM 节点（想想一个 td 里面再来一个 table），会导致页面加载变慢、影响加载和渲染，维护麻烦，不利于 SEO（table 原本就不是用来布局的）。也因此，在 CSS 成熟之后，table 布局马上就变成历史了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】解释下 CSS sprites 的原理和优缺点分别是什么？</p>
<p>CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position 可以用数字精确的定位出<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87">背景图片</a>的位置。</p>
<p><strong>优点：</strong></p>
<ul>
<li>减少网页的 http 请求，大大的提高页面的性能</li>
<li>减少图片的字节</li>
<li>解决了网页设计师在图片命名上的困扰</li>
<li>更换风格方便，维护起来更加方便</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>在图片合并的时候，要留好足够的空间，防止板块内出现不必要的背景；最痛苦的是在宽屏，高分辨率的屏幕下的自适应页面，你的图片如果不够宽，很容易出现背景断裂；</li>
<li>CSS Sprites 在开发的时候比较麻烦，通过<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/photoshop">photoshop</a>或其他工具测量计算每一个背景单元的精确位置</li>
</ul>
<p>3、【js】typeof(‘abc’)和 typeof ‘abc’都是 string, 那么 typeof 是操作符还是函数？</p>
<p><code>typeof</code> 是<strong>操作符</strong>，不是函数。可以添加括号，但是括号的作用是进行分组而非函数的调用。</p>
<blockquote>
<p>参考自 &lt;JavaScript 高级程序设计&gt;</p>
</blockquote>
<p>4、【软技能】 说说你对 SVN 和 GIT 的理解和区别 ？</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bfec042349ca">话说 Svn 与 Git 的区别</a></p>
<ul>
<li><p><strong>最核心的区别</strong> ：Git 是<strong>分布式</strong>SCM，而 SVN 是基于<strong>服务器</strong>的，也就是说每个开发者本地都有一套 git 库，每个人维护自己的版本（或者合并其他人的版本），而 SVN 是每个人写完代码后都及时的 checkin 到服务器上，进行合并。</p>
</li>
<li><p>Git 把内容按元数据方式存储，而 SVN 是按文件</p>
</li>
<li><p>Git 没有一个全局版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。</p>
</li>
<li><p>Git 的内容的完整性要优于 SVN: GIT 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</p>
</li>
<li><p>Git 下载下来后，在 OffLine 状态下可以看到所有的 Log,SVN 不可以。</p>
</li>
<li><p>刚开始用时很狗血的一点，SVN 必须先 Update 才能 Commit,忘记了合并时就会出现一些错误，git 还是比较少的出现这种情况。</p>
</li>
<li><p>克隆一份全新的目录以同样拥有五个分支来说，SVN 是同时复製 5 个版本的文件,也就是说重复五次同样的动作。而 Git 只是获取文件的每个版本的 元素，然后只载入主要的分支(master)在我的经验,克隆一个拥有将近一万个提交(commit),五个分支,每个分支有大约 1500 个文件的 SVN,耗了将近一个小时！而 Git 只用了区区的 1 分钟！</p>
</li>
<li><p>版本库（repository):SVN 只能有一个指定中央版本库。当这个中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。而 Git 可以有无限个版本库。</p>
<p>…..</p>
</li>
</ul>
<p>最后总结一下：</p>
<p>SVN 的特点是简单，只是需要一个放代码的地方时用是 OK 的。</p>
<p>Git 的特点版本控制可以不依赖网络做任何事情，对分支和合并有更好的支持(当然这是开发者最关心的地方)，不过想各位能更好使用它，需要花点时间尝试下。</p>
<h3 id="第-18-天-2019-10-14"><a href="#第-18-天-2019-10-14" class="headerlink" title="第 18 天 (2019.10.14)"></a>第 18 天 (2019.10.14)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/58">怎样在页面上实现一个圆形的可点击区域？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/59">什么是 FOUC？你是如何避免 FOUC 的？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/60">你理解的”use strict”;是什么?使用它有什么优缺点？</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/61">你如何看待团建的？你们团建一般都怎么实施？</a></li>
</ul>
<p>1、【html】怎样在页面上实现一个圆形的可点击区域？</p>
<ul>
<li>DOM 元素配合 <code>border-radius: 50%</code> 即可实现圆形点击区域。<a target="_blank" rel="noopener" href="https://codepen.io/Konata9/pen/zgNJVy?editors=1111">例子</a></li>
<li>利用 <code>&lt;map&gt;</code> 和 <code>&lt;area&gt;</code> 标签设置圆形点击区域。参考文章:<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2017/05/html-area-map/">HTML 标签及在实际开发中的应用</a></li>
<li>利用 SVG 作出圆形，然后添加点击事件。</li>
<li>如果在 <code>canvas</code> 上，就需要画出圆形，然后计算鼠标的坐标是否落在圆内。</li>
</ul>
<p>2、【css】什么是 FOUC？你是如何避免 FOUC 的？</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xianyulaodi/p/5198603.html">什么是 FOUC？如何避免 FOUC？</a></p>
<p><strong>什么叫做 FOUC 浏览器样式闪烁</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果使用import方法对css进行导入,会导致某些页面在Windows 下的Internet Explorer出现一些奇怪的现象</span><br><span class="line"></span><br><span class="line">以无样式显示页面内容的瞬间闪烁,</span><br><span class="line"></span><br><span class="line">这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>原因大致为：</p>
<ol>
<li>使用 import 方法导入样式表。</li>
<li>将样式表放在页面底部</li>
<li>有几个样式表，放在 html 结构的不同位置。</li>
</ol>
<p>其实原理很清楚：当样式表晚于结构性 html 加载，当加载到此样式表时，页面将停止之前的渲染。</p>
<p>此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。</p>
<p><strong>解决方法</strong> ：使用 link 标签将样式表放在文档 head 中</p>
<p>3、【js】 你理解的”use strict”;是什么?使用它有什么优缺点？</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-strict.html">JavaScript 严格模式(use strict)</a></p>
<blockquote>
<p>JavaScript 严格模式（strict mode）即在严格的条件下运行。</p>
</blockquote>
<p>严格模式，其实就是更严格了</p>
<blockquote>
<p>设立”严格模式”的目的，主要有以下几个：</p>
<ul>
<li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的 Javascript 做好铺垫。</li>
</ul>
</blockquote>
<p>我放几个常见的吧，详情可以去下面的文章中看</p>
<ol>
<li>禁止 this 关键字指向全局对象 （严格模式下的 全局中的 this 是 undefined 不是 window）</li>
<li>禁止在函数内部遍历调用栈</li>
<li>全局变量必须显式声明</li>
<li>arguments 不再追踪参数的变化</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  b = <span class="number">1</span>; <span class="comment">//Uncaught ReferenceError: b is not defined</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html">http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html</a></p>
<p>4、【软技能】你如何看待团建的？你们团建一般都怎么实施？</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">公司希望团建加强团队的凝聚力，大家可能在想：怎么可能能加强，吃喝玩乐，玩几个游戏就可以加强了？其实公司加强的是对公司有认可度的那群人的凝聚力，而不是那群打酱油，每天骂公司、摸鱼的那群人的凝聚力。</span><br><span class="line">团建人太多了确实没太大的意义，更多就是完成公司的政治任务，对外宣传。我经常是参加团建的时候去认识公司的那些高级领导，和他们聊聊天，混个脸熟。后面我更多就带着小组的人一起出去浪，或者带着其他想和我们一起出去浪的同事出去浪，很多时候都是 AA 或者公司出一小部分，因为只要走公司账，他们经常玩不尽兴，总想着钱太少，玩的没意思，并且又有占便宜的心理，总之会玩的不舒服，所以很多时候我们都是自费出去玩。大家都是在外面打工的一群人，周末有很大一部分人想出去玩但是一个人不知道干啥，所以有一群人出去玩就会玩的比较好。</span><br><span class="line">个人做法、看法，随意评价</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-19-天-2019-10-16"><a href="#第-19-天-2019-10-16" class="headerlink" title="第 19 天 (2019.10.16)"></a>第 19 天 (2019.10.16)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/62">说说你对 html 中的置换元素和非置换元素的理解</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/63">css 的属性 content 有什么作用呢？有哪些场景可以用到？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/64">“attribute”和”property”有什么不同？</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/65">最近都流行些什么？你经常会浏览哪些网站？</a></li>
</ul>
<p>1、【html】 说说你对 html 中的置换元素和非置换元素的理解 ？</p>
<p><strong>置换元素</strong></p>
<p>置换元素是指：浏览器根据元素的标签和属性，来决定元素的具体显示内容。</p>
<p>例如：浏览器根据&lt;_img_ &gt;标签的 src 属性显示图片。根据标签的 type 属性决定显示输入框还是按钮。</p>
<blockquote>
<p>置换元素在其显示中生成了框，这也就是有的内联元素能够设置宽高的原因。</p>
</blockquote>
<p>html 中的&lt;_img_&gt;&lt;_input_&gt;&lt;_textarea_&gt;&lt;_select_&gt;&lt;_object_&gt;都是置换元素，这些置换元素往往没有实际内容，即是一个空元素。</p>
<p><strong>非置换元素</strong></p>
<p>浏览器中的大多数元素都是不可置换元素，即其内容直接展示给浏览器。</p>
<p>例如&lt;_label_&gt;标签，&lt;_p_&gt;标签里的内容会被浏览器直接显示给用户。</p>
<p>2、【css】 css 的属性 content 有什么作用呢？有哪些场景可以用到？</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://xiangshuo.blog.csdn.net/article/details/89843456">CSS 属性 content 有什么作用呢？有哪些场景可以用到？</a> <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content">MDN:content</a></p>
<p>CSS 的 <code>content</code> CSS 属性用于在元素的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before"><code>::before</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after"><code>::after</code></a> 伪元素中插入内容。使用<code>content</code> 属性插入的内容都是匿名的<em>可替换元素。</em></p>
<p><strong>场景：</strong></p>
<ol>
<li><p>content: string value 字符串</p>
<p>可以加入任何字符，包括 Unicode 编码等各种字符。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://www.xunlei.com/&quot;</span> <span class="attr">title</span>=<span class="string">&quot;精彩，一下就有&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span>精彩，一下就有<span class="tag">&lt;/<span class="name">a</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"></span><br><span class="line">.demo:after&#123; content: &quot;↗&quot; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们还可以通过 <code>content</code> 内字符串的变化，实现类似 加载中… 的动画效果</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: dot <span class="number">1.6s</span> linear both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframe</span> dot &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  33% &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;..&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  66% &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;...&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20190508094105804.gif"></p>
<ol start="3">
<li>content: uri value 外部资源，用于引用媒体文件，图片，图标，SVG 等。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">url</span>(https://img-vip-ssl.a.<span class="number">88</span>cdn.com/img/xunleiadmin/<span class="number">5</span>b9889e14dcdc.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、【js】 “attribute”和”property”有什么不同？</p>
<p><strong>attribute</strong> 是我们在 <strong>html</strong> 代码中经常看到的键值对</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;the-input&quot;</span> type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;Name:&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中的 input 节点有三个 attribute:</p>
<ul>
<li>id : the-input</li>
<li>type : text</li>
<li>value : Name:</li>
</ul>
<p><strong>property</strong> 是 attribute 对应的 DOM 节点的 对象属性 (Object field),</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTMLInputElement.id === <span class="string">&quot;the-input&quot;</span>;</span><br><span class="line">HTMLInputElement.type === <span class="string">&quot;text&quot;</span>;</span><br><span class="line">HTMLInputElement.value === <span class="string">&quot;Name:&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>区别：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;the-input&quot;</span> type=<span class="string">&quot;typo&quot;</span> value=<span class="string">&quot;Name:&quot;</span> /&gt; <span class="comment">// 在页面加载后,</span></span><br><span class="line">我们在这个input中输入 <span class="string">&quot;Jack&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>让我们来看看上面这个 input 节点的 attribute 和 property:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attribute still remains the original value</span></span><br><span class="line">input.getAttribute(<span class="string">&quot;id&quot;</span>); <span class="comment">// the-input</span></span><br><span class="line">input.getAttribute(<span class="string">&quot;type&quot;</span>); <span class="comment">// typo</span></span><br><span class="line">input.getAttribute(<span class="string">&quot;value&quot;</span>); <span class="comment">// Name:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// property is a different story</span></span><br><span class="line">input.id; <span class="comment">// the-input</span></span><br><span class="line">input.type; <span class="comment">//  text</span></span><br><span class="line">input.value; <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>

<p>可以看到, 在 attribute 中, 值仍然是 html 代码中的值. 而在 property 中, type 被自动修正为了 <strong>text</strong>, 而 value 随着用户改变 input 的输入, 也变更为了 <strong>Jack</strong></p>
<p><strong>这就是 attribute 和 Property 间的区别:</strong></p>
<p>attribute 会始终保持 html 代码中的初始值, 而 Property 是有可能变化的.</p>
<blockquote>
<p>其实, 我们从这两个单词的名称也能看出些端倪:</p>
</blockquote>
<p><strong>attribute</strong> 从语义上, 更倾向于不可变更的</p>
<p>而 <strong>property</strong> 从语义上更倾向于在其生命周期中是可变的</p>
<p><strong>Attribute or Property 可以自定义吗?</strong> ：attribute 可以 property 不行</p>
<p>4、【软技能】最近都流行些什么？你经常会浏览哪些网站？</p>
<p>慕课网、掘金、github、stackoverflow/segmentfault、Google、相关技术官网文档</p>
<h3 id="第-20-天-2019-10-17"><a href="#第-20-天-2019-10-17" class="headerlink" title="第 20 天 (2019.10.17)"></a>第 20 天 (2019.10.17)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/66">请描述 HTML 元素的显示优先级</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/67">要让 Chrome 支持小于 12px 的文字怎么做？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/68">写一个验证身份证号的方法</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/69">你会手写原生 js 代码吗？</a></li>
</ul>
<p>1、【html】请描述 HTML 元素的显示优先级</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/868a7d16fb68">HTML 元素的显示优先级</a></p>
<p><strong>帧元素&gt;HTML 元素优先，表单元素总&gt;非表单元素优先</strong><br>层级显示优先级： <code>frameset &gt; 表单元素 &gt; 非表单元素</code></p>
<ul>
<li>表单元素包括：文本输入框，密码输入框，单选框，复选框，文本输入域，列表框等等；</li>
<li>非表单元素包括：连接（a），div,table,span 等。</li>
</ul>
<p>所有的 html 元素又可以根据其显示分成两类：有窗口元素以及无窗口元素。有窗口元素总是显示在无窗口元素的前面。<br>有窗口元素包括：select 元素，object 元素，以及 frames 元素等等。<br>无窗口元素：大部分 html 元素都是无窗口元素。</p>
<p>按照浏览器类型比较，HTML 元素的显示次序也有所不同：</p>
<p>2、【css】要让 Chrome 支持小于 12px 的文字怎么做？</p>
<p><strong>解析：</strong></p>
<p>Chrome 中有最小字号的限制，一般为 12px。原因是 Chrome 认为小于这个字号会影响阅读。</p>
<p>当需要小于 12px 字体的时候，有以下几个方法可以使用。</p>
<ul>
<li><p>-webkit-text-size-adjust:none; 这个属性在高版本的 Chrome 中已经被废除。</p>
</li>
<li><p>使用 <code>transform: scale(0.5, 0.5)</code>，但使用 transform</p>
<p>需要注意下面几点：</p>
<ul>
<li><code>transform</code> 对行内元素无效，因此要么使用 <code>display: block;</code> 要么使用 <code>display: inline-block;</code></li>
<li><code>transform</code> 即使进行了缩放，原来元素还是会占据对应的位置。因此需要做调整，最好是在外面再包一层元素，以免影响其他元素。</li>
</ul>
</li>
<li><p>作为图片。</p>
</li>
</ul>
<p>最好的办法还是进行切图，或者就不要使用小于 12px 的字体。</p>
<p>3、【js】 写一个验证身份证号的方法</p>
<blockquote>
<p>分析：身份证号码的组成：地址码 6 位+年份码 4 位+月份码 2 位+日期码 2 位+顺序码 3 位+校验码 1 位</p>
</blockquote>
<p><strong>解析：</strong></p>
<ol>
<li>粗暴型: 只考虑位数、最后的 x \d{17}[\dXx]</li>
<li>一般型: /^\d{6}\d{4}(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])\d{3}[\dXx]$/</li>
</ol>
<p>4、【软技能】你会手写原生 js 代码吗？</p>
<p><strong>解析：</strong></p>
<p>其实是要看你理解原生的定义了。不管现在用的什么框架，我们很多写的业务代码不都是原生的嘛。还有很多公用的方法，一般用的是原生的 js。</p>
<h3 id="第-21-天-2019-10-18"><a href="#第-21-天-2019-10-18" class="headerlink" title="第 21 天 (2019.10.18)"></a>第 21 天 (2019.10.18)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/70">谈谈你对 input 元素中 readonly 和 disabled 属性的理解</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/71">说说你对 line-height 是如何理解的？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/72">写一个方法验证是否为中文</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/73">来说说你对重绘和重排的理解，以及如何优化？</a></li>
</ul>
<p>1、【html】 谈谈你对 input 元素中 readonly 和 disabled 属性的理解</p>
<p><strong>解析：</strong></p>
<ul>
<li>相同点：都会使文本框变成只读，不可编辑。</li>
<li>不同点：<br>1.disabled 属性在将 input 文本框变成只读不可编辑的同时，还会使文本框变灰，但是 readonly 不会。<br>2.disabled 属性修饰后的文本框内容，在不可编辑的同时，通过 js 也是获取不到的。但是用 readonly 修饰后的文本框内容，是可以通过 js 获取到的，也就只是简单的不可编辑而已！<br>3.disabled 属性对 input 文本框，单选 radio,多选 checkbox 都适用，但是 readonly 就不适用，用它修饰后的单选以及多选按钮仍然是可以编辑状态的。</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">总结了前面老哥们的回答，再加上自己查了一下。</span><br><span class="line"></span><br><span class="line">在表现上 readonly 和 disabled 都不能让用户对 input 进行编辑。但从含义上两者还是有较大的差别的。</span><br><span class="line">readonly 直译为 “只读”，一般用于只允许用户填写一次的信息，提交过一次之后，就不允许再次修改了。</span><br><span class="line"></span><br><span class="line">disabled 直译为 “禁用”，即这个 input 就是不允许填写和使用的（可能是因为权限或者其他原因）。</span><br><span class="line">因此在外观上，readonly 与普通 input 无异，只是点击后无法进行编辑；而 disabled 的 input 呈灰色，也不允许点击。从这两点其实也可以看出，对于 input 的事件，readonly 会响应，而 disabled 是不响应的。并且在传输数据上，disabled 的数据是不会被获取和上传，readonly 的数据会被获取和上传。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】 说说你对 line-height 是如何理解的？</p>
<p><code>line-height</code> 在日常用的最多的是让单行文字垂直居中（其实不需要设置 <code>height</code>，一个 <code>line-height</code> 即可）。因为 <code>line-height - font-size</code> 为行距，一般会近似平分到文字的上下两边，使文字看上去垂直居中。如果需要多行文字的垂直居中，还需要加上 <code>vertical-align: middle;</code>。</p>
<p><code>line-height</code> 可以不设置单位，表示 <code>font-size</code> 的倍数。</p>
<p>另外对于非替换元素的纯内联元素，其高度是由 <code>line-height</code> 所决定的。</p>
<p>3【js】 写一个方法验证是否为中文</p>
<blockquote>
<p>由于中文比较特殊，最稳妥的还是使用 <code>unicode</code> 来进行匹配。这两个 <code>unicode</code> 分别表示第一个和最后一个汉字。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isChinese</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> re = <span class="regexp">/^[\u4e00-\u9fa5]+$/</span>;</span><br><span class="line">  <span class="keyword">return</span> re.test(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、【软技能】来说说你对重绘和重排的理解，以及如何优化？</p>
<p><strong>重绘：</strong></p>
<p>当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。<br>触发重绘的条件：改变元素外观属性。如：color，background-color，font-size 等。</p>
<p><strong>重排(回流)：</strong></p>
<p>当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。<br>重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。<br>所以，<strong>重排必定会引发重绘，但重绘不一定会引发重排</strong>。<br>　　触发重排的条件：任何页面布局和几何属性的改变都会触发重排，<br>比如：<br>　　 1、页面渲染初始化；(无法避免)<br>　　 2、添加或删除可见的 DOM 元素；<br>　　 3、元素位置的改变，或者使用动画；<br>　　 4、元素尺寸的改变——大小，外边距，边框；<br>　　 5、浏览器窗口尺寸的变化（resize 事件发生时）；<br>　　 6、填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；<br>触发重排的条件：改变元素的大小 位置 等如：width、height、pading、margin、position 等，　添加删除 DOM 操作等<br><strong>重绘重排的代价：耗时，导致浏览器卡慢。</strong></p>
<p><strong>优化</strong></p>
<p>1、浏览器自己的优化：浏览器会维护 1 个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会 flush 队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。<br>2、我们要注意的优化：我们要减少重绘和重排就是要减少对渲染树的操作，则我们可以合并多次的 DOM 和样式的修改。并减少对 style 样式的请求。<br>（1）直接改变元素的 className<br>（2）display：none；先设置元素为 display：none；然后进行页面布局等操作；设置完成后将元素设置为 display：block；这样的话就只引发两次重绘和重排；<br>（3）不要经常访问浏览器的 flush 队列属性；如果一定要访问，可以利用缓存。将访问的值存储起来，接下来使用就不会再引发回流；<br>（4）使用 cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；<br>（5）将需要多次重排的元素，position 属性设为 absolute 或 fixed，元素脱离了文档流，它的变化不会影响到其他元素；<br>（6）如果需要创建多个 DOM 节点，可以使用 DocumentFragment 创建完后一次性的加入 document；</p>
<h3 id="第-22-天-2019-10-20"><a href="#第-22-天-2019-10-20" class="headerlink" title="第 22 天 (2019.10.20)"></a>第 22 天 (2019.10.20)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/74">js 放在 html 的<code>和</code>有什么区别？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/75">说说浏览器解析 CSS 选择器的过程？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/76">你对 new 操作符的理解是什么？手动实现一个 new 方法</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/77">前端工程师这个职位你是怎么样理解的？聊聊它的前景？</a></li>
</ul>
<p>1、【html】 js 放在 html 的&lt;_body_&gt;和&lt;_head_ &gt;有什么区别？</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">js 放在 &lt;head&gt; 中，如果不添加 async 或者 defer 时，当浏览器遇到 script 时，会阻塞 DOM 树的构建，进而影响页面的加载。当 js 文件较多时，页面白屏的时间也会变长。</span><br><span class="line"></span><br><span class="line">在这个过程中，如果解析器遇到了一个脚本(script)，它就会停下来，并且执行这个脚本，然后才会继续解析 HTML。如果遇到了一个引用外部资源的脚本(script)，它就必须停下来等待这个脚本资源的下载，而这个行为会导致一个或者多个的网络往返，并且会延迟页面的首次渲染时间。</span><br><span class="line"></span><br><span class="line">把 js 放到 &lt;body&gt; 里（一般在 &lt;/body&gt; 的上面）时，由于 DOM 时顺序解析的，因此 js 不会阻塞 DOM 的解析。对于必须要在 DOM 解析前就要加载的 js，我们需要放在 &lt;head&gt; 中。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】说说浏览器解析 CSS 选择器的过程？</p>
<p><strong>解析：</strong> 浏览器对于 CSS 选择器的解析过程是从右向左的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  // css 属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是这样的一个结构，浏览器会从右向左开始解析。因为一般来说，最右侧的节点范围反而会比较大，越向左限定的条件就越多。也因此 CSS 的选择器设计上不宜嵌套过多，会带来性能上的问题。</p>
<p>3、【js】你对 new 操作符的理解是什么？手动实现一个 new 方法</p>
<p><strong>解析：</strong></p>
<p><strong>new 的理解</strong></p>
<blockquote>
<p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一</p>
</blockquote>
<p><strong>new 步骤</strong></p>
<p>模拟 new 操作前，要先知道 new 操作是发生了什么，就拿<code>new Object()</code>举例:</p>
<ol>
<li>创建一个新对象</li>
<li>把新对象的原型指向构造函数的 prototype</li>
<li>把构造函数里的 this 指向新对象</li>
<li>返回这个新对象</li>
</ol>
<p><strong>构造函数：</strong></p>
<p>先准备一个构造函数来<code>new</code>使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructorFunction</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">constructorFunction.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>原生 new：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> constructorFunction(<span class="string">&quot;willian&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name, obj.age); <span class="comment">//&#x27;willian&#x27;, 18</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.say()); <span class="comment">//Hello willian</span></span><br></pre></td></tr></table></figure>

<p><strong>模拟 new</strong></p>
<p>模拟的<code>new </code>暂称为<code>newNew </code>（囡..囡 哈哈<del>）<br>使用：<code>newNew(constructor, arg1, arg2, ..) </code>第 0 个参数传入构造函数，1</del>n 个参数是构造函数的形参。<br>使用上面的构造函数试一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newObj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 1. 创建一个新对象</span></span><br><span class="line">  <span class="keyword">var</span> Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 得到构造函数</span></span><br><span class="line">  newObj.__proto__ = Con.prototype;</span><br><span class="line">  <span class="comment">// 2. 把新对象的原型指向构造函数的prototype</span></span><br><span class="line">  <span class="keyword">var</span> res = Con.apply(newObj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 3. 把构造函数里的this指向新对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&quot;object&quot;</span> ? res : newObj;</span><br><span class="line">  <span class="comment">// 4. 返回新对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = newNew(constructorFunction, <span class="string">&quot;willian&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name, obj.age); <span class="comment">//&#x27;willian&#x27;, 18</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.say()); <span class="comment">//Hello willian</span></span><br></pre></td></tr></table></figure>

<p>得到和 new 一样的答案，说明模拟成功。<br>你也可以 F12 打开控制台试一试。<br>以上参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/13">mqyqingfeng/Blog#13</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/liwenfei123/article/details/80580883">https://blog.csdn.net/liwenfei123/article/details/80580883</a></li>
</ol>
<p>3、【软技能】 前端工程师这个职位你是怎么样理解的？聊聊它的前景？</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">广义的来说，只要涉及展示的都属于前端，包括各种系统，图片，动画，看得见就可以。从这个角度来说，前端永远不会被抛弃，会被淘汰的只有个体，因为个体是有极限，有局限的。</span><br><span class="line">个人需要精确的定位，例如web工程师，也可以是电影特效工程师，工程师还分为软件硬件呢。</span><br><span class="line"></span><br><span class="line">前景</span><br><span class="line">具体到互联网行业的前端前景，在可见的范围内，前端承担的责任会增加而不是减少，保持进步就不会被淘汰，这点对于任何行业都一样，被抛弃的根本原因在于自身没有匹配需求的能力，而不是客观因素，那只是诱因，且必然发生。</span><br><span class="line">话说本人是先从事一段时间后端才渐渐偏向前端的，正是因为看得见，便于分享的东西更吸引人。不是后端做不到，只是觉得旅途会更轻松一些</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过各种终端来向用户展示数据，或者给用户提供一些和后台的交互接口。</span><br><span class="line">前景：首先，在我看来，一切和用户交互的终端都可以属于前端。并且随着现在跨端开发框架的兴起，比如Electron框架等，也使得前端的那套开发技术栈以及开发流程可以复制到桌面端来，使得前端的范畴越来越广泛。</span><br><span class="line">并且，随着AR，VR技术的兴起，手机app中应用了大量的3维场景来提高用户体验，比如手机app上看房，看车，甚至是看一个城市的街景，都已经有了3D的场景，并且用户还能进行简单的操作。而这些都对前端提出了更高的要求</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-23-天（2019-10-21）"><a href="#第-23-天（2019-10-21）" class="headerlink" title="第 23 天（2019.10.21）"></a>第 23 天（2019.10.21）</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/78">关于<code>*form*</code>标签的编码类型属性你有一些了解？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/79">说说 CSS 的优先级是如何计算的？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/80">0.1 + 0.2、0.1 + 0.3 和 0.1 * 0.2 分别等于多少？并解释下为什么？</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/81">说说一件或几件（介绍下除了工作外）你觉得能为你面试加分的事</a></li>
</ul>
<p>1、【html】 第 23 天关于&lt;_form_&gt;标签的 enctype 属性你有什么了解？</p>
<p><strong>解析：</strong></p>
<p><code>&lt;form&gt;</code>标签的<code>enctype</code>属性，用于控制表单上传的数据的编码格式。其值和 HTTP 请求的<code>Content-type</code>值相同。在数据提交到服务器之前，会以<code>enctype</code>值进行编码。</p>
<p><code>enctype</code> 对应的值如下</p>
<table>
<thead>
<tr>
<th>值</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>应用程序/ x-www-form-urlencoded</td>
<td>默认值，预设所有字符转进行编码（将空格转换为“ +”符号，特殊字符转换为 ASCII HEX 值）</td>
</tr>
<tr>
<td>多部分/表单数据</td>
<td>不会对字符进行编码，当表单中有文件时必须要此编码</td>
</tr>
<tr>
<td>文字/纯文字</td>
<td>将空格转换为“ +”符号，但不编码特殊字符</td>
</tr>
</tbody></table>
<p>参考文章：<br><a target="_blank" rel="noopener" href="https://www.runoob.com/tags/att-form-enctype.html">HTML <code>form</code> enctype 属性</a></p>
<p>2、【css】说说 CSS 的优先级是如何计算的？</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://github.com/ZhChen7/Technical-interview/blob/master/1%20HTML-CSS/1%20%20CSS%E6%9D%83%E9%87%8D%E5%8F%8A%E5%85%B6%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F.md">点击此处</a></p>
<p>3、【js】 0.1 + 0.2、0.1 + 0.3 和 0.1 * 0.2 分别等于多少？并解释下为什么？</p>
<p><strong>解析：</strong></p>
<blockquote>
<p>用一句话概括就是：</p>
<p>EcmaScrpt 规范定义 Number 的类型遵循了 IEEE754-2008 中的 64 位浮点数规则定义的小数后的有效位数至多为 52 位导致计算出现精度丢失问题！</p>
</blockquote>
<p>这个问题也算是经常遇到的面试题之一了，楼上说的对，简单来说就是 js 中采用 IEEE754 的双精度标准，因为精度不足导致的问题，只是二进制表示 0.1 时这这样表示<code>1001100110011...</code>（0011 无线循环），那么这些循环的数字被 js 裁剪后，就会出现精度丢失的问题，也就造成了<code>0.1</code>不再是<code> 0.1 了</code>，而是变成了<code>0.100000000000000002</code></p>
<p>我们可以来测试一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.100000000000000002</span> === <span class="number">0.1</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>那么同样的，0.2 在二进制也是无限循环的，被裁剪后也失去了精度变成了<code>0.200000000000000002</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.200000000000000002</span> === <span class="number">0.2</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>由此我们可以得出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.30000000000000004</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>所以自然<code>0.1+0.2!=0.3</code>。<br>那么如何解决这个问题；使用原生最简单的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span> + <span class="number">0.2</span>).toFixed(<span class="number">10</span>)) === <span class="number">0.3</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>参考：<br>深度剖析 0.1 +0.2 === 0.30000000000000004 的原因：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d6b81e4e25e3">https</a> ://<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/d6b81e4e25e3">www.jianshu.com/p/d6b81e4e25e3</a></p>
<p>【软技能】 说说一件或几件（介绍下除了工作外）你觉得能为你面试加分的事</p>
<p>比如可以这么回答：</p>
<ol>
<li>每年都要跑满 1000 公里，已经坚持 3 年了</li>
<li>我风雨无阻每天早上 4：30 起床坚持阅读，坚持了 10 年，已经习惯了！</li>
<li>我坚持每周至少三次去锻炼身体</li>
<li>……<br>可以从坚持、勇敢、适应环境、担当、人际关系等个人性格特点方面回答。</li>
</ol>
<h3 id="第-24-天（2019-10-22）"><a href="#第-24-天（2019-10-22）" class="headerlink" title="第 24 天（2019.10.22）"></a>第 24 天（2019.10.22）</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/82">说说你对属性 data-的理解</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/83">你有用过 CSS 预处理器吗？喜欢用哪个？原理是什么？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/84">如何快速让一个数组乱序，写出来</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/85">你经历过老板要求兼容 IE 吗？IE 几？有什么感悟？</a><a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/85">https://github.com/haizlin/fe-interview/issues/85</a>)</li>
</ul>
<p>1、【html】 说说你对属性 data-的理解？</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先定义一下：data-是h5对自定义标签属性扩展的知识点，可以存储自定义属性，可以通过js获取到，一般会存储业务需要的数据，和vue中的bind很类似的</span><br><span class="line">是暂存非用户输入的数据</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】你有用过 CSS 预处理器吗？喜欢用哪个？原理是什么？</p>
<p>它能让你的 CSS 具备更加简洁、适应性更强、可读性更强、层级关系更加明显、更易于代码的维护等诸多好处。<br>CSS 预处理器种类繁多，目前 Sass、Less、用的比较多。<br>使用功能：<br>1、嵌套：反映层级和约束<br>2、变量和计算： 减少重复代码<br>3、Extend 和 Mixin 代码片段 (用的少)<br>4、循环：适用于复杂有规律的样式<br>5、import css 文件模块化<br>具体使用方法 均可百度</p>
<p>3、【js】如何快速让一个数组乱序，写出来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如何快速让一个数组乱序，写出来</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.sort(<span class="function">() =&gt;</span> (<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="number">1</span> : <span class="number">-1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// 乱序</span></span><br></pre></td></tr></table></figure>

<p>4、【软技能】 你经历过老板要求兼容 IE 吗？IE 几？有什么感悟</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IE6，7一年，IE8半年，IE9一直以来的最低标准。</span><br><span class="line">近半年PC项目直接Chrome，移动端项目直接-webkit-</span><br><span class="line">总结就是最近没有兼容问题，爽。</span><br><span class="line">感受就是兼容确实没啥大问题，你知道了IE的兼容问题之后尽量避开和熟练掌握对应的hack方法，其实也没有特别恐怖，怎么说呢，就是解决问题吧。</span><br><span class="line">稳住，我们能赢！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-25-天-2019-10-23"><a href="#第-25-天-2019-10-23" class="headerlink" title="第 25 天 (2019.10.23)"></a>第 25 天 (2019.10.23)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/86">请说说&lt;_script_&gt;、&lt;_script async_&gt;和&lt;_script defer_&gt;的区别 </a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/87">在页面中的应该使用奇数还是偶数的字体？为什么呢？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/88">写一个判断设备来源的方法</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/89">说说你工作中遇到过比较难的技术问题是什么？是如何解决的？</a></li>
</ul>
<p>1、【html】 请说说&lt;_script_&gt;、&lt;_script async_&gt;和&lt;_script defer_&gt;的区别</p>
<p>单纯的 <code>&lt;script&gt;</code> 会阻塞 DOM 的渲染，如果放在 <code>&lt;head&gt;</code> 标签中，对页面的显示会有延迟。如果是用过 <code>src</code> 引入外部资源时，浏览器会先停止解析下载外部资源，之后再执行其中的 <code>javaScript</code>（即立即加载并渲染）。</p>
<p>在添加 <code>async</code> 或者 <code>defer</code> 之后，<code>&lt;script&gt;</code> 的下载不会阻塞 DOM 的渲染。两者的区别如下：</p>
<ul>
<li><code>async</code> 在脚本下载完成后立即执行（此时会阻塞 DOM 的渲染），并且多个 <code>async</code> 脚本存在时，执行的顺序取决于下载完成的顺序。因此对于有前后依赖关系的脚本（比如 jQuery 以及依赖 jQuery 的组件库，就不适合 <code>async</code>）</li>
<li><code>defer</code> 在的脚本执行放在 DOM 渲染之后（对于老的浏览器如果不支持 <code>defer</code> 就不行了）。并且多个脚本时，其执行顺序时按照引入顺序执行的。比较符合实际项目众多的需求，但为了兼容老版本浏览器，最佳的实践还是把 <code>&lt;script&gt;</code> 放在 <code>&lt;/body&gt;</code> 前。</li>
</ul>
<p>参考文章：<br><a target="_blank" rel="noopener" href="https://www.wakuwakubank.com/posts/614-javascript-async-defer/">スクリプトの非同期読み込み(async, defer の違い)</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000000640869">defer 和 async 的区别</a></p>
<p>2、【css】 在页面中的应该使用奇数还是偶数的字体？为什么呢？</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常用偶数号字体,但奇数号字体也没关系,例如 知乎正文使用15px字体,豆瓣电影使用13px字体</span><br><span class="line">UI设计师导出的设计稿一般都是偶数号字体</span><br><span class="line">偶数字号容易和页面其他标签的其他属性形成比例关系</span><br><span class="line">Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，</span><br><span class="line">而 13、15、17 px 时用的是小一号的点阵（即每个字占的空间大了 1 px，但点阵没变），于是略显稀</span><br><span class="line">疏。(没试过)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】 写一个判断设备来源的方法</p>
<blockquote>
<p>根据 navigator.userAgent 来判断</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deviceType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> ua = navigator.userAgent;</span><br><span class="line">       <span class="keyword">var</span> agent = [<span class="string">&quot;Android&quot;</span>, <span class="string">&quot;iPhone&quot;</span>, <span class="string">&quot;SymbianOS&quot;</span>, <span class="string">&quot;Windows Phone&quot;</span>, <span class="string">&quot;iPad&quot;</span>, <span class="string">&quot;iPod&quot;</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, i&lt;agent.length; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(ua.indexOf(agent[i])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               alert(agent[i])</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4、【软技能】说说你工作中遇到过比较难的技术问题是什么？是如何解决的？</p>
<blockquote>
<p>这是在面试中经常被问到的一个问题，目的是查看面试者解决问题的能力。这里不做详细的某个技术难点来讲，因为可能你认为很难得问题，在别人那里根本不是事，就讲一下回答这个问题的思路吧。<br>这里的问题代表某个 bug 或某个难搞的需求。</p>
</blockquote>
<p>回答思路：</p>
<ol>
<li>问题出现的背景，比如说：‘在使用 Vue 开发 xxx 功能时中遇到 xxx…’</li>
<li>问题出现的原因在哪里，如果定位到的。比如：’在使用 xx 调试发现的问题出现在 xx..’</li>
<li>查找问题解决方法，比如：‘在 xx 论坛看到解决方法，在某某交流群内提问，询问身边(网上)的技术大佬’</li>
<li>问题解决后达到了什么效果，比如：‘加载速度提升了约 4 倍，受到领导同事的一致好评..’</li>
<li>问题解决后有什么感悟或收获，比如：‘原来使用 xx 方法就能 xx，记录到我的 bug-log 中..’</li>
</ol>
<h3 id="第-26-天-2019-10-24"><a href="#第-26-天-2019-10-24" class="headerlink" title="第 26 天 (2019.10.24)"></a>第 26 天 (2019.10.24)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/90">解释下你对 GBK 和 UTF-8 的理解？并说说页面上产生乱码的可能原因</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/91">说说你对 z-index 的理解</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/92">说说 bind、call、apply 的区别？并手写实现一个 bind 的方法</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/93">你对 Git 的 branch 及工作流的理解是什么？</a></li>
</ul>
<p>1、【html】 解释下你对 GBK 和 UTF-8 的理解？并说说页面上产生乱码的可能原因</p>
<p><strong>gbk 和 utf8 的理解</strong></p>
<p>我们这里将以最简单最容易理解的方式来描述 GBK 和 UTF8 的区别，以及它们分别是什么。</p>
<p>GBK 编码：是指中国的中文字符，其它它包含了简体中文与繁体中文字符，另外还有一种字符“gb2312”，这种字符仅能存储简体中文字符。</p>
<p>UTF-8 编码：它是一种全国家通过的一种编码，如果你的网站涉及到多个国家的语言，那么建议你选择 UTF-8 编码。</p>
<p><strong>GBK 和 UTF8 有什么区别？</strong></p>
<p>UTF8 编码格式很强大，支持所有国家的语言，正是因为它的强大，才会导致它占用的空间大小要比 GBK 大，对于网站打开速度而言，也是有一定影响的。</p>
<p>GBK 编码格式，它的功能少，仅限于中文字符，当然它所占用的空间大小会随着它的功能而减少，打开网页的速度比较快。</p>
<p>2、【css】说说你对 z-index 的理解？</p>
<p><strong>z-index 理解</strong></p>
<p>当网页上出现多个由绝对定位（position:absolute）或固定定位（position:fixed）所产生的浮动层时，必然就会产生一个问题，就是当这些层的位置产生重合时，谁在谁的上面呢？或者说谁看得见、谁看不见呢？这时候就可以通过设置<code>z-index</code>的值来解决，这个值较大的就在上面，较小的在下面。</p>
<blockquote>
<p><code>z-index</code>的意思就是在 z 轴的顺序，如果说网页是由 x 轴和 y 轴所决定的一个平面，那么 z 轴就是垂直于屏幕的一条虚拟坐标轴，浮动层就在这个坐标轴上，那么它们的顺序号就决定了谁上谁下了。</p>
</blockquote>
<p>参考：</p>
<ul>
<li>关于 z-index 那些你不知道的事：<a target="_blank" rel="noopener" href="https://webdesign.tutsplus.com/zh-hans/articles/what-you-may-not-know-about-the-z-index-property--webdesign-16892">https://webdesign.tutsplus.com/zh-hans/articles/what-you-may-not-know-about-the-z-index-property--webdesign-16892</a></li>
<li>MDN[z-index]： <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index">https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index</a></li>
</ul>
<p>3、【js】 说说 bind、call、apply 的区别？并手写实现一个 bind 的方法</p>
<p><code>call</code>和<code>apply</code>都是为了解决改变<code>this</code>的指向。作用都是相同的，只是传参的方式不同。</p>
<p>除了第一个参数外，<code>call</code>可以接收一个参数列表，<code>apply</code>只接受一个参数数组。 <code>bind</code>绑定完之后返回一个新的函数，不执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context = window</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">  <span class="comment">// 执行完后干掉</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context = window</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  <span class="comment">// 判断 arguments[1] 是不是 undefined</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, args.concat(...arguments));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4、【软技能】 你对 Git 的 branch 及工作流的理解是什么？</p>
<p>待续~</p>
<h3 id="第-27-天-2019-10-25"><a href="#第-27-天-2019-10-25" class="headerlink" title="第 27 天 (2019.10.25)"></a>第 27 天 (2019.10.25)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/94">说说你对影子(Shadow)DOM 的了解</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/95">怎样修改 chrome 记住密码后自动填充表单的黄色背景？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/96">说说你对 arguments 的理解，它是数组吗？</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/97">你为什么离职呢？</a></li>
</ul>
<p>1、【html】说说你对影子(Shadow)DOM 的了解</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/59f2ef2d6fb9a045076ee831">影子节点 ShadowDOM</a></p>
</blockquote>
<p><code>Shadow DOM</code> 可以想象成我们在 Vue 或者 React 中使用的一个个组件，是一种将 HTML 结构、Style 封装起来的结构。我们熟悉的 <code>&lt;video&gt;</code> 标签，其实就是 <code>Shadow DOM</code> 的封装。</p>
<p>借用 MDN 上的图，可以看到 <code>Shadow DOM</code> 允许我们在 DOM 文档中插入一个 DOM 的子树。<code>Shadow Tree</code> 会挂在 <code>Shadow host</code> 对应的 DOM 上。之后，<code>Shadow DOM</code> 与外层 DOM 不会相互影响，因此可以放心用来做组件。</p>
<p><img src="https://camo.githubusercontent.com/d64532b4dc47ac438a7a0614887f198e4d0f8dfa/68747470733a2f2f6d646e2e6d6f7a696c6c6164656d6f732e6f72672f66696c65732f31353738382f736861646f772d646f6d2e706e67"></p>
<p>具体的例子可以参考 MDN 给出的案例<a target="_blank" rel="noopener" href="https://github.com/mdn/web-components-examples/tree/master/popup-info-box-web-component">``</a></p>
<p>这个例子告诉我们可以利用 <code>Shadow DOM</code> 封装自己的 <code>tag</code> 标签，并且可以在网页中使用。</p>
<p>参考文章：<br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM">使用 shadow DOM</a><br><a target="_blank" rel="noopener" href="https://aotu.io/notes/2016/06/24/Shadow-DOM/index.html">神奇的 Shadow DOM</a></p>
<p>2、【css】怎样修改 chrome 记住密码后自动填充表单的黄色背景？</p>
<p>设置表单属性 autocomplete=”off” 或者改变背景颜色为白色或透明</p>
<p>3、【js】说说你对 arguments 的理解，它是数组吗？</p>
<blockquote>
<p><code>arguments</code>是一个对象。</p>
<p>js 不能像 java 一样实现重载，<code>arguments</code>对象可以模拟重载。</p>
<p>js 中每个函数都会有<code>arguments</code>这个实例，它引用着函数的实参，可以用数组下标的方式”[]”引用<code>arguments</code>的元素。<code>arguments.length</code>为函数实参个数，<code>arguments.callee</code>引用函数自身。</p>
<p>arguments 他的特性和使用方法</p>
</blockquote>
<p><strong>特性：</strong></p>
<ol>
<li>arguments 对象和 Function 是分不开的。</li>
<li>因为 arguments 这个对象不能显式创建。</li>
<li>arguments 对象只有函数开始时才可用。</li>
</ol>
<p><strong>使用方法：</strong></p>
<p>虽然 arguments 对象并不是一个数组，但是访问单个参数的方式与访问数组元素的方式相同</p>
<p>例如：</p>
<p>arguments[0],arguments[1]…</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arguments 不是数组，是类数组。</span><br><span class="line">类数组 转 数组的方法有</span><br><span class="line"></span><br><span class="line">[...arguments]</span><br><span class="line">Array.from(arguments)</span><br><span class="line">Array.prototype.slice.call(arguments)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-28-天-2019-10-26"><a href="#第-28-天-2019-10-26" class="headerlink" title="第 28 天 (2019.10.26)"></a>第 28 天 (2019.10.26)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/98">说说你对<code>&lt;meta&gt;</code>标签的理解</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/99">rgba()和 opacity 这两个的透明效果有什么区别呢？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/100">解释下这段代码的意思！</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/101">在浏览器中输入 url 到页面显示出来的过程发生了什么？</a></li>
</ul>
<p>1、【html】 说说你对&lt;_meta_ &gt;标签的理解</p>
<p><strong>解析：</strong><a target="_blank" rel="noopener" href="https://juejin.im/entry/588074c62f301e00696b481d">关于 HTML 中 meta 标签的理解和总结</a></p>
<p><strong>简介</strong></p>
<blockquote>
<p>这儿采用英文版 W3school 的解释:</p>
<p>The <meta> tag provides metadata about the HTML document. Metadata will not be displayed on the page, but will be machine parsable.</p>
</blockquote>
<p>不难看出，其中的关键是 metadata，中文名叫元数据，是用于描述数据的数据。它不会显示在页面上，但是机器却可以识别。这么一来 meta 标签的作用方式就很好理解了。</p>
<p><strong>用处</strong></p>
<p>meta 常用于定义页面的说明，关键字，最后修改日期，和其它的元数据。这些元数据将服务于浏览器（如何布局或重载页面），搜索引擎和其它网络服务</p>
<p><strong>组成</strong></p>
<p><strong>1、name 属性</strong></p>
<p>name 属性主要用于描述网页，比如网页的关键词，叙述等。与之对应的属性值为 content，content 中的内容是对 name 填入类型的具体描述，便于搜索引擎抓取。<br>meta 标签中 name 属性语法格式是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;参数&quot;</span> <span class="attr">content</span>=<span class="string">&quot;具体的描述&quot;</span> /&gt;</span>。</span><br></pre></td></tr></table></figure>

<p>其中 name 属性共有以下几种参数。**(A-C 为常用属性)**</p>
<ul>
<li><p>A. keywords(关键字)</p>
<ul>
<li>说明：用于告诉搜索引擎，你网页的关键字</li>
</ul>
<p>举例：</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Lxxyx,博客，文科生，前端&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>B. description(网站内容的描述)</p>
<ul>
<li>说明：用于告诉搜索引擎，你网站的主要内容。</li>
</ul>
<p>举例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;description&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;文科生，热爱前端与编程。目前大二，这是我的前端博客&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C. viewport(移动端的窗口)</p>
<ul>
<li>说明：这个概念较为复杂，具体的会在下篇博文中讲述。<br>这个属性常用于设计移动端网页。在用 bootstrap,AmazeUI 等框架时候都有用过 viewport。</li>
</ul>
<p>举例（常用范例）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>D. robots(定义搜索引擎爬虫的索引方式)</p>
<ul>
<li>说明：robots 用来告诉爬虫哪些页面需要索引，哪些页面不需要索引。<br>content 的参数有 all,none,index,noindex,follow,nofollow。默认是 all</li>
</ul>
<p>举例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;none&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体参数如下：</p>
<p>1.none : 搜索引擎将忽略此网页，等价于 noindex，nofollow。<br>2.noindex : 搜索引擎不索引此网页。<br>3.nofollow: 搜索引擎不继续通过此网页的链接索引搜索其它的网页。<br>4.all : 搜索引擎将索引此网页与继续通过此网页的链接索引，等价于 index，follow。<br>5.index : 搜索引擎索引此网页。<br>6.follow : 搜索引擎继续通过此网页的链接索引搜索其它的网页。</p>
</li>
<li><p>E. author(作者)</p>
<ul>
<li>说明：用于标注网页作者</li>
</ul>
<p>举例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Lxxyx,841380530@qq.com&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>F. generator(网页制作软件)</p>
<ul>
<li>说明：用于标明网页是什么软件做的</li>
</ul>
<p>举例: (不知道能不能这样写)：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;generator&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Sublime Text3&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>G. copyright(版权)</p>
<ul>
<li>说明：用于标注版权信息</li>
</ul>
<p>举例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;copyright&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Lxxyx&quot;</span> /&gt;</span> //代表该网站为Lxxyx个人版权所有。</span><br></pre></td></tr></table></figure>
</li>
<li><p>H. revisit-after(搜索引擎爬虫重访时间)</p>
<ul>
<li>说明：如果页面不是经常更新，为了减轻搜索引擎爬虫对服务器带来的压力，可以设置一个爬虫的重访时间。如果重访时间过短，爬虫将按它们定义的默认时间来访问。<br>举例：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;revisit-after&quot;</span> <span class="attr">content</span>=<span class="string">&quot;7 days&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>I. renderer(双核浏览器渲染方式)</p>
<ul>
<li>说明：renderer 是为双核浏览器准备的，用于指定双核浏览器默认以何种方式渲染页面。比如说 360 浏览器。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;webkit&quot;</span> /&gt;</span> //默认webkit内核</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie-comp&quot;</span> /&gt;</span> //默认IE兼容模式</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie-stand&quot;</span> /&gt;</span> //默认IE标准模式</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>2、http-equiv 属性</strong></p>
<blockquote>
<p>这个我所认为的 http-equiv 意思的简介。<br><code>相当于HTTP的作用，比如说定义些HTTP参数啥的。</code></p>
</blockquote>
<p>meta 标签中 http-equiv 属性语法格式是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;参数&quot;</span> <span class="attr">content</span>=<span class="string">&quot;具体的描述&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 http-equiv 属性主要有以下几种参数：</p>
<ul>
<li><p>A. content-Type(设定网页字符集)(推荐使用 HTML5 的方式)</p>
<ul>
<li>说明：用于设定网页字符集，便于浏览器解析与渲染页面</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line">//旧的HTML，不推荐</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span> //HTML5设定网页字符集的方式，推荐使用UTF-8</span><br></pre></td></tr></table></figure>
</li>
<li><p>B. X-UA-Compatible(浏览器采取何种版本渲染当前页面)</p>
<ul>
<li>说明：用于告知浏览器以何种版本来渲染页面。（一般都设置为最新模式，在各大框架中这个设置也很常见。）</li>
</ul>
<p>举例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span> /&gt;</span></span><br><span class="line">//指定IE和Chrome使用最新版本渲染当前页面</span><br></pre></td></tr></table></figure>
</li>
<li><p>C. cache-control(指定请求和响应遵循的缓存机制)</p>
</li>
</ul>
<p><strong>用法 1.</strong></p>
<p>说明：指导浏览器如何缓存某个响应以及缓存多长时间。这一段内容我在网上找了很久，但都没有找到满意的。<br>最后终于在 Google Developers 中发现了我想要的答案。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/1/19/5dc80e2e097679bc7c9822ccc293489c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>举例:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;cache-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>共有以下几种用法：</p>
<ol>
<li>no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。</li>
<li>no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）</li>
<li>public : 缓存所有响应，但并非必须。因为 max-age 也可以做到相同效果</li>
<li>private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说 CDN 就不允许缓存 private 的响应）</li>
<li>maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60 表示响应可以再缓存和重用 60 秒。</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn#cache-control">参考链接：HTTP 缓存</a></p>
</blockquote>
<p><strong>用法 2.(禁止百度自动转码)</strong></p>
<p>说明：用于禁止当前页面在移动端浏览时，被百度自动转码。虽然百度的本意是好的，但是转码效果很多时候却不尽人意。所以可以在 head 中加入例子中的那句话，就可以避免百度自动转码了。<br>举例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Cache-Control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-siteapp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>D. expires(网页到期时间)<ul>
<li>说明:用于设定网页的到期时间，过期后网页必须到服务器上重新传输。<br>举例：</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;expires&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Sunday 26 October 2016 01:00 GMT&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>E. refresh(自动刷新并指向某页面)<ul>
<li>说明：网页将在设定的时间内，自动刷新并调向设定的网址。<br>举例:</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;refresh&quot;</span> content=<span class="string">&quot;2；URL=http://www.lxxyx.win/&quot;</span>&gt; <span class="comment">//意思是2秒后跳转向我的博客</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>F. Set-Cookie(cookie 设定)<ul>
<li>说明：如果网页过期。那么这个网页存在本地的 cookies 也会被自动删除。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;Set-Cookie&quot;</span> content=<span class="string">&quot;name, date&quot;</span>&gt; <span class="comment">//格式</span></span><br><span class="line"></span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Set-Cookie&quot;</span> content=<span class="string">&quot;User=Lxxyx; path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT&quot;</span>&gt; <span class="comment">//具体范例</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】 rgba()和 opacity 这两个的透明效果有什么区别呢？</p>
<p>1.<code>opacity</code> 是属性，<code>rgba()</code>是函数，计算之后是个属性值； 2.<code>opacity</code> 作用于元素和元素的内容，内容会继承元素的透明度，取值 0-1； 3.<code>rgba()</code> 一般作为背景色 <code>background-color</code> 或者颜色 <code>color</code> 的属性值，透明度由其中的 <code>alpha</code> 值生效，取值 0-1；</p>
<p><strong>扩展：</strong> 1.<code>transparent</code> 也是透明，是个属性值，颜色值，跟<code>#000</code>是一类，不过它是关键字来描述。 2.如何隐藏一个元素？</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">回复@xiangshuo1992</span><br><span class="line">隐藏元素可以从属性上进行隐藏，</span><br><span class="line">display：none 通过定义自身的隐藏，并没有在页面存在dom节点，所以重新显示的时候，会导致页面重排。</span><br><span class="line">visibility：hidden, 上面的不同，虽为隐藏，但在页面上还是有dom节点，个人认为比display：none较优。</span><br><span class="line">opacity:1 透明度 给元素定义 隐藏、透明 是独立的透明属性,</span><br><span class="line">transparent 透明颜色 是作为透明的颜色值使用，常见用在border隐藏做三角形,</span><br><span class="line">rgba(0,0,0,1) 是颜色值的一种复合写法，既能显示颜色也能配合透明效果,</span><br><span class="line">z-index=-1 定义层级属性若平常的页面显示为一，想看不到显示，可以把层级降低 用平常页面成为遮罩层，达到隐藏效果，换而言之，想突出一个元素也可把层级调大，类似于绝对定位的绝对效果。</span><br><span class="line">, 还有一种是通过css3新增 用transform变化属性 rotate旋转 角度，也是可以达到隐藏效果，这里就涉及三维空间的思考。</span><br><span class="line">欢迎大家，提出补充和有问题的地方。大家相互交流</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@hbl045 visibility：hidden 视觉上隐藏了，但是DOM布局占位还在，所以有可能会影响现有的布局，应用场景并不多</span><br><span class="line"></span><br><span class="line">隐藏元素也可以 transform: scale(0); 跟 visibility：hidden 一样，占位也是一直在的。</span><br><span class="line">也可以设置宽高为零</span><br><span class="line">还可以通过定位或者 translate 移出可视区域。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】解释下这段代码的意思！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call($$(<span class="string">&quot;*&quot;</span>), <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  a.style.outline =</span><br><span class="line">    <span class="string">&quot;1px solid #&quot;</span> + (~~(<span class="built_in">Math</span>.random() * (<span class="number">1</span> &lt;&lt; <span class="number">24</span>))).toString(<span class="number">16</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<blockquote>
<p>随机颜色获取：‘#’+(~~(Math.random() * (1 &lt;&lt; 24))).toString(16)</p>
</blockquote>
<p><strong>作用</strong></p>
<blockquote>
<p>在你的 Chrome 浏览器的控制台中输入这段代码，你会发现不同 HTML 层都被使用不同的颜色添加了一个高亮的边框。是不是非常酷？但是，简单来说，这段代码只是首先获取了所有的页面元素，然后使用一个不同的颜色为它们添加了一个 1px 的边框。</p>
</blockquote>
<p><strong>解析</strong></p>
<ul>
<li><code>[].forEach.call() </code>=&gt; 调用引用数组的 forEach 方法</li>
<li><code>$$(&#39;*&#39;) </code>=&gt; <code>document.querySelectorAll(&#39;*&#39;)</code></li>
<li><code>~~a</code> =&gt; <code>parseInt(a)</code></li>
<li><code>1&lt;&lt;24</code> =&gt; 对二进数 1 小数点右移 24 位</li>
<li><code>(parseInt(Math.random()*(1&lt;&lt;24)).toString(16))</code> =&gt; 获得了一个位于<code>0-16777216</code>之间的随机整数，也就是随机颜色，再使用<code>toString(16)</code>将它转化为十六进制数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $$(&#x27;*&#x27;) 为获取所有 dom 元素，返回数组</span></span><br><span class="line">[].forEach.call($$(<span class="string">&quot;*&quot;</span>), <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// forEach 的回调函数，这里的 a 是数组中每个 dom 元素，不是 a 标签</span></span><br><span class="line">  a.style.outline =</span><br><span class="line">    <span class="comment">// ～～是取整 1&lt;&lt;24 是位运算 结果为 16777216</span></span><br><span class="line">    <span class="comment">// 之后的 toString(16) 为进行 16 进制的转换 即颜色</span></span><br><span class="line">    <span class="string">&quot;1px solid #&quot;</span> + (~~(<span class="built_in">Math</span>.random() * (<span class="number">1</span> &lt;&lt; <span class="number">24</span>))).toString(<span class="number">16</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>因此这段代码的意思为，给页面所有 dom 元素添加随机颜色的边框。</p>
<p>4、【软技能】在浏览器中输入 url 到页面显示出来的过程发生了什么？</p>
<p>总体来说分为以下几个过程: <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006879700">从输入 URL 到页面加载发生了什么</a></p>
<ol>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h3 id="第-29-天-2019-10-27"><a href="#第-29-天-2019-10-27" class="headerlink" title="第 29 天 (2019.10.27)"></a>第 29 天 (2019.10.27)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/102">你了解什么是无障碍 web（WAI）吗？在开发过程中要怎么做呢？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/103">请描述 css 的权重计算规则</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/104">写一个获取数组的最大值、最小值的方法</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/105">在工作中能让你最有成就感的是什么？并介绍下你最得意的作品吧</a></li>
</ul>
<p>1、【html】你了解什么是无障碍 web（WAI）吗？在开发过程中要怎么做呢？</p>
<p>无障碍 web 是指能让视觉障碍的人也能根据屏幕阅读器的提示阅读网页。这一块只知道一个大致概念，国内使用较少（甚至还遇到过加了 <code>title</code> 被测试提 bug 的情况）</p>
<p>目前能想到的只有下面几点：</p>
<ul>
<li>尽可能地使用语义化标签，如 <code>&lt;section&gt;</code>, <code>&lt;article&gt;</code> 等标签</li>
<li><code>img</code> 标签添加 <code>alt</code></li>
<li><code>button</code> 或者按钮上添加 <code>title</code></li>
<li>表单尽量使用 <code>label</code> for 可以和控件的 id 进行关联</li>
</ul>
<p>参考文章：<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/3QNXBpGB0ZiroV8OGnXCbA">无障碍 Web</a></p>
<p>2、【css】 请描述 css 的权重计算规则</p>
<p>权重值计算</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>案例</th>
<th>权重值</th>
</tr>
</thead>
<tbody><tr>
<td>!important</td>
<td>!important</td>
<td>Infinity</td>
</tr>
<tr>
<td>内联样式</td>
<td>style=”..”</td>
<td>1000</td>
</tr>
<tr>
<td>ID</td>
<td>#id</td>
<td>100</td>
</tr>
<tr>
<td>class</td>
<td>.class</td>
<td>10</td>
</tr>
<tr>
<td>属性</td>
<td>[type=’text’]</td>
<td>10</td>
</tr>
<tr>
<td>伪类</td>
<td>:hover</td>
<td>10</td>
</tr>
<tr>
<td>标签</td>
<td>p</td>
<td>1</td>
</tr>
<tr>
<td>伪元素</td>
<td>::first-line</td>
<td>1</td>
</tr>
<tr>
<td>相邻选择器、子代选择器、通配符</td>
<td>* &gt; +</td>
<td>0</td>
</tr>
</tbody></table>
<p><strong>比较规则：</strong></p>
<ul>
<li>1000&gt;100。也就是说从左往右逐个等级比较，前一等级相等才往后比。</li>
<li>在权重相同的情况下，后面的样式会覆盖掉前面的样式。</li>
<li>继承属性没有权重值</li>
<li>通配符、子选择器、相邻选择器等的。虽然权值为 0，但是也比继承的样式优先。</li>
<li>ie6 以上才支持<code>important</code>，并且尽量少用它。</li>
</ul>
<p>3、【js】 写一个获取数组的最大值、最小值的方法</p>
<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.max = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>es6:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(...array);</span><br></pre></td></tr></table></figure>

<p>4、【软技能】在工作中能让你最有成就感的是什么？并介绍下你最得意的作品吧</p>
<h3 id="第-30-天-2019-10-28"><a href="#第-30-天-2019-10-28" class="headerlink" title="第 30 天 (2019.10.28)"></a>第 30 天 (2019.10.28)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/106">网页上的验证码是为了解决什么问题？说说你了解的验证码种类有哪些</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/107">描述下你所了解的图片格式及使用场景</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/108">写一个方法判断字符串是否为回文字符串</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/109">解释下 CRLF 是什么？</a></li>
</ul>
<p>1、【html】 网页上的验证码是为了解决什么问题？说说你了解的验证码种类有哪些</p>
<p><strong>解决的问题：</strong></p>
<ol>
<li>防止机器行为，确定是人为操作，比如登陆、发帖等。</li>
<li>保护服务器，比如 12306 买票的时候，各种抢购的时候。</li>
</ol>
<p><strong>验证码的类型：</strong></p>
<blockquote>
<p>其实这种方式本质上是出于对系统的保护</p>
</blockquote>
<ol>
<li>滑动</li>
<li>手机验证码</li>
<li>图形验证码</li>
</ol>
<p>2、【css】 描述下你所了解的图片格式及使用场景</p>
<p>通常网页在显示的图片（图形）的时候，有以下几种格式：GIF、PNG、JPG、SVG，还有个比较新的 WebP 格式。</p>
<p>▍GIF</p>
<p>优点：GIF 是动态的；支持无损耗压缩和透明度。</p>
<p>缺点：的详细的图片和写实摄影图像会丢失颜色信息；在大多数情况下，无损耗压缩效果不如 JPEG 格式或 PNG 格式；GIF 支持有限的透明度，没有半透明效果或褪色效果。</p>
<p>适用场景：主要用于比较小的动态图标。</p>
<p>▍PNG</p>
<p>优点：PNG 格式图片是无损压缩的图片，能在保证最不失真的情况下尽可能压缩图像文件的大小；图片质量高；色彩表现好；支持透明效果；提供锋利的线条和边缘，所以做出的 logo 等小图标效果会更好；更好地展示文字、颜色相近的图片。</p>
<p>缺点：占内存大,会导致网页加载速度慢；对于需要高保真的较复杂的图像，PNG 虽然能无损压缩，但图片文件较大，不适合应用在 Web 页面上。</p>
<p>适用场景：主要用于小图标或颜色简单对比强烈的小的背景图。</p>
<p>▍JPG</p>
<p>优点：占用内存小，网页加载速度快。</p>
<p>缺点：JPG 格式图片是有损压缩的图片，有损压缩会使原始图片数据质量下降，即 JPG 会在压缩图片时降低品质。</p>
<p>适用场景：由于这种格式图片对色彩表现比较好，所以适用于色彩丰富的图片。主要用于摄影作品或者大的背景图等。不合适文字比较多的图片。</p>
<p>▍SVG</p>
<p>优点：SVG 是矢量图形，不受像素影响，在不同平台上都表现良好；可以通过 JS 控制实现动画效果。</p>
<p>缺点：DOM 比正常的图形慢，而且如果其结点多而杂，就更慢；不能与 HTML 内容集成。</p>
<p>适用场景：主要用于设计模型的展示等。</p>
<p>▍WebP</p>
<p>优点：WebP 格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有 JPEG 的 2/3，并能节省大量的服务器宽带资源和数据空间。</p>
<p>缺点：相较编码 JPEG 文件，编码同样质量的 WebP 文件需要占用更多的计算资源。</p>
<p>适用场景：WebP 既支持有损压缩也支持无损压缩。将来可能是 JPEG 的代替品。</p>
<p>3、【js】写一个方法判断字符串是否为回文字符串</p>
<blockquote>
<p>考点：正则表达式、数组 API</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s.length === <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> str = s.replace(<span class="regexp">/[^a-zA-Z0-9]/g</span>, <span class="string">&quot;&quot;</span>).toLowerCase();</span><br><span class="line">  <span class="keyword">const</span> strReverse = str.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> str === strReverse;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4、【软技能】 解释下 CRLF 是什么？</p>
<blockquote>
<p>CRLF 是 carriagereturnlinefeed 的缩写。中文意思是回车换行。</p>
</blockquote>
<h3 id="第-31-天-2019-10-29"><a href="#第-31-天-2019-10-29" class="headerlink" title="第 31 天 (2019.10.29)"></a>第 31 天 (2019.10.29)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/110">DOM 和 BOM 有什么区别？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/111">让网页的字体变得清晰，变细用 CSS 怎么做？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/112">写一个方法把 0 和 1 互转（0 置 1，1 置 0）</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/113">对于有压力时，你是怎么抗压的？</a></li>
</ul>
<p>1、【html】 DOM 和 BOM 有什么区别？</p>
<blockquote>
<p>BOM 是 Browser Object Model 的缩写，即浏览器对象模型。DOM 是 Document Object Model 的缩写，即文档对象模型。他们都是浏览器提供给 JavaScript 的 API 接口。</p>
</blockquote>
<p><strong>BOM 指 浏览器对象模型</strong></p>
<p>提供了独立于内容而与浏览器窗口进行交互的对象。描述了与浏览器进行交互的方法和接口，可以对浏览器窗口进行访问和操作，譬如可以弹出新的窗口，改变状态栏中的文本。</p>
<p><strong>DOM 指 文档对象模型</strong></p>
<p>DOM 是针对 HTML 的基于树的 API。描述了处理网页内容的方法和接口，是 HTML 的 API，DOM 把整个页面规划成由节点层级构成的文档。</p>
<p>注意: 只有 JS 的宿主环境是浏览器的时候才有 DOM 和 BOM ，在 Node 中是没有这两个对象的。</p>
<p><img src="http://static.zxinc520.com/blog/20191029/g9qOHtCPLxyr.png?imageslim" alt="mark"></p>
<p>2、【css】 让网页的字体变得清晰，变细用 CSS 怎么做？</p>
<p><strong>解析：</strong></p>
<ul>
<li>第一个反应是想到 <code>font-weight: lighter;</code> ，简单测试了下，是有效的，不过没有多平台测试。</li>
<li>第二个想到的是 <code>font-family</code> 设置偏细的字体</li>
<li>第三个是在重置样式里见过，针对 MAC，IOS 平台，有个 <code>-webkit-webkit-font-smoothing: antialiased</code> 样式。</li>
</ul>
<p>3、【js】 写一个方法把 0 和 1 互转（0 置 1，1 置 0）</p>
<blockquote>
<p>学学 js 里面中的特殊符号用法，了解写</p>
</blockquote>
<p>定义 <code>var a</code>：</p>
<ul>
<li>!a &amp;&amp; 1 || 0 ;</li>
<li>~a+2</li>
<li>+!a</li>
<li>a === 1 ? 0 : 1 （ 三元表达式 ）</li>
</ul>
<p>4、【软技能】 对于有压力时，你是怎么抗压的？</p>
<p>现代人有点压力的正常的，我觉得抗压也是每一个成年人都要掌握的。<br>或者说排解压力比较准确吧，每个人都不一样，这里我就分享自己的解压方式吧。<br>解压方式：</p>
<ol>
<li>听歌，压力大的时候在网易云上听会自己喜欢的歌。</li>
<li>运动，如果有时间就去运动吧，有时间就去打球、跑步，运动完之后一天的压力和疲惫都会减轻了很多。</li>
<li>找朋友倾诉，记住要找知心朋友，尽量不要找家人，不要让家人担心。</li>
</ol>
<p><strong>其实我觉得最重要的一点是：提高自己的能力，让那些对你有压力的事情变得简单，你自然就不会有压力的。</strong></p>
<h3 id="第-32-天-2019-10-30"><a href="#第-32-天-2019-10-30" class="headerlink" title="第 32 天 (2019.10.30)"></a>第 32 天 (2019.10.30)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/114">说说你对 HTML 元素的显示优先级的理解</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/115">说下 line-height 三种赋值方式有何区别？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/116">造成内存泄漏的操作有哪些？</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/117">你在上一家公司工作流程是怎么样的，如何与其他人协作的？是怎样跨部门合作的？</a></li>
</ul>
<p>1、【html】 说说你对 HTML 元素的显示优先级的理解</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/868a7d16fb68">HTML 元素的显示优先级</a> <u>与 20 题一样</u></p>
<p><strong>考点</strong>： <a target="_blank" rel="noopener" href="https://www.icode9.com/tags-frameset-0.html">frameset</a>,<a target="_blank" rel="noopener" href="https://www.icode9.com/tags-%E4%BC%98%E5%85%88%E7%BA%A7-0.html">优先级</a>,<a target="_blank" rel="noopener" href="https://www.icode9.com/tags-%E5%85%83%E7%B4%A0-0.html">元素</a>,<a target="_blank" rel="noopener" href="https://www.icode9.com/tags-html-0.html">html</a>,<a target="_blank" rel="noopener" href="https://www.icode9.com/tags-%E8%A1%A8%E5%8D%95-0.html">表单</a>,<a target="_blank" rel="noopener" href="https://www.icode9.com/tags-%E9%9D%A2%E8%AF%95-0.html">面试</a>,<a target="_blank" rel="noopener" href="https://www.icode9.com/tags-HTML-0.html">HTML</a>,<a target="_blank" rel="noopener" href="https://www.icode9.com/tags-%E7%AA%97%E5%8F%A3-0.html">窗口</a></p>
<p><strong>帧元素&gt;HTML 元素优先，表单元素总&gt;非表单元素优先</strong><br>层级显示优先级： <code>frameset &gt; 表单元素 &gt; 非表单元素</code></p>
<ul>
<li>表单元素包括：文本输入框，密码输入框，单选框，复选框，文本输入域，列表框等等；</li>
<li>非表单元素包括：连接（a），div,table,span 等。</li>
</ul>
<p>所有的 html 元素又可以根据其显示分成两类：有窗口元素以及无窗口元素。有窗口元素总是显示在无窗口元素的前面。<br>有窗口元素包括：select 元素，object 元素，以及 frames 元素等等。<br>无窗口元素：大部分 html 元素都是无窗口元素。</p>
<p>按照浏览器类型比较，HTML 元素的显示次序也有所不同：</p>
<p>2、【css】说下 line-height 三种赋值方式有何区别？</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>line-height: 1.5em;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>line-height: 1.5;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2018/1/28/1613cfa1c9610935?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>可以看到，当设置<code>line-height: 1.5em</code>时，很明显子 div 的文字已经超出自己的行高范围了，设置<code>line-height: 1.5</code>时子 div 的文字没有超出自己的行高。</p>
<p>这是由于 CSS 继承时的计算方式区别造成的，如示例，当我们给类名为 parent1 的父 div 设置<code>line-height：1.5em</code>时，该 div 的<code>font-size</code>为 14，此时经过计算父 div 的<code>line-height</code>为 14px*1.5=21px，然后子 div 的<code>line-height</code>就会继承 21px 这个值，而子 div 的<code>font-size</code>为 26px，自然会超出自己的行高范围。</p>
<p>而当我们给类名为 parent2 的父 div 设置<code>line-height：1.5</code>时，子 div 会直接继承<code>line-height：1.5</code>，然后计算 26px*1.5=39px，不会超出自己的行高范围。</p>
<p>经过测试<code>line-height: 150%</code>和<code>line-height: 1.5em</code>相同，都是先计算然后把固定的行高继承给子元素，所以我们可以总结一下，<strong>继承 line-height 的时候，带单位的先计算再继承，不带单位的直接继承</strong>。</p>
<p>3、【js】 造成内存泄漏的操作有哪些？</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/763ba9562864">JS 哪些操作会造成内存泄漏？</a></p>
<p>现在的 GC 好像是越来越牛逼了，有时候感觉无效的闭包都能被回收掉（还没有做过测试）</p>
<ol>
<li>意外的全局变量引起的内存泄漏</li>
<li>闭包引起的内存泄漏（主要是<strong>循环引用</strong> ，其实和 <strong>闭包</strong>的关系不大）</li>
<li>没有清理的 DOM 元素</li>
<li>被遗忘的定时器或者回调</li>
<li>子元素存在引用引起的内存泄漏</li>
</ol>
<h3 id="第-33-天-2019-10-30"><a href="#第-33-天-2019-10-30" class="headerlink" title="第 33 天 (2019.10.30)"></a>第 33 天 (2019.10.30)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/118">html 和 html5 有什么区别呢？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/119">用 CSS 绘制一个三角形</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/120">说说你对 this 的理解</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/121">你对全栈工程师的理解是什么？</a></li>
</ul>
<p>1、【html】html 和 html5 有什么区别呢？</p>
<ol>
<li>HTML5 简化了很多细微的语法，例如 doctype 的声明，只需要写<!doctype html>就行了。HTML5 与 HTML5，XHTML1 兼容，但是与 SGML 不兼容。</li>
<li>新增与语义化标签【header、footer、section、article 等】</li>
<li>canvas 替代 Flash</li>
</ol>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">html4一下是基于SGML（标准通用标记语言）的，H5不是，因为HTML要写很长的DTD规范描述，H5不用写</span><br><span class="line">H5在HTML基础上增加了很多语义化的标签以及canvas和svg，媒体等的支持</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】 用 CSS 绘制一个三角形</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">35px</span> solid lightgreen;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">35px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、【js】说说你对 this 的理解？</p>
<p>基本上可以归为四类，</p>
<ul>
<li>全局 this 是 window （默认指向）</li>
<li>函数 this 是调用者 （隐式指向）</li>
<li>call 和 apply bind 的 this 第一个参数 （显示指向）</li>
<li>构造函数的 this 是 new 之后的新对象 （构造器）</li>
</ul>
<p>4、【软技能】 你对全栈工程师的理解是什么？</p>
<p>首先，我对于全栈工程师的要求很高。</p>
<ol>
<li>独立完成页面</li>
<li>独立完成接口</li>
<li>超强学习能力</li>
</ol>
<h3 id="第-34-天-2019-10-31"><a href="#第-34-天-2019-10-31" class="headerlink" title="第 34 天 (2019.10.31)"></a>第 34 天 (2019.10.31)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/122">Standards 模式和 Quirks 模式有什么区别？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/123">浏览器是怎样判断元素是否和某个 CSS 选择器匹配？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/124">请用 canvas 写一个关于 520 浪漫表白的代码</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/125">你了解什么是技术债务吗？</a></li>
</ul>
<p>1、【html】 Standards 模式和 Quirks 模式有什么区别？</p>
<p>解析：</p>
<p>后来查了下是浏览器渲染模式，最大区别还是盒模型的解释吧</p>
<p>标准盒模型：元素内容的宽度 = width ；元素的实际宽度= width+ 2<em>padding + 2</em>border</p>
<p>怪异盒模型：元素内容宽度 = width - border 2 - paddin 2 ；实际宽度 = width</p>
<p>2、【css】浏览器是怎样判断元素是否和某个 CSS 选择器匹配？</p>
<p>先产生一个元素集合，然后从后往前判断；</p>
<blockquote>
<p>浏览器先产生一个元素集合，这个集合往往由最后一个部分的索引产生（如果没有索引就是所有元素的集合）。然后向上匹配，如果不符合上一个部分，就把元素从集合中删除，直到真个选择器都匹配完，还在集合中的元素就匹配这个选择器了。</p>
</blockquote>
<p><strong>举个例子：</strong></p>
<p>有选择器：<br><code>div.ready #wrapper &gt; .bg-red</code><br>先把所有元素 <code>class</code> 中有 <code>bg-red</code> 的元素拿出来组成一个集合，然后上一层，对每一个集合中的元素，如果元素的 <code>parent id </code>不为 <code>#wrapper </code>则把元素从集合中删去。 再向上，从这个元素的父元素开始向上找，没有找到一个 <code>tagName</code> 为 <code>div</code> 且 <code>class</code> 中有 <code>ready</code> 的元素，就把原来的元素从集合中删去。<br>至此这个选择器匹配结束，所有还在集合中的元素满足。大体就是这样，不过浏览器还会有一些奇怪的优化。<br>如图：</p>
<p><img src="https://user-images.githubusercontent.com/29278068/57994240-c9535e80-7aee-11e9-8f26-9b660fb478b9.jpg"></p>
<p><strong>注意：</strong></p>
<p>1、为什么从后往前匹配因为效率和文档流的解析方向。效率不必说，找元素的父亲和之前的兄弟比遍历所哟儿子快而且方便。关于文档流的解析方向，是因为现在的<code> CSS</code>，一个元素只要确定了这个元素在文档流之前出现过的所有元素，就能确定他的匹配情况；应用在即使 <code>html</code> 没有载入完成，浏览器也能根据已经载入的这一部分信息完全确定出现过的元素的属性。</p>
<p>2、为什么是用集合主要也还是效率。基于<code> CSS Rule</code> 数量远远小于元素数量的假设和索引的运用，遍历每一条 <code>CSS Rule</code> 通过集合筛选，比遍历每一个元素再遍历每一条 <code>Rule</code> 匹配要快得多。</p>
<p>3、【js】 请用 canvas 写一个关于 520 浪漫表白的代码 ？</p>
<p>解析： 嘻嘻嘻~~老衲 阿弥陀佛</p>
<p>4、【软技能】 你了解什么是技术债务吗？</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/125">参考</a></p>
</blockquote>
<h3 id="第-35-天-2019-11-01"><a href="#第-35-天-2019-11-01" class="headerlink" title="第 35 天 (2019.11.01)"></a>第 35 天 (2019.11.01)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/128">用一个 div 模拟 textarea 的实现</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/129">使用 flex 实现三栏布局，两边固定，中间自适应</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/130">请你解释一个为什么 10.toFixed(10)会报错？</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/131">谈一谈你知道的前端性能优化方案有哪些？</a></li>
</ul>
<p>1、【html】 用一个 div 模拟 textarea 的实现</p>
<p><strong>解析：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.edit</span> &#123;</span></span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    padding: 5px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: <span class="selector-tag">solid</span> 1<span class="selector-tag">px</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    resize: both;</span><br><span class="line">    overflow: auto;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;edit&quot;</span> <span class="attr">contenteditable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  这里是可以编辑的内容，配合容器的 overflow</span><br><span class="line">  ，多行截断，自定义滚动条，简直好用的不要不要的。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、【css】 使用 flex 实现三栏布局，两边固定，中间自适应</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    display: flex;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.left</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: red;</span><br><span class="line">    flex: 0 0 auto;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line">    flex: 1 1 auto;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: salmon;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、【js】 请你解释一个为什么 10.toFixed(10)会报错？</p>
<p>之所以会报错，是因为在这里的 <code>.</code> 发生了歧义，它既可以理解为小数点，也可以理解为对方法的调用。<br>因为这个点紧跟于一个数字之后，按照规范，解释器就把它判断为一个小数点。</p>
<p>所以我们可以这样修改下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">10</span>).toFixed(<span class="number">10</span></span><br><span class="line"><span class="number">10.</span>.toFixed(<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span> .toFixed(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span>.toFixed(<span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然出现这个报错是因为前面这个数是整数，如果本来就是小数就不会出现这个报错。</p>
<p>4、【软技能】 谈一谈你知道的前端性能优化方案有哪些？</p>
<p>这个优化的范围挺大，但是总归可以分为 <strong>服务端优化</strong> 和 <strong>客户端优化</strong> 。</p>
<blockquote>
<p>整理如下</p>
</blockquote>
<p><strong>客户端优化</strong></p>
<ul>
<li>减少 http 请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存 ，图片服务器。</li>
<li>使用 CSS 雪碧图（CSS Sprites）CSS Sprites 一句话：将多个图片合并到一张单独的图片，这样就大大减少了页面中图片的 HTTP 请求。</li>
<li>减少 DOM 操作次数，优化 javascript 性能。</li>
<li>少用全局变量、减少 DOM 操作、缓存 DOM 节点查找的结果。减少 IO 读取操作。</li>
<li>延迟加载 | 延迟渲染</li>
<li>图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。</li>
<li>避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示比 div+css 布局慢。</li>
</ul>
<p><strong>服务端优化</strong></p>
<ul>
<li>尽量减少响应的体积，比如用 gzip 压缩，优化图片字节数，压缩 css 和 js；或加快文件读取速度，优化服务端的缓存策略。</li>
<li>客户端优化 dom、css 和 js 的代码和加载顺序；或进行服务器端渲染，减轻客户端渲染的压力。</li>
<li>优化网络路由，比如增加 CDN 缓存；或增加并发处理能力，比如服务端设置多个域名，客户端使用多个域名同时请求资源，增加并发量。</li>
</ul>
<p><strong>最后</strong></p>
<p>对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘 IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。<br>　　减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如 join 查询），减少磁盘 IO 指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。</p>
<p>涉及的知识点太多，从客户端浏览器、渲染机制、缓存、 网络请求、代码压缩合并、图片格式、服务器代理、数据库的查询…..<br>暂时只能想到这么多，觉得自己答得并不是很好，希望有大佬回答一下这个问题。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">缓存</span><br><span class="line">http缓存 设置好cache-control expires Last-modified；</span><br><span class="line">前端缓存 对于一些页面今天配置直接存储到localStorage中；对于长期不发生改变的代码可以直接通过server-work存储到本地；</span><br><span class="line"></span><br><span class="line">优化加载</span><br><span class="line">webpack 开启 tree-shaking 减少代码体积</span><br><span class="line">通过preload prefetch优化加载资源的时间</span><br><span class="line">import(&#x27;&#x27;).then()异步加载资源</span><br><span class="line">图片小于30k的图片直接做成base64；</span><br><span class="line">对于首屏的样式可以直接内嵌到html中；</span><br><span class="line"></span><br><span class="line">服务端渲染</span><br><span class="line">SSR</span><br><span class="line">对于首页可以直接通过node jade模板引擎输出，其他页面继续使用前端渲染，优化首屏、SEO</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-36-天-2019-11-02"><a href="#第-36-天-2019-11-02" class="headerlink" title="第 36 天 (2019.11.02)"></a>第 36 天 (2019.11.02)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/132">HTML 与 XHTML 二者有不同?</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/133">写出主流浏览器内核私有属性的 css 前缀</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/134">请手写一个幻灯片的效果</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/135">对于前端安全，你了解多少？说说你对 XSS 和 CSRF 的理解</a></li>
</ul>
<p>1、【html】 HTML 与 XHTML 二者有不同？</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8e65f98980bb">HTML、XML、XHTML 有什么区别</a></p>
<p><strong>定义：</strong></p>
<ul>
<li>HTML：HyperText Markup Language / 超文本标记语言</li>
<li>XML: Extensible Markup Language / 可扩展标记语言</li>
<li>XHTML: Extensible Hypertext Markup Language / 可扩展超文本标记语</li>
</ul>
<p><strong>作为一个前端，最熟悉是就是 HTML 了，所以我们先从 HTML 说起。</strong></p>
<p>HTML 是用来描述和定义网页内容的标记语言，是构成网页的最基本的东西。<br>所谓超文本，就是说它除了能标记文本，还能标记其他的内容，比如：图片，链接，音频，视频等。<br>它的作用就是一个规范，告诉所有浏览器都统一标准，比如我给这段文字加个 <code>&lt;p&gt;</code> 标签，那就是告诉浏览器：这是一个段落。我加个 <code>&lt;img&gt;</code> 标签：这是一张图片，别弄错了。浏览器看到后，就会正确解析，产生相应的行为。</p>
<p><strong>然后说一下 XML</strong></p>
<p>它的表现形式就是给一个文档加一堆标签，说明每段文字是干什么的，有什么意义。这样做的目的是方便存储、传输、分享数据，人和机器都可以很方便的阅读。XML 和 HTML 有一个明显的区别就是：HTML 的标签都是预定义的，你不可以自己随便增加，比如你不能自造一个标签叫 <code>&lt;nihao&gt;</code>, 但是 XML 可以，你可以自己“发明”标签————这也是“可扩展的”一个含义。</p>
<p><strong>HTML 和 XML 一结合，就产生了 XHTML</strong></p>
<p>XHTML 就是以 XML 的语法形式来写 HTML.<br>XHTML 出现的原因是：HTML 是一种语法形式比较松散的标记语言，语法要求也不严格。比如大小可以混用，属性值随便你加不加引号，单引号还是双引号也随便你，标签也可以不闭合。HTML 标准的制定者 W3C 一看这样下去不行，所谓无规矩不成方圆，所以就把 XML 的语法形式往 HTML 上一套，出现了 XHTML，所以你也可以把 XHTML 理解为 HTML 的严格语法形式，除此之外，其它方面基本一样。<br>比如 XHTML 有一些强制的要求，如下：</p>
<ol>
<li>必须包含一个文件头声明 <code>&lt;!DOCTYPE&gt;</code></li>
<li>所有元素名必须小写</li>
<li>所有空元素必须关闭</li>
<li>所有属性名必须小写</li>
<li>所有属性值必须加引号</li>
<li>所有布尔值属性必须加上属性值</li>
</ol>
<p>2、【css】 写出主流浏览器内核私有属性的 css 前缀</p>
<p>完善一下：现在用 scss 等预处理器用多了，前缀确实不怎么关注了。</p>
<p>-webkit- (谷歌, Safari, 新版 Opera 浏览器等)<br>-moz- (火狐浏览器)<br>-o- (旧版 Opera 浏览器等)<br>-ms- (IE 浏览器 和 Edge 浏览器)</p>
<p>3、【js】 请手写一个幻灯片（轮播）的效果</p>
<p><strong>思路一</strong> ：元素并排浮动 改变 offset<br><strong>思路二</strong> ：position 层叠 改变 z-Index</p>
<p>4、【软技能】 对于前端安全，你了解多少？说说你对 XSS 和 CSRF 的理解？</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Blog/issues/33">源地址</a></p>
<ul>
<li>xss 输入+脚本</li>
<li>csrf 偷信息伪造请求</li>
</ul>
<h3 id="第-37-天-2019-11-02"><a href="#第-37-天-2019-11-02" class="headerlink" title="第 37 天 (2019.11.02)"></a>第 37 天 (2019.11.02)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/136">html5 哪些标签可以优化 SEO?</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/137">不使用 border 画出 1px 高的线，在不同浏览器的标准和怪异模式下都能保持效果一样</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/138">找到字符串中最长的单词，并返回它的长度</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/139">如果让你快速使用一门你不熟悉的新技术，你该怎么办？</a></li>
</ul>
<p>1、【html】 html5 哪些标签可以优化 SEO?</p>
<p><strong>解析：</strong></p>
<p>meta 信息中的 title，description，keyword。尽量使用语义化的标签，不要都是 div</p>
<p>优化 SEO 应该是可以给爬虫有比较明确的含义的标签。尽可能地不要使用 <code>div</code> 到底。</p>
<ul>
<li>meta: meta 标签中的 keywords 和 description</li>
<li>h1-h6</li>
<li>nav</li>
<li>section</li>
<li>article</li>
<li>footer</li>
<li>header</li>
</ul>
<p>2、【css】不使用 border 画出 1px 高的线，在不同浏览器的标准和怪异模式下都能保持效果一样</p>
<p><strong>解析：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 1px; width: 100%;background: black&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、【js】 找到字符串中最长的单词，并返回它的长度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;aaa b cc, hello word&quot;</span>;</span><br><span class="line">str.split(<span class="regexp">/\s|,/</span>).reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> (acc &gt; cur.length ? acc : cur.length));</span><br></pre></td></tr></table></figure>

<p>4、【软技能】如果让你快速使用一门你不熟悉的新技术，你该怎么办？</p>
<p>我现在的做法：<br>1、一定先去官网查看官方文档和 API，其他别人写的教程无视。<br>2、下载官方 Demo 运行学习。<br>3、自己练习 1~2 个 Demo，涵盖常用的重要的 API 的使用，实践学习理解，有问题就谷歌。<br>4、运用到项目中。</p>
<h3 id="第-38-天-2019-11-04"><a href="#第-38-天-2019-11-04" class="headerlink" title="第 38 天 (2019.11.04)"></a>第 38 天 (2019.11.04)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/140">说说你对 cookie 和 session 的理解</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/141">实现单行文本居中和多行文本左对齐并超出显示”…”</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/142">说说你对 eval 的理解</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/143">你知道网页三剑客指的是什么吗？你有用过 Dreamwear 吗？</a></li>
</ul>
<p>1、【html】说说你对 cookie 和 session 的理解？</p>
<p><strong>解析：</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">由于 http 是无状态的，服务端没法记录客户端的状态。因此 cookie 和 session 本身就是为了记录客户端的状态。</span><br><span class="line"></span><br><span class="line">只是 cookie 是存放在客户端而 session 是记录在服务端。cookie 可以在客户端生成也可以由服务器生成传给客户端，通过 name=value 的形式存储数据。</span><br><span class="line"></span><br><span class="line">一般 cookie 会记录一个由服务端生成的 token，session 同样会记录这个 token。服务端就可以通过 token 来鉴别身份。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cookie: 可以通过客户端, 服务端设置, 容量小, 可以通过设置domain来实现同步登录, 除了name, value, 它还有多个选项, domain, path, secure, expires, 客户端和服务端可以通过cookie来通讯, 传递信息</span><br><span class="line"></span><br><span class="line">session: 由服务端设置并发起, 是服务端对于用户行为的一种凭证, 通常也是由cookie来维持这种关系, 比如session_id, 或者现在webstorm设置的Webstorm-bb00fc34等! 通过这种维持两者的关系,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cookie: name=value 形式，可以设置过期时间，一般用来保持状态，不然每次都要登录</span><br><span class="line"></span><br><span class="line">session：也是保存状态，在服务端产生，一些敏感信息放在服务端session，然后产生一个 sessionId,通过 cookie 传到客户端，然后每次客户端请求会带cookie，服务端从cookie中获取sessionID，从而获取敏感信息。不过浏览器一关就没了，不关过一会儿也会失效</span><br><span class="line"></span><br><span class="line">把session放入cookie中便有了session cookie 2223</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】 实现单行文本居中和多行文本左对齐并超出显示”…”</p>
<p><strong>解析：</strong> 有点懵<del>~</del></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.multi</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden</span><br><span class="line">  text-overflow: ellipsis</span><br><span class="line">  display: -webkit-box</span><br><span class="line">  -webkit-line-clamp: <span class="number">3</span></span><br><span class="line">  -webkit-box-orient: vertical</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】 说说你对 eval 的理解？</p>
<p><code>eval()</code> 相当于一个小型的 js 解析器，接受一个字符串，可以把字符串解析成 js 代码并执行，所以有很有大的安全隐患，并且写进去的代码都是字符串，不利于维护，使用它执行代码性能也会大大折扣，所以正常情况下不建议使用</p>
<p>执行 js 代码，有性能问题，又可以执行一些恶意代码。webpack 中处理 soucemap 就用到了 eval，所有一个东西用途还是需要看场景。</p>
<h3 id="第-39-天-2019-11-08"><a href="#第-39-天-2019-11-08" class="headerlink" title="第 39 天 (2019.11.08)"></a>第 39 天 (2019.11.08)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/144">title 与 h1、b 与 strong、i 与 em 的区别分别是什么？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/145">写出你知道的 CSS 水平和垂直居中的方法</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/146">说说你对模块化的理解</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/147">公钥加密和私钥加密是什么？</a></li>
</ul>
<p>1、【html】 title 与 h1、b 与 strong、i 与 em 的区别分别是什么？</p>
<p>关于 <code>title</code> 和 <code>h1</code>，<code>title</code> 是网页的标题。主要面向的对象是搜索引擎和通过搜索结果过来的人（面向外人，可以理解为报纸首页的标题）。而 <code>h1</code> 是网页内部的标题，是给已经进到页面的人看的（可以理解为报纸某个版面的大标题）。从人类的语境上来理解，两者并没有差别。</p>
<p><code>b</code> 与 <code>strong</code> 的效果人眼上是无法区分的。在语义上，<code>b</code> 仅表示加粗既装饰用，我们应该使用 CSS 而不应该使用 <code>b</code>；而 <code>strong</code> 则表示被包围的内容很重要，是语气上的感觉。对于搜索引擎来说，会把 <code>b</code> 和 <code>strong</code> 视为同一含义。因此我们在使用上需要注意。</p>
<p><code>i</code> 与 <code>em</code> 的区别类似 <code>b</code> 和 <code>strong</code> 的区别。<code>i</code> 用于斜体展示，我们应该使用 CSS 而不应该使用 <code>i</code>；而 <code>em</code> 则是对内容的强调，但程度没有 <code>strong</code> 那么高。同样，对搜索引擎来说，两者是没有区别的。</p>
<p>3、【js】 说说你对模块化的理解？</p>
<p>模块化解决了代码污染的问题。提高了代码的重复率以及让多人合作编程了可能。</p>
<p><strong>模块化分为：</strong></p>
<ul>
<li>AMD: require.js 为代表，依赖前置，一律先加载再使用。</li>
<li>CMD: sea.js 为代表，依赖就近原则。</li>
<li>UMD: 同时支持 AMD 和 CMD 方法。</li>
<li>ES6 import/export</li>
</ul>
<p>4、【软技能】 公钥加密和私钥加密是什么？</p>
<p>公钥加密，私钥解密吧。非对称加密的方式，比如 rsa 方式。对称加密 des</p>
<h3 id="第-40-天-2019-11-17"><a href="#第-40-天-2019-11-17" class="headerlink" title="第 40 天 (2019.11.17)"></a>第 40 天 (2019.11.17)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/148">html5 都有哪些新的特性？移除了哪些元素？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/149">怎么才能让图文不可复制？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/150">为什么会有跨域问题？怎么解决跨域？</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/151">说说你对 NodeJs 的理解及用途</a></li>
</ul>
<p>1、【html】 html5 都有哪些新的特性？移除了哪些元素？</p>
<ol>
<li>语义化的标签，header,footer,nav,section,article 等。</li>
<li>表单类型增多，date,datetime,email,range,url,time 等。</li>
<li>视频音频标签，localstorage,sessionstorage 等。canvas，拖动的 api。</li>
<li>移除了 basefont，big，center，font,s，strike，tt，u，frame，frameset，noframes；</li>
</ol>
<p>2、【css】 怎么才能让图文不可复制 ?</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/user-select">MDN</a></p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.unselectable</span> &#123;</span><br><span class="line">  <span class="attribute">-moz-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-ms-user-select</span>: none;</span><br><span class="line">  <span class="attribute">user-select</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、【js】 为什么会有跨域问题？怎么解决跨域？</p>
<blockquote>
<p>跨域一句话的理解就是：服务端和请求端的地址不一样。</p>
</blockquote>
<p>浏览器为了安全，产生了同源策略，协议、域名、端口有一个不同，就会产生跨域。跨域方式有 jsonp,代理方式，cors，domain 改变主域相同，postmessage 也可以</p>
<p><strong>什么是跨域</strong></p>
<p>Ajax 的便利性大家都清楚，可以在不向服务器提交完整的页面的情况下，实现局部更新页面。但是浏览器处于对安全方面的考虑，不允许跨域调用其他页面的对象。<br>其实这个也不能怪浏览器，假设谁都可以随随便便向你发送请求，那样有很大的安全隐患。<br>根据浏览器的同源策略, 只有当协议，域名，端口相同的时候才算是同源, 反之则均视为是一个跨域的请求.<br>也就是说我刚刚的 Vue 端口是<code>8081</code>，服务端端口是<code>8080</code>，端口不一样，因为同源策略的存在 ，所有我的请求会失败。</p>
<p><strong>怎么解决跨域</strong> <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/150">参考</a></p>
<ol>
<li>JSONP</li>
<li>CORS</li>
<li>Server Proxy</li>
</ol>
<p><strong>总结</strong></p>
<p>常用的跨域方式基本就是这三种：</p>
<ol>
<li>JSONP<br>优点是可以兼容老浏览器，缺点是只能发送 GET 请求</li>
<li>CORS<br>优点简单方便，支持 post 请求，缺点是需要后端的配合,不支持老版浏览器。。</li>
<li>Server Proxy<br>优点是前端正常发送 ajax 请求，缺点是后端会二次请求。</li>
</ol>
<p>参考资料：</p>
<ul>
<li>跨域资源共享 CORS 详解[阮一峰的博客]：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/04/cors.html">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></li>
<li>关于跨域，你想知道的全在这里：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25778815">https://zhuanlan.zhihu.com/p/25778815</a></li>
<li>不要再问我跨域的问题了[sf]：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015597029">https://segmentfault.com/a/1190000015597029</a></li>
<li>关于跨域,以及跨域的几种方式[cnblog]：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenshishuo/p/4919224.html">https://www.cnblogs.com/chenshishuo/p/4919224.html</a></li>
<li>浏览器的同源策略[MDN]:<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></li>
</ul>
<p>4、【软技能】说说你对 NodeJs 的理解及用途？</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/33578075">Node.js 是用来做什么的？</a></p>
</blockquote>
<p>Node.js 是一个 javascript 运行环境。它让 javascript 可以开发后端程序，实现几乎其他后端语言实现的所有功能，可以与 PHP、Java、Python、.NET、Ruby 等后端语言平起平坐。</p>
<p>Nodejs 是基于 V8 引擎，V8 是 Google 发布的开源 JavaScript 引擎，本身就是用于 Chrome 浏览器的 js 解释部分，但是 Ryan Dahl 这哥们，鬼才般的，把这个 V8 搬到了服务器上，用于做服务器的软件。</p>
<p>优势：</p>
<ol>
<li>Nodejs 语法完全是 js 语法，只要你懂 js 基础就可以学会 Nodejs 后端开发</li>
<li>NodeJs 超强的高并发能力</li>
<li>实现高性能服务器</li>
<li>开发周期短、开发成本低、学习成本低</li>
</ol>
<p><strong>Node.js 能干什么</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20181107112112563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzQyNzIw,size_16,color_FFFFFF,t_70"></p>
<h3 id="第-41-天-2019-11-17"><a href="#第-41-天-2019-11-17" class="headerlink" title="第 41 天 (2019.11.17)"></a>第 41 天 (2019.11.17)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/152">webSocket 怎么做兼容处理？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/153">怎么让英文单词的首字母大写？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/154">说说你对 IIFE 的理解</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/155">你有自己的博客吗？平时自己有写一些技术文章吗？</a></li>
</ul>
<p>1、【html】 webSocket 怎么做兼容处理？</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5aef0e9c518825673a20754d">如何解决 WebSocket 的兼容性</a></p>
</blockquote>
<p>2、【css】怎么让英文单词的首字母大写？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">  <span class="attribute">text-transform</span>: capitalize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Keyword values */</span></span><br><span class="line"><span class="selector-tag">text-transform</span>: <span class="selector-tag">capitalize</span>;</span><br><span class="line"><span class="selector-tag">text-transform</span>: <span class="selector-tag">uppercase</span>;</span><br><span class="line"><span class="selector-tag">text-transform</span>: <span class="selector-tag">lowercase</span>;</span><br><span class="line"><span class="selector-tag">text-transform</span>: <span class="selector-tag">none</span>;</span><br><span class="line"><span class="selector-tag">text-transform</span>: <span class="selector-tag">full-width</span>;</span><br></pre></td></tr></table></figure>

<p>capitalize<br>这个关键字强制每个单词的首字母转换为大写。</p>
<p>uppercase<br>这个关键字强制所有字符被转换为大写。</p>
<p>lowercase<br>这个关键字强制所有字符被转换为小写。</p>
<p>none<br>这个关键字阻止所有字符的大小写被转换。</p>
<p>full-width （实验性属性值）<br>这个关键字强制字符 — 主要是表意字符和拉丁文字 — 书写进一个方形里，并允许它们按照一般的东亚文字（比如中文或日文）对齐。</p>
<p>除了以上，还有一些基本上不会用到的默认值等，就不多说了。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="selector-tag">text-transform</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="selector-tag">text-transform</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">text-transform</span>: <span class="selector-tag">unset</span>;</span><br></pre></td></tr></table></figure>

<p>3、【js】说说你对 IIFE 的理解</p>
<blockquote>
<p>最大的作用是创建一个<strong>独立的作用域</strong></p>
</blockquote>
<p>用 IIFE（匿名函数立即执行）实现，针对<strong>不需要复用的功能模块</strong>可以用 IIFE 完全消除全局变量，所以一般 IIFE 都是用来辅助命名空间/模块化方式的</p>
<h3 id="第-42-天-2019-11-18"><a href="#第-42-天-2019-11-18" class="headerlink" title="第 42 天 (2019.11.18)"></a>第 42 天 (2019.11.18)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/156">解释下什么是 ISISO8859-2 字符集？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/158">重置（初始化）css 的作用是什么？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/157">window 对象和 document 对象有干什么区别？</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/159">你现在在团队是什么角色，有起到了什么显著的作用吗？</a></li>
</ul>
<p>1、【html】解释下什么是 ISISO8859-2 字符集？</p>
<p>当今开发环境下，对于一个字符集，通常情况下，我们只需要有两个认识：</p>
<blockquote>
<ul>
<li>它是 UTF-8 吗？</li>
<li>如果不是，那它兼容 UTF-8 吗？</li>
</ul>
</blockquote>
<p>对于 ISO-8859，回答是：</p>
<blockquote>
<p>它不是 UTF-8，但它兼容 UTF-8。它是 UTF-8 的子集。</p>
</blockquote>
<p>当然，知道了也没用。你还是用 UTF-8。</p>
<blockquote>
<p>注：你如果接手一个遗留项目，可能会接触到和 UTF-8 不同的其他字符集。你的开发体验通常会很差，因为其他工具都用 UTF-8。所以，最好的方法是：不要接手非 UTF-8 的遗留项目。</p>
</blockquote>
<hr>
<p>这个知识点在非科班的来看算是比较偏门的了。<br>查了一下才知道，原来是 Ascll 扩展部分的字符集。</p>
<blockquote>
<p>ISO/IEC 8859-1，又称 Latin-1 或“西欧语言”，ISO/IEC 8859-2 Latin-2 或“中欧语言”，是国际标准化组织内 ISO/IEC 8859 的 8 位字符集。它以 ASCII 为基础，在空置的 0xA0-0xFF 的范围内，加入 192 个字母及符号，藉以供使用变音符号的拉丁字母语言使用。</p>
</blockquote>
<p>我觉得可以把它看做是 Ascll 码的一部分</p>
<p>2、【css】 第 42 天 重置（初始化）css 的作用是什么？</p>
<blockquote>
<p>我理解的，简单讲主要是为了 统一各个浏览器自带的默认样式而诞生的。</p>
</blockquote>
<p>这是一个，还有就是 <strong>视觉问题</strong> ，浏览器默认样式会影响我们的设计还原，而且默认样式一般不够美观，满足不了定制化的视觉需求，达不到视觉产品的信息传达目标。</p>
<p>3、【js】 window 对象和 document 对象有什么区别？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Window是浏览器的对象可以称为宿主对象。宿主对象包括（Bom，<span class="built_in">setTimeout</span>，storage，work Server等 ）</span><br><span class="line">Document是文档对象，以html形式展示。是<span class="built_in">window</span>对象里面的 一部分。</span><br><span class="line"></span><br><span class="line">## window对象</span><br><span class="line">   代表浏览器中的一个打开的窗口或者框架，<span class="built_in">window</span>对象会在或者每次出现时被自动创建，在客户端JavaScript中，Window对象是全局对象<span class="built_in">global</span>，所有的表达式都在当前的环境中计算，要引用当前的窗口不需要特殊的语法，可以把那个窗口属性作为全局变量使用，例如：可以只写<span class="built_in">document</span>，而不必写<span class="built_in">window</span>.document。同样可以把窗口的对象方法当做函数来使用，如：只写alert()，而不必写<span class="built_in">window</span>.alert.</span><br><span class="line"><span class="built_in">window</span>对象实现了核心JavaScript所定义的全局属性和方法。</span><br><span class="line"></span><br><span class="line">## document对象</span><br><span class="line">   代表整个HTML文档，可以用来访问页面中的所有元素 。</span><br><span class="line">每一个载入浏览器的HTML文档都会成为<span class="built_in">document</span>对象。<span class="built_in">document</span>对象使我们可以使用脚本(js)中对HTML页面中的所有元素进行访问。</span><br><span class="line"><span class="built_in">document</span>对象是<span class="built_in">window</span>对象的一部分可以通过<span class="built_in">window</span>.document属性对其进行访问</span><br><span class="line">HTMLDocument接口进行了扩展，定义HTML专用的属性和方法，很多属性和方法都是HTMLCollection对象，其中保存了对锚、表单、链接以及其他可脚本元素的引用。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-43-天-2019-05-29"><a href="#第-43-天-2019-05-29" class="headerlink" title="第 43 天 (2019.05.29)"></a>第 43 天 (2019.05.29)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/161">如何让元素固定在页面底部？有哪些比较好的实践？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/162">span 与 span 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/163">JQuery 的源码看过吗？能不能简单概括一下它的实现原理？</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/164">最近在学什么？能谈谈你未来 3，5 年给自己的规划吗？</a></li>
</ul>
<p>1、【html】 如何让元素固定在页面底部？有哪些比较好的实践？</p>
<p>解析：这个是在结构的底部还是视图的底部 ，视图底部就是 fixed，结构的底部就是 sticky footer 布局咯~</p>
<p>2、【css】span 与 span 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/">张鑫旭</a></p>
</blockquote>
<ol>
<li><p>方法之移除空格</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;space&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;##&quot;&gt;</span><br><span class="line">    惆怅&lt;/a&gt;&lt;a href=&quot;##&quot;&gt;</span><br><span class="line">    淡定&lt;/a&gt;&lt;a href=&quot;##&quot;&gt;</span><br><span class="line">    热血&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 margin 负值</p>
</li>
<li><p>让闭合标签吃胶囊</p>
</li>
<li><p>使用 font-size:0</p>
</li>
<li><p>使用 letter-spacing</p>
</li>
<li><p>使用 word-spacing</p>
</li>
<li><p>其他成品方法</p>
</li>
</ol>
<p>3、【js】JQuery 的源码看过吗？能不能简单概括一下它的实现原理？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window, undefined, document</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params">prop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jQuery.prototype.init();</span><br><span class="line">  &#125;</span><br><span class="line">  jQuery.prototype = &#123;</span><br><span class="line">    contructor: jQuery,</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> (<span class="params">prop</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">  jQuery.prototype.init.prototype = jQuery.prototype;</span><br><span class="line">  <span class="built_in">window</span>[<span class="string">&quot;jQuery&quot;</span>] = <span class="built_in">window</span>[<span class="string">&quot;$&quot;</span>] = <span class="keyword">new</span> jQuery();</span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="literal">undefined</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>

<p>jQuery 是通过封装浏览器原生的 DOM API 实现 dom 元素的选取，然后封装到 jQuery 对象中去，同时根据浏览器检测对不同浏览器操作不同的 APi .jQuery 对象上高度集成了超的 API。当然 jQuery 还有做的更多比如，我们可以 new jQuery(‘div’),也可以直接$(‘div’),这个巧妙地运算就是上面init方法；如果页面已经有$时，jQuery 会先将$接管把之前$的全局名保存下来 等后面使用是在释放、。。。大致了解。</p>
<p>4、【软技能】 最近在学什么？能谈谈你未来 3，5 年给自己的规划吗？</p>
<h3 id="第-44-天-2019-11-19"><a href="#第-44-天-2019-11-19" class="headerlink" title="第 44 天 (2019.11.19)"></a>第 44 天 (2019.11.19)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/165">说说 video 标签中预加载视频用到的属性是什么？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/166">手写一个满屏品字布局的方案</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/167">深度克隆对象的方法有哪些，并把你认为最好的写出来</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/168">说说你对 http、https、http2 的理解</a></li>
</ul>
<p>1、【html】 说说 video 标签中预加载视频用到的属性是什么？</p>
<blockquote>
<p>preload</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>autoplay</td>
<td>autoplay</td>
<td>如果出现该属性，则视频在就绪后马上播放。</td>
</tr>
<tr>
<td>controls</td>
<td>controls</td>
<td>如果出现该属性，则向用户显示控件，比如播放按钮。</td>
</tr>
<tr>
<td>height</td>
<td>pixels</td>
<td>设置视频播放器的高度。</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>如果出现该属性，则当媒介文件完成播放后再次开始播放。</td>
</tr>
<tr>
<td>preload</td>
<td>preload</td>
<td>如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td>
</tr>
<tr>
<td>src</td>
<td>url</td>
<td>要播放的视频的 URL。</td>
</tr>
<tr>
<td>width</td>
<td>pixels</td>
<td>设置视频播放器的宽度。</td>
</tr>
</tbody></table>
<p>2、【css】手写一个满屏品字布局的方案？</p>
<blockquote>
<p>flex 、float、grid 布局</p>
</blockquote>
<p>3、【js】 深度克隆对象的方法有哪些，并把你认为最好的写出来</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5abb55ee6fb9a028e33b7e0a">面试官:请你实现一个深克隆</a></p>
</blockquote>
<p>1、前几年微博上流传着一个传说中最便捷实现深克隆的方法, JSON 对象 parse 方法可以将 JSON 字符串反序列化成 JS 对象，stringify 方法可以将 JS 对象序列化成 JSON 字符串,这两个方法结合起来就能产生一个便捷的深克隆.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(oldObj));</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：</p>
<ol>
<li><p>它无法实现对函数 、RegExp 等特殊对象的克隆</p>
</li>
<li><p>会抛弃对象的 constructor,所有的构造函数会指向 Object</p>
</li>
<li><p>对象有循环引用,会报错</p>
</li>
<li><p>构造一个深克隆函数</p>
</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626bc7a5caf947c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>4、【软技能】说说你对 http、https、http2 的理解？</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d4a47226fb9a06b0a275f33">说说你对 http、https、http2.0 的理解？</a></p>
</blockquote>
<h3 id="第-45-天-2019-11-23"><a href="#第-45-天-2019-11-23" class="headerlink" title="第 45 天 (2019.11.23)"></a>第 45 天 (2019.11.23)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/169">xml 与 html 有什么区别？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/170">你知道的等高布局有多少种？写出来</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/171">写出几种创建对象的方式，并说说他们的区别是什么？</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/172">从你的角度上来讲，你觉得如何管理前端团队？</a></li>
</ul>
<p>1、【html】 xml 与 html 有什么区别？</p>
<blockquote>
<p>XML：<br>必须闭合；元素嵌套正确；标签小写； 必须有根元素</p>
</blockquote>
<ol>
<li>html 不区分大小写，xml 区分大小写</li>
<li>html 可以没有闭合标签，xml 必须有闭合标签</li>
<li>html 可以拥有不带值的属性名，xml 中所有的属性必须带值</li>
<li>html 是用于显示数据，xml 主要用于描述，存放数据</li>
<li>XML 的多个空格不会被合并成一个空格，而 HTML 会。</li>
</ol>
<p>2、【css】 你知道的等高布局有多少种？写出来</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b0fb34151882515662238fd">常用的多列等高布局</a></p>
</blockquote>
<ol>
<li><p>使用负 margin-bottom 和正 padding-bottom 对冲实现</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.Article</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span> -<span class="number">9999px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">9999px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#4577dc</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>flex 布局</p>
</li>
<li><p>模仿 table 布局</p>
</li>
<li><p>grid 布局</p>
</li>
<li><p>js 计算</p>
</li>
</ol>
<p>3、【js】 写出几种创建对象的方式，并说说他们的区别是什么？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 创建, 不推荐  ---new 实例化</span></span><br><span class="line"><span class="keyword">const</span> b = &#123;&#125;; <span class="comment">// 赋值, 性能比a要好  --字面量</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="built_in">Object</span>.create(); <span class="comment">// 继承创建, Object.create(null) 很多框架都有用来做性能优化</span></span><br></pre></td></tr></table></figure>

<p><strong>new Object()</strong></p>
<p>直接通过构造函数创建一个新对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; new Object()</span><br><span class="line">&#x2F;&#x2F;等同于 var obj &#x3D; &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用字面量的方式更简单，其实他俩是一样的。<br>优点是足够简单，缺点是每个对象都是独立的。</p>
<p><strong>工厂模式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  obj.name = name;</span><br><span class="line">  obj.age = age;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Anson = createObj(<span class="string">&quot;Anson&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Anson);</span><br><span class="line"><span class="comment">//&#123;name: &quot;Anson&quot;, age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<p>优点是 可以解决创建多个相似对象的问题，缺点是 无法识别对象的类型。</p>
<p><strong>构造函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>, <span class="number">13</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br><span class="line"><span class="comment">//Person &#123;name: &quot;小明&quot;, age: 13, sayName: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<p>优点是 可以创建特定类型的对象，缺点是 多个实例重复创建方法</p>
<p><strong>（构造函数+原型）组合模式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;小白&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br><span class="line"><span class="comment">//Person &#123;name: &quot;小白&quot;, age: 18&#125; __proto__ -&gt; sayName: ƒ ()</span></span><br></pre></td></tr></table></figure>

<p>优点 多个实例引用一个原型上的方法 比较常用</p>
<p><strong>动态原型</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span>.sayName != <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;小红&quot;</span>, <span class="number">15</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br><span class="line"><span class="comment">//Person &#123;name: &quot;小红&quot;, age: 15&#125; 动态创建sayName: ƒ ()</span></span><br></pre></td></tr></table></figure>

<p>优点 可以判断某个方法是否有效，来决定是否需要初始化原型，if 只会在仅在碰到第一个实例调用方法<br>时会执行，此后所有实例共享此方法，需要注意的一点是，不能重新原型对象。</p>
<p><strong>寄生构造函数模式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">&quot;her&quot;</span>, <span class="number">18</span>, <span class="string">&quot;Front-end Engineer&quot;</span>);</span><br><span class="line">friend.sayName();</span><br><span class="line"><span class="comment">//her</span></span><br></pre></td></tr></table></figure>

<p>除了使用<code>new</code>操作符，其他的和工厂函数一样，可以为对象创建构造函数。</p>
<p><strong>稳妥模式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o=&#123;&#125;;</span><br><span class="line">    o.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(name) &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = (<span class="string">&#x27;小亮&#x27;</span>，<span class="number">24</span>);</span><br><span class="line">person.sayName();<span class="comment">//’小亮‘</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了使用<code>person.sayName()</code>之外 ，没有办法在访问到 name 的值，适合在某些安全执行环景下使用。</p>
<p><strong>Object.create()</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  isHuman: <span class="literal">false</span>,</span><br><span class="line">  printIntroduction: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>. Am I human? <span class="subst">$&#123;<span class="built_in">this</span>.isHuman&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.create(person);</span><br><span class="line"></span><br><span class="line">me.name = <span class="string">&quot;Matthew&quot;</span>; <span class="comment">// &quot;name&quot; is a property set on &quot;me&quot;, but not on &quot;person&quot;</span></span><br><span class="line">me.isHuman = <span class="literal">true</span>; <span class="comment">// inherited properties can be overwritten</span></span><br><span class="line"></span><br><span class="line">me.printIntroduction();</span><br><span class="line"><span class="comment">// expected output: &quot;My name is Matthew. Am I human? true&quot;</span></span><br></pre></td></tr></table></figure>

<p>传入一个原型对象，创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>，实现继承。</p>
<p><strong>参考：</strong>《JavaScript 高级程序设计第三版》、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">MDN</a></p>
<h3 id="第-46-天-2019-11-24"><a href="#第-46-天-2019-11-24" class="headerlink" title="第 46 天 (2019.11.24)"></a>第 46 天 (2019.11.24)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/173">页面中怎么嵌入 Flash？有哪些方法？写出来</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/174">说说你对媒体查询的理解</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/175">写一个使两个整数进行交换的方法（不能使用临时变量）</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/176">说说你对本项目的看法及建议</a></li>
</ul>
<p>1、【html】 页面中怎么嵌入 Flash？有哪些方法？写出来</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/%E5%85%B6%E4%BB%96%E5%B5%8C%E5%85%A5%E6%8A%80%E6%9C%AF">从对象到 iframe - 其他嵌入技术</a></p>
<p>看一些能让您在网页中嵌入各种内容类型的元素： <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe">``</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed">``</a> 和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object">``</a> 元素。<code>&lt;iframe&gt;</code>用于嵌入其他网页，另外两个元素则允许您嵌入 PDF，SVG，甚至 Flash — 一种正在被淘汰的技术，但您仍然会时不时的看到它。</p>
<table>
<thead>
<tr>
<th>预备知识：</th>
<th>基本的计算机素养，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/Learn/Getting_started_with_the_web/Installing_basic_software">安装基础软件</a>，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/Learn/Getting_started_with_the_web/Dealing_with_files">文件处理</a> 的基本知识，熟悉 HTML 基础知识（阅读 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML/Getting_started">开始学习 HTML</a>）以及本模块中以前的文章。</th>
</tr>
</thead>
<tbody><tr>
<td>学习目标：</td>
<td>要了解如何使用<code>&lt;object&gt;、</code><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed">``</a>以及<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe">``</a>在网页中嵌入部件，例如 Flash 电影或其他网页。</td>
</tr>
</tbody></table>
<p>&lt;_embed_ &gt;和&lt;_object_ &gt;元素</p>
<p>&lt;_embed_ &gt;和&lt;_object_ &gt;元素的功能不同于<code>&lt;iframe&gt;</code>—— 这些元素是用来嵌入多种类型的外部内容的通用嵌入工具，其中包括像 Java 小程序和 Flash，PDF（可在浏览器中显示为一个 PDF 插件）这样的插件技术，甚至像视频，SVG 和图像的内容！</p>
<p><strong>注意</strong>：<strong>插件</strong>是一种对浏览器原生无法读取的内容提供访问权限的软件。</p>
</blockquote>
<p><strong>页面中怎么嵌入 Flash？</strong></p>
<ol>
<li>object + embed 传统的方法</li>
<li>单 object</li>
<li>双 object</li>
<li>flex 提供的标准方法</li>
<li>swfobject</li>
<li>单 embed 显示 ie7 和 ff3 下都能正常显示</li>
</ol>
<p>2、【css】 说说你对媒体查询的理解？</p>
<blockquote>
<p>为了适应不同的设备终端</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190522114353452.png"></p>
<p>3、【js】 写一个使两个整数进行交换的方法（不能使用临时变量）</p>
<p><strong>解析：</strong></p>
<ul>
<li>ES5</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line">a = b + a;</span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure>

<ul>
<li>ES6</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b] = [b, a];</span><br></pre></td></tr></table></figure>

<p>异或取值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a ^= b;</span><br><span class="line">b ^= a;</span><br><span class="line">a ^= b;</span><br></pre></td></tr></table></figure>

<h3 id="第-47-天-2019-12-05"><a href="#第-47-天-2019-12-05" class="headerlink" title="第 47 天 (2019.12.05)"></a>第 47 天 (2019.12.05)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/177">HTML5 如何使用音频和视频？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/178">你是怎样抽离样式模块的？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/179">请说说你对事件冒泡机制的理解？</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/180">如果 HR 说要做背调，还要你给出近三个月的银行流水，你该怎么办？</a></li>
</ul>
<p>1、【html】HTML5 如何使用音频和视频？</p>
<p>HTML5 新标签可以直接用 video 和 audio，但是想要自动播放还有些兼容性问题，在手机上各浏览器需要做兼容处理。</p>
<p>2、【css】你是怎样抽离样式模块的？</p>
<p>样式模块？<br>通过组件化思想，用 <a target="_blank" rel="noopener" href="https://github.com/Tencent/tmt-workflow/wiki/%E2%92%9B-%5B%E8%A7%84%E8%8C%83%5D--CSS-BEM-%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83">BEM </a>方式命名。</p>
<p>3、【js】 <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/179">请说说你对事件冒泡机制的理解？</a></p>
<p>按照 W3C 事件模型，事件流按照次序依次为<code>捕获阶段</code>， <code>目标阶段</code>，<code>冒泡阶段</code>。如果事件绑定时候，禁止了冒泡，则事件流会停止在目标阶段。</p>
<p>先说两个有关 DOM 事件流的概念<code>事件冒泡</code>和<code>事件捕获</code>。</p>
<ul>
<li>事件冒泡： 事件沿着 DOM 树向上通知</li>
<li>事件捕获：和事件冒泡相反，事件沿着 DOM 数向下通知</li>
</ul>
<p>开发者可以自己决定事件处理注册到捕获阶段，或者是冒泡阶段。<br><code>element1.addEventListener(&#39;click&#39;,doSomething2,true)</code> 如果最后一个参数为 true，则注册到捕获阶段。</p>
<p><strong>事件委托(事件代理)</strong><br>介绍完上面的，事件委托是时候登场了。事件委托简单说起来就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>
<h3 id="第-48-天-2019-12-05"><a href="#第-48-天-2019-12-05" class="headerlink" title="第 48 天 (2019.12.05)"></a>第 48 天 (2019.12.05)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/181">说说你对 WEB 标准和 W3C 的理解与认识？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/182">你知道全屏滚动的原理是什么吗？它用到了 CSS 的那些属性？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/183">你对事件循环有了解吗？说说看！</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/184">最近 996 一词很火，谈谈你对 996 的看法</a></li>
</ul>
<p>1、【html】 说说你对 WEB 标准和 W3C 的理解与认识？</p>
<p><strong>web 标准</strong></p>
<ul>
<li>什么是 web 标准：一系列标准的集合，包括结构化标准语言（html 等）、表现标准语言（css）、行为标准语言（EMCAScript 等）。这些标准大部分由万维网联盟起草和发布</li>
<li>为什么使用 web 标准：为了解决因浏览器版本不同、软硬件设备不同导致的需多版本开发的问题</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">html是名词--表现</span><br><span class="line">css是形容词--结构</span><br><span class="line">javascript是动词--行为</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上这三个东西就形成了一个完整的网页，但是 js 改变时，可以会造成 css 和 html 的混乱，让这三个的界限不是那么清晰。</p>
<p>这个时候，web 标准就出来了，web 标准一般是将该三部分独立分开，使其更具有模块化。</p>
<p>W3C 对 web 标准提出了规范化的要求，也就是在实际编程中的一些代码规范：包含如下几点</p>
<p>1.对于结构要求：（标签规范可以提高搜索引擎对页面的抓取效率，对 SEO 很有帮助）</p>
<p>标签字母要小写<br>标签要闭合<br>标签不允许随意嵌套 2.对于 css 和 js 来说</p>
<p>尽量使用外链 css 样式表和 js 脚本。是结构、表现和行为分为三块，符合规范。同时提高页面渲染速度，提高用户的体验。<br>样式尽量少用行间样式表，使结构与表现分离，标签的 id 和 class 等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版</p>
<p><strong>W3C</strong>：万维网联盟，是一个 web 开发的国际性联盟</p>
<p>2、【css】知道全屏滚动的原理是什么吗？它用到了 CSS 的哪些属性？</p>
<p><strong>一、知识点</strong></p>
<ul>
<li>JS 滚动监听事件</li>
<li>JS 移动端 touch 监听事件</li>
<li>函数节流</li>
<li>DOM 操作</li>
</ul>
<p><strong>二、代码分析</strong></p>
<p><strong>1.CSS</strong></p>
<p>html, body 设置 overflow 为 hidden, 让视图中只包括一个分页;设置滑动分页的长宽都是 100%; 外部容器设置 transition 过渡效果, 并设置为相对定位, 滚动是修改外部容器的 Top 值, 实现滚动效果.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page-container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1000ms</span> ease;</span><br><span class="line">  <span class="attribute">touch-action</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page-item</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.HTML</strong></p>
<p>初始三个分页</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-item&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-item&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-item&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3.JavaScript</strong></p>
<p>1.初始化值<br>容器高度设置为窗口高度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.page-container&quot;</span>);</span><br><span class="line"><span class="comment">// 获取根元素高度, 页面可视高度</span></span><br><span class="line"><span class="keyword">var</span> viewHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line"><span class="comment">// 获取滚动的页数</span></span><br><span class="line"><span class="keyword">var</span> pageNum = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.page-item&quot;</span>).length;</span><br><span class="line"><span class="comment">// 初始化当前位置, 距离原始顶部距离</span></span><br><span class="line"><span class="keyword">var</span> currentPosition = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 设置页面高度</span></span><br><span class="line">container.style.height = viewHeight + <span class="string">&quot;px&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>2.初始化滚动事件<br>向下滚动时, 当 <code>currentPosition</code> 比 <code>-整体分页高度</code> 大的时候(绝对值相比小的时候), 向下滚动;向上滚动时, 当 <code>currentPosition</code> 大于 <code>0</code> 的时候, 向上滚动.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向下滚动页面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goDown</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (currentPosition &gt; -viewHeight * (pageNum - <span class="number">1</span>)) &#123;</span><br><span class="line">    currentPosition = currentPosition - viewHeight;</span><br><span class="line">    container.style.top = currentPosition + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上滚动页面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (currentPosition &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    currentPosition = currentPosition + viewHeight;</span><br><span class="line">    container.style.top = currentPosition + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.节流函数<br>即在规定时间内只会触发一次指定方法, 用于滚动时防止多次触发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function throttle (fn, delay) &#123;</span><br><span class="line">  let baseTime &#x3D; 0</span><br><span class="line">  return function () &#123;</span><br><span class="line">    const currentTime &#x3D; Date.now()</span><br><span class="line">    if (baseTime + delay &lt; currentTime) &#123;</span><br><span class="line">      fn.apply(this, arguments)</span><br><span class="line">      baseTime &#x3D; currentTime</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;js</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.监听鼠标滚动<br>滚动事件<code>firefox</code>与其他浏览器的事件不同, 所以需要进行判断. <code>deltaY</code>大于<code>0</code>的时候, 想下滚动; 反之, 向上滚动.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handlerWheel = throttle(scrollMove, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// https://developer.mozilla.org/en-US/docs/Web/API/Element/mousewheel_event#The_detail_property</span></span><br><span class="line"><span class="comment">// firefox的页面滚动事件其他浏览器不一样</span></span><br><span class="line"><span class="keyword">if</span> (navigator.userAgent.toLowerCase().indexOf(<span class="string">&quot;firefox&quot;</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">&quot;mousewheel&quot;</span>, handlerWheel);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">&quot;DOMMouseScroll&quot;</span>, handlerWheel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollMove</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.deltaY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    goDown();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    goUp();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.监听移动端 touch 操作<br>当 touch 的最终位置大于起始位置时, 则页面向上滚动; 反之, 向下滚动.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> touchStartY = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;touchstart&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  touchStartY = event.touches[<span class="number">0</span>].pageY;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> handleTouchEnd = throttle(touchEnd, <span class="number">500</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;touchend&quot;</span>, handleTouchEnd);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">touchEnd</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> touchEndY = e.changedTouches[<span class="number">0</span>].pageY;</span><br><span class="line">  <span class="keyword">if</span> (touchEndY - touchStartY &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 向上滑动, 页面向下滚动</span></span><br><span class="line">    goDown();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    goUp();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-49-天-2019-12-15"><a href="#第-49-天-2019-12-15" class="headerlink" title="第 49 天 (2019.12.15)"></a>第 49 天 (2019.12.15)</h3><ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/185">说说你对 target=”_blank”的理解？有啥安全性问题？如何防范？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/186">假如设计稿使用了非标准的字体，你该如何去实现它？</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/187">写个还剩下多少天过年的倒计时</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/188">你有遇到过字体侵权的事吗？如何解决？</a></li>
</ul>
<p>1【html】说说你对 target=”_blank”的理解？有啥安全性问题？如何防范？</p>
<blockquote>
<p>通常在网页中使用链接时，你很可能会添加一个简单的 target=”_blank” 属性到 a 标签上来让浏览器用一个新的标签页来打开一个 URL 地址。但是这一属性正在成为网络钓鱼者攻击的机会。 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/53132574">你从未注意的隐藏危险</a></p>
</blockquote>
<p>2、【css】 假如设计稿使用了非标准的字体，你该如何去实现它？</p>
<p>解析：设计的职责是美观，前端的职责是尽可能还原，设计之所以会使用非标准的字体、甚至侵权的字体是因为不了解技术实现和版权意识。<br>所以先 <strong>沟通</strong> ，告知设计实际的情况，然后在综合考量的情况下应该尽可能去实现，通常采用 <strong>载入字体</strong> 和 <strong>图片化</strong> 的方式。</p>
<p>3、【js】写个还剩下多少天过年的倒计时</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor((<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;2019-12-31&quot;</span>) - <span class="built_in">Date</span>.now()) / (<span class="number">10</span> ** <span class="number">5</span> * <span class="number">36</span> * <span class="number">24</span>));</span><br></pre></td></tr></table></figure>

<h3 id="第-50-天-2019-12-24"><a href="#第-50-天-2019-12-24" class="headerlink" title="第 50 天 (2019.12.24)"></a>第 50 天 (2019.12.24)</h3><ul>
<li>[html] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/189">Ajax 与 Flash 的优缺点分别是什么？</a></li>
<li>[css] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/190">列举 CSS 优化、提高性能的方法</a></li>
<li>[js] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/191">请写出一个函数求出 N 的阶乘（即 N!）</a></li>
<li>[软技能] <a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/192">说说你对 http、https 的理解</a></li>
</ul>
<p>2、【css】 列举 CSS 优化、提高性能的方法</p>
<p>加载性能</p>
<ol>
<li>压缩 CSS</li>
<li>通过 link 方式加载，而不是<a target="_blank" rel="noopener" href="https://github.com/import">@import</a></li>
<li>复合属性其实分开写，执行效率更高，因为 CSS 最终也还是要去解析如 <code>margin-left: left;</code></li>
</ol>
<p>选择器性能</p>
<ol>
<li>尽量少的使用嵌套，可以采用 BEM 的方式来解决命名冲突</li>
<li>尽量少甚至是不使用标签选择器，这个性能实在是差，同样的还有<code>*</code>选择器</li>
<li>利用继承，减少代码量</li>
</ol>
<p>渲染性能</p>
<ol>
<li>慎重使用高性能属性：浮动、定位；</li>
<li>尽量减少页面重排、重绘；</li>
<li>css 雪碧图</li>
<li>自定义 web 字体，尽量少用</li>
<li>尽量减少使用昂贵属性，如 box-shadow/border-radius/filter/透明度/:nth-child 等</li>
<li>使用<code>transform</code>来变换而不是宽高等会造成重绘的属性</li>
</ol>
<p>暂且先这样吧，看来想回答好，得好好梳理下了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%89%9B%E4%BA%BA%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">牛人面试题</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-muyiyang"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/09/20/muyiyang/"
    >木易杨每日一题</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/09/20/muyiyang/" class="article-date">
  <time datetime="2019-09-20T06:45:02.000Z" itemprop="datePublished">2019-09-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%89%9B%E4%BA%BA%E9%9D%A2%E8%AF%95%E9%A2%98/">牛人面试题</a> / <a class="article-category-link" href="/categories/%E7%89%9B%E4%BA%BA%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%9C%A8%E6%98%93%E6%9D%A8%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">木易杨每日一题</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h2><blockquote>
<p>每天一道大厂前端面试题，一年后再回头，会感谢曾经努力的自己！</p>
<p>待更新状态</p>
<p>今天 2019/12/23 ~ 💪</p>
</blockquote>
<h3 id="第-1-题-（2019-9-19）"><a href="#第-1-题-（2019-9-19）" class="headerlink" title="第 1 题 （2019/9/19）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md#%E7%AC%AC-1-%E9%A2%98%E5%86%99-react--vue-%E9%A1%B9%E7%9B%AE%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8%E5%88%97%E8%A1%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%86%99-key%E5%85%B6%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">第 1 题</a> （2019/9/19）</h3><p><strong>题目</strong>：写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？</p>
<p><strong>公司</strong>：滴滴、饿了么</p>
<p><strong>需了解</strong> ：vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中。可以先了解一下 diff 算法。<br>在交叉对比的时候，当新节点跟旧节点<code>头尾交叉对比</code>没有结果的时候，会根据新节点的 key 去对比旧节点数组中的 key，从而找到相应旧节点（这里对应的是一个 key =&gt; index 的 map 映射）。如果没找到就认为是一个新增节点。而如果没有 key，那么就会采用一种遍历查找的方式去找到对应的旧节点。一种一个 map 映射，另一种是遍历查找。相比而言。map 映射的速度更快。</p>
<p><strong>答案</strong>：</p>
<blockquote>
<p>key 是给每一个 vnode 的唯一 id,可以<code>依靠key</code>,更<code>准确</code>, 更<code>快</code>的拿到 oldVnode 中对应的 vnode 节点。</p>
<p>key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。</p>
</blockquote>
<p>1、更准确</p>
<p>因为带 key 就不是<code>就地复用</code>了，在 sameNode 函数 <code>a.key === b.key</code>对比中可以避免就地复用的情况。所以会更加准确。</p>
<p>2、更快</p>
<p>利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快。(这个观点，就是我最初的那个观点。从这个角度看，map 会比遍历更快。)</p>
<h3 id="第-2-题（2019-9-20）"><a href="#第-2-题（2019-9-20）" class="headerlink" title="第 2 题（2019/9/20）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/4">第 2 题</a>（2019/9/20）</h3><p><strong>题目</strong>：<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code> what &amp; why ?</p>
<p><strong>答案</strong> ：第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是 **真正的答案是[1, NaN, NaN]**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;12&quot;</span>)); <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;08&quot;</span>)); <span class="comment">//8</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;0x16&quot;</span>)); <span class="comment">//22</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;-12&quot;</span>)); <span class="comment">//-12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;   -12&quot;</span>)); <span class="comment">//-12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;   -  12&quot;</span>)); <span class="comment">///NAN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;124ref&quot;</span>)); <span class="comment">//124</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;ref&quot;</span>)); <span class="comment">//NAN</span></span><br></pre></td></tr></table></figure>

<p>以上几乎就是<code>parseInt</code>函数一个形式参数时的所有情况</p>
<p>radix 形参没指定的时候是<strong>10</strong>，其次他是具有有效范围滴：[2, 36]和特殊值 0<br>下面是英语渣渣的我翻译后，简化的<code>parseInt</code>执行步骤：（ECMAScript 原解析-&gt;<a target="_blank" rel="noopener" href="http://www.ecma-international.org/ecma-262/6.0/#sec-parseint-string-radix">传送门</a>）</p>
<ol>
<li>将第一个形参转换为字符串</li>
<li>识别 string 转换是否有<strong>code unit</strong>，如果有 -&gt; <code>-</code>标记为负数，<code>0x</code>或<code>0X</code>则把 radix 赋值为<strong>16</strong></li>
<li>radix 形参（int 类型）是否存在，存在则重新赋值（会对实参进行 Int32 转化，无法转换成 int 类型则不会重新赋值 radix）</li>
<li>radix 为 0，则设置 radix 为默认值 10</li>
<li>如果 radix 为 1，或者大于等于 37，parseInt 直接返回<strong>NaN</strong></li>
<li>如果 radix 为[2, 36]时则代表，string 参数分别是二进制，三进制（如果有得话~）…三十六进制类型</li>
<li>然后对 string 进行的 radix 进制 -&gt; 十进制转换</li>
</ol>
<p>以上就是<code>parseInt</code>转换时的步骤，那么我们来开始解释<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code><br><strong>at first, 答案是[1, NaN, NaN]</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>].map(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(value, index);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(ret);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>这是<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code>内部执行的剖析，<code>value</code>和<code>index</code>相信大家都懂，不懂请自行<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/map">MDN</a>,执行步骤为：<br><code>value=&#39;1&#39;,index=0</code> -&gt; <code>parseInt(value, index)</code><br><code>value=&#39;2&#39;,index=1</code> -&gt; <code>parseInt(value, index)</code><br><code>value=&#39;3&#39;,index=2</code> -&gt; <code>parseInt(value, index)</code><br>抽离出来，其实就是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;1&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;2&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;3&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><code>parseInt(&#39;3&#39;, 2)</code>这是根据二进制对字符串<code>3</code>进行十进制转换对吧！！！<br>exm???有毛病?没毛病，老铁，就是……你家二进制有<code>3</code>?二进制不就是<code>0</code>和<code>1</code>啊</p>
<p>因此返回<strong>NaN</strong>。</p>
<p>解决方案：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnInt</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(element, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>].map(returnInt); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="comment">// Actual result is an array of numbers (as expected)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Same as above, but using the concise arrow function syntax</span></span><br><span class="line">[<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>].map(<span class="function">(<span class="params">str</span>) =&gt;</span> <span class="built_in">parseInt</span>(str));</span><br><span class="line"></span><br><span class="line"><span class="comment">// A simpler way to achieve the above, while avoiding the &quot;gotcha&quot;:</span></span><br><span class="line">[<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>].map(<span class="built_in">Number</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// But unlike parseInt(), Number() will also return a float or (resolved) exponential notation:</span></span><br><span class="line">[<span class="string">&quot;1.1&quot;</span>, <span class="string">&quot;2.2e2&quot;</span>, <span class="string">&quot;3e300&quot;</span>].map(<span class="built_in">Number</span>); <span class="comment">// [1.1, 220, 3e+300]</span></span><br><span class="line"><span class="comment">// For comparison, if we use parseInt() on the array above:</span></span><br><span class="line">[<span class="string">&quot;1.1&quot;</span>, <span class="string">&quot;2.2e2&quot;</span>, <span class="string">&quot;3e300&quot;</span>].map(<span class="function">(<span class="params">str</span>) =&gt;</span> <span class="built_in">parseInt</span>(str)); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="第-3-题（2019-9-21）"><a href="#第-3-题（2019-9-21）" class="headerlink" title="第 3 题（2019/9/21）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5">第 3 题</a>（2019/9/21）</h3><p><strong>题目</strong>：什么是防抖和节流？有什么区别？如何实现？</p>
<p><strong>公司</strong> ：挖财</p>
<p><strong>解析</strong> ：</p>
<p>1、<strong>防抖</strong></p>
<blockquote>
<p>触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间</p>
</blockquote>
<p>思路：</p>
<blockquote>
<p>每次触发事件时都取消之前的延时调用方法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>; <span class="comment">// 创建一个标记用来存放定时器的返回值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout); <span class="comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span></span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;防抖成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inp = <span class="built_in">document</span>.getElementById(<span class="string">&quot;inp&quot;</span>);</span><br><span class="line">inp.addEventListener(<span class="string">&quot;input&quot;</span>, debounce(sayHi, <span class="number">500</span>)); <span class="comment">// 防抖</span></span><br></pre></td></tr></table></figure>

<p>提出问题：请问，为什么要 fn.apply(this, arguments);而不是这样 fn()</p>
<p>解答：加上 apply 确保 在 sayHi 函数里的 this 指向的是 input 对象(不然就指向 window 了，不是我们想要的)。<br>这里的箭头函数依旧是指向 input 对象。</p>
<p><img src="http://static.zxinc520.com/blog/20190921/g4jPyh09vVh7.gif" alt="mark"></p>
<p>防抖应用场景：</p>
<ol>
<li>搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。</li>
<li>表单验证</li>
<li>按钮提交事件。</li>
<li>浏览器窗口缩放，resize 事件等。</li>
</ol>
<p>2、<strong>节流</strong></p>
<blockquote>
<p>高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率</p>
</blockquote>
<p>思路：</p>
<blockquote>
<p>每次触发事件时都判断当前是否有等待执行的延时函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span>; <span class="comment">// 通过闭包保存一个标记</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) <span class="keyword">return</span>; <span class="comment">// 在函数开头判断标记是否为true，不为true则return</span></span><br><span class="line">    canRun = <span class="literal">false</span>; <span class="comment">// 立即设置为false</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 将外部传入的函数的执行放在setTimeout中</span></span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      <span class="comment">// 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉</span></span><br><span class="line">      canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.innerWidth, e.target.innerHeight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, throttle(sayHi, <span class="number">500</span>));</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190921/nJbaVeD1wpaz.gif" alt="mark"></p>
<h3 id="第-4-题-2019-9-22"><a href="#第-4-题-2019-9-22" class="headerlink" title="第 4 题 (2019/9/22)"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md#%E7%AC%AC-4-%E9%A2%98%E4%BB%8B%E7%BB%8D%E4%B8%8B-setmapweakset-%E5%92%8C-weakmap-%E7%9A%84%E5%8C%BA%E5%88%AB">第 4 题</a> (2019/9/22)</h3><p><strong>题目</strong> ：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://muyiy.cn/question/js/4.html">木易杨前端进阶</a></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Set</span><br><span class="line">    成员唯一、无序且不重复</span><br><span class="line">    [value, value]，键值与键名是一致的（或者说只有键值，没有键名）</span><br><span class="line">    可以遍历，方法有：add、delete、has</span><br><span class="line"></span><br><span class="line">WeakSet</span><br><span class="line">    成员都是对象</span><br><span class="line">    成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏</span><br><span class="line">    不能遍历，方法有add、delete、has</span><br><span class="line"></span><br><span class="line">Map</span><br><span class="line">    本质上是键值对的集合，类似集合</span><br><span class="line">    可以遍历，方法很多可以跟各种数据格式转换</span><br><span class="line"></span><br><span class="line">WeakMap</span><br><span class="line">    只接受对象作为键名（null除外），不接受其他类型的值作为键名</span><br><span class="line">    键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的</span><br><span class="line">    不能遍历，方法有get、set、has、delete</span><br><span class="line"></span><br><span class="line"> Set与WeakSet区别:</span><br><span class="line">    1. WeakSet只能存放对象</span><br><span class="line">    2. WeakSet不支持遍历, 没有size熟悉</span><br><span class="line">    3. WeakSet存放的对象不会计入到对象的引用技术, 因此不会影响GC的回收</span><br><span class="line">    4. WeakSet存在的对象如果在外界消失了, 那么在WeakSet里面也会不存在</span><br><span class="line"></span><br><span class="line"> Map与WeakMap区别</span><br><span class="line"> 	1. WeakMap只能接受对象作为键名字(null除外)</span><br><span class="line">	2. WeakMap键名指向对象不会计入对象的引用数</span><br></pre></td></tr></table></figure>

<h3 id="第-5-题-2019-9-22"><a href="#第-5-题-2019-9-22" class="headerlink" title="第 5 题 (2019/9/22)"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/9">第 5 题</a> (2019/9/22)</h3><p><strong>题目：</strong> 介绍下深度优先遍历和广度优先遍历，如何实现？</p>
<p>解析： 我先学习一下啥是 深度优先 和 广度优先… 惭愧！！！</p>
<h3 id="第-6-题-（2019-9-23）"><a href="#第-6-题-（2019-9-23）" class="headerlink" title="第 6 题 （2019/9/23）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/10">第 6 题</a> （2019/9/23）</h3><p><strong>题目</strong> ：请分别用深度优先思想和广度优先思想实现一个拷贝函数？</p>
<blockquote>
<p>弄懂了 优先遍历和广度优先遍历 再来做</p>
</blockquote>
<h3 id="第-7-题-（2019-9-23）"><a href="#第-7-题-（2019-9-23）" class="headerlink" title="第 7 题 （2019/9/23）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20">第 7 题</a> （2019/9/23）</h3><p><strong>题目</strong> ：ES5/ES6 的继承除了写法以外还有什么区别？</p>
<p><strong>解析</strong> ： <a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20">更多</a></p>
<ol>
<li><code>class</code> 声明会提升，但不会初始化赋值。<code>Foo</code> 进入暂时性死区，类似于 <code>let</code>、<code>const</code> 声明变量。</li>
<li><code>class</code> 声明内部会启用严格模式。</li>
<li><code>class</code> 的所有方法（包括静态方法和实例方法）都是不可枚举的。</li>
<li><code>class</code> 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有<code>[[construct]]</code>，不能使用 <code>new</code> 来调用。</li>
<li>必须使用 <code>new</code> 调用 <code>class</code>。</li>
<li><code>class</code> 内部无法重写类名。</li>
</ol>
<h3 id="第-8-题（2019-9-24）"><a href="#第-8-题（2019-9-24）" class="headerlink" title="第 8 题（2019/9/24）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/33">第 8 题</a>（2019/9/24）</h3><p><strong>题目：</strong> setTimeout、Promise、Async/Await 的区别 ？</p>
<p><strong>知识点</strong> ：这里涉及到<code>Microtasks</code>、<code>Macrotasks</code>、event loop 以及 JS 的异步运行机制。<a target="_blank" rel="noopener" href="https://github.com/sisterAn/blog/issues/21">可参考</a></p>
<p><strong>解析</strong> ：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我觉得这题主要是考察这三者在事件循环中的区别，事件循环中分为宏任务队列和微任务队列。</span><br><span class="line">其中 setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；</span><br><span class="line">promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。</span><br></pre></td></tr></table></figure>

<p><strong>1、setTimeout</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>); <span class="comment">//1. 打印 script start</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;settimeout&quot;</span>); <span class="comment">// 4. 打印 settimeout</span></span><br><span class="line">&#125;); <span class="comment">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>); <span class="comment">//3. 打印 script start</span></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;script end-&gt;settimeout</span></span><br></pre></td></tr></table></figure>

<p><strong>2、 Promise</strong></p>
<p>Promise 本身是<strong>同步的立即执行函数</strong>， 当在 executor 中执行 resolve 或者 reject 的时候, 此时是异步操作， 会先执行 then/catch 等，当主栈完成后，才会去调用 resolve/reject 中存放的方法执行，打印 p 的时候，是打印的返回结果，一个 Promise 实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1 end&quot;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;settimeout&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"><span class="comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span></span><br></pre></td></tr></table></figure>

<p>当 JS 主线程执行到 Promise 对象时，</p>
<ul>
<li>promise1.then() 的回调就是一个 task</li>
<li>promise1 是 resolved 或 rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li>
<li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li>
<li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li>
</ul>
<p><strong>3. async/await</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br></pre></td></tr></table></figure>

<p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(func1());</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190924/M0YN5oCKtEhr.png?imageslim" alt="mark"></p>
<p>很显然，func1 的运行结果其实就是一个 Promise 对象。因此我们也可以使用 then 来处理后续逻辑。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func1().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);  <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>await 的含义为等待，也就是 async 函数需要等待 await 后的函数执行完成并且有了返回结果（Promise 对象）之后，才能继续执行下面的代码。await 通过返回一个 Promise 对象来实现同步的效果。</p>
<blockquote>
<p>更多可见 <a target="_blank" rel="noopener" href="https://github.com/sisterAn/blog/issues/21">setTimeout、Promise、Async/Await</a></p>
</blockquote>
<h3 id="第-9-题（2019-9-25）"><a href="#第-9-题（2019-9-25）" class="headerlink" title="第 9 题（2019/9/25）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/33">第 9 题</a>（2019/9/25）</h3><p><strong>题目</strong> ： Async/Await 如何通过同步的方式实现异步？</p>
<p><strong>公司</strong> ：头条、微医</p>
<p><strong>解析</strong> ： [Async/Await 如何通过同步的方式实现异步](Async/Await 如何通过同步的方式实现异步)</p>
<p>首先，<code>async/await</code> 是 <code>Generator</code> 的语法糖</p>
<p>先来看一下二者的对比：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator</span></span><br><span class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res1 = <span class="keyword">yield</span> readFile(path.resolve(__dirname, <span class="string">&#x27;../data/a.json&#x27;</span>), &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">yield</span> readFile(path.resolve(__dirname, <span class="string">&#x27;../data/b.json&#x27;</span>), &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// async/await</span></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> res1 = <span class="keyword">await</span> readFile(path.resolve(__dirname, <span class="string">&#x27;../data/a.json&#x27;</span>), &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> readFile(path.resolve(__dirname, <span class="string">&#x27;../data/b.json&#x27;</span>), &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = readFile();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，<code>async function</code> 代替了 <code>function*</code>，<code>await</code> 代替了 <code>yield</code>，同时也无需自己手写一个自动执行器 <code>run</code> 了</p>
<p>现在再来看看<code>async/await</code> 的特点：</p>
<ul>
<li>当 <code>await</code> 后面跟的是 Promise 对象时，才会异步执行，其它类型的数据会同步执行</li>
<li>执行 <code>const res = readFile();</code> 返回的仍然是个 Promise 对象，上面代码中的 <code>return &#39;done&#39;;</code> 会直接被下面 <code>then</code> 函数接收到</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// done</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-10-题（2019-9-26）"><a href="#第-10-题（2019-9-26）" class="headerlink" title="第 10 题（2019/9/26）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7">第 10 题</a>（2019/9/26）</h3><p><strong>题目类型</strong> ：异步笔试题</p>
<p><strong>公司</strong> ：头条</p>
<blockquote>
<p>请写出下面代码的运行结果</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    script start</span></span><br><span class="line"><span class="comment">    async1 start</span></span><br><span class="line"><span class="comment">    async2</span></span><br><span class="line"><span class="comment">    promise1</span></span><br><span class="line"><span class="comment">    script end</span></span><br><span class="line"><span class="comment">    async1 end</span></span><br><span class="line"><span class="comment">    promise2</span></span><br><span class="line"><span class="comment">    setTimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="第-11-题-（2019-9-26）"><a href="#第-11-题-（2019-9-26）" class="headerlink" title="第 11 题 （2019/9/26）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/8">第 11 题</a> （2019/9/26）</h3><p><strong>公司</strong> ：携程</p>
<blockquote>
<p>已知如下数组：</p>
<p>var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];</p>
<p>编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.flat(<span class="literal">Infinity</span>))).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;); <span class="comment">//使用 flat</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.toString().split(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">  .sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;)</span><br><span class="line">  .map(<span class="built_in">Number</span>); <span class="comment">//利用 toString()</span></span><br></pre></td></tr></table></figure>

<h3 id="第-12-题-（2019-9-27）"><a href="#第-12-题-（2019-9-27）" class="headerlink" title="第 12 题 （2019/9/27）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/11">第 12 题</a> （2019/9/27）</h3><p><strong>题目：</strong> JS 异步解决方案的发展历程以及优缺点。</p>
<p><strong>公司</strong> ：滴滴、挖财、微医、海康</p>
<p><strong>解析：</strong></p>
<ol>
<li><strong>回调函数（callback）</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// callback 函数体</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：回调地狱，不能用 try catch 捕获错误，不能 return</p>
<p>回调地狱的根本问题在于：</p>
<ul>
<li>缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符</li>
<li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（<strong>控制反转</strong>）</li>
<li>嵌套函数过多的多话，很难处理错误</li>
</ul>
<p><strong>优点</strong> ：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）</p>
<ol start="2">
<li><strong>Promise</strong></li>
</ol>
<p>Promise 就是为了解决 callback 的问题而产生的。</p>
<p>Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装</p>
<p><strong>优点</strong> ：解决了回调地狱的问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">&quot;XXX1&quot;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 操作逻辑</span></span><br><span class="line">    <span class="keyword">return</span> ajax(<span class="string">&quot;XXX2&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 操作逻辑</span></span><br><span class="line">    <span class="keyword">return</span> ajax(<span class="string">&quot;XXX3&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 操作逻辑</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong> ：无法取消 Promise ，错误需要通过回调函数来捕获</p>
<ol start="3">
<li><strong>Generato</strong></li>
</ol>
<p><strong>特点</strong> ：可以控制函数的执行，可以配合 co 函数库使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> ajax(<span class="string">&quot;XXX1&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">  <span class="keyword">yield</span> ajax(<span class="string">&quot;XXX2&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">  <span class="keyword">yield</span> ajax(<span class="string">&quot;XXX3&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = fetch();</span><br><span class="line"><span class="keyword">let</span> result1 = it.next();</span><br><span class="line"><span class="keyword">let</span> result2 = it.next();</span><br><span class="line"><span class="keyword">let</span> result3 = it.next();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>Async/await</strong></li>
</ol>
<p>async、await 是异步的终极解决方案</p>
<p><strong>优点</strong>：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题</p>
<p><strong>缺点</strong>：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式</span></span><br><span class="line">  <span class="comment">// 如果有依赖性的话，其实就是解决回调地狱的例子了</span></span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">&quot;XXX1&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">&quot;XXX2&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">&quot;XXX3&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来看一个使用 <code>await</code> 的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + (<span class="keyword">await</span> <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>, a); <span class="comment">// -&gt; &#x27;2&#x27; 10</span></span><br><span class="line">&#125;;</span><br><span class="line">b();</span><br><span class="line">a++;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>, a); <span class="comment">// -&gt; &#x27;1&#x27; 1</span></span><br></pre></td></tr></table></figure>

<p>对于以上代码你可能会有疑惑，让我来解释下原因</p>
<ul>
<li>首先函数 <code>b</code> 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 0，因为 <code>await</code> 内部实现了 <code>generator</code> ，<strong>generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来</strong></li>
<li>因为 <code>await</code> 是异步操作，后来的表达式不返回 <code>Promise</code> 的话，就会包装成 <code>Promise.reslove(返回值)</code>，然后会去执行函数外的同步代码</li>
<li>同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 0 + 10</code></li>
</ul>
<p>上述解释中提到了 <code>await</code> 内部实现了 <code>generator</code>，其实 <code>await</code> 就是 <code>generator</code> 加上 <code>Promise</code>的语法糖，且内部实现了自动执行 <code>generator</code>。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。</p>
<h3 id="第-13-题-（2019-9-28）"><a href="#第-13-题-（2019-9-28）" class="headerlink" title="第 13 题 （2019/9/28）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/19">第 13 题</a> （2019/9/28）</h3><p><strong>题目</strong> ：Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？</p>
<p><strong>公司</strong> ：微医</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">看过 Event Loop 基础原理的就明白，Promise构造函数是同步执行，而 .then .catch .啥啥的是异步（还有process.nextTick等等，大家可以查），</span><br><span class="line">而且放到了微队列中，async/await 中，await 前面的是同步，await 后面的是异步，写法上是这样，但是其实是 语法糖，最后还会转为 Promise.then的形式</span><br><span class="line"></span><br><span class="line">.then()当然是同步执行，只不过是.then的cb被放入了微任务队列，产生了异步执行</span><br><span class="line"></span><br><span class="line">promise是微观任务，setTimeout是宏观任务，先执行微观任务，在执行宏观任务；微观任务里，先执行同步再执行异步</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-14-题-（2019-9-29）"><a href="#第-14-题-（2019-9-29）" class="headerlink" title="第 14 题 （2019/9/29）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/12">第 14 题</a> （2019/9/29）</h3><p><strong>题目</strong> ：情人节福利题，如何实现一个 new ？</p>
<p><strong>公司</strong>：兑吧</p>
<p><strong>解析</strong> ： <a target="_blank" rel="noopener" href="https://alexzhong22c.github.io/2017/08/12/js-new-happen/#%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%BB%93%E6%9E%9C%E8%A7%A3%E6%9E%90">new 创建对象的过程发生了什么</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 的作用</span></span><br><span class="line"><span class="comment">// 创建一个新对象obj</span></span><br><span class="line"><span class="comment">// 把obj的__proto__指向Dog.prototype 实现继承</span></span><br><span class="line"><span class="comment">// 执行构造函数，传递参数，改变this指向 Dog.call(obj, ...args)</span></span><br><span class="line"><span class="comment">// 最后把obj赋值给sanmao</span></span><br><span class="line"><span class="keyword">var</span> _new = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">constructor</span> = Array.prototype.shift.call(arguments);</span><br><span class="line">  let args = arguments;</span><br><span class="line">  const obj = new Object();</span><br><span class="line">  obj.__proto__ = <span class="keyword">constructor</span>.prototype;</span><br><span class="line">  <span class="keyword">constructor</span>.call(obj, ...args);</span><br><span class="line">  return obj;</span><br><span class="line">&#125;;</span><br><span class="line">var simao = _new(Dog, &quot;simao&quot;);</span><br><span class="line">simao.bark();</span><br><span class="line">simao.sayName();</span><br><span class="line">console.log(simao instanceof Dog); // true</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样写是不是简单点啊</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">fn, ...arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">  <span class="keyword">const</span> ret = fn.apply(obj, arg);</span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-15-题-（2019-9-30）"><a href="#第-15-题-（2019-9-30）" class="headerlink" title="第 15 题 （2019/9/30）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/14">第 15 题</a> （2019/9/30）</h3><p><strong>题目</strong> ：简单讲解一下 http2 的多路复用</p>
<p><strong>公司</strong>：网易</p>
<p><strong>解析</strong> ：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在 HTTP/1 中，每次请求都会建立一次HTTP连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：</span><br><span class="line"></span><br><span class="line">    第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）</span><br><span class="line"></span><br><span class="line">    第二个：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。</span><br><span class="line"></span><br><span class="line">HTTP/2的多路复用就是为了解决上述的两个性能问题。</span><br><span class="line">在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。</span><br><span class="line">帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</span><br><span class="line">多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-16-题-（2019-10-01）"><a href="#第-16-题-（2019-10-01）" class="headerlink" title="第 16 题 （2019/10/01）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/15">第 16 题</a> （2019/10/01）</h3><p><strong>题目</strong> ：谈谈你对 TCP 三次握手和四次挥手的理解</p>
<p><strong>解析</strong> ：<a target="_blank" rel="noopener" href="https://juejin.im/post/5ccd0dfc6fb9a0324a08bb73">关于三次握手与四次挥手面试官想考我们什么？— 不看后悔系列</a></p>
<p>三次握手：</p>
<ol>
<li>第一次握手：客户端给服务器发送一个 SYN 报文。</li>
<li>第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。</li>
<li>第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。</li>
<li>服务器收到 ACK 报文之后，三次握手建立完成。</li>
</ol>
<blockquote>
<p><strong>这里我顺便解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以</strong>：<br>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。<br>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>
</blockquote>
<p>四次挥手:</p>
<ol>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于<strong>FIN_WAIT1</strong>状态。</li>
<li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <strong>CLOSE_WAIT</strong>状态。</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <strong>LAST_ACK</strong> 的状态。</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 <strong>TIME_WAIT</strong> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li>
<li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li>
</ol>
<p>这里特别需要主要的就是<strong>TIME_WAIT</strong>这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p>
<p>至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p>
<h3 id="第-17-题-（2019-10-08）"><a href="#第-17-题-（2019-10-08）" class="headerlink" title="第 17 题 （2019/10/08）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/21">第 17 题</a> （2019/10/08）</h3><p><strong>题目</strong> ： A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态 ？</p>
<blockquote>
<p>如果 A 与 B 建立了正常连接后，从未相互发过数据，这个时候 B 突然机器重启，问 A 此时处于 TCP 什么状态？如何消除服务器程序中的这个状态？（超纲题，了解即可）</p>
</blockquote>
<h3 id="第-18-题-（2019-10-08）"><a href="#第-18-题-（2019-10-08）" class="headerlink" title="第 18 题 （2019/10/08）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/17">第 18 题</a> （2019/10/08）</h3><p><strong>题目</strong> ：React 中 setState 什么时候是同步的，什么时候是异步的？</p>
<p><strong>公司</strong> ：微医 <a target="_blank" rel="noopener" href="https://juejin.im/post/5ac1aaad6fb9a028d444bb87">React 中 setState 真的是异步的吗</a></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.在组件生命周期中或者react事件绑定中，setState是通过异步更新的。</span><br><span class="line">2.在延时的回调或者原生事件绑定的回调中调用setState不一定是异步的。</span><br><span class="line">这个结果并不说明setState异步执行的说法是错误的，更加准确的说法应该是setState不能保证同步执行。</span><br><span class="line">Dan Abramov也多次提到今后会将setState彻底改造为异步的，从js conf中提到的suspend新特新也印证了这一点。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里所说的同步异步，并非真正的同步异步，通常是同步执行的。</span><br><span class="line">这里的异步指的是多个状态会合成到一起进行批量更新。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-19-题-（2019-10-08）"><a href="#第-19-题-（2019-10-08）" class="headerlink" title="第 19 题  （2019/10/08）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/18">第 19 题 </a> （2019/10/08）</h3><p><strong>题目</strong> ：React setState 笔试题，下面的代码输出什么？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      val: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">val</span>: <span class="built_in">this</span>.state.val + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.val); <span class="comment">// 第 1 次 log</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">val</span>: <span class="built_in">this</span>.state.val + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.val); <span class="comment">// 第 2 次 log</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123; <span class="attr">val</span>: <span class="built_in">this</span>.state.val + <span class="number">1</span> &#125;);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.val); <span class="comment">// 第 3 次 log</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.setState(&#123; <span class="attr">val</span>: <span class="built_in">this</span>.state.val + <span class="number">1</span> &#125;);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.val); <span class="comment">// 第 4 次 log</span></span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、第一次和第二次都是在 react 自身生命周期内，触发时 isBatchingUpdates 为 <span class="literal">true</span>，所以并不会直接执行更新 state，而是加入了 dirtyComponents，所以打印时获取的都是更新前的状态 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、两次 setState 时，获取到 <span class="built_in">this</span>.state.val 都是 <span class="number">0</span>，所以执行时都是将 <span class="number">0</span> 设置成 <span class="number">1</span>，在 react 内部会被合并掉，只执行一次。设置完成后 state.val 值为 <span class="number">1</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、<span class="built_in">setTimeout</span> 中的代码，触发时 isBatchingUpdates 为 <span class="literal">false</span>，所以能够直接进行更新，所以连着输出 <span class="number">2</span>，<span class="number">3</span>。</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出： 0 0 2 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-20-题-（2019-10-09）"><a href="#第-20-题-（2019-10-09）" class="headerlink" title="第 20 题  （2019/10/09）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/22">第 20 题 </a> （2019/10/09）</h3><p><strong>题目</strong> ：介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？</p>
<p><strong>解析</strong> ：</p>
<p><strong>1、npm 模块安装机制：</strong></p>
<ul>
<li>发出<code>npm install</code>命令</li>
<li>查询 node_modules 目录之中是否已经存在指定模块<ul>
<li>若存在，不再重新安装</li>
<li>若不存在<ul>
<li>npm 向 registry 查询模块压缩包的网址</li>
<li>下载压缩包，存放在根目录下的<code>.npm</code>目录里</li>
<li>解压压缩包到当前项目的<code>node_modules</code>目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>2、npm 实现原理</strong></p>
<p>输入 npm install 命令并敲下回车后，会经历如下几个阶段（以 npm 5.5.1 为例）：</p>
<ol>
<li><strong>执行工程自身 preinstall</strong></li>
</ol>
<p>当前 npm 工程如果定义了 preinstall 钩子此时会被执行。</p>
<ol start="2">
<li><strong>确定首层依赖模块</strong></li>
</ol>
<p>首先需要做的是确定工程中的首层依赖，也就是 dependencies 和 devDependencies 属性中直接指定的模块（假设此时没有添加 npm install 参数）。</p>
<p>工程本身是整棵依赖树的根节点，每个首层依赖模块都是根节点下面的一棵子树，npm 会开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点。</p>
<ol start="3">
<li><strong>获取模块</strong></li>
</ol>
<p>获取模块是一个递归的过程，分为以下几步：</p>
<ul>
<li>获取模块信息。在下载一个模块之前，首先要确定其版本，这是因为 package.json 中往往是 semantic version（semver，语义化版本）。此时如果版本描述文件（npm-shrinkwrap.json 或 package-lock.json）中有该模块信息直接拿即可，如果没有则从仓库获取。如 packaeg.json 中某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。</li>
<li>获取模块实体。上一步会获取到模块的压缩包地址（resolved 字段），npm 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。</li>
<li>查找该模块依赖，如果有依赖则回到第 1 步，如果没有则停止。</li>
</ul>
<ol start="4">
<li><strong>模块扁平化（dedupe）</strong></li>
</ol>
<p>上一步获取到的是一棵完整的依赖树，其中可能包含大量重复模块。比如 A 模块依赖于 loadsh，B 模块同样依赖于 lodash。在 npm3 以前会严格按照依赖树的结构进行安装，因此会造成模块冗余。</p>
<p>从 npm3 开始默认加入了一个 dedupe 的过程。它会遍历所有节点，逐个将模块放在根节点下面，也就是 node-modules 的第一层。当发现有<strong>重复模块</strong>时，则将其丢弃。</p>
<p>这里需要对<strong>重复模块</strong>进行一个定义，它指的是<strong>模块名相同</strong>且 <strong>semver 兼容。每个 semver 都对应一段版本允许范围，如果两个模块的版本允许范围存在交集，那么就可以得到一个兼容</strong>版本，而不必版本号完全一致，这可以使更多冗余模块在 dedupe 过程中被去掉。</p>
<p>比如 node-modules 下 foo 模块依赖 lodash@^1.0.0，bar 模块依赖 lodash@^1.1.0，则 <strong>^1.1.0</strong> 为兼容版本。</p>
<p>而当 foo 依赖 lodash@^2.0.0，bar 依赖 lodash@^1.1.0，则依据 semver 的规则，二者不存在兼容版本。会将一个版本放在 node_modules 中，另一个仍保留在依赖树里。</p>
<p>举个例子，假设一个依赖树原本是这样：</p>
<p>node_modules<br>– foo<br>—- lodash@version1</p>
<p>– bar<br>—- lodash@version2</p>
<p>假设 version1 和 version2 是兼容版本，则经过 dedupe 会成为下面的形式：</p>
<p>node_modules<br>– foo</p>
<p>– bar</p>
<p>– lodash（保留的版本为兼容版本）</p>
<p>假设 version1 和 version2 为非兼容版本，则后面的版本保留在依赖树中：</p>
<p>node_modules<br>– foo<br>– lodash@version1</p>
<p>– bar<br>—- lodash@version2</p>
<ol start="5">
<li><strong>安装模块</strong></li>
</ol>
<p>这一步将会更新工程中的 node_modules，并执行模块中的生命周期函数（按照 preinstall、install、postinstall 的顺序）。</p>
<ol start="6">
<li><strong>执行工程自身生命周期</strong></li>
</ol>
<p>当前 npm 工程如果定义了钩子此时会被执行（按照 install、postinstall、prepublish、prepare 的顺序）。</p>
<p>最后一步是生成或更新版本描述文件，npm install 过程完成。</p>
<p>参考 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/01/npm-install.html">npm 模块安装机制简介</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bbsmax.com/A/qVdemmnEdP/">详解 npm 的模块安装机制</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/66629910">npm install 的实现原理</a></p>
<h3 id="第-21-题-（2019-10-10）"><a href="#第-21-题-（2019-10-10）" class="headerlink" title="第 21 题 （2019/10/10）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/23">第 21 题</a> （2019/10/10）</h3><p><strong>题目：</strong> 有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣</p>
<blockquote>
<p>Object.prototype.toString.call() 、 instanceof 以及 Array.isArray()</p>
</blockquote>
<p><strong>解析：</strong></p>
<p><strong>1、Object.prototype.toString.call()</strong></p>
<p>每一个继承 Object 的对象都有 <code>toString</code> 方法，如果 <code>toString</code> 方法没有重写的话，会返回 <code>[Object type]</code>，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 <code>toString</code> 方法时，会直接返回都是内容的字符串，所以我们需要使用 call 或者 apply 方法来改变 toString 方法的执行上下文。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> an = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;An&quot;</span>];</span><br><span class="line">an.toString(); <span class="comment">// &quot;Hello,An&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(an); <span class="comment">// &quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure>

<p>这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&quot;An&quot;</span>); <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>); <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>(<span class="number">1</span>)); <span class="comment">// &quot;[object Symbol]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>); <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;); <span class="comment">// &quot;[object Function]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123; <span class="attr">name</span>: <span class="string">&quot;An&quot;</span> &#125;); <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Object.prototype.toString.call()</code> 常用于判断浏览器内置对象时。</p>
<p>更多实现可见 <a target="_blank" rel="noopener" href="https://juejin.im/post/591647550ce4630069df1c4a">谈谈 Object.prototype.toString</a></p>
<p><strong>2、instanceof</strong></p>
<p><code>instanceof</code> 的内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code>。</p>
<p>使用 <code>instanceof</code>判断一个对象是否为数组，<code>instanceof</code> 会判断这个对象的原型链上是否会找到对应的 <code>Array</code> 的原型，找到返回 <code>true</code>，否则返回 <code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但 <code>instanceof</code> 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>3、Array.isArray()</strong></p>
<ul>
<li><p>功能：用来判断对象是否为数组</p>
</li>
<li><p>instanceof 与 isArray</p>
<p>当检测 Array 实例时，<code>Array.isArray</code> 优于 <code>instanceof</code> ，因为 <code>Array.isArray</code> 可以检测出 <code>iframes</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">xArray = <span class="built_in">window</span>.frames[<span class="built_in">window</span>.frames.length - <span class="number">1</span>].Array;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> xArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Correctly checking for Array</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Considered harmful, because doesn&#x27;t work though iframes</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.isArray()</code> 与 <code>Object.prototype.toString.call()</code></p>
<p><code>Array.isArray()</code>是 ES5 新增的方法，当不存在 <code>Array.isArray()</code> ，可以用 <code>Object.prototype.toString.call()</code> 实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (!Array.isArray) &#123;</span><br><span class="line">  Array.isArray &#x3D; function(arg) &#123;</span><br><span class="line">    return Object.prototype.toString.call(arg) &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="第-22-题-（2019-10-11）"><a href="#第-22-题-（2019-10-11）" class="headerlink" title="第 22 题 （2019/10/11）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24">第 22 题</a> （2019/10/11）</h3><p><strong>题目：</strong> 介绍下重绘和回流（Repaint &amp; Reflow），以及如何进行优化？</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://juejin.im/post/5a9923e9518825558251c96a">浏览器的回流与重绘 (Reflow &amp; Repaint)</a></p>
<p><strong>1、浏览器渲染机制</strong></p>
<ul>
<li>浏览器采用流式布局模型（<code>Flow Based Layout</code>）</li>
<li>浏览器会把<code>HTML</code>解析成<code>DOM</code>，把<code>CSS</code>解析成<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并就产生了渲染树（<code>Render Tree</code>）。</li>
<li>有了<code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</li>
<li>由于浏览器使用流式布局，对<code>Render Tree</code>的计算通常只需要遍历一次就可以完成，<strong>但 table 及其内部元素除外，他们可能需要多次计算，通常要花 3 倍于同等元素的时间，这也是为什么要避免使用 table 布局的原因之一</strong>。</li>
</ul>
<p><strong>2、重绘</strong></p>
<p>由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如<code>outline</code>, <code>visibility</code>, <code>color</code>、<code>background-color</code>等，重绘的代价是高昂的，因为浏览器必须验证 DOM 树上其他节点元素的可见性。</p>
<p><strong>3、回流</strong></p>
<p>回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及 DOM 中紧随其后的节点、祖先节点元素的随后的回流。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;error&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>我的组件<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>错误：<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>错误的描述…<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>错误纠正<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一步<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二步<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的 HTML 片段中，对该段落(<code>&lt;p&gt;</code>标签)回流将会引发强烈的回流，因为它是一个子节点。这也导致了祖先的回流（<code>div.error</code>和<code>body</code> – 视浏览器而定）。此外，<code>&lt;h5&gt;</code>和<code>&lt;ol&gt;</code>也会有简单的回流，因为其在 DOM 中在回流元素之后。<strong>大部分的回流将导致页面的重新渲染。</strong></p>
<p><strong>回流必定会发生重绘，重绘不一定会引发回流。</strong></p>
<p><strong>4、浏览器优化</strong></p>
<p>现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即 16.6ms）才会清空队列，但当你<strong>获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值</strong>。</p>
<p>主要包括以下属性或方法：</p>
<ul>
<li><code>offsetTop</code>、<code>offsetLeft</code>、<code>offsetWidth</code>、<code>offsetHeight</code></li>
<li><code>scrollTop</code>、<code>scrollLeft</code>、<code>scrollWidth</code>、<code>scrollHeight</code></li>
<li><code>clientTop</code>、<code>clientLeft</code>、<code>clientWidth</code>、<code>clientHeight</code></li>
<li><code>width</code>、<code>height</code></li>
<li><code>getComputedStyle()</code></li>
<li><code>getBoundingClientRect()</code></li>
</ul>
<p>所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列<strong>。</strong></p>
<p><strong>5、减少重绘与回流</strong></p>
<ol>
<li><p>CSS</p>
<ul>
<li><p><strong>使用 transform 替代 top</strong></p>
</li>
<li><p><strong>使用 visibility 替换 display: none</strong> ，因为前者只会引起重绘，后者会引发回流（改变了布局</p>
</li>
<li><p><strong>避免使用 table 布局</strong>，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局。</p>
</li>
<li><p><strong>尽可能在 DOM 树的最末端改变 class</strong>，回流是不可避免的，但可以减少其影响。尽可能在 DOM 树的最末端改变 class，可以限制了回流的范围，使其影响尽可能少的节点。</p>
</li>
<li><p><strong>避免设置多层内联样式</strong>，CSS 选择符<strong>从右往左</strong>匹配查找，避免节点层级过多。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  span &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">  div &gt; a &gt; span &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 <code>span</code> 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 <code>span</code> 标签，然后找到 <code>span</code> 标签上的 <code>a</code> 标签，最后再去找到 <code>div</code> 标签，然后给符合这种条件的 <code>span</code> 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写<strong>过于具体</strong>的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证<strong>层级扁平</strong>。</p>
</li>
<li><p><strong>将动画效果应用到 position 属性为 absolute 或 fixed 的元素上</strong>，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 <code>requestAnimationFrame</code>，详见<a target="_blank" rel="noopener" href="https://github.com/LuNaHaiJiao/blog/issues/30">探讨 requestAnimationFrame</a>。</p>
</li>
<li><p><strong>避免使用 CSS 表达式</strong>，可能会引发回流。</p>
</li>
<li><p><strong>将频繁重绘或者回流的节点设置为图层</strong>，图层能够阻止该节点的渲染行为影响别的节点，例如<code>will-change</code>、<code>video</code>、<code>iframe</code>等标签，浏览器会自动将该节点变为图层。</p>
</li>
<li><p><strong>CSS3 硬件加速（GPU 加速）</strong>，使用 css3 硬件加速，可以让<code>transform</code>、<code>opacity</code>、<code>filters</code>这些动画不会引起回流重绘 。但是对于动画的其它属性，比如<code>background-color</code>这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</p>
</li>
</ul>
</li>
<li><p>JavaScript</p>
<ul>
<li><strong>避免频繁操作样式</strong>，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li>
<li><strong>避免频繁操作 DOM</strong>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM操作</code>，最后再把它添加到文档中。</li>
<li><strong>避免频繁读取会引发回流/重绘的属性</strong>，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li><strong>对具有复杂动画的元素使用绝对定位</strong>，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
</li>
</ol>
<p>详见<a target="_blank" rel="noopener" href="https://github.com/sisterAn/blog/issues/33">浏览器的重绘与回流（Repaint、Reflow）</a></p>
<h3 id="第-23-题-（2019-10-12）"><a href="#第-23-题-（2019-10-12）" class="headerlink" title="第 23 题 （2019/10/12）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/25">第 23 题 </a>（2019/10/12）</h3><p><strong>题目：</strong> 介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景</p>
<p><strong>解析：</strong></p>
<p>我们先来看下这两个模式的实现结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20190329182209470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmODcyOTE0MzM0,size_16,color_FFFFFF,t_70"></p>
<p>观察者模式： 观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。</p>
<p>发布订阅模式： 订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Topic），当发布者（Publisher）发布该事件（Publish topic）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。</p>
<p><strong>区别：</strong></p>
<p>观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心。</p>
<p>观察者模式由具体目标调度，每个被订阅的目标里面都需要有对观察者的处理，这种处理方式比较直接粗暴，但是会造成代码的冗余。</p>
<p>而发布订阅模式中统一由调度中心进行处理，订阅者和发布者互不干扰，消除了发布者和订阅者之间的依赖。这样一方面实现了解耦，还有就是可以实现更细粒度的一些控制。比如发布者发布了很多消息，但是不想所有的订阅者都接收到，就可以在调度中心做一些处理，类似于权限控制之类的。还可以做一些节流操作。</p>
<p><strong>观察者模式是不是发布订阅模式</strong></p>
<p>网上关于这个问题的回答，出现了两极分化，有认为发布订阅模式就是观察者模式的，也有认为观察者模式和发布订阅模式是真不一样的。</p>
<p>其实我不知道发布订阅模式是不是观察者模式，就像我不知道辨别模式的关键是设计意图还是设计结构（理念），虽然《JavaScript 设计模式与开发实践》一书中说了分辨模式的关键是意图而不是结构。</p>
<p>如果以结构来分辨模式，发布订阅模式相比观察者模式多了一个中间件订阅器，所以发布订阅模式是不同于观察者模式的；如果以意图来分辨模式，他们都是实现了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新，那么他们就是同一种模式，发布订阅模式是在观察者模式的基础上做的优化升级。</p>
<p>不过，不管他们是不是同一个设计模式，他们的实现方式确实有差别，我们在使用的时候应该根据场景来判断选择哪个。</p>
<h3 id="第-24-题-（2019-10-13）"><a href="#第-24-题-（2019-10-13）" class="headerlink" title="第 24 题 （2019/10/13）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/45">第 24 题</a> （2019/10/13）</h3><p><strong>题目：</strong> 聊聊 Redux 和 Vuex 的设计思想</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://juejin.im/post/5b6d75dce51d4533d20487b0">关于 Flux,Vuex,Redux 的思考</a> <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/01/flux.html">Flux 架构入门教程</a></p>
<p>Flux 是一种前端状态管理架构思想，专门解决软件的结构问题。<br>基于 Flux 的设计思想，出现了一批前端状态管理框架。<br>他们给出了一些库用于实现 Flux 的思想，并在 Flux 的基础上做了一些改进。<br>在这些框架里，当前最热门的莫过于 Redux 和 Vuex 了</p>
<p><strong>Flux</strong></p>
<p>Flux 数据流的顺序是:</p>
<p>View 发起 Action-&gt;Action 传递到 Dispatcher-&gt;Dispatcher 将通知 Store-&gt;Store 的状态改变通知 View 进行改变</p>
<p><strong>Redux</strong></p>
<p>Redux 相对于 Flux 的改进：</p>
<ul>
<li>把 store 和 Dispatcher 合并,结构更加简单清晰</li>
<li>新增 state 角色，代表每个时间点 store 对应的值，对状态的管理更加明确</li>
</ul>
<p>Redux 数据流的顺序是:</p>
<p>View 调用 store.dispatch 发起 Action-&gt;store 接受 Action(action 传入 reducer 函数,reducer 函数返回一个新的 state)-&gt;通知 store.subscribe 订阅的重新渲染函数</p>
<p>ps:<a href="https://link.juejin.im/?target=https://github.com/reactjs/redux/tree/master/examples/counter">阮一峰老师的 Redux+React 小 demo</a></p>
<p><strong>Vuex</strong></p>
<p>Vuex 是专门为 Vue 设计的状态管理框架,<br>同样基于 Flux 架构，并吸收了 Redux 的优点</p>
<p>Vuex 相对于 Redux 的不同点有:</p>
<ul>
<li>改进了 Redux 中的 Action 和 Reducer 函数，以 mutations 变化函数取代 Reducer，<br>无需 switch,只需在对应的 mutation 函数里改变 state 值即可</li>
<li>由于 Vue 自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的 State 即可</li>
</ul>
<p>Vuex 数据流的顺序是:</p>
<p>View 调用 store.commit 提交对应的请求到 Store 中对应的 mutation 函数-&gt;store 改变(vue 检测到数据变化自动渲染)</p>
<h3 id="第-25-题-（2019-10-14）"><a href="#第-25-题-（2019-10-14）" class="headerlink" title="第 25 题 （2019/10/14）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/26">第 25 题</a> （2019/10/14）</h3><p><strong>题目：</strong> 说说浏览器和 Node 事件循环的区别</p>
<p><strong>解析：</strong></p>
<p><strong>浏览器</strong></p>
<p><strong>关于微任务和宏任务在浏览器的执行顺序是这样的：</strong></p>
<ul>
<li>执行一只 task（宏任务）</li>
<li>执行完 micro-task 队列 （微任务）</li>
</ul>
<p>如此循环往复下去</p>
<blockquote>
<p>浏览器的 task（宏任务）执行顺序在 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">html#event-loops</a> 里面有讲就不翻译了<br>常见的 task（宏任务） 比如：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。<br>常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5 新特性) 等。</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/10/1683863633586974?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p><strong>Node</strong></p>
<p>Node 的事件循环是 libuv 实现的，引用一张官网的图：</p>
<p><img src="https://user-images.githubusercontent.com/20101525/53734427-eba9e880-3ebe-11e9-8511-eb4948e336ae.png"></p>
<p>大体的 task（宏任务）执行顺序是这样的：</p>
<ul>
<li>timers 定时器：本阶段执行已经安排的 setTimeout() 和 setInterval() 的回调函数。</li>
<li>pending callbacks 待定回调：执行延迟到下一个循环迭代的 I/O 回调。</li>
<li>idle, prepare：仅系统内部使用。</li>
<li>poll 轮询：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate() 排定的之外），其余情况 node 将在此处阻塞。</li>
<li>check 检测：setImmediate() 回调函数在这里执行。</li>
<li>close callbacks 关闭的回调函数：一些准备关闭的回调函数，如：socket.on(‘close’, …)。</li>
</ul>
<p><strong>微任务和宏任务在 Node 的执行顺序</strong></p>
<p>Node 10 以前：</p>
<ul>
<li>执行完一个阶段的所有任务</li>
<li>执行完 nextTick 队列里面的内容</li>
<li>然后执行完微任务队列的内容</li>
</ul>
<p>Node 11 以后：<br>和浏览器的行为统一了，都是每执行一个宏任务就执行完微任务队列</p>
<h3 id="第-26-题-（2019-10-16）"><a href="#第-26-题-（2019-10-16）" class="headerlink" title="第 26 题 （2019/10/16）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/28">第 26 题</a> （2019/10/16）</h3><p><strong>题目：</strong> 介绍模块化发展历程</p>
<blockquote>
<p>可从 IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module、<code>&lt;script type=&quot;module&quot;&gt;</code> 这几个角度考虑。</p>
</blockquote>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5c8409bbe4b02b2ce492286a">es6,amd,smd,commonjs 思维导图</a></p>
<p>模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。</p>
<p><strong>IIFE</strong>： 使用自执行函数来编写模块化，特点：<strong>在一个单独的函数作用域中执行代码，避免变量冲突</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    data: [],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>AMD</strong>： 使用 requireJS 来编写模块化，特点：<strong>依赖必须提前声明好</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">&quot;./index.js&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// code 就是index.js 返回的内容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>CMD</strong>： 使用 seaJS 来编写模块化，特点：<strong>支持动态引入依赖文件</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> indexCode = <span class="built_in">require</span>(<span class="string">&quot;./index.js&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>CommonJS</strong>： nodejs 中自带的模块化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>UMD</strong>：兼容 AMD，CommonJS 模块化语法。</p>
<p>**webpack(require.ensure)**：webpack 2.x 版本中的代码分割。</p>
<p><strong>ES Modules</strong>： ES6 引入的模块化，支持 import 来引入另一个 js 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="第-27-题-（2019-10-16）"><a href="#第-27-题-（2019-10-16）" class="headerlink" title="第 27 题 （2019/10/16）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/30">第 27 题</a> （2019/10/16）</h3><p><strong>题目：</strong> 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？。</p>
<p><strong>解析：</strong></p>
<p>在 ES5 中，顶层对象的属性和全局变量是等价的，var 命令和 function 命令声明的全局变量，自然也是顶层对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.f); <span class="comment">// f()&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>但 ES6 规定，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，但 let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> bb = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.aa); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.bb); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>在函数的内部属性<code>[[Scopes]]</code>中找到了</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/8/1678e8be5c831804?imageslim"></p>
<blockquote>
<p>如上图，在全局作用域中用<code>const</code>声明的变量在函数<code>noop</code>中可以正常访问，没有问题。我用<code>dir</code>方法打印出函数<code>noop</code>的属性，最后在<code>[[Scopes]]</code>属性内找到了消失的全局变量<code>abcd</code>。</p>
</blockquote>
<h3 id="第-28-题-（2019-10-17）"><a href="#第-28-题-（2019-10-17）" class="headerlink" title="第 28 题 （2019/10/17）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/31">第 28 题</a> （2019/10/17）</h3><p><strong>题目：</strong> cookie 和 token 都存放在 header 中，为什么不会劫持 token？</p>
<p><strong>解析：</strong></p>
<ol>
<li>首先 token 不是防止 XSS 的，而是为了防止 CSRF 的；</li>
<li>CSRF 攻击的原因是浏览器会自动带上 cookie，而浏览器不会自动带上 token</li>
</ol>
<hr>
<blockquote>
<p>cookie：登陆后后端生成一个 sessionid 放在 cookie 中返回给客户端，并且服务端一直记录着这个 sessionid，客户端以后每次请求都会带上这个 sessionid，服务端通过这个 sessionid 来验证身份之类的操作。所以别人拿到了 cookie 拿到了 sessionid 后，就可以完全替代你。</p>
</blockquote>
<blockquote>
<p>token：登陆后后端不返回一个 token 给客户端，客户端将这个 token 存储起来，然后每次客户端请求都需要开发者手动将 token 放在 header 中带过去，服务端每次只需要对这个 token 进行验证就能使用 token 中的信息来进行下一步操作了。</p>
</blockquote>
<blockquote>
<p>xss：用户通过各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本获取信息，发起请求，之类的操作。</p>
</blockquote>
<blockquote>
<p>csrf：跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了 web 中用户身份验证的一个漏洞：<strong>简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的</strong>。csrf 并不能够拿到用户的任何信息，它只是欺骗用户浏览器，让其以用户的名义进行操作。</p>
</blockquote>
<blockquote>
<p>csrf 例子：假如一家银行用以运行转账操作的 URL 地址如下： <a target="_blank" rel="noopener" href="http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</a><br>那么，一个恶意攻击者可以在另一个网站上放置如下代码： <code>&lt;img src=&quot;&lt;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&gt;&quot;&gt;</code><br>如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 资金。</p>
</blockquote>
<p>上面的两种攻击方式，如果被 xss 攻击了，不管是 token 还是 cookie，都能被拿到，所以对于 xss 攻击来说，cookie 和 token 没有什么区别。但是对于 csrf 来说就有区别了。</p>
<p>以上面的 csrf 攻击为例：</p>
<ul>
<li>cookie：用户点击了链接，cookie 未失效，导致发起请求后后端以为是用户正常操作，于是进行扣款操作。</li>
<li>token：用户点击链接，由于浏览器不会自动带上 token，所以即使发了请求，后端的 token 验证不会通过，所以不会进行扣款操作。</li>
</ul>
<p>这是个人理解的为什么只劫持 cookie 不劫持 token 的原因。</p>
<h3 id="第-29-题-（2019-10-17）"><a href="#第-29-题-（2019-10-17）" class="headerlink" title="第 29 题  （2019/10/17）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/34">第 29 题 </a> （2019/10/17）</h3><p><strong>题目：</strong> 聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的</p>
<p><strong>解析：</strong></p>
<p>VM 主要做了两件微小的事情：</p>
<ul>
<li>从 M 到 V 的映射（Data Binding），这样可以大量节省你人肉来 update View 的代码（将数据绑定到 view）</li>
<li>从 V 到 M 的事件监听（DOM Listeners），这样你的 Model 会随着 View 触发事件而改变 （view 改变的时候改变数据）</li>
</ul>
<p><strong>1、M 到 V 实现</strong></p>
<p>做到这件事的第一步是形成类似于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template</span></span><br><span class="line"><span class="keyword">var</span> tpl = <span class="string">&#x27;&lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">// data</span></span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">text: ‘This is some text‘</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// magic process</span></span><br><span class="line">template(tpl, data); <span class="comment">// &#x27;&lt;p&gt;This is some text&lt;/p&gt;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>中间的 magic process 是模板引擎所做的事情，已经有非常多种模板引擎可供选择</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://developer.mozilla.org/en/docs/JavaScript_templates">JavaScript templates</a></li>
</ul>
<p>当然你比较喜欢造轮子的话也可以自己实现一个</p>
<ul>
<li><a href="https://link.zhihu.com/?target=http://kyleslight.net/article/27">一个 JavaScript 模板引擎的实现</a></li>
</ul>
<p>无论是 Angular 的 $scope，React 的 state 还是 Vue 的 data 都提供了一个较为核心的 model 对象用来保存模型的状态；它们的模板引擎稍有差别，不过大体思路相似；拿到渲染后的 string 接下来做什么不言而喻了（中间还有很多处理，例如利用 model 的 diff 来最小量更新 view ）。</p>
<p>但是仅仅是这样并不够，我们需要知道什么时候来更新 view（ 即 render ），一般来说主要的 VM 做了以下几种选择：</p>
<ul>
<li>VM 实例初始化时</li>
<li>model 动态修改时</li>
</ul>
<p>其中初始化拿到 model 对象然后 render 没什么好讲的；model 被修改的时候如何监听属性的改变是一个问题，目前有以下几种思路：</p>
<ul>
<li>借助于 Object 的 observe 方法</li>
<li>自己在 set，以及数组的常用操作里触发 change 事件</li>
<li>手动 setState()，然后在里面触发 change 事件</li>
</ul>
<p>知道了触发 render 的时机以及如何 render，一个简单的 M 到 V 映射就实现了。</p>
<p><strong>2、V 到 M 实现</strong></p>
<p>从 V 到 M 主要由两类（ 虽然本质上都是监听 DOM ）构成，一类是用户自定义的 listener， 一类是 VM 自动处理的含有 value 属性元素的 listener</p>
<p>第一类类似于你在 Vue 里用 v-on 时绑定的那样，VM 在实例化得时候可以将所有用户自定义的 listener 一次性代理到根元素上，这些 listener 可以访问到你的 model 对象，这样你就可以在 listener 中改变 model</p>
<p>第二类类似于对含有 v-model 与 value 元素的自动处理，我们期望的是例如在一个输入框内</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;message&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>输入值，那么我与之对应的 model 属性 message 也会随之改变，相当于 VM 做了一个默认的 listener，它会监听这些元素的改变然后自动改变 model，具体如何实现相信你也明白了</p>
<h3 id="第-30-题-（2019-10-18）"><a href="#第-30-题-（2019-10-18）" class="headerlink" title="第 30 题 （2019/10/18）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/39">第 30 题</a> （2019/10/18）</h3><p><strong>题目：</strong> 两个数组合并成一个数组</p>
<blockquote>
<p>请把两个数组 [‘A1’, ‘A2’, ‘B1’, ‘B2’, ‘C1’, ‘C2’, ‘D1’, ‘D2’] 和 [‘A’, ‘B’, ‘C’, ‘D’]，合并为 [‘A1’, ‘A2’, ‘A’, ‘B1’, ‘B2’, ‘B’, ‘C1’, ‘C2’, ‘C’, ‘D1’, ‘D2’, ‘D’]。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MergeArray</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a2 = arr2.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item + <span class="number">3</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> arr = [...arr1, ...a2].sort();</span><br><span class="line">  <span class="keyword">return</span> arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.includes(<span class="number">3</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> item.split(<span class="string">&quot;&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-31-题-（2019-10-18）"><a href="#第-31-题-（2019-10-18）" class="headerlink" title="第 31 题 （2019/10/18）"></a>第 31 题 （2019/10/18）</h3><p><strong>题目：</strong> 改造下面的代码，使之输出 0 - 9，写出你能想到的所有解法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<ol>
<li>使用闭包：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  (<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 let</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-32-题-（2019-10-19）"><a href="#第-32-题-（2019-10-19）" class="headerlink" title="第 32 题 （2019/10/19）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/47">第 32 题</a> （2019/10/19）</h3><p><strong>题目：</strong> Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法。</p>
<p><strong>解析：</strong></p>
<p>作者：尤雨溪</p>
<p>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31809713/answer/53544875">https://www.zhihu.com/question/31809713/answer/53544875</a></p>
<p>来源：知乎</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p><strong>1. 原生 DOM 操作 vs. 通过框架封装操作。</strong></p>
<p>这是一个性能 vs. 可维护性的取舍。框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。</p>
<p><strong>2. 对 React 的 Virtual DOM 的误解。</strong></p>
<p>React 从来没有说过 “React 比原生操作 DOM 快”。React 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作… 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。</p>
<p>我们可以比较一下 innerHTML vs. Virtual DOM 的重绘性能消耗：</p>
<ul>
<li>innerHTML: render html string <strong>O(template size)</strong> + 重新创建所有 DOM 元素 <strong>O(DOM size)</strong></li>
<li>Virtual DOM: render Virtual DOM + diff <strong>O(template size)</strong> + 必要的 DOM 更新 <strong>O(DOM change)</strong></li>
</ul>
<p>Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。前面说了，和 DOM 操作比起来，js 计算是极其便宜的。这才是为什么要有 Virtual DOM：它保证了 1）不管你的数据变化多少，每次重绘的性能都可以接受；2) 你依然可以用类似 innerHTML 的思路去写你的应用。</p>
<p><strong>3. MVVM vs. Virtual DOM</strong></p>
<p>相比起 React，其他 MVVM 系框架比如 Angular, Knockout 以及 Vue、Avalon 采用的都是数据绑定：通过 Directive/Binding 对象，观察数据变化并保留对实际 DOM 元素的引用，当有数据变化时进行对应的操作。MVVM 的变化检查是数据层面的，而 React 的检查是 DOM 结构层面的。MVVM 的性能也根据变动检测的实现原理有所不同：Angular 的脏检查使得任何变动都有固定的</p>
<p>O(watcher count)</p>
<p>的代价；Knockout/Vue/Avalon 都采用了依赖收集，在 js 和 DOM 层面都是</p>
<p>O(change)</p>
<p>：</p>
<ul>
<li>脏检查：scope digest <strong>O(watcher count)</strong> + 必要 DOM 更新 <strong>O(DOM change)</strong></li>
<li>依赖收集：重新收集依赖 <strong>O(data change)</strong> + 必要 DOM 更新 <strong>O(DOM change)</strong></li>
</ul>
<p>可以看到，Angular 最不效率的地方在于任何小变动都有的和 watcher 数量相关的性能代价。但是！当所有数据都变了的时候，Angular 其实并不吃亏。依赖收集在初始化和数据变化的时候都需要重新收集依赖，这个代价在小量更新的时候几乎可以忽略，但在数据量庞大的时候也会产生一定的消耗。</p>
<p>MVVM 渲染列表的时候，由于每一行都有自己的数据作用域，所以通常都是每一行有一个对应的 ViewModel 实例，或者是一个稍微轻量一些的利用原型继承的 “scope” 对象，但也有一定的代价。所以，MVVM 列表渲染的初始化几乎一定比 React 慢，因为创建 ViewModel / scope 实例比起 Virtual DOM 来说要昂贵很多。这里所有 MVVM 实现的一个共同问题就是在列表渲染的数据源变动时，尤其是当数据是全新的对象时，如何有效地复用已经创建的 ViewModel 实例和 DOM 元素。假如没有任何复用方面的优化，由于数据是 “全新” 的，MVVM 实际上需要销毁之前的所有实例，重新创建所有实例，最后再进行一次渲染！这就是为什么题目里链接的 angular/knockout 实现都相对比较慢。相比之下，React 的变动检查由于是 DOM 结构层面的，即使是全新的数据，只要最后渲染结果没变，那么就不需要做无用功。</p>
<p>Angular 和 Vue 都提供了列表重绘的优化机制，也就是 “提示” 框架如何有效地复用实例和 DOM 元素。比如数据库里的同一个对象，在两次前端 API 调用里面会成为不同的对象，但是它们依然有一样的 uid。这时候你就可以提示 track by uid 来让 Angular 知道，这两个对象其实是同一份数据。那么原来这份数据对应的实例和 DOM 元素都可以复用，只需要更新变动了的部分。或者，你也可以直接 track by $index 来进行 “原地复用”：直接根据在数组里的位置进行复用。在题目给出的例子里，如果 angular 实现加上 track by $index 的话，后续重绘是不会比 React 慢多少的。甚至在 dbmonster 测试中，Angular 和 Vue 用了 track by $index 以后都比 React 快: <a href="https://link.zhihu.com/?target=http://vuejs.github.io/js-repaint-perfs/">dbmon</a> (注意 Angular 默认版本无优化，优化过的在下面）</p>
<p>顺道说一句，React 渲染列表的时候也需要提供 key 这个特殊 prop，本质上和 track-by 是一回事。</p>
<p><strong>4. 性能比较也要看场合</strong></p>
<p>在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求。Virtual DOM 为了提升小量数据更新时的性能，也需要针对性的优化，比如 shouldComponentUpdate 或是 immutable data。</p>
<ul>
<li>初始渲染：Virtual DOM &gt; 脏检查 &gt;= 依赖收集</li>
<li>小量数据更新：依赖收集 &gt;&gt; Virtual DOM + 优化 &gt; 脏检查（无法优化） &gt; Virtual DOM 无优化</li>
<li>大量数据更新：脏检查 + 优化 &gt;= 依赖收集 + 优化 &gt; Virtual DOM（无法/无需优化）&gt;&gt; MVVM 无优化</li>
</ul>
<p>不要天真地以为 Virtual DOM 就是快，diff 不是免费的，batching 么 MVVM 也能做，而且最终 patch 的时候还不是要用原生 API。在我看来 Virtual DOM 真正的价值从来都不是性能，而是它 1) 为函数式的 UI 编程方式打开了大门；2) 可以渲染到 DOM 以外的 backend，比如 ReactNative。</p>
<h3 id="第-33-题-（2019-10-20）"><a href="#第-33-题-（2019-10-20）" class="headerlink" title="第 33 题 （2019/10/20）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/48">第 33 题</a> （2019/10/20）</h3><p><strong>题目：</strong> 下面的代码打印什么内容，为什么？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p>非严格模式：【输出函数体】</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ƒ b()&#123;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>严格模式：【报错】</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;Uncaught TypeError: Assignment to constant variable.&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>针对这题，在知乎上看到别人的回答说：</p>
<ol>
<li>函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。</li>
<li>对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。</li>
<li>IIFE 中的函数是函数表达式，而不是函数声明。</li>
</ol>
<p>实际上，有点类似于以下代码，但不完全相同，因为使用 const 不管在什么模式下，都会 TypeError 类型的错误</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const foo &#x3D; function () &#123;</span><br><span class="line">foo &#x3D; 10;</span><br><span class="line">console.log(foo)</span><br><span class="line">&#125;</span><br><span class="line">(foo)() &#x2F;&#x2F; Uncaught TypeError: Assignment to constant variable.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>我的理解是，b 函数是一个相当于用 const 定义的常量，内部无法进行重新赋值，如果在严格模式下，会报错”Uncaught TypeError: Assignment to constant variable.”<br>例如下面的：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var b &#x3D; 10;</span><br><span class="line">(function b() &#123;</span><br><span class="line">&#39;use strict&#39;</span><br><span class="line">b &#x3D; 20;</span><br><span class="line">console.log(b)</span><br><span class="line">&#125;)() &#x2F;&#x2F; &quot;Uncaught TypeError: Assignment to constant variable.&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p>这个回答主要表达的是：函数表达式的函数名只在该函数内部有效，且绑定是常量类似 const，不能修改</p>
<h3 id="第-34-题（2019-10-21）"><a href="#第-34-题（2019-10-21）" class="headerlink" title="第 34 题（2019/10/21）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/51">第 34 题</a>（2019/10/21）</h3><p><strong>题目：</strong> 简单改造下面的代码，使之分别打印 10 和 20。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>打印 20：</p>
<p>方法一：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)(b);</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>打印 10：</p>
<p>方法一：（挂载在 全局 window 上）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)(b);</span><br></pre></td></tr></table></figure>

<p>方法二： （挂载在 b 函数（函数也是特殊的对象）上）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  b.b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)(b);</span><br></pre></td></tr></table></figure>

<h3 id="第-35-题-（2019-10-22）"><a href="#第-35-题-（2019-10-22）" class="headerlink" title="第 35 题  （2019/10/22）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/51">第 35 题 </a> （2019/10/22）</h3><p><strong>题目</strong>：浏览器缓存读取规则 ?</p>
<blockquote>
<p>可以分成 Service Worker、Memory Cache、Disk Cache 和 Push Cache，那请求的时候 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache 中？</p>
</blockquote>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/54cc04190252">深入理解浏览器的缓存机制</a> <a target="_blank" rel="noopener" href="https://juejin.im/post/5c22ee806fb9a049fb43b2c5?utm_source=gold_browser_extension">一文读懂前端缓存</a></p>
<p>对于第一个问题前面的文章都说得很详细了我这里就不再多余述<br>第二个问题可以参考我写的<a target="_blank" rel="noopener" href="https://jayzangwill.github.io/blog/2019/02/07/cache/">博文</a> <strong>命中强制缓存时，该从哪拿缓存</strong><br>小节。总的来说：</p>
<ol>
<li>如果开启了 Service Worker 首先会从 Service Worker 中拿</li>
<li>如果新开一个以前打开过的页面缓存会从 Disk Cache 中拿（称为是命中强缓存）</li>
<li>刷新当前页面时浏览器会根据当前运行环境内存来决定是从 Memory Cache 还是从 Disk Cache 中拿（可以看到下图最后几个文件有时候是从 Memory Cache 中拿有时候是从 Disk Cache 中拿）</li>
</ol>
<h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://camo.githubusercontent.com/6254fa34eb5e693a51cb2b5b2eb257f38f0b1634/68747470733a2f2f6a61797a616e6777696c6c2e6769746875622e696f2f626c6f672f696d672f63616368652f7765697a68695f312e676966"></h6><h3 id="第-36-题-（2019-10-22）"><a href="#第-36-题-（2019-10-22）" class="headerlink" title="第 36 题 （2019/10/22）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/54">第 36 题</a> （2019/10/22）</h3><p><strong>题目：</strong> 使用迭代的方式实现 flatten 函数。</p>
<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用迭代的方式实现flatten函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用递归的方式处理</span></span><br><span class="line"><span class="comment"> * wrap内保存结果ret</span></span><br><span class="line"><span class="comment"> * 返回一个递归函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, [<span class="number">7</span>, [<span class="number">8</span>]]]];</span><br><span class="line"><span class="built_in">console</span>.log(wrap()(arr));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.constructor === <span class="built_in">Array</span>) &#123;</span><br><span class="line">        ret.concat(flatten(item));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret.push(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-37-题-（2019-10-22）"><a href="#第-37-题-（2019-10-22）" class="headerlink" title="第 37 题 （2019/10/22）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/65">第 37 题</a> （2019/10/22）</h3><p><strong>题目：</strong> 为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？</p>
<p><strong>解析：</strong> 待续…</p>
<h3 id="第-38-题-（2019-10-23）"><a href="#第-38-题-（2019-10-23）" class="headerlink" title="第 38 题  （2019/10/23）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/57">第 38 题 </a> （2019/10/23）</h3><p><strong>题目：</strong> 下面代码中 a 在什么情况下会打印 1？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = ?;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>)&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>公司：</strong> 京东</p>
<p><strong>考点</strong>： 隐式类型转换</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/399499">从 (a==1&amp;&amp;a==2&amp;&amp;a==3) 成立中看 javascript 的隐式类型转换</a></p>
<p><strong>关于 === 于 ==</strong></p>
<blockquote>
<p>但是我比较喜欢的一本书 <code> You don&#39;t know JS</code>,中作者也写道过一个我比较赞同的观点</p>
<p>很多开发者认为 === 的行为更加容易预测，从而主张使用 === 而远离 ==。我认为这种观点是非常短视的，如果你花点时间去搞清楚它的工作原理，== 将是你开发的强大工具</p>
</blockquote>
<ol>
<li>运算子是对象时候的 valueOf toString 方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  i: <span class="number">1</span>,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.i++;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>); <span class="comment">//1</span></span><br><span class="line">  <span class="built_in">console</span>.log(a.i); <span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果原始类型的值和对象比较，对象会转为原始类型的值，再进行比较。<code>(我想到的也是这种方法)</code>，对象转换成原始类型的值，算法是先调用<code>valueOf</code>方法；如果返回的还是对象，再接着调用<code>toString</code>方法。我们每次比较时候都会执行方法返回 <code>a</code> 的 <code>i</code> 属性同时也改变 <code>i</code> 的值,所以上面 <code>if</code> 执行完以后 <code>a</code> 的 <code>i</code> 属性已经变为了 4，<strong>这里也表现出了 == 比较是有可能会对变量带来副作用的</strong></p>
<p><strong>利用数组的特性</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.join = a.shift;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个答案还是比较巧妙的，我们知道 <code>array</code> 也属于对象，应该和对象的规则一样。关于 <code>array</code> 的原型链上的 <code>toString</code> 方法</p>
<blockquote>
<p>对于数组对象，toString 方法返回一个字符串，该字符串由数组中的每个元素的 toString() 返回值经调用 join() 方法连接（由逗号隔开）组成。</p>
</blockquote>
<p>可以看到数组 <code>toString</code> 会调用本身的 <code>join</code> 方法，这里把自己的<code>join</code>方法该写为<code>shift</code>,每次返回第一个元素，而且原数组删除第一个值，正好可以使判断成立。<strong>这里 == 比较也带来的副作用</strong></p>
<p><strong>利用 with 关键字</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">a</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>with</code> 也是被严重建议不使用的对象，这里也是利用它的特性在代码块里面利用对象的 <code>get</code> 方法动态返回 <code>i</code>.</p>
<p><strong>和 with 类似修改 window 的 get 方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++val;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;yay&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道我们用的全局变量也相当于 <code>window</code> 对象上的一个属性，这里用<code>defineProperty</code> 定义了 <code>a</code>的 <code>get</code> 也使得其动态返回值。和<code>with</code> 有一些类似。</p>
<p><strong>es6 的 Symbol 特性</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; [<span class="built_in">Symbol</span>.toPrimitive]: (<span class="function">(<span class="params">i</span>) =&gt;</span> <span class="function">() =&gt;</span> ++i)(<span class="number">0</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><code>ES6</code> 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。我们之前在定义类的内部私有属性时候习惯用 <code>__xxx</code> ,这种命名方式避免别人定义相同的属性名覆盖原来的属性，有了 <code>Symbol </code> 之后我们完全可以用 <code>Symbol</code>值来代替这种方法，而且完全不用担心被覆盖。</p>
<p>除了定义自己使用的 <code>Symbol</code> 值以外，<code>ES6</code> 还提供了 11 个内置的 <code>Symbol</code> 值，指向语言内部使用的方法。<code>Symbol.toPrimitive</code>就是其中一个，它指向一个方法，表示该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。这里就是改变这个属性，把它的值改为一个 <code>闭包</code> 返回的函数。</p>
<h3 id="第-39-题-（2019-10-24）"><a href="#第-39-题-（2019-10-24）" class="headerlink" title="第 39 题 （2019/10/24）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/59">第 39 题</a> （2019/10/24）</h3><p><strong>题目：</strong> 介绍下 BFC 及其应用</p>
<p><strong>解析：</strong></p>
<p>BFC 就是块级格式上下文，是页面盒模型布局中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。创建 BFC 的方式有：</p>
<ol>
<li>html 根元素</li>
<li>float 浮动</li>
<li>绝对定位</li>
<li>overflow 不为 visiable</li>
<li>display 为表格布局或者弹性布局</li>
</ol>
<p>BFC 主要的作用是：</p>
<ol>
<li>清除浮动</li>
<li>防止同一 BFC 容器中的相邻元素间的外边距重叠问题</li>
</ol>
<h3 id="第-40-题-（2019-10-25）"><a href="#第-40-题-（2019-10-25）" class="headerlink" title="第 40 题  （2019/10/25）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/60">第 40 题 </a> （2019/10/25）</h3><p><strong>题目：</strong> 在 Vue 中，子组件为何不可以修改父组件传递的 Prop?</p>
<blockquote>
<p>如果修改了，Vue 是如何监控到属性的修改并给出警告的。</p>
</blockquote>
<p><strong>解析：</strong></p>
<ol>
<li>子组件为何不可以修改父组件传递的 Prop<br>单向数据流，易于监测数据的流动，出现了错误可以更加迅速的定位到错误发生的位置。</li>
<li>如果修改了，Vue 是如何监控到属性的修改并给出警告的。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> hyphenatedKey = hyphenate(key);</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">    config.isReservedAttr(hyphenatedKey)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">&#x27;&quot;&#x27;</span> +</span><br><span class="line">        hyphenatedKey +</span><br><span class="line">        <span class="string">&#x27;&quot; is a reserved attribute and cannot be used as component prop.&#x27;</span>,</span><br><span class="line">      vm</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  defineReactive$$<span class="number">1</span>(props, key, value, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">&quot;Avoid mutating a prop directly since the value will be &quot;</span> +</span><br><span class="line">          <span class="string">&quot;overwritten whenever the parent component re-renders. &quot;</span> +</span><br><span class="line">          <span class="string">&quot;Instead, use a data or computed property based on the prop&#x27;s &quot;</span> +</span><br><span class="line">          <span class="string">&#x27;value. Prop being mutated: &quot;&#x27;</span> +</span><br><span class="line">          key +</span><br><span class="line">          <span class="string">&#x27;&quot;&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 initProps 的时候，在 defineReactive 时通过判断是否在开发环境，如果是开发环境，会在触发 set 的时候判断是否此 key 是否处于 updatingChildren 中被修改，如果不是，说明此修改来自子组件，触发 warning 提示。</p>
<blockquote>
<p>需要特别注意的是，当你从子组件修改的 prop 属于基础类型时会触发提示。 这种情况下，你是无法修改父组件的数据源的， 因为基础类型赋值时是值拷贝。你直接将另一个非基础类型（Object, array）赋值到此 key 时也会触发提示(但实际上不会影响父组件的数据源)， 当你修改 object 的属性时不会触发提示，并且会修改父组件数据源的数据。</p>
</blockquote>
<h3 id="第-41-题-（2019-10-25）"><a href="#第-41-题-（2019-10-25）" class="headerlink" title="第 41 题 （2019/10/25）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/61">第 41 题</a> （2019/10/25）</h3><p><strong>题目：</strong> 下面代码输出什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">  a = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//20</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong> 分别为 undefined 　 10 　 20，原因是作用域问题，在内部声名 var a = 20;相当于先声明 var a;然后再执行赋值操作，这是在ＩＩＦＥ内形成的独立作用域，如果把 var a=20 注释掉，那么 a 只有在外部有声明，显示的就是外部的Ａ变量的值了。结果Ａ会是 10 　 5 　 5</p>
<h3 id="第-42-题-（2019-10-25）"><a href="#第-42-题-（2019-10-25）" class="headerlink" title="第 42 题  （2019/10/25）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/63">第 42 题 </a> （2019/10/25）</h3><p><strong>题目：</strong> 实现一个 sleep 函数</p>
<blockquote>
<p>比如 sleep(1000) 意味着等待 1000 毫秒，可从 Promise、Generator、Async/Await 等角度实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise1</span></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, time));</span><br><span class="line">&#125;;</span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Generator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">sleepGenerator</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">sleepGenerator(<span class="number">1000</span>)</span><br><span class="line">  .next()</span><br><span class="line">  .value.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//async</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, time));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> out = <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">output();</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">callback, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&quot;function&quot;</span>) <span class="built_in">setTimeout</span>(callback, time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">sleep(output, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ImagineCode/article/details/81089107">Promise | 自个写一个 Promise | Generator</a></li>
</ul>
<h3 id="第-43-题-（2019-10-26）"><a href="#第-43-题-（2019-10-26）" class="headerlink" title="第 43 题 （2019/10/26）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/66">第 43 题</a> （2019/10/26）</h3><p><strong>题目：</strong> 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果</p>
<p><strong>解析：</strong></p>
<p>原题目：</p>
<blockquote>
<p>使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果</p>
</blockquote>
<p>我的答案：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">102</span>, <span class="number">15</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">3</span>, <span class="number">8</span>];</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>根据 MDN 上对<code>Array.sort()</code>的解释，默认的排序方法会将数组元素转换为字符串，然后比较字符串中字符的 UTF-16 编码顺序来进行排序。所以<code>&#39;102&#39;</code> 会排在 <code>&#39;15&#39;</code> 前面。以下是 MDN 中的解释原文：</p>
<blockquote>
<p>The sort() method sorts the elements of an array in place and returns the array. The default sort order is built upon converting the elements into strings, then comparing their sequences of UTF-16 code units values.</p>
</blockquote>
<h3 id="第-44-题-（2019-10-26）"><a href="#第-44-题-（2019-10-26）" class="headerlink" title="第 44 题 （2019/10/26）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/70">第 44 题 </a>（2019/10/26）</h3><p><strong>题目：</strong> 介绍 HTTPS 握手过程</p>
<p><strong>解析：</strong> ~~</p>
<h3 id="第-45-题-（2019-10-26）"><a href="#第-45-题-（2019-10-26）" class="headerlink" title="第 45 题  （2019/10/26）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/74">第 45 题 </a> （2019/10/26）</h3><p><strong>题目：</strong> HTTPS 握手过程中，客户端如何验证证书的合法性</p>
<p><strong>解析：</strong> ~~</p>
<h3 id="第-46-题-（2019-10-26）"><a href="#第-46-题-（2019-10-26）" class="headerlink" title="第 46 题  （2019/10/26）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/76">第 46 题 </a> （2019/10/26）</h3><p><strong>题目：</strong> 输出以下代码执行的结果并解释为什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="number">4</span>,</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">  splice: <span class="built_in">Array</span>.prototype.splice,</span><br><span class="line">  push: <span class="built_in">Array</span>.prototype.push,</span><br><span class="line">&#125;;</span><br><span class="line">obj.push(<span class="number">1</span>);</span><br><span class="line">obj.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">    Object(4) [empty × 2, 1, 2, splice: ƒ, push: ƒ]</span></span><br><span class="line"><span class="comment">    2: 1</span></span><br><span class="line"><span class="comment">    3: 2</span></span><br><span class="line"><span class="comment">    length: 4</span></span><br><span class="line"><span class="comment">    push: ƒ push()</span></span><br><span class="line"><span class="comment">    splice: ƒ splice()</span></span><br><span class="line"><span class="comment">    __proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>我的理解是这样的<br>1: call push 这个方法如果对象有 length 属性，length 属性会加 1 并且返回，这个是在某本书的上看到的，一直记得。<br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push#Description">MDN</a></p>
<blockquote>
<p>push 方法将值追加到数组中。</p>
<p>push 方法有意具有通用性。该方法和 call() 或 apply() 一起使用时，可应用在类似数组的对象上。push 方法根据 length 属性来决定从哪里开始插入给定的值。如果 length 不能被转成一个数值，则插入的元素索引为 0，包括 length 不存在时。当 length 不存在时，将会创建它。</p>
<p>唯一的原生类数组（array-like）对象是 Strings，尽管如此，它们并不适用该方法，因为字符串是不可改变的。</p>
</blockquote>
<ol>
<li>调用 push 方法的时候会在调用对象的 key=length 的地方做一个赋值，不管前面 key 有没有值，也就是说在调用 push 的时候 对象实际被理解为了[0:undefined,1:undefined,2:3,3:4],<br>这样也就有了结果里面的<br>key===2 value =1<br>key===3 value =2 3.额外的<br>这个对象如果有 push 和 splice 会输出会转换为数组，下图为去掉 splice</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/11674767/55370329-b8459280-552c-11e9-96ec-0924b03f70a4.png"></p>
<p>包含 splice 方法</p>
<p><img src="https://user-images.githubusercontent.com/11674767/55370427-065a9600-552d-11e9-9525-236038e73009.png"></p>
<h3 id="第-47-题-（2019-10-27）"><a href="#第-47-题-（2019-10-27）" class="headerlink" title="第 47 题  （2019/10/27）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/81">第 47 题 </a> （2019/10/27）</h3><p><strong>题目：</strong> 双向绑定和 vuex 是否冲突</p>
<p><strong>解析：</strong></p>
<p>在严格模式下直接使用确实会有问题。<br>解决方案：</p>
<blockquote>
<p>官网说的比较详细<br><a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh/guide/forms.html">https://vuex.vuejs.org/zh/guide/forms.html</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;message&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    message: &#123;</span><br><span class="line">        set (value) &#123;</span><br><span class="line">            <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;updateMessage&#x27;</span>, value);</span><br><span class="line">        &#125;,</span><br><span class="line">        get () &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.obj.message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mutations: &#123;</span><br><span class="line">    UPDATE_MESSAGE (state, v) &#123;</span><br><span class="line">        state.obj.message = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">actions: &#123;</span><br><span class="line">    update_message (&#123; commit &#125;, v) &#123;</span><br><span class="line">        commit(<span class="string">&#x27;UPDATE_MESSAGE&#x27;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-48-题-（2019-10-27）"><a href="#第-48-题-（2019-10-27）" class="headerlink" title="第 48 题 （2019/10/27）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/84">第 48 题</a> （2019/10/27）</h3><p><strong>题目：</strong> call 和 apply 的区别是什么，哪个性能更好一些</p>
<p><strong>解析：</strong></p>
<blockquote>
<p><code>**call()**</code> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p>
<p><strong>apply()</strong> 方法调用一个具有给定<code>this</code>值的函数，以及作为一个数组（或<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects">类似数组对象</a>）提供的参数。</p>
</blockquote>
<ol>
<li>Function.prototype.apply 和 Function.prototype.call 的作用是一样的，区别在于传入参数的不同；</li>
<li>第一个参数都是，指定函数体内 this 的指向；</li>
<li>第二个参数开始不同，apply 是传入<strong>带下标的集合</strong>，数组或者类数组，apply 把它传给函数作为参数，call 从第二个开始<strong>传入的参数是不固定的，都会传给函数作为参数</strong>。</li>
<li>call 比 apply 的性能要好，平常可以多用 call, call 传入参数的格式正是内部所需要的格式，参考<a target="_blank" rel="noopener" href="https://github.com/noneven/__/issues/6">call 和 apply 的性能对比</a></li>
</ol>
<h3 id="第-49-题-（2019-10-27）"><a href="#第-49-题-（2019-10-27）" class="headerlink" title="第 49 题  （2019/10/27）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/87">第 49 题 </a> （2019/10/27）</h3><p><strong>题目：</strong> 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/36411025">数据埋点是什么？设置埋点的意义是什么？</a></p>
<blockquote>
<p><strong>1. 埋点是什么？</strong></p>
<p>所谓“埋点”，是 <strong>数据采集领域</strong>（尤其是用户行为数据采集领域）的术语，指的是针对特定用户行为或事件进行捕获、处理和发送的相关技术及其实施过程。比如用户某个 icon 点击次数、观看某个视频的时长等等。</p>
<p>埋点的技术实质，是先监听软件应用运行过程中的事件，当需要关注的事件发生时进行判断和捕获。</p>
<p>特别注意需要明确事件发生时间点、判别条件，这里如果遇到不清楚的，需要和开发沟通清楚，避免采集数据与理想存在差异。例如：期望采集某个 app 的某个广告的有效曝光数，有效曝光的判别条件是停留时长超过 1 秒且有效加载出广告内容。</p>
<p><strong>解答：</strong></p>
</blockquote>
<p>作用：工作中，用于前端监控，比如曝光等等，谷歌和百度的都是用的 1x1 像素的透明 gif 图片；<br>why?</p>
<ol>
<li>没有跨域问题，一般这种上报数据，代码要写通用的；（排除 ajax）</li>
<li>不会阻塞页面加载，影响用户的体验，只要 new Image 对象就好了；（排除 JS/CSS 文件资源方式上报）</li>
<li>在所有图片中，体积最小；（比较 PNG/JPG）</li>
</ol>
<h3 id="第-50-题-（2019-10-28）"><a href="#第-50-题-（2019-10-28）" class="headerlink" title="第 50 题 （2019/10/28）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/88">第 50 题 </a>（2019/10/28）</h3><p><strong>题目：</strong> 实现 (5).add(3).minus(2) 功能。</p>
<blockquote>
<p>例： 5 + 3 - 2，结果为 6</p>
</blockquote>
<p><strong>公司</strong>：百度</p>
<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() + num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.prototype.minus = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() - num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">5</span>).add(<span class="number">3</span>).minus(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h3 id="第-51-题-（2019-10-28）"><a href="#第-51-题-（2019-10-28）" class="headerlink" title="第 51 题 （2019/10/28）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/90">第 51 题</a> （2019/10/28）</h3><p><strong>题目：</strong> Vue 的响应式原理中 Object.defineProperty 有什么缺陷？</p>
<blockquote>
<p>为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？</p>
</blockquote>
<p><strong>解析：</strong> 不懂<del>~</del></p>
<h3 id="第-52-题-（2019-10-28）"><a href="#第-52-题-（2019-10-28）" class="headerlink" title="第 52 题 （2019/10/28）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/92">第 52 题</a> （2019/10/28）</h3><p><strong>题目：</strong> 怎么让一个 div 水平垂直居中</p>
<p><strong>解析：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>1、利用 flex</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、绝对定位</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 或 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、网格布局</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">justify-self</span>: center;</span><br><span class="line">  <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  &amp;::before &#123;</span><br><span class="line">    <span class="selector-tag">content</span>: &quot;&quot;;</span><br><span class="line">    <span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br><span class="line">    <span class="selector-tag">width</span>: 0;</span><br><span class="line">    <span class="selector-tag">height</span>: 100%;</span><br><span class="line">    <span class="selector-tag">vertical-align</span>: <span class="selector-tag">middle</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、补充</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: table-cell</span><br><span class="line">vertical-align: middle;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-53-题-（2019-10-29）"><a href="#第-53-题-（2019-10-29）" class="headerlink" title="第 53 题 （2019/10/29）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/93">第 53 题</a> （2019/10/29）</h3><p><strong>题目：</strong> 输出以下代码的执行结果并解释为什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x = a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b.x); <span class="comment">//&#123; n: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//&#123; n: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//&#123; n: 1, x: &#123; n: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先，a和b同时引用了&#123;n:2&#125;对象，接着执行到a.x &#x3D; a &#x3D; &#123;n：2&#125;语句，尽管赋值是从右到左的没错，但是.的优先级比&#x3D;要高，所以这里首先执行a.x，相当于为a（或者b）所指向的&#123;n:1&#125;对象新增了一个属性x，即此时对象将变为&#123;n:1;x:undefined&#125;。之后按正常情况，从右到左进行赋值，此时执行a &#x3D;&#123;n:2&#125;的时候，a的引用改变，指向了新对象&#123;n：2&#125;,而b依然指向的是旧对象。之后执行a.x &#x3D; &#123;n：2&#125;的时候，并不会重新解析一遍a，而是沿用最初解析a.x时候的a，也即旧对象，故此时旧对象的x的值为&#123;n：2&#125;，旧对象为 &#123;n:1;x:&#123;n：2&#125;&#125;，它被b引用着。</span><br><span class="line">后面输出a.x的时候，又要解析a了，此时的a是指向新对象的a，而这个新对象是没有x属性的，故访问时输出undefined；而访问b.x的时候，将输出旧对象的x的值，即&#123;n:2&#125;。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-54-题-（2019-10-29）"><a href="#第-54-题-（2019-10-29）" class="headerlink" title="第 54 题  （2019/10/29）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/94">第 54 题 </a> （2019/10/29）</h3><p><strong>题目：</strong> 冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？</p>
<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BubbleSort</span>(<span class="params">nums, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j + <span class="number">1</span>] &lt; nums[j]) &#123;</span><br><span class="line">        [nums[j], nums[j + <span class="number">1</span>]] = [nums[j + <span class="number">1</span>], nums[j]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>性质：</p>
<p>1、时间复杂度：O(n^2)</p>
<p>2、空间复杂度：O(1)</p>
<p>3、稳定排序</p>
<p>4、原地排序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改进冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort1</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        pos = j;</span><br><span class="line">        <span class="keyword">const</span> temp = arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i = pos;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-55-题-（2019-10-30）"><a href="#第-55-题-（2019-10-30）" class="headerlink" title="第 55 题 （2019/10/30）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/96">第 55 题</a> （2019/10/30）</h3><p><strong>题目：</strong> 某公司 1 到 12 月份的销售额存在一个对象里面</p>
<blockquote>
<p>如下：{1:222, 2:123, 5:888}，请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null]。</p>
</blockquote>
<blockquote>
<p><code>**Array.from()**</code> 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="number">1</span>: <span class="number">222</span>, <span class="number">2</span>: <span class="number">123</span>, <span class="number">5</span>: <span class="number">888</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.length = <span class="number">13</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(obj).slice(<span class="number">1</span>).map(item = &gt; &#123;</span><br><span class="line">        <span class="keyword">return</span>  item === <span class="literal">undefined</span> ? <span class="literal">null</span> : item</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f(obj))</span><br><span class="line"><span class="comment">//[ 222, 123, null, null, 888, null, null, null, null, null, null, null ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-56-题-（2019-10-30）"><a href="#第-56-题-（2019-10-30）" class="headerlink" title="第 56 题 （2019/10/30）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/98">第 56 题</a> （2019/10/30）</h3><p><strong>题目：</strong> 要求设计 LazyMan 类，实现以下功能。</p>
<p><strong>考点</strong>：数据结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LazyMan(<span class="string">&quot;Tony&quot;</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"></span><br><span class="line">LazyMan(<span class="string">&quot;Tony&quot;</span>).sleep(<span class="number">10</span>).eat(<span class="string">&quot;lunch&quot;</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"><span class="comment">// 等待了10秒...</span></span><br><span class="line"><span class="comment">// I am eating lunch</span></span><br><span class="line"></span><br><span class="line">LazyMan(<span class="string">&quot;Tony&quot;</span>).eat(<span class="string">&quot;lunch&quot;</span>).sleep(<span class="number">10</span>).eat(<span class="string">&quot;dinner&quot;</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"><span class="comment">// I am eating lunch</span></span><br><span class="line"><span class="comment">// 等待了10秒...</span></span><br><span class="line"><span class="comment">// I am eating diner</span></span><br><span class="line"></span><br><span class="line">LazyMan(<span class="string">&quot;Tony&quot;</span>)</span><br><span class="line">  .eat(<span class="string">&quot;lunch&quot;</span>)</span><br><span class="line">  .eat(<span class="string">&quot;dinner&quot;</span>)</span><br><span class="line">  .sleepFirst(<span class="number">5</span>)</span><br><span class="line">  .sleep(<span class="number">10</span>)</span><br><span class="line">  .eat(<span class="string">&quot;junk food&quot;</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"><span class="comment">// 等待了5秒...</span></span><br><span class="line"><span class="comment">// I am eating lunch</span></span><br><span class="line"><span class="comment">// I am eating dinner</span></span><br><span class="line"><span class="comment">// 等待了10秒...</span></span><br><span class="line"><span class="comment">// I am eating junk food</span></span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong> <del>~</del></p>
<h3 id="第-57-题（2019-10-31）"><a href="#第-57-题（2019-10-31）" class="headerlink" title="第 57 题（2019/10/31）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/100">第 57 题</a>（2019/10/31）</h3><p><strong>题目：</strong> 分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。</p>
<p><strong>解析：</strong></p>
<blockquote>
<p>总结一下：</p>
</blockquote>
<p><strong>结构:</strong><br>display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击，<br>visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击<br>opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击</p>
<p><strong>继承：</strong><br>display: none 和 opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。<br>visibility: hidden：是继承属性，子孙节点消失由于继承了 hidden，通过设置 visibility: visible;可以让子孙节点显式。</p>
<p><strong>性能：</strong><br>displaynone : 修改元素会造成文档回流,读屏器不会读取 display: none 元素内容，性能消耗较大<br>visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取 visibility: hidden 元素内容<br>opacity: 0 ： 修改元素会造成重绘，性能消耗较少</p>
<p><strong>联系</strong> ：它们都能让元素不可见</p>
<h3 id="第-58-题（2019-10-31）"><a href="#第-58-题（2019-10-31）" class="headerlink" title="第 58 题（2019/10/31）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/101">第 58 题</a>（2019/10/31）</h3><p><strong>题目：</strong> 第 58 题：箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？</p>
<p><strong>解析：</strong></p>
<blockquote>
<p>引入箭头函数有两个方面的作用：更简短的函数并且不绑定 this</p>
</blockquote>
<p>箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：</p>
<ol>
<li>箭头函数<strong>没有 this</strong>，它会从自己的<strong>作用域链</strong>的上一层继承 this（因此无法使用 apply / call / bind 进行绑定 this 值）；</li>
<li>不可以使用 <strong>arguments 对象</strong>，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>不可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield">yield 命令</a>，因此箭头函数不能用作 Generator 函数。</li>
<li>无法使用 <strong>new 实例化对象</strong>，因为普通构造函数通过 new 实例化对象时 this 指向实例对象，而箭头函数没有 this 值，同时 箭头函数也没有 prototype。</li>
</ol>
<p>new 过程大致是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFunc</span>(<span class="params">father, ...rest</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">  result.__proto__ = father.prototype;</span><br><span class="line">  <span class="keyword">var</span> result2 = father.apply(result, rest);</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (<span class="keyword">typeof</span> result2 === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result2 === <span class="string">&quot;function&quot;</span>) &amp;&amp;</span><br><span class="line">    result2 !== <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> result2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-59-题-（2019-10-31）"><a href="#第-59-题-（2019-10-31）" class="headerlink" title="第 59 题 （2019/10/31）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/102">第 59 题</a> （2019/10/31）</h3><p><strong>题目：</strong> 给定两个数组，写一个方法来计算它们的交集。</p>
<blockquote>
<p>例如：给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">  nums2 = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="comment">// 有个问题， [NaN].indexOf(NaN) === -1</span></span><br><span class="line"><span class="keyword">var</span> newArr1 = nums1.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nums2.indexOf(item) &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">var</span> newArr2 = nums1.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> nums2.includes(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="第-60-题-（2019-10-31）"><a href="#第-60-题-（2019-10-31）" class="headerlink" title="第 60 题 （2019/10/31）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/105">第 60 题</a> （2019/10/31）</h3><p><strong>题目：</strong> 已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。</p>
<blockquote>
<p>&lt;img src=”1.jpg” style=”width:480px!important;”&gt;</p>
</blockquote>
<p><strong>解决方案：</strong></p>
<ol>
<li><code>max-width: 300px</code></li>
<li><code>transform: scale(0.625,0.625) </code></li>
<li><code>zoom: 0.625</code>; <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@viewport/zoom">MDN：zoom</a></li>
<li>解法：</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br><span class="line"><span class="selector-tag">padding</span>: 0 90<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>js：<code>document.getElementsByTagName(&#39;img&#39;)[0].style.width=&#39;300px&#39;</code></li>
</ol>
<h3 id="第-61-题-（2019-11-01）"><a href="#第-61-题-（2019-11-01）" class="headerlink" title="第 61 题 （2019/11/01）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/106">第 61 题</a> （2019/11/01）</h3><p><strong>题目：</strong> 介绍下如何实现 token 加密 ?</p>
<p><strong>解析：</strong></p>
<blockquote>
<p>这个题目是问：生成 token 的方法，比如 <strong>JWT</strong>，还是说利用加密算法，比如对称加密或者非对称加密 加密生成后的 token ?</p>
</blockquote>
<p>这边也是这么做的，后端根据 token 来查权限和是否登录以及失效等</p>
<blockquote>
<p>token 加密方式：</p>
<ul>
<li>服务器通过私钥对一部分信息进行加密生成签名，并将签名和数据拼接在一起作为 token 的一部分。例如 JWT。</li>
<li>使用客户端的 UA 或其他数据作为干扰码对 token 进行加密。</li>
</ul>
</blockquote>
<p>相关参考文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e0ac7c3067eb">Token - 服务端身份验证的流行方案</a></li>
<li><a target="_blank" rel="noopener" href="https://ninghao.net/blog/2834">基于 Token 的身份验证：JSON Web Token</a></li>
</ul>
<blockquote>
<p>jwt 举例</p>
<ol>
<li>需要一个 secret（随机数）</li>
<li>后端利用 secret 和加密算法(如：HMAC-SHA256)对 payload(如账号密码)生成一个字符串(token)，返回前端</li>
<li>前端每次 request 在 header 中带上 token</li>
<li>后端用同样的算法解密</li>
</ol>
</blockquote>
<p>这边也是这么做的，后端根据 token 来查权限和是否登录以及失效等</p>
<h3 id="第-62-题-（2019-11-01）"><a href="#第-62-题-（2019-11-01）" class="headerlink" title="第 62 题  （2019/11/01）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/107">第 62 题 </a> （2019/11/01）</h3><p><strong>题目：</strong> redux 为什么要把 reducer 设计成纯函数</p>
<p><strong>解析：</strong> 学习 react ~~</p>
<h3 id="第-63-题（2019-11-02）"><a href="#第-63-题（2019-11-02）" class="headerlink" title="第 63 题（2019/11/02）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/108">第 63 题</a>（2019/11/02）</h3><p><strong>题目：</strong> 如何设计实现无缝轮播如何设计实现无缝轮播</p>
<p><strong>解析：</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">无限轮播基本插件都可以做到,不过要使用原生代码实现无缝滚动的话我可以提点思路,</span><br><span class="line">因为轮播图基本都在ul盒子里面的li元素,</span><br><span class="line">首先获取第一个li元素和最后一个li元素,</span><br><span class="line">克隆第一个li元素,和最后一个li元素,</span><br><span class="line">分别插入到lastli的后面和firstli的前面,</span><br><span class="line">然后监听滚动事件,如果滑动距离超过x或-x,让其实现跳转下一张图或者跳转上一张,(此处最好设置滑动距离),</span><br><span class="line">然后在滑动最后一张实现最后一张和克隆第一张的无缝转换,当到克隆的第一张的时候停下的时候,,让其切入真的第一张,则实现无线滑动,向前滑动同理</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-64-题（2019-11-02）"><a href="#第-64-题（2019-11-02）" class="headerlink" title="第 64 题（2019/11/02）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/109">第 64 题</a>（2019/11/02）</h3><p><strong>题目：</strong>模拟实现一个 Promise.finally</p>
<p><strong>知识点</strong> ：异步</p>
<p><strong>解析：</strong></p>
<h3 id="第-65-题-（2019-11-02）"><a href="#第-65-题-（2019-11-02）" class="headerlink" title="第 65 题 （2019/11/02）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/111">第 65 题</a> （2019/11/02）</h3><p><strong>题目：</strong> <code>a.b.c.d</code> 和 <code>a[&#39;b&#39;][&#39;c&#39;][&#39;d&#39;]</code>，哪个性能更高？</p>
<p><strong>解析：</strong></p>
<p>应该是 <code>a.b.c.d</code> 比 <code>a[&#39;b&#39;][&#39;c&#39;][&#39;d&#39;]</code> 性能高点，后者还要考虑 <code>[ ]</code> 中是变量的情况，再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点。<br>下图是两者的 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016231512">AST</a> (抽象语法树) 对比：</p>
<p><img src="https://user-images.githubusercontent.com/9009389/56872978-501d9a00-6a61-11e9-9e69-85ff00c031fc.png"></p>
<h3 id="第-66-题-（2019-11-02）"><a href="#第-66-题-（2019-11-02）" class="headerlink" title="第 66 题 （2019/11/02）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/112">第 66 题</a> （2019/11/02）</h3><p><strong>题目：</strong> ES6 代码转成 ES5 代码的实现思路是什么</p>
<p><strong>解析：</strong></p>
<p>回到正题上来，说到 ES6 代码转成 ES5 代码，我们肯定会想到 Babel。所以，我们可以参考 Babel 的实现方式。</p>
<p>那么 Babel 是如何把 ES6 转成 ES5 呢，其大致分为三步：</p>
<ul>
<li>将代码字符串解析成抽象语法树，即所谓的 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016231512">AST</a></li>
<li>对 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016231512">AST</a> 进行处理，在这个阶段可以对 ES6 代码进行相应转换，即转成 ES5 代码</li>
<li>根据处理后的 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016231512">AST</a> 再生成代码字符串</li>
</ul>
<p>基于此，其实我们自己就可以实现一个简单的“编译器”，用于把 ES6 代码转成 ES5。</p>
<p>比如，可以使用 <code>@babel/parser</code> 的 <code>parse</code> 方法，将代码字符串解析成 AST；使用 <code>@babel/core</code> 的 <code>transformFromAstSync</code> 方法，对 AST 进行处理，将其转成 ES5 并生成相应的代码字符串；过程中，可能还需要使用 <code>@babel/traverse</code> 来获取依赖文件等。对此感兴趣的可以看看<a target="_blank" rel="noopener" href="https://github.com/FishPlusOrange/easy-webpack">这个</a>。</p>
<h3 id="第-67-题-（2019-11-03）"><a href="#第-67-题-（2019-11-03）" class="headerlink" title="第 67 题 （2019/11/03）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/113">第 67 题</a> （2019/11/03）</h3><p><strong>题目：</strong> 数组编程题</p>
<blockquote>
<p>随机生成一个长度为 10 的整数类型的数组，例如 <code>[2, 10, 3, 4, 5, 11, 10, 11, 20]</code>，将其排列成一个新数组，要求新数组形式如下，例如 <code>[[2, 3, 4, 5], [10, 11], [20]]</code>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	我理解是：去重排序数组后，分类连续数列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> initArr = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getRandomIntInclusive(<span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个两数之间的随机整数，包括两个数在内</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomIntInclusive</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  min = <span class="built_in">Math</span>.ceil(min);</span><br><span class="line">  max = <span class="built_in">Math</span>.floor(max);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min; <span class="comment">//含最大值，含最小值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newarr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">var</span> pre = <span class="number">0</span>,</span><br><span class="line">    cur = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> xarr = [newarr[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">var</span> Finllyarr = [];</span><br><span class="line">  <span class="keyword">while</span> (cur &lt;= newarr.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newarr[cur] - newarr[pre] === count) &#123;</span><br><span class="line">      xarr.push(newarr[cur]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pre = cur;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">      Finllyarr.push(xarr);</span><br><span class="line">      xarr = [newarr[pre]];</span><br><span class="line">    &#125;</span><br><span class="line">    cur++;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Finllyarr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(GetArr(initArr));</span><br></pre></td></tr></table></figure>

<h3 id="第-68-题-（2019-11-04）"><a href="#第-68-题-（2019-11-04）" class="headerlink" title="第 68 题 （2019/11/04）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/115">第 68 题</a> （2019/11/04）</h3><p><strong>题目：</strong> 如何解决移动端 Retina 屏 1px 像素问题</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://juejin.im/entry/584e427361ff4b006cd22c7c">7 种方法解决移动端 Retina 屏幕 1px 边框问题</a></p>
<ol>
<li>0.5px 边框</li>
<li>使用 border-image 实现</li>
<li>使用 background-image 实现</li>
<li>多背景渐变实现</li>
<li>使用 box-shadow 模拟边框</li>
<li>viewport + rem 实现</li>
<li>伪类 + transform 实现</li>
</ol>
<h3 id="第-69-题-（2019-11-07）"><a href="#第-69-题-（2019-11-07）" class="headerlink" title="第 69 题 （2019/11/07）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/116">第 69 题</a> （2019/11/07）</h3><p><strong>题目：</strong> 如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC’ 变成 ‘aBc’ 。</p>
<p>解析</p>
<ol>
<li>利用 ASCII 码 （A: 65 ，Z：90，a：97，z：122）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Getstr</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">    .split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.charCodeAt() &lt;= <span class="number">90</span> &amp;&amp; item.charCodeAt() &gt;= <span class="number">65</span>)</span><br><span class="line">        <span class="keyword">return</span> item.toLowerCase();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> item.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用 小技巧</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Getstr</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">    .split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item === item.toUpperCase()</span><br><span class="line">        ? item.toLowerCase()</span><br><span class="line">        : item.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-70-题-（2019-11-08）"><a href="#第-70-题-（2019-11-08）" class="headerlink" title="第 70 题 （2019/11/08）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/118">第 70 题</a> （2019/11/08）</h3><p><strong>题目：</strong> 介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的</p>
<p><strong>解析：</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.当修改了一个或多个文件；</span><br><span class="line">2.文件系统接收更改并通知webpack；</span><br><span class="line">3.webpack重新编译构建一个或多个模块，并通知HMR服务器进行更新；</span><br><span class="line">4.HMR Server 使用webSocket通知HMR runtime 需要更新，HMR运行时通过HTTP请求更新jsonp；</span><br><span class="line">5.HMR运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-71-题-（2019-11-14）"><a href="#第-71-题-（2019-11-14）" class="headerlink" title="第 71 题 （2019/11/14）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/119">第 71 题</a> （2019/11/14）</h3><p><strong>题目：</strong> 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。</p>
<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为 T 的 length 是一定的，所以在循环S的的时候 ，循环当前项 i 后面至少还有 T.length 个元素</span></span><br><span class="line"><span class="keyword">const</span> find = <span class="function">(<span class="params">S, T</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (S.length &lt; T.length) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; S.length - T.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (S.substr(i, T.length) === T) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：</span></span><br><span class="line"><span class="keyword">const</span> find = <span class="function">(<span class="params">S, T</span>) =&gt;</span> S.search(T);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：</span></span><br><span class="line"><span class="keyword">const</span> find = <span class="function">(<span class="params">S, T</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> matched = S.match(T);</span><br><span class="line">  <span class="keyword">return</span> matched ? matched.index : <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第-72-题-（2019-11-15）"><a href="#第-72-题-（2019-11-15）" class="headerlink" title="第 72 题 （2019/11/15）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/121">第 72 题</a> （2019/11/15）</h3><p><strong>题目：</strong>为什么普通 <code>for</code> 循环的性能远远高于 <code>forEach</code> 的性能，请解释其中的原因。</p>
<p><strong>解析：</strong></p>
<ul>
<li>for 循环没有任何额外的函数调用栈和上下文；</li>
<li>forEach 函数签名实际上是</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>它不是普通的 for 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能；</p>
<h3 id="第-73-题-（2019-11-15）"><a href="#第-73-题-（2019-11-15）" class="headerlink" title="第 73 题 （2019/11/15）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/122">第 73 题</a> （2019/11/15）</h3><p><strong>题目：</strong> 介绍下 BFC、IFC、GFC 和 FFC</p>
<p><strong>解析：</strong></p>
<p><strong>BFC（Block formatting contexts）：块级格式上下文</strong><br>页面上的一个隔离的渲染区域，那么他是如何产生的呢？可以触发 BFC 的元素有 float、position、overflow、display：table-cell/ inline-block/table-caption ；BFC 有什么作用呢？比如说实现多栏布局’</p>
<p><strong>IFC（Inline formatting contexts）：内联格式上下文</strong><br>IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding/margin 影响)IFC 中的 line box 一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与与 line box 之间，使得 line box 宽度缩短。 同个 ifc 下的多个 line box 高度会不同<br>IFC 中时不可能有块级元素的，当插入块级元素时（如 p 中插入 div）会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。<br>那么 IFC 一般有什么用呢？<br>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。<br>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</p>
<p><strong>GFC（GrideLayout formatting contexts）：网格布局格式化上下文</strong><br>当为一个元素设置 display 值为 grid 的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。那么 GFC 有什么用呢，和 table 又有什么区别呢？首先同样是一个二维的表格，但 GridLayout 会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。</p>
<p><strong>FFC（Flex formatting contexts）:自适应格式上下文</strong><br>display 值为 flex 或者 inline-flex 的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少 safari 和 chrome 还是 OK 的，毕竟这俩在移动端才是王道。Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/dingyufenglian/p/4845477.html">在这</a></p>
<h3 id="第-74-题-（2019-11-16）"><a href="#第-74-题-（2019-11-16）" class="headerlink" title="第 74 题  （2019/11/16）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/123">第 74 题 </a> （2019/11/16）</h3><p><strong>题目：</strong> 使用 JavaScript Proxy 实现简单的数据绑定</p>
<p><strong>解析：</strong> ~~</p>
<h3 id="第-75-题-（2019-11-17）"><a href="#第-75-题-（2019-11-17）" class="headerlink" title="第 75 题 （2019/11/17）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/124">第 75 题</a> （2019/11/17）</h3><p><strong>题目：</strong> 数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少</p>
<p><strong>解析：</strong></p>
<p><strong>考点：</strong> <u>JavaScript 数组底层原理</u></p>
<p>数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)</p>
<p>得出结论：<strong>消耗时间几乎一致，差异可以忽略不计</strong></p>
<blockquote>
<p>Chrome 浏览器 JS 引擎 V8 中，数组有两种存储模式，一种是类似 C 语言中的线性结构存储（索引值连续，且都是正整数的情况下），一种是采用 Hash 结构存储（索引值为负数，数组稀疏，间隔比较大）；</p>
</blockquote>
<p>JavaScript 没有真正意义上的数组，所有的数组其实是对象，其“索引”看起来是数字，其实会被转换成字符串，作为属性名（对象的 key）来使用。所以无论是取第 1 个还是取第 10 万个元素，都是用 key 精确查找哈希表的过程，其消耗时间大致相同。</p>
<blockquote>
<p>推荐一下这篇文章：<a target="_blank" rel="noopener" href="https://juejin.im/entry/59ae664d518825244d207196">深究 JavaScript 数组</a></p>
</blockquote>
<h3 id="第-76-题-（2019-11-17）"><a href="#第-76-题-（2019-11-17）" class="headerlink" title="第 76 题 （2019/11/17）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/125">第 76 题</a> （2019/11/17）</h3><blockquote>
<p>输出以下代码运行结果</p>
<p><strong>考点</strong> ：这题考察的是对象的键名的转换。</p>
<ul>
<li>对象的键名只能是字符串和 Symbol 类型。</li>
<li>其他类型的键名会被转换成字符串类型。</li>
<li>对象转字符串默认会调用 toString 方法。</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="string">&#x27;123&#x27;</span>, c=<span class="number">123</span>;</span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a[b]);  <span class="comment">//c</span></span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="built_in">Symbol</span>(<span class="string">&#x27;123&#x27;</span>), c=<span class="built_in">Symbol</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a[b]); <span class="comment">//b</span></span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">// example 3</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=&#123;<span class="attr">key</span>:<span class="string">&#x27;123&#x27;</span>&#125;, c=&#123;<span class="attr">key</span>:<span class="string">&#x27;456&#x27;</span>&#125;;</span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a[b]); <span class="comment">//c</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="string">&#x27;123&#x27;</span>, c=<span class="number">123</span>;</span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 的键名会被转换成字符串&#x27;123&#x27;，这里会把 b 覆盖掉。</span></span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 c</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="built_in">Symbol</span>(<span class="string">&#x27;123&#x27;</span>), c=<span class="built_in">Symbol</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b 是 Symbol 类型，不需要转换。</span></span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 是 Symbol 类型，不需要转换。任何一个 Symbol 类型的值都是不相等的，所以不会覆盖掉 b。</span></span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 b</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 3</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=&#123;<span class="attr">key</span>:<span class="string">&#x27;123&#x27;</span>&#125;, c=&#123;<span class="attr">key</span>:<span class="string">&#x27;456&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b 不是字符串也不是 Symbol 类型，需要转换成字符串。</span></span><br><span class="line"><span class="comment">// 对象类型会调用 toString 方法转换成字符串 [object Object]。</span></span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 不是字符串也不是 Symbol 类型，需要转换成字符串。</span></span><br><span class="line"><span class="comment">// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。</span></span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 c</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-77-题-（2019-11-18）"><a href="#第-77-题-（2019-11-18）" class="headerlink" title="第 77 题 （2019/11/18）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/126">第 77 题</a> （2019/11/18）</h3><p><strong>题目：</strong></p>
<blockquote>
<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] 和 k = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: [<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步: [<span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">向右旋转 <span class="number">3</span> 步: [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">-1</span>, <span class="number">-100</span>, <span class="number">3</span>, <span class="number">99</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出: [<span class="number">3</span>, <span class="number">99</span>, <span class="number">-1</span>, <span class="number">-100</span>]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: [<span class="number">99</span>, <span class="number">-1</span>, <span class="number">-100</span>, <span class="number">3</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步: [<span class="number">3</span>, <span class="number">99</span>, <span class="number">-1</span>, <span class="number">-100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rotateArr</span>(<span class="params">arr, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    arr.unshift(arr.pop());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-78-题-（2019-11-18）"><a href="#第-78-题-（2019-11-18）" class="headerlink" title="第 78 题  （2019/11/18）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/128">第 78 题 </a> （2019/11/18）</h3><p><strong>题目</strong> ：Vue 的父组件和子组件生命周期钩子执行顺序是什么</p>
<p><strong>解析：</strong></p>
<blockquote>
<p>总结：<u>从外到内，再从内到外</u></p>
</blockquote>
<ol>
<li>加载渲染过程<br><code>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</code></li>
<li>子组件更新过程<br><code>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</code></li>
<li>父组件更新过程<br><code>父beforeUpdate-&gt;父updated</code></li>
<li>销毁过程<br><code>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</code></li>
</ol>
<p><img src="https://segmentfault.com/img/bVbePUv?w=302&h=298"></p>
<h3 id="第-79-题-（2019-11-18）"><a href="#第-79-题-（2019-11-18）" class="headerlink" title="第 79 题 （2019/11/18）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/129">第 79 题</a> （2019/11/18）</h3><p><strong>题目：</strong> input 搜索如何防抖，如何处理中文输入</p>
<p><strong>解析：</strong> <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013094932">input 事件中文触发多次问题研究</a></p>
<p>简易防抖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-80-题-（2019-11-19）"><a href="#第-80-题-（2019-11-19）" class="headerlink" title="第 80 题 （2019/11/19）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/130">第 80 题</a> （2019/11/19）</h3><p><strong>题目：</strong> 介绍下 Promise.all 使用、原理实现及错误处理</p>
<h3 id="第-81-题-（2019-11-19）"><a href="#第-81-题-（2019-11-19）" class="headerlink" title="第 81 题 （2019/11/19）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/131">第 81 题</a> （2019/11/19）</h3><p><strong>题目：</strong> 打印出 1 - 10000 之间的所有对称数</p>
<blockquote>
<p>例如：121、1331 等</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num.toString() === num.toString().split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (f(i)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-82-题-（2019-11-19）"><a href="#第-82-题-（2019-11-19）" class="headerlink" title="第 82 题 （2019/11/19）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/132">第 82 题</a> （2019/11/19）</h3><blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">12</span>];</span><br><span class="line">输出: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<ol>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ol>
</blockquote>
<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Movezero</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] != <span class="number">0</span>) &#123;</span><br><span class="line">      arr[index++] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; arr.length) &#123;</span><br><span class="line">    arr[index++] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-83-题-（2019-11-20）"><a href="#第-83-题-（2019-11-20）" class="headerlink" title="第 83 题 （2019/11/20）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/133">第 83 题</a> （2019/11/20）</h3><p><strong>题目：</strong> var、let 和 const 区别的实现原理是什么</p>
<p><strong>解析：</strong></p>
<p><strong>区别：</strong></p>
<ol>
<li><p>var 声明的变量会挂载在 window 上，而 let 和 const 声明的变量不会</p>
</li>
<li><p>var 声明变量存在变量提升，let 和 const 不存在变量提升</p>
</li>
<li><p>let 和 const 声明形成块作用域，而 var 不存在此作用域</p>
</li>
<li><p>同一作用域下 let 和 const 不能声明同名变量，而 var 可以</p>
</li>
<li><p>let、const 存在暂存死区</p>
</li>
<li><p>const</p>
<ol>
<li>一旦声明必须赋值,不能使用 null 占位。</li>
<li>声明后不能再修改</li>
<li>如果声明的是复合类型数据，可以修改其属性*</li>
</ol>
</li>
</ol>
<p><strong>var、let、const 实现原理</strong></p>
<p>记得 JS 权威指南中有一句很精辟的描述:　”JavaScript 中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里.”</p>
<p>以下属于推测，在网上没查到确凿的原理机制（若有误望指正）：</p>
<p>原理大概是：在 js 解析的时候，优先解析 const，因为它不能修改的是栈内存在的值和地址。然后解析 let 因为没有块作用域可能底层有处理，最后解析 var</p>
<h3 id="第-84-题-（2019-11-21）"><a href="#第-84-题-（2019-11-21）" class="headerlink" title="第 84 题 （2019/11/21）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/134">第 84 题</a> （2019/11/21）</h3><p><strong>题目：</strong> 请实现一个 add 函数，满足以下功能。</p>
<p><strong>知识点</strong> ：函数柯里化 <a target="_blank" rel="noopener" href="https://github.com/chokcoco/cnblogsArticle/issues/15">题解</a> <u>运用了函数会自行调用 <code>valueOf</code> 方法这个技巧</u></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>); 			<span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);  	<span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)；<span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>之前参阅 2 篇文章，可以参考一二。<br>1、<a target="_blank" rel="noopener" href="https://github.com/yygmind/blog/issues/36#%E6%80%9D%E8%80%83%E9%A2%98">【进阶 6-1 期】JavaScript 高阶函数浅析</a><br>2、<a target="_blank" rel="noopener" href="https://github.com/yygmind/blog/issues/37">【进阶 6-2 期】深入高阶函数应用之柯里化</a></p>
<p>其中第一篇文章给出了前三个功能的实现，并没有覆盖到后面三种。<br>第二篇文章实现了一个通用的柯里化函数，覆盖实现了所有功能。</p>
<p><strong>解析：</strong></p>
<p><strong>去重</strong>（ <u>数字组数</u> ） ：使用高阶函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = arr1.filter(<span class="function">(<span class="params">element, index, self</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> self.indexOf(element) === index;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br><span class="line"><span class="comment">// [1, 2, 3, 5, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="comment">// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]</span></span><br></pre></td></tr></table></figure>

<p>函数作为返回值输出</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isType = <span class="function">(<span class="params">type</span>) =&gt;</span> <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">&quot;[object &quot;</span> + type + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">isType(<span class="string">&quot;String&quot;</span>)(<span class="string">&quot;123&quot;</span>); <span class="comment">// true</span></span><br><span class="line">isType(<span class="string">&quot;Array&quot;</span>)([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// true</span></span><br><span class="line">isType(<span class="string">&quot;Number&quot;</span>)(<span class="number">123</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;进入add&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arg_fn = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;调用fn&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> add.apply(<span class="literal">null</span>, args.concat(arg_fn));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  fn.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;调用valueOf&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    add(1);</span></span><br><span class="line"><span class="comment">    // 输出如下：</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用valueOf</span></span><br><span class="line"><span class="comment">    // 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    add(1)(2);</span></span><br><span class="line"><span class="comment">    // 输出如下：</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用fn</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用valueOf</span></span><br><span class="line"><span class="comment">    // 3</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    add(1)(2)(3);</span></span><br><span class="line"><span class="comment">    // 输出如下：</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用fn</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用fn</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用valueOf</span></span><br><span class="line"><span class="comment">    // 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里有个规律，如果只改写 <code>valueOf()</code> 或是 <code>toString()</code> 其中一个，会优先调用被改写了的方法，而如果两个同时改写，则会像 String 转换规则一样，优先查询 <code>valueOf()</code> 方法，在 <code>valueOf() </code>方法返回的是非原始类型的情况下再查询 <code>toString()</code> 方法。</p>
<h3 id="第-85-题-（2019-11-23）"><a href="#第-85-题-（2019-11-23）" class="headerlink" title="第 85 题 （2019/11/23）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/135">第 85 题</a> （2019/11/23）</h3><p><strong>题目：</strong> react-router 里的 <code>&lt;Link&gt;</code> 标签和 <code>&lt;a&gt;</code> 标签有什么区别</p>
<blockquote>
<p>如何禁掉 <code>&lt;a&gt;</code> 标签默认事件，禁掉之后如何实现跳转。</p>
</blockquote>
<p><strong>解析：</strong></p>
<p>从最终渲染的 DOM 来看，这两者都是链接，都是 <code>&lt;a&gt;</code> 标签，区别是：<br><code>&lt;Link&gt;</code> 是 react-router 里实现路由跳转的链接，一般配合 <code>&lt;Route&gt;</code> 使用，react-router 接管了其默认的链接跳转行为，区别于传统的页面跳转，<code>&lt;Link&gt;</code> 的“跳转”行为只会触发相匹配的 <code>&lt;Route&gt;</code> 对应的页面内容更新，而不会刷新整个页面。<br>而 <code>&lt;a&gt;</code> 标签就是普通的超链接了，用于从当前页面跳转到 href 指向的另一个页面（非锚点情况）。</p>
<h3 id="第-86-题-（2019-11-23）"><a href="#第-86-题-（2019-11-23）" class="headerlink" title="第 86 题 （2019/11/23）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/136">第 86 题</a> （2019/11/23）</h3><p><strong>题目：</strong> 周一算法题之「两数之和」</p>
<blockquote>
<p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p>
<p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>公司</strong> ：京东、快手</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Getarr</span>(<span class="params">num, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pre = <span class="number">0</span>,</span><br><span class="line">    cur = num.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (num.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;至少提供2个数字&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (pre &lt; cur) &#123;</span><br><span class="line">    result = num[pre] + num[cur];</span><br><span class="line">    <span class="keyword">if</span> (result &gt; target) &#123;</span><br><span class="line">      cur--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &lt; target) &#123;</span><br><span class="line">      pre++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> [pre, cur];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-87-题-（2019-11-24）"><a href="#第-87-题-（2019-11-24）" class="headerlink" title="第 87 题 （2019/11/24）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/138">第 87 题</a> （2019/11/24）</h3><p><strong>题目：</strong>在输入框中如何判断输入的是一个正确的网址。</p>
<p><strong>解析：</strong> <u>location 可以获取本页面的 URL 信息</u></p>
<blockquote>
<p>不上正则，一个简单的玩法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUrl</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">	a.href = url</span><br><span class="line">	<span class="keyword">return</span> [</span><br><span class="line">		/^(http|https):$/.test(a.protocol), <span class="comment">// &quot;https:&quot; 协议</span></span><br><span class="line">		a.host,  						<span class="comment">//  &quot;baidu.com&quot; =&gt; 端口（port）</span></span><br><span class="line">		a.pathname !== url,				<span class="comment">// &quot;/&quot;</span></span><br><span class="line">		a.pathname !== <span class="string">`/<span class="subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">	].find(<span class="function"><span class="params">x</span> =&gt;</span> !x) === <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用 <code>URL()</code> 构造函数返回一个新创建的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL"><code>URL</code></a> 对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUrl</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> URL(url);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isUrl = <span class="function">(<span class="params">urlStr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; href, origin, host, hostname, pathname &#125; = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">    <span class="keyword">return</span> href &amp;&amp; origin &amp;&amp; host &amp;&amp; hostname &amp;&amp; pathname &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>正则：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^(https?:\/\/)?([a-z0<span class="number">-9</span>]\.|[a-z0<span class="number">-9</span>][-a-z0<span class="number">-9</span>]*[a-z0<span class="number">-9</span>]\.)*([a-z]+)(:\d+)?(\/.*)?$/;</span><br></pre></td></tr></table></figure>

<h3 id="第-88-题-（2019-12-04）"><a href="#第-88-题-（2019-12-04）" class="headerlink" title="第 88 题 （2019/12/04）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/139">第 88 题</a> （2019/12/04）</h3><p>以下数据结构中，id 代表部门编号，name 是部门名称，parentId 是父部门编号，为 0 代表一级部门，现在要求实现一个 convert 方法，把原始 list 转换成树形结构，parentId 为多少就挂载在该 id 的属性 children 数组下，结构如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始 list 如下</span></span><br><span class="line"><span class="keyword">let</span> list =[</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">&#x27;部门A&#x27;</span>,<span class="attr">parentId</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">&#x27;部门B&#x27;</span>,<span class="attr">parentId</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:<span class="string">&#x27;部门C&#x27;</span>,<span class="attr">parentId</span>:<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">4</span>,<span class="attr">name</span>:<span class="string">&#x27;部门D&#x27;</span>,<span class="attr">parentId</span>:<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">5</span>,<span class="attr">name</span>:<span class="string">&#x27;部门E&#x27;</span>,<span class="attr">parentId</span>:<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">6</span>,<span class="attr">name</span>:<span class="string">&#x27;部门F&#x27;</span>,<span class="attr">parentId</span>:<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">7</span>,<span class="attr">name</span>:<span class="string">&#x27;部门G&#x27;</span>,<span class="attr">parentId</span>:<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">8</span>,<span class="attr">name</span>:<span class="string">&#x27;部门H&#x27;</span>,<span class="attr">parentId</span>:<span class="number">4</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> result = convert(list, ...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换后的结果如下</span></span><br><span class="line"><span class="keyword">let</span> result = [</span><br><span class="line">    &#123;</span><br><span class="line">      id: <span class="number">1</span>,</span><br><span class="line">      name: <span class="string">&#x27;部门A&#x27;</span>,</span><br><span class="line">      parentId: <span class="number">0</span>,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: <span class="number">3</span>,</span><br><span class="line">          name: <span class="string">&#x27;部门C&#x27;</span>,</span><br><span class="line">          parentId: <span class="number">1</span>,</span><br><span class="line">          children: [</span><br><span class="line">            &#123;</span><br><span class="line">              id: <span class="number">6</span>,</span><br><span class="line">              name: <span class="string">&#x27;部门F&#x27;</span>,</span><br><span class="line">              parentId: <span class="number">3</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">              id: <span class="number">16</span>,</span><br><span class="line">              name: <span class="string">&#x27;部门L&#x27;</span>,</span><br><span class="line">              parentId: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: <span class="number">4</span>,</span><br><span class="line">          name: <span class="string">&#x27;部门D&#x27;</span>,</span><br><span class="line">          parentId: <span class="number">1</span>,</span><br><span class="line">          children: [</span><br><span class="line">            &#123;</span><br><span class="line">              id: <span class="number">8</span>,</span><br><span class="line">              name: <span class="string">&#x27;部门H&#x27;</span>,</span><br><span class="line">              parentId: <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">  ···</span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong> ~~</p>
<h3 id="第-89-题-（2019-12-04）"><a href="#第-89-题-（2019-12-04）" class="headerlink" title="第 89 题 （2019/12/04）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/140">第 89 题</a> （2019/12/04）</h3><p><strong>题目</strong> ：设计并实现 Promise.race()</p>
<p><strong>解析：</strong> 代写~</p>
<h3 id="第-90-题-（2019-12-05）"><a href="#第-90-题-（2019-12-05）" class="headerlink" title="第 90 题 （2019/12/05）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/141">第 90 题</a> （2019/12/05）</h3><p><strong>题目：</strong> 实现模糊搜索结果的关键词高亮显示</p>
<p><img src="http://static.zxinc520.com/blog/20191205/sF0nw6wEI0qf.png?imageslim" alt="mark"></p>
<blockquote>
<p>考虑节流、缓存。其实还可以上列表 diff+定时清理缓存</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>auto complete<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      bdi &#123;</span><br><span class="line">        color: rgb(0, 136, 255);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      li &#123;</span><br><span class="line">        list-style: none;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;inp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, timeout = <span class="number">300</span></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> t;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span></span><br><span class="line">        if (t) &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">clearTimeout</span>(t);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        t = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line">          fn.apply(fn, args);</span><br><span class="line">        &#125;, timeout);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">fn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span></span><br><span class="line">        if (!name) &#123;</span><br><span class="line"><span class="javascript">          container.innerHTML = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        if (cache.get(name)) &#123;</span><br><span class="line">          container.innerHTML = cache.get(name);</span><br><span class="line"><span class="javascript">          <span class="keyword">return</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> res = fn.call(fn, name).join(<span class="string">&quot;&quot;</span>);</span></span><br><span class="line">        cache.set(name, res);</span><br><span class="line">        container.innerHTML = res;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">handleInput</span>(<span class="params">value</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`\(<span class="subst">$&#123;value&#125;</span>\)`</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> search = data.reduce(<span class="function">(<span class="params">res, cur</span>) =&gt;</span> &#123;</span></span><br><span class="line">        if (reg.test(cur)) &#123;</span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> match = <span class="built_in">RegExp</span>.$<span class="number">1</span>;</span></span><br><span class="line"><span class="handlebars"><span class="xml">          res.push(`<span class="tag">&lt;<span class="name">li</span>&gt;</span>$&#123;cur.replace(match, &quot;<span class="tag">&lt;<span class="name">bdi</span>&gt;</span>$&amp;<span class="tag">&lt;/<span class="name">bdi</span>&gt;</span>&quot;)&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>`);</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> res;</span></span><br><span class="line">      &#125;, []);</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> search;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> data = [</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;上海野生动物园&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;上饶野生动物园&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;北京巷子&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;上海中心&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;上海黄埔江&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;迪士尼上海&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;陆家嘴上海中心&quot;</span>,</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> container = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.container&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> memorizeInput = memorize(handleInput);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">&quot;.inp&quot;</span>).addEventListener(</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;input&quot;</span>,</span></span><br><span class="line"><span class="javascript">      debounce(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.target.value);</span></span><br><span class="line">        memorizeInput(e.target.value);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="第-91-题-（2019-12-05）"><a href="#第-91-题-（2019-12-05）" class="headerlink" title="第 91 题 （2019/12/05）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/142">第 91 题</a> （2019/12/05）</h3><p><strong>题目：</strong> 介绍下 HTTPS 中间人攻击</p>
<p><strong>解析：</strong></p>
<p>https 协议由 http + ssl 协议构成，具体的链接过程可参考<a target="_blank" rel="noopener" href="https://github.com/lvwxx/blog/issues/3">SSL 或 TLS 握手的概述</a></p>
<p>中间人攻击过程如下：</p>
<ol>
<li>服务器向客户端发送公钥。</li>
<li>攻击者截获公钥，保留在自己手上。</li>
<li>然后攻击者自己生成一个【伪造的】公钥，发给客户端。</li>
<li>客户端收到伪造的公钥后，生成加密 hash 值发给服务器。</li>
<li>攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥。</li>
<li>同时生成假的加密 hash 值，发给服务器。</li>
<li>服务器用私钥解密获得假秘钥。</li>
<li>服务器用加秘钥加密传输信息</li>
</ol>
<p>防范方法：</p>
<ol>
<li>服务端在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性</li>
</ol>
<h3 id="第-92-题-（2019-12-15）"><a href="#第-92-题-（2019-12-15）" class="headerlink" title="第 92 题 （2019/12/15）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/143">第 92 题</a> （2019/12/15）</h3><p><strong>题目：</strong>已知数据格式，实现一个函数 fn 找出链条中所有的父级 id</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="string">&#x27;112&#x27;</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">fn(value) <span class="comment">// 输出 [1， 11， 112]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="string">&quot;112&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">    arr.push(value.slice(<span class="number">0</span>, i + <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.map(<span class="built_in">Number</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第-93-题-（2019-12-15）"><a href="#第-93-题-（2019-12-15）" class="headerlink" title="第 93 题 （2019/12/15）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/144">第 93 题</a> （2019/12/15）</h3><p><strong>题目：</strong> 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log(m+n))。</p>
<p>示例 1：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line">nums2 = [<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>中位数是 2.0</p>
<p>示例 2：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">nums2 = [<span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>中位数是(2 + 3) / 2 = 2.5</p>
<p><strong>解析：</strong></p>
<h3 id="第-94-题-（2019-12-15）"><a href="#第-94-题-（2019-12-15）" class="headerlink" title="第 94 题 （2019/12/15）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/145">第 94 题</a> （2019/12/15）</h3><p><strong>题目：</strong> vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？</p>
<p><strong>解析:</strong></p>
<blockquote>
<p>Well, delegation has two main advantages: one is practical - it saves you from having to add (and remove!!) those listeners individually. But Vue already does that for you.</p>
<p>The other one is performance / memory. But since every click listener in a v-vor loop would use the same callback, this is minimal unless you have hundreds or thousands of rows.</p>
<p>And finally, you can use delegation pretty easily by adding an @click listener to the <ul> element instead of the children. But then you have to resort to checks on the click target to evaluate which item in your data it might represent. So I would only use that if you truly find any performance problems without delegation.</p>
</blockquote>
<p>好，委派有两个主要优点：一个是实用的-它使您不必分别添加（和删除！）这些侦听器。 但是 Vue 已经为您做到了。</p>
<p>另一个是性能/内存。 但是，由于 v-vor 循环中的每个单击侦听器都将使用相同的回调，因此除非您有成百上千的行，否则这是最小的。</p>
<p>最后，您可以通过在&lt;_ul_ &gt;元素（而不是子元素）中添加@click 侦听器来轻松使用委派。 但是随后，您必须求助于点击目标，以评估数据中可能代表的项目。 因此，只有在您真正发现任何性能问题而没有委派的情况下，我才使用它。</p>
<h3 id="第-95-题-（2019-12-23）"><a href="#第-95-题-（2019-12-23）" class="headerlink" title="第 95 题 （2019/12/23）"></a><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/148">第 95 题</a> （2019/12/23）</h3><p><strong>题目：</strong> 模拟实现一个深拷贝，并考虑对象相互引用以及 Symbol 拷贝的情况</p>
<p><strong>解析：</strong></p>
<blockquote>
<p>一个不考虑其他数据类型的公共方法，基本满足大部分场景</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">target, cache = new Set()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&quot;object&quot;</span> || cache.has(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target)) &#123;</span><br><span class="line">    target.map(<span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line">      cache.add(t);</span><br><span class="line">      <span class="keyword">return</span> t;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      ...Object.keys(target),</span><br><span class="line">      ...Object.getOwnPropertySymbols(target),</span><br><span class="line">    ].reduce(</span><br><span class="line">      (res, key) =&gt; &#123;</span><br><span class="line">        cache.add(target[key]);</span><br><span class="line">        res[key] = deepCopy(target[key], cache);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">      &#125;,</span><br><span class="line">      target.constructor !== <span class="built_in">Object</span></span><br><span class="line">        ? <span class="built_in">Object</span>.create(target.constructor.prototype)</span><br><span class="line">        : &#123;&#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要问题是</p>
<ol>
<li>symbol 作为 key，不会被遍历到，所以 stringify 和 parse 是不行的</li>
<li>有环引用，stringify 和 parse 也会报错</li>
</ol>
<p>我们另外用<code>getOwnPropertySymbols</code>可以获取 symbol key 可以解决问题 1，用集合记忆曾经遍历过的对象可以解决问题 2。当然，还有很多数据类型要独立去拷贝。比如拷贝一个 RegExp，lodash 是最全的数据类型拷贝了，有空可以研究一下</p>
<p>另外，如果不考虑用 symbol 做 key，还有两种黑科技深拷贝，可以解决环引用的问题，比 stringify 和 parse 优雅强一些</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopyByHistory</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prev = history.state;</span><br><span class="line">  history.replaceState(target, <span class="built_in">document</span>.title);</span><br><span class="line">  <span class="keyword">const</span> res = history.state;</span><br><span class="line">  history.replaceState(prev, <span class="built_in">document</span>.title);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">deepCopyByMessageChannel</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">    channel.port2.onmessage = <span class="function">(<span class="params">ev</span>) =&gt;</span> resolve(ev.data);</span><br><span class="line">    channel.port1.postMessage(target);</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论哪种方法，它们都有一个共性：失去了继承关系，所以剩下的需要我们手动补上去了，故有<code>Object.create(target.constructor.prototype)</code>的操作</p>
</blockquote>
<p>有两个问题：</p>
<ol>
<li>如果 <code>target</code> 是一个数组，拷贝结果没有返回</li>
<li>如果 <code>target</code> 是一个函数，函数没有被深拷贝</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%89%9B%E4%BA%BA%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">牛人面试题</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Step-By-Step"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/09/20/Step-By-Step/"
    >【Step-By-Step】一周面试题深入解析</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/09/20/Step-By-Step/" class="article-date">
  <time datetime="2019-09-20T06:43:04.000Z" itemprop="datePublished">2019-09-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%89%9B%E4%BA%BA%E9%9D%A2%E8%AF%95%E9%A2%98/">牛人面试题</a> / <a class="article-category-link" href="/categories/%E7%89%9B%E4%BA%BA%E9%9D%A2%E8%AF%95%E9%A2%98/Step-By-Step/">Step-By-Step</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="【Step-By-Step】一周面试题深入解析-周刊-01"><a href="#【Step-By-Step】一周面试题深入解析-周刊-01" class="headerlink" title="【Step-By-Step】一周面试题深入解析 / 周刊 01"></a>【Step-By-Step】一周面试题深入解析 / 周刊 01</h2><blockquote>
<p>已完结~</p>
<p>今天 2019/11/04 😜 (ง •_•)ง</p>
</blockquote>
<h3 id="1-如何正确判断-this-的指向？-2019-09-19"><a href="#1-如何正确判断-this-的指向？-2019-09-19" class="headerlink" title="1.如何正确判断 this 的指向？(2019-09-19)"></a>1.如何正确判断 this 的指向？(2019-09-19)</h3><p>如果用一句话说明 this 的指向，那么即是: 谁调用它，this 就指向谁。</p>
<p>但是仅通过这句话，我们很多时候并不能准确判断 this 的指向。因此我们需要借助一些规则去帮助自己：</p>
<p>this 的指向可以按照以下顺序判断:</p>
<p><strong>1、全局环境中的 this</strong></p>
<p>浏览器环境：无论是否在 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式</a> 下，在全局执行环境中（在任何函数体外部）this 都指向全局对象 <code>window</code>;</p>
<p>node 环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部），this 都是空对象 <code>&#123;&#125;</code></p>
<p><strong>2、是否是 <code>new</code> 绑定</strong></p>
<p>如果是 <code>new</code> 绑定，并且构造函数中没有返回 function 或者是 object，那么 this 指向这个新对象。如下:</p>
<blockquote>
<p>构造函数返回值不是 function 或 object。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> Super(<span class="string">&quot;26&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance.age); <span class="comment">//26</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造函数返回值是 function 或 object，这种情况下 this 指向的是返回的对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">&quot;2&quot;</span> &#125;;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> Super(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance.age); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>你可以想知道为什么会这样？我们来看一下 <code>new</code> 的实现原理:</p>
<ol>
<li>创建一个新对象。</li>
<li>这个新对象会被执行 <code>[[原型]]</code> 连接。</li>
<li>属性和方法被加入到 this 引用的对象中。并执行了构造函数中的方法.</li>
<li>如果函数没有返回其他对象，那么 this 指向这个新对象，否则 this 指向构造函数中返回的对象。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line">  target.__proto__ = func.prototype;</span><br><span class="line">  <span class="keyword">let</span> res = func.call(target);</span><br><span class="line">  <span class="comment">//排除 null 的情况</span></span><br><span class="line">  <span class="keyword">if</span> ((res &amp;&amp; <span class="keyword">typeof</span> res == <span class="string">&quot;object&quot;</span>) || <span class="keyword">typeof</span> res == <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3</strong>、函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么 this 绑定的就是指定的对象【归结为显式绑定】。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  info,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">var</span> info = person.info;</span><br><span class="line">info.call(person); <span class="comment">//20</span></span><br><span class="line">info.apply(person); <span class="comment">//20</span></span><br><span class="line">info.bind(person)(); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<p>这里同样需要注意一种<strong>特殊</strong>情况，如果 call,apply 或者 bind 传入的第一个参数值是 <code>undefined</code> 或者 <code>null</code>，严格模式下 this 的值为传入的值 null /undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node 环境为 global，浏览器环境为 window)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//node环境中:非严格模式 global，严格模式为null</span></span><br><span class="line">  <span class="comment">//浏览器环境中:非严格模式 window，严格模式为null</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  info,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">var</span> info = person.info;</span><br><span class="line"><span class="comment">//严格模式抛出错误；</span></span><br><span class="line"><span class="comment">//非严格模式，node下输出undefined（因为全局的age不会挂在 global 上）</span></span><br><span class="line"><span class="comment">//非严格模式。浏览器环境下输出 28（因为全局的age会挂在 window 上）</span></span><br><span class="line">info.call(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><strong>4、</strong>隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: <code>xxx.fn()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  info,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line">person.info(); <span class="comment">//20;执行的是隐式绑定</span></span><br></pre></td></tr></table></figure>

<p><strong>5、</strong> 默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。</p>
<p>非严格模式： node 环境，执行全局对象 global，浏览器环境，执行全局对象 window。</p>
<p>严格模式：执行 undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="comment">//严格模式；抛错</span></span><br><span class="line"><span class="comment">//非严格模式，node下输出 undefined（因为全局的age不会挂在 global 上）</span></span><br><span class="line"><span class="comment">//非严格模式。浏览器环境下输出 28（因为全局的age会挂在 window 上）</span></span><br><span class="line"><span class="comment">//严格模式抛出，因为 this 此时是 undefined</span></span><br><span class="line">info();</span><br></pre></td></tr></table></figure>

<p><strong>6、</strong> 箭头函数的情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  info: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.age); <span class="comment">//this继承的是外层上下文绑定的this</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">age</span>: <span class="number">28</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> info = obj.info();</span><br><span class="line">info(); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> info2 = obj.info.call(person);</span><br><span class="line">info2(); <span class="comment">//28</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/1">点击查看更多</a></p>
<h3 id="2-JS-中原始类型有哪几种？null-是对象吗？原始数据类型和复杂数据类型有什么区别？-2019-09-20"><a href="#2-JS-中原始类型有哪几种？null-是对象吗？原始数据类型和复杂数据类型有什么区别？-2019-09-20" class="headerlink" title="2.JS 中原始类型有哪几种？null 是对象吗？原始数据类型和复杂数据类型有什么区别？(2019-09-20)"></a>2.JS 中原始类型有哪几种？null 是对象吗？原始数据类型和复杂数据类型有什么区别？(2019-09-20)</h3><p><strong>目前，JS 原始类型有六种，分别为:</strong></p>
<ul>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Undefined</li>
<li>Null</li>
<li>Symbol(ES6 新增)</li>
</ul>
<p>ES10 新增了一种基本数据类型：BigInt</p>
<p>复杂数据类型只有一种: Object</p>
<p>null 不是一个对象，尽管 <code>typeof null</code> 输出的是 <code>object</code>，这是一个历史遗留问题，JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，<code>null</code> 表示为全零，所以将它错误的判断为 <code>object</code> 。</p>
<p><strong>基本数据类型和复杂数据类型的区别为:</strong></p>
<p>1、内存的分配不同</p>
<ul>
<li>基本数据类型存储在栈中。</li>
<li>复杂数据类型存储在堆中，栈中存储的变量，是指向堆中的引用地址。</li>
</ul>
<p>2、访问机制不同</p>
<ul>
<li>基本数据类型是按值访问</li>
<li>复杂数据类型按引用访问，JS 不允许直接访问保存在堆内存中的对象，在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值。</li>
</ul>
<p>3、复制变量时不同(a=b)</p>
<ul>
<li>基本数据类型：a=b;是将 b 中保存的原始值的副本赋值给新变量 a，a 和 b 完全独立，互不影响</li>
<li>复杂数据类型：a=b;将 b 保存的对象内存的引用地址赋值给了新变量 a;a 和 b 指向了同一个堆内存地址，其中一个值发生了改变，另一个也会改变。</li>
</ul>
<p>4、参数传递的不同(实参/形参)</p>
<p>函数传参都是按值传递(栈中的存储的内容)：基本数据类型，拷贝的是值；复杂数据类型，拷贝的是引用地址</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/5">点击查看更多</a></p>
</blockquote>
<h3 id="3-说一说你对-HTML5-语义化的理解-2019-09-21"><a href="#3-说一说你对-HTML5-语义化的理解-2019-09-21" class="headerlink" title="3.说一说你对 HTML5 语义化的理解(2019-09-21)"></a>3.说一说你对 HTML5 语义化的理解(2019-09-21)</h3><p>语义化意味着顾名思义，HTML5 的语义化指的是合理正确的使用语义化的标签来创建页面结构，如 header,footer,nav，从标签上即可以直观的知道这个标签的作用，而不是滥用 div。</p>
<p><strong>语义化的优点有:</strong></p>
<ul>
<li>代码结构清晰，易于阅读，利于开发和维护</li>
<li>方便其他设备解析（如屏幕阅读器）根据语义渲染网页。</li>
<li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</li>
<li></li>
</ul>
<h3 id="4-如何让-a-1-amp-amp-a-2-amp-amp-a-3-的值为-true？-2019-09-22"><a href="#4-如何让-a-1-amp-amp-a-2-amp-amp-a-3-的值为-true？-2019-09-22" class="headerlink" title="4.如何让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 的值为 true？(2019-09-22)"></a>4.如何让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 的值为 true？(2019-09-22)</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Blog/issues/31">可参考</a></p>
</blockquote>
<p><strong>4.1 利用隐式转换规则</strong></p>
<p><code>==</code> 操作符在左右数据类型不一致时，会先进行隐式转换。</p>
<p><code>a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</code> 的值意味着其不可能是基本数据类型。因为如果 a 是 null 或者是 undefined bool 类型，都不可能返回 true。</p>
<p>因此可以推测 a 是复杂数据类型，JS 中复杂数据类型只有 <code>object</code>，回忆一下，Object 转换为原始类型会调用什么方法？</p>
<ul>
<li>如果部署了 <code>[Symbol.toPrimitive]</code> 接口，那么调用此接口，若返回的不是基本数据类型，抛出错误。</li>
<li>如果没有部署 <code>[Symbol.toPrimitive]</code> 接口，那么根据要转换的类型，先调用 <code>valueOf</code> / <code>toString</code><ol>
<li>非 Date 类型对象，<code>hint</code> 是 <code>default</code> 时，调用顺序为：<code>valueOf</code> &gt;&gt;&gt; <code>toString</code>，即<code>valueOf</code> 返回的不是基本数据类型，才会继续调用 <code>toString</code>，如果<code>toString</code> 返回的还不是基本数据类型，那么抛出错误。</li>
<li>如果 <code>hint</code> 是 <code>string</code>(Date 对象的 hint 默认是 string) ，调用顺序为：<code>toString</code> &gt;&gt;&gt; <code>valueOf</code>，即<code>toString</code> 返回的不是基本数据类型，才会继续调用 <code>valueOf</code>，如果<code>valueOf</code> 返回的还不是基本数据类型，那么抛出错误。</li>
<li>如果 <code>hint</code> 是 <code>number</code>，调用顺序为： <code>valueOf</code> &gt;&gt;&gt; <code>toString</code></li>
</ol>
</li>
</ul>
<p>那么对于这道题，只要 <code>[Symbol.toPrimitive]</code> 接口，第一次返回的值是 1，然后递增，即成功成立。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]: (<span class="function"><span class="keyword">function</span> (<span class="params">hint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//闭包的特性之一：i 不会被回收</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>调用 <code>valueOf</code> 接口的情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  valueOf: (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//闭包的特性之一：i 不会被回收</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>另外，除了 i 自增的方法外，还可以利用 正则，如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  reg: <span class="regexp">/\d/g</span>,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.reg.exec(<span class="number">123</span>)[<span class="number">0</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>4.2 利用数据劫持</strong></p>
<p>使用 <code>Object.defineProperty</code> 定义的属性，在获取属性时，会调用 <code>get</code> 方法。利用这个特性，我们在 <code>window</code> 对象上定义 <code>a</code> 属性，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i++;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>ES6 新增了 <code>Proxy</code> ，此处我们同样可以利用 <code>Proxy</code> 去实现，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    i: <span class="number">1</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">this</span>.i++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>4.3 数组的 <code>toString</code> 接口默认调用数组的 <code>join</code> 方法，重写数组的 <code>join</code> 方法。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.join = a.shift;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>4.4 利用 <code>with</code> 关键字</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">a</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-防抖-debounce-函数的作用是什么？有哪些应用场景，请实现一个防抖函数。-2019-09-23"><a href="#5-防抖-debounce-函数的作用是什么？有哪些应用场景，请实现一个防抖函数。-2019-09-23" class="headerlink" title="5.防抖(debounce)函数的作用是什么？有哪些应用场景，请实现一个防抖函数。(2019-09-23)"></a>5.防抖(debounce)函数的作用是什么？有哪些应用场景，请实现一个防抖函数。(2019-09-23)</h3><blockquote>
<p><a target="_blank" rel="noopener" href="http://zxinc520.com/lcj/%225d84756e662e3d49cc2c5b01%22">可参考第三题 </a></p>
</blockquote>
<h4 id="防抖函数的作用"><a href="#防抖函数的作用" class="headerlink" title="防抖函数的作用"></a>防抖函数的作用</h4><p>防抖函数的作用就是控制函数在一定时间内的执行次数。防抖意味着 N 秒内函数只会被执行一次，如果 N 秒内再次被触发，则重新计算延迟时间。</p>
<p>举例说明：小思最近在减肥，但是她非常贪吃。为此，与其男朋友约定好，如果 10 天不吃零食，就可以购买一个包(不要问为什么是包，因为包治百病)。但是如果中间吃了一次零食，那么就要重新计算时间，直到小思坚持 10 天没有吃零食，才能购买一个包。所以，管不住嘴的小思，没有机会买包(悲伤的故事)…这就是<strong>防抖</strong>。</p>
<p>不管吃没吃零食，每 10 天买一个包，中间想买包，忍着，等到第十天的时候再买，这种情况是<strong>节流</strong>。如何控制女朋友的消费，各位攻城狮们，get 到了吗？防抖可比节流有效多了！</p>
<h4 id="防抖应用场景"><a href="#防抖应用场景" class="headerlink" title="防抖应用场景"></a>防抖应用场景</h4><ol>
<li>搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。</li>
<li>表单验证</li>
<li>按钮提交事件。</li>
<li>浏览器窗口缩放，resize 事件等。</li>
</ol>
<h2 id="【Step-By-Step】一周面试题深入解析-周刊-02"><a href="#【Step-By-Step】一周面试题深入解析-周刊-02" class="headerlink" title="【Step-By-Step】一周面试题深入解析 / 周刊 02"></a>【Step-By-Step】一周面试题深入解析 / 周刊 02</h2><blockquote>
<p>本周面试题一览:</p>
</blockquote>
<ul>
<li>节流(throttle)函数的作用是什么？有哪些应用场景，请实现一个节流函数</li>
<li>说一说你对 JS 执行上下文栈和作用域链的理解？</li>
<li>什么是 BFC？BFC 的布局规则是什么？如何创建 BFC？</li>
<li>let、const、var 的区别有哪些？</li>
<li>深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？</li>
</ul>
<h3 id="6-节流-throttle-函数的作用是什么？有哪些应用场景，请实现一个节流函数。-2019-09-24"><a href="#6-节流-throttle-函数的作用是什么？有哪些应用场景，请实现一个节流函数。-2019-09-24" class="headerlink" title="6. 节流(throttle)函数的作用是什么？有哪些应用场景，请实现一个节流函数。(2019-09-24)"></a>6. 节流(throttle)函数的作用是什么？有哪些应用场景，请实现一个节流函数。(2019-09-24)</h3><blockquote>
<p><strong>解析</strong>： <a target="_blank" rel="noopener" href="http://zxinc520.com/lcj/%225d84756e662e3d49cc2c5b01%22">可参考第三题 </a></p>
</blockquote>
<p><strong>节流函数的作用：</strong></p>
<p>节流函数的作用是规定一个单位时间，在这个单位时间内最多只能触发一次函数执行，如果这个单位时间内多次触发函数，只能有一次生效。</p>
<p>举例说明：小明的妈妈和小明约定好，如果小明在周考中取得满分，那么当月可以带他去游乐场玩，但是一个月最多只能去一次。</p>
<p>这其实就是一个节流的例子，在一个月的时间内，去游乐场最多只能触发一次。即使这个时间周期内，小明取得多次满分。</p>
<p><strong>节流应用场景：</strong></p>
<p>1.按钮点击事件</p>
<p>2.拖拽事件</p>
<p>3.onScoll</p>
<p>4.计算鼠标移动的距离(mousemove)</p>
<h3 id="7-说一说你对-JS-执行上下文栈和作用域链的理解？-2019-09-24"><a href="#7-说一说你对-JS-执行上下文栈和作用域链的理解？-2019-09-24" class="headerlink" title="7. 说一说你对 JS 执行上下文栈和作用域链的理解？(2019-09-24)"></a>7. 说一说你对 JS 执行上下文栈和作用域链的理解？(2019-09-24)</h3><p><a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/?nsukey=rQHqMrFpKq6JJN//OeubPCslaSTSRyuc/XCznnIDze1SGzwva5SZtzixJ13p2gAlxua95Xa7fraZXwj5tyLRDK33+pNhyfKR/xyzhWNyB/qaIlsDGyQBckNoHQGPveOB24M+cK/gF8Tg1ehUGLWiCvumxdgcQwZOWj2BGfD3n/Y=#sec-execution-contexts">JS 执行上下文</a></p>
<p>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。</p>
<blockquote>
<p>执行上下文类型分为：</p>
</blockquote>
<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li>eval 函数执行上下文(不被推荐)</li>
</ul>
<p>执行上下文创建过程中，需要做以下几件事:</p>
<ol>
<li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。</li>
<li>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。</li>
<li>确定 this 的值，即 ResolveThisBinding</li>
</ol>
<p><strong>作用域</strong></p>
<p><strong>作用域</strong>负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。—— 摘录自《你不知道的 JavaScript》(上卷)</p>
<p>作用域有两种工作模型：词法作用域和动态作用域，JS 采用的是<strong>词法作用域</strong>工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。(<code>with</code> 和 <code>eval</code> 能够修改词法作用域，但是不推荐使用，对此不做特别说明)</p>
<blockquote>
<p>作用域分为：</p>
</blockquote>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域</li>
</ul>
<p><strong>JS 执行上下文栈(后面简称执行栈)</strong></p>
<p>执行栈，也叫做调用栈，具有 <strong>LIFO</strong> (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。</p>
<blockquote>
<p>规则如下：</p>
</blockquote>
<ul>
<li>首次运行 JavaScript 代码的时候,会创建一个全局执行的上下文并 Push 到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 Push 当前执行栈的栈顶。</li>
<li>当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中 Pop 出，上下文的控制权将移动到当前执行栈的下一个执行上下文。</li>
</ul>
<p>以一段代码具体说明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;fun3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fun3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure>

<p><code>Global Execution Context</code> (即全局执行上下文)首先入栈，过程如下：</p>
<p><img src="http://static.zxinc520.com/blog/20190925/KgyYmKIHz7fx.png?imageslim" alt="mark"></p>
<p><strong>作用域链</strong></p>
<p>作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。</p>
<h3 id="8-什么是-BFC？BFC-的布局规则是什么？如何创建-BFC？-2019-09-25"><a href="#8-什么是-BFC？BFC-的布局规则是什么？如何创建-BFC？-2019-09-25" class="headerlink" title="8. 什么是 BFC？BFC 的布局规则是什么？如何创建 BFC？(2019-09-25)"></a>8. 什么是 BFC？BFC 的布局规则是什么？如何创建 BFC？(2019-09-25)</h3><blockquote>
<p>什么是 BFC</p>
<p>BFC 是 Block Formatting Context 的缩写，即块格式化上下文。我们来看一下 CSS2.1 规范中对 BFC 的说明</p>
<p>浮动、绝对定位的元素、非块级盒子的块容器（如 inline-blocks、table-cells 和 table-captions），以及<code>overflow</code>的值不为<code>visible</code>（该值已传播到视区时除外）为其内容建立新的块格式上下文。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#block-formatting">BFC 布局规则</a></p>
<ul>
<li>BFC 内，盒子依次垂直排列。</li>
<li>BFC 内，两个盒子的垂直距离由 <code>margin</code> 属性决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠【符合合并原则的 margin 合并后是使用大的 margin】</li>
<li>BFC 内，每个盒子的左外边缘接触内部盒子的左边缘（对于从右到左的格式，右边缘接触）。即使在存在浮动的情况下也是如此。除非创建新的 BFC。</li>
<li>BFC 的区域不会与 float box 重叠。</li>
<li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li>计算 BFC 的高度时，浮动元素也参与计算。</li>
</ul>
<p><strong>如何创建 BFC</strong></p>
<ul>
<li>根元素</li>
<li>浮动元素（float 属性不为 none）</li>
<li>position 为 absolute 或 relative</li>
<li>overflow 不为 visible 的块元素</li>
<li>display 为 inline-block, table-cell, table-caption</li>
</ul>
<p><strong>BFC 的应用</strong></p>
<ol>
<li>防止 margin 重叠</li>
</ol>
<p>根据 BFC 规则，同一个 BFC 内的两个两个相邻 Box 的 <code>margin</code> 会发生重叠，因此我们可以在 div 外面再嵌套一层容器，并且触发该容器生成一个 BFC，这样 <code>&lt;div class=&quot;a&quot;&gt;&lt;/div&gt;</code> 就会属于两个 BFC，自然也就不会再发生 <code>margin</code> 重叠</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.a</span>&#123;</span></span><br><span class="line">        height: 100px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        margin: 50px;</span><br><span class="line">        background: pink;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">overflow</span>: <span class="selector-tag">auto</span>; <span class="comment">/*触发生成BFC*/</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>清除内部浮动</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.a</span>&#123;</span></span><br><span class="line">        height: 100px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        margin: 10px;</span><br><span class="line">        background: pink;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span>&#123;</span></span><br><span class="line">        width: 120px;</span><br><span class="line"><span class="css">        <span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;<span class="comment">/*触发生成BFC*/</span></span></span><br><span class="line">        border: 2px solid black;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>container 的高度没有被撑开，如果我们希望 container 的高度能够包含浮动元素，那么可以创建一个新的 BFC，因为根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算。</p>
<ol start="3">
<li>自适应多栏布局</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body&#123;</span><br><span class="line">        width: 500px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.a</span>&#123;</span></span><br><span class="line">        height: 150px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        background: pink;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.b</span>&#123;</span></span><br><span class="line">        height: 200px;</span><br><span class="line"><span class="css">        <span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>; <span class="comment">/*触发生成BFC*/</span></span></span><br><span class="line">        background: blue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190925/zIMIHi7uVOq6.png?imageslim" alt="mark"></p>
<blockquote>
<p>加了 <code>overflow: hidden;</code> 触发生成 BFC</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190925/BFiWOckmwL9V.png?imageslim" alt="mark"></p>
<h3 id="9-let、const、var-的区别有哪些？-2019-09-26"><a href="#9-let、const、var-的区别有哪些？-2019-09-26" class="headerlink" title="9. let、const、var 的区别有哪些？(2019-09-26)"></a>9. let、const、var 的区别有哪些？(2019-09-26)</h3><p><img src="http://static.zxinc520.com/blog/20190926/0imlOVJDQTTd.png?imageslim" alt="mark"></p>
<ol>
<li>let/const 定义的变量不会出现变量提升，而 var 定义的变量会提升。</li>
<li>相同作用域中，let 和 const 不允许重复声明，var 允许重复声明。</li>
<li>cosnt 声明变量时必须设置初始值</li>
<li>const 声明一个只读的常量，这个常量不可改变</li>
<li>let/const 声明的变量仅在块级作用域中有效。而 var 声明的变量在块级作用域外仍能访问到。</li>
<li>顶层作用域中 var 声明的变量挂在 window 上(浏览器环境)</li>
<li>let/const 有暂时性死区的问题，即 let/const 声明的变量，在定义之前都是不可用的。如果使用会抛出错误。</li>
</ol>
<h3 id="10-深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？-2019-09-27"><a href="#10-深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？-2019-09-27" class="headerlink" title="10. 深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？(2019-09-27)"></a>10. 深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？(2019-09-27)</h3><blockquote>
<p>深拷贝和浅拷贝是针对复杂数据类型来说的。</p>
</blockquote>
<p><strong>深拷贝</strong></p>
<blockquote>
<p>深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</p>
</blockquote>
<p><strong>浅拷贝</strong></p>
<blockquote>
<p>浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。</p>
</blockquote>
<p>可以使用 <code>for in</code>、 <code>Object.assign</code>、 扩展运算符 <code>...</code> 、<code>Array.prototype.slice()</code>、<code>Array.prototype.concat()</code> 等，例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="keyword">let</span> obj3 = &#123; ...obj &#125;;</span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">obj.hobbies.push(<span class="string">&quot;coding&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123; name: &#x27;Jack&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3); <span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看出浅拷贝只最第一层属性进行了拷贝，当第一层的属性值是基本数据类型时，新的对象和原对象互不影响，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性值其指向的是同一块内存地址。来看一下使用 <code>for in</code> 实现浅拷贝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  newObj[key] = obj[key];</span><br><span class="line">  <span class="comment">//这一步不需要多说吧，复杂数据类型栈中存的是对应的地址，因此赋值操作，相当于两个属性值指向同一个内存空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newObj);</span><br><span class="line"><span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18, hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27; ] &#125;</span></span><br><span class="line">obj.age = <span class="number">20</span>;</span><br><span class="line">obj.hobbies.pop();</span><br><span class="line"><span class="built_in">console</span>.log(newObj);</span><br><span class="line"><span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18, hobbies: [ &#x27;reading&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>深拷贝实现</strong></p>
<blockquote>
<p>深拷贝最简单的实现是: <code>JSON.parse(JSON.stringify(obj))</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">//newObj和obj互不影响</span></span><br><span class="line">obj.hobbies.push(<span class="string">&quot;coding&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18, hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>JSON.parse(JSON.stringify(obj))</code> 是最简单的实现方式，但是有一点缺陷：</p>
<ol>
<li>对象的属性值是函数时，无法拷贝。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(sayHi);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18, hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原型链上的属性无法获取</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Super.prototype.location = <span class="string">&quot;NanJing&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age, hobbies</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Super();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Child(<span class="string">&quot;Yvette&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.location); <span class="comment">//NanJing</span></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.location); <span class="comment">//undefined;原型链上的属性无法获取</span></span><br></pre></td></tr></table></figure>

<p>3.不能正确的处理 Date 类型的数据</p>
<p>4.不能处理 RegExp</p>
<p>5.会忽略 symbol</p>
<p>6.会忽略 undefined</p>
<blockquote>
<p>2.实现一个 deepClone 函数</p>
</blockquote>
<ol>
<li>如果是基本数据类型，直接返回</li>
<li>如果是 <code>RegExp</code> 或者 <code>Date</code> 类型，返回对应类型</li>
<li>如果是复杂数据类型，递归。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//递归拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">//如果不是复杂数据类型，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果obj是数组，那么 obj.constructor 是 [Function: Array]</span></span><br><span class="line"><span class="comment">   * 如果obj是对象，那么 obj.constructor 是 [Function: Object]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">let</span> t = <span class="keyword">new</span> obj.constructor();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">//如果 obj[key] 是复杂数据类型，递归</span></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">//是否是自身的属性</span></span><br><span class="line">      t[key] = deepClone(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Super.prototype.location = <span class="string">&quot;NanJing&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age, hobbies</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.hobbies = hobbies;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Super();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Child(<span class="string">&quot;Yvette&quot;</span>, <span class="number">18</span>, [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>]);</span><br><span class="line">obj.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.location); <span class="comment">//NanJing</span></span><br><span class="line"><span class="keyword">let</span> newObj = deepClone(obj);</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.location); <span class="comment">//NanJing 可以获取到原型链上的属性</span></span><br><span class="line">newObj.sayHi(); <span class="comment">//hi 函数属性拷贝正常</span></span><br></pre></td></tr></table></figure>

<h2 id="【Step-By-Step】一周面试题深入解析-周刊-03"><a href="#【Step-By-Step】一周面试题深入解析-周刊-03" class="headerlink" title="【Step-By-Step】一周面试题深入解析 / 周刊 03"></a>【Step-By-Step】一周面试题深入解析 / 周刊 03</h2><blockquote>
<p>本周面试题一览:</p>
</blockquote>
<ul>
<li>什么是 XSS 攻击，XSS 攻击可以分为哪几类？我们如何防范 XSS 攻击？</li>
<li>如何隐藏页面中的某个元素？</li>
<li>浏览器事件代理机制的原理是什么？</li>
<li>setTimeout 倒计时为什么会出现误差？</li>
</ul>
<h3 id="11-什么是-XSS-攻击，XSS-攻击可以分为哪几类？我们如何防范-XSS-攻击？（2019-09-28）"><a href="#11-什么是-XSS-攻击，XSS-攻击可以分为哪几类？我们如何防范-XSS-攻击？（2019-09-28）" class="headerlink" title="11. 什么是 XSS 攻击，XSS 攻击可以分为哪几类？我们如何防范 XSS 攻击？（2019-09-28）"></a>11. 什么是 XSS 攻击，XSS 攻击可以分为哪几类？我们如何防范 XSS 攻击？（2019-09-28）</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Blog/issues/33">源地址</a></p>
</blockquote>
<p><strong>1. XSS 攻击</strong></p>
<p>XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。</p>
<p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击者定义的请求。</p>
<p><strong>XSS 分类</strong></p>
<p>根据攻击的来源，XSS 攻击可以分为存储型(持久性)、反射型(非持久型)和 DOM 型三种。下面我们来详细了解一下这三种 XSS 攻击：</p>
<blockquote>
<p>1.1 反射型 XSS</p>
</blockquote>
<p>当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web 服务器将注入脚本，比如一个错误信息，搜索结果等，未进行过滤直接返回到用户的浏览器上。</p>
<blockquote>
<p>反射型 XSS 的攻击步骤：</p>
</blockquote>
<ol>
<li>攻击者构造出特殊的 <code>URL</code>，其中包含恶意代码。</li>
<li>用户打开带有恶意代码的 <code>URL</code> 时，网站服务端将恶意代码从 <code>URL</code> 中取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p>反射型 XSS 漏洞常见于通过 <code>URL</code> 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 <code>URL</code> 才能生效，攻击者往往会结合多种手段诱导用户点击。</p>
<p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p>
<p>如果不希望被前端拿到 cookie，后端可以设置 <code>httpOnly</code> (不过这不是 <code>XSS攻击</code> 的解决方案，只能降低受损范围)</p>
<blockquote>
<p>如何防范反射型 XSS 攻击</p>
</blockquote>
<p><strong>对字符串进行编码。</strong></p>
<p>对 url 的查询参数进行转义后再输出到页面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&quot;/welcome&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//对查询参数进行编码，避免反射型 XSS攻击</span></span><br><span class="line">  res.send(<span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(req.query.type)&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.2 DOM 型 XSS</p>
</blockquote>
<p>DOM 型 XSS 攻击，实际上就是前端 <code>JavaScript</code> 代码不够严谨，把不可信的内容插入到了页面。在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>.appendChild</code>、<code>document.write()</code>等 API 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 <code>.innerText</code>、<code>.textContent</code>、<code>.setAttribute()</code> 等。</p>
<blockquote>
<p>DOM 型 XSS 的攻击步骤：</p>
</blockquote>
<ol>
<li>攻击者构造出特殊数据，其中包含恶意代码。</li>
<li>用户浏览器执行了恶意代码。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<blockquote>
<p>如何防范 DOM 型 XSS 攻击</p>
</blockquote>
<p>防范 DOM 型 XSS 攻击的核心就是对输入内容进行转义(DOM 中的内联事件监听器和链接跳转都能把字符串作为代码运行，需要对其内容进行检查)。</p>
<p>1.对于<code>url</code>链接(例如图片的<code>src</code>属性)，那么直接使用 <code>encodeURIComponent</code> 来转义。</p>
<p>2.非<code>url</code>，我们可以这样进行编码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeHtml</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">    .replace(<span class="regexp">/&quot;/g</span>, <span class="string">&quot;&amp;quot;&quot;</span>)</span><br><span class="line">    .replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&quot;&amp;apos;&quot;</span>)</span><br><span class="line">    .replace(<span class="regexp">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>)</span><br><span class="line">    .replace(<span class="regexp">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞。</p>
<blockquote>
<p>1.3 存储型 XSS</p>
</blockquote>
<p>恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和 DOM 型 XSS 更大。存储型 XSS 攻击的原因仍然是没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出</p>
<blockquote>
<p>存储型 XSS 的攻击步骤：</p>
</blockquote>
<ol>
<li>攻击者将恶意代码提交到目标网站的数据库中。</li>
<li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>
</ol>
<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>
<blockquote>
<p>如何防范存储型 XSS 攻击：</p>
</blockquote>
<ol>
<li>前端数据传递给服务器之前，先转义/过滤(防范不了抓包修改数据的情况)</li>
<li>服务器接收到数据，在存储到数据库之前，进行转义/过滤</li>
<li>前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤</li>
</ol>
<p><strong>除了谨慎的转义，我们还需要其他一些手段来防范 XSS 攻击:</strong></p>
<p><strong>1.Content Security Policy</strong></p>
<p>在服务端使用 HTTP 的 <code>Content-Security-Policy</code> 头部来指定策略，或者在前端设置 <code>meta</code> 标签。</p>
<p>例如下面的配置只允许加载同域下的资源：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src <span class="string">&#x27;self&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;form-action &#x27;self&#x27;;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>前端和服务端设置 CSP 的效果相同，但是<code>meta</code>无法使用<code>report</code></p>
<p>严格的 CSP 在 XSS 的防范中可以起到以下的作用：</p>
<ol>
<li>禁止加载外域代码，防止复杂的攻击逻辑。</li>
<li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。</li>
<li>禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。</li>
<li>禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。</li>
<li>合理使用上报可以及时发现 XSS，利于尽快修复问题。</li>
</ol>
<p><strong>2.输入内容长度控制</strong></p>
<p>对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。</p>
<p><strong>3.输入内容限制</strong></p>
<p>对于部分输入，可以限定不能包含特殊字符或者仅能输入数字等。</p>
<p><strong>4.其他安全措施</strong></p>
<ul>
<li>HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。</li>
<li>验证码：防止脚本冒充用户提交危险操作。</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/18">点击查看更多</a></p>
</blockquote>
<h3 id="12-如何隐藏页面中的某个元素？（2019-09-29）"><a href="#12-如何隐藏页面中的某个元素？（2019-09-29）" class="headerlink" title="12.如何隐藏页面中的某个元素？（2019-09-29）"></a>12.如何隐藏页面中的某个元素？（2019-09-29）</h3><p><strong>隐藏类型：</strong></p>
<p>屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类：</p>
<ul>
<li>完全隐藏：元素从渲染树中消失，不占据空间。</li>
<li>视觉上的隐藏：屏幕中不可见，占据空间。</li>
<li>语义上的隐藏：读屏软件不可读，但正常占据空。</li>
</ul>
<p>完全隐藏：</p>
<ol>
<li><code>display</code> 属性(不占据空间)</li>
</ol>
<p>HTML5 新增属性，相当于 <code>display: none</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hidden</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>hidden 属性 (不占据空间)</li>
</ol>
<p>视觉上的隐藏：</p>
<p><strong>利用 <code>position</code> 和 盒模型 将元素移出可视区范围</strong></p>
<ol>
<li><p>设置 <code>posoition</code> 为 <code>absolute</code> 或 <code>fixed</code>，� 通过设置 <code>top</code>、<code>left</code> 等值，将其移出可视区域。(可视区域不占位)</p>
</li>
<li><p>设置 <code>position</code> 为 <code>relative</code>，通过设置 <code>top</code>、<code>left</code> 等值，将其移出可视区域。（可视区域占位）；如希望其在可视区域不占位置，需同时设置 <code>height: 0</code>;</p>
</li>
<li><p>设置 margin 值，将其移出可视区域范围（可视区域占位）；如果希望其在可视区域不占位，需同时设置 <code>height: 0</code>;</p>
</li>
</ol>
<p><strong>利用 transfrom</strong></p>
<ol>
<li>缩放</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>移动 <code>translateX</code>, <code>translateY</code></li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(<span class="selector-tag">-99999px</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>旋转 <code>rotate</code></li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotateY</span>(90<span class="selector-tag">deg</span>);</span><br></pre></td></tr></table></figure>

<p><strong>设置其大小为 0</strong></p>
<ol>
<li>宽高为 0，字体大小为 0</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">height</span>: 0;</span><br><span class="line"><span class="selector-tag">width</span>: 0;</span><br><span class="line"><span class="selector-tag">font-size</span>: 0;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>宽高为 0，超出隐藏</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">height</span>: 0;</span><br><span class="line"><span class="selector-tag">width</span>: 0;</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure>

<p>设置透明度为 0</p>
<p><code>visibility</code>属性</p>
<p>层级覆盖，<code>z-index</code> 属性</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br><span class="line"><span class="selector-tag">z-index</span>: <span class="selector-tag">-999</span>;</span><br></pre></td></tr></table></figure>

<p>再设置一个层级较高的元素覆盖在此元素上。</p>
<p>clip-path 裁剪</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">clip-path</span>: <span class="selector-tag">polygon</span>(0 0, 0 0, 0 0, 0 0);</span><br></pre></td></tr></table></figure>

<h3 id="13-浏览器事件代理机制的原理是什么？（2019-09-30）"><a href="#13-浏览器事件代理机制的原理是什么？（2019-09-30）" class="headerlink" title="13.浏览器事件代理机制的原理是什么？（2019-09-30）"></a>13.浏览器事件代理机制的原理是什么？（2019-09-30）</h3><p><strong>事件代理机制的原理</strong></p>
<p>事件代理又称为事件委托，在祖先级 DOM 元素绑定一个事件，当触发子孙级 DOM 元素的事件时，利用事件冒泡的原理来触发绑定在祖先级 DOM 的事件。因为事件会从目标元素一层层冒泡至 document 对象。</p>
<p><strong>为什么要事件代理？</strong></p>
<ol>
<li>添加到页面上的事件数量会影响页面的运行性能，如果添加的事件过多，会导致网页的性能下降。采用事件代理的方式，可以大大减少注册事件的个数。</li>
<li>事件代理的当时，某个子孙元素是动态增加的，不需要再次对其进行事件绑定。</li>
<li>不用担心某个注册了事件的 DOM 元素被移除后，可能无法回收其事件处理程序，我们只要把事件处理程序委托给更高层级的元素，就可以避免此问题。</li>
<li>允许给一个事件注册多个监听。</li>
<li>提供了一种更精细的手段控制 <code>listener</code> 的触发阶段(可以选择捕获或者是冒泡)。</li>
<li>对任何 <code>DOM</code> 元素都是有效的，而不仅仅是对 <code>HTML</code> 元素有效。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener">addEventListener</a> :</p>
<p>addEventListener 接受 3 个参数，分别是要处理的事件名、实现了 EventListener 接口的对象或者是一个函数、一个对象/一个布尔值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener[, options]);</span><br><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>options(对象) | 可选</strong></p>
<ul>
<li>capture: <code>Boolean</code>。true 表示在捕获阶段触发，false 表示在冒泡阶段触发。默认是 false。</li>
<li>once:<code>Boolean</code>。true 表示 listener 在添加之后最多只调用一次，listener 会在其被调用之后自动移除。默认是 false。</li>
<li>passive: <code>Boolean</code>。true 表示 listener 永远不会调用 <code>preventDefault()</code>。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。默认是 false。</li>
</ul>
<p><strong>useCapture(Boolean) | 可选</strong></p>
<p><code>useCapture</code> 默认为 false。表示冒泡阶段调用事件处理程序，若设置为 true，表示在捕获阶段调用事件处理程序。</p>
<blockquote>
<p>如将页面中的所有 click 事件都代理到 document 上:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获阶段调用调用事件处理程序，eventPhase是 1;</span></span><br><span class="line"><span class="comment">     * 处于目标，eventPhase是2</span></span><br><span class="line"><span class="comment">     * 冒泡阶段调用事件处理程序，eventPhase是 3；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.eventPhase);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>与 <code>addEventListener</code> 相对应的是 <code>removeEventListener</code>,用于移除事件监听。</p>
<h3 id="14-setTimeout-倒计时为什么会出现误差？-（2019-10-08）"><a href="#14-setTimeout-倒计时为什么会出现误差？-（2019-10-08）" class="headerlink" title="14. setTimeout 倒计时为什么会出现误差？ （2019-10-08）"></a>14. setTimeout 倒计时为什么会出现误差？ （2019-10-08）</h3><p><code>setTimeout</code> 只能保证延时或间隔不小于设定的时间。因为它实际上只是将回调添加到了宏任务队列中，但是如果主线程上有任务还没有执行完成，它必须要等待。</p>
<p>如果你对前面这句话不是非常理解，那么有必要了解一下 JS 的运行机制。</p>
<p><strong>JS 的运行机制</strong></p>
<p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</p>
<p>（2）主线程之外，还存在”任务队列”(task queue)。</p>
<p>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p>
<p>（4）主线程不断重复上面的第三步。</p>
<p>如 <code>setTimeout(()=&gt;&#123;callback();&#125;, 1000)</code> ，即表示在 1s 之后将 <code>callback</code> 放到宏任务队列中，当 1s 的时间到达时，如果主线程上有其它任务在执行，那么 <code>callback</code> 就必须要等待，另外 <code>callback</code> 的执行也需要时间，因此 <code>setTimeout</code> 的时间间隔是有误差的，它只能保证延时不小于设置的时间。</p>
<p><strong>如何减少 <code>setTimeout</code> 的误差</strong></p>
<p>我们只能减少执行多次的 <code>setTimeout</code> 的误差，例如倒计时功能。</p>
<p>倒计时的时间通常都是从服务端获取的。造成误差的原因：</p>
<p>1.没有考虑误差时间（函数执行的时间/其它代码的阻塞）</p>
<p>2.没有考虑浏览器的“休眠”</p>
<p>完全消除 <code>setTimeout</code>的误差是不可能的，但是我们减少 <code>setTimeout</code> 的误差。通过对下一次任务的调用时间进行修正，来减少误差。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> countdown = <span class="number">5000</span>; <span class="comment">//服务器返回的倒计时时间</span></span><br><span class="line"><span class="keyword">let</span> interval = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">let</span> timer = <span class="built_in">setTimeout</span>(countDownStart, interval); <span class="comment">//首次执行</span></span><br><span class="line"><span class="comment">//定时器测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countDownStart</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="keyword">const</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">const</span> nextInterval = interval - offset; <span class="comment">//修正后的延时时间</span></span><br><span class="line">  <span class="keyword">if</span> (nextInterval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    nextInterval = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  countdown -= interval;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&quot;误差：&quot;</span> +</span><br><span class="line">      offset +</span><br><span class="line">      <span class="string">&quot;ms，下一次执行：&quot;</span> +</span><br><span class="line">      nextInterval +</span><br><span class="line">      <span class="string">&quot;ms后，离活动开始还有：&quot;</span> +</span><br><span class="line">      countdown +</span><br><span class="line">      <span class="string">&quot;ms&quot;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (countdown &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(countDownStart, nextInterval);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前页面是不可见的，那么倒计时会出现大于 100ms 的误差时间。因此在页面显示时，应该重新从服务端获取剩余时间进行倒计时。当然，为了更好的性能，当倒计时不可见(Tab 页切换/倒计时内容不在可视区时)，可以选择停止倒计时。</p>
<p>为此，我们可以监听 <code>visibityChange</code> 事件进行处理。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/21">点击查看更多</a></p>
</blockquote>
<h2 id="【Step-By-Step】一周面试题深入解析-周刊-04"><a href="#【Step-By-Step】一周面试题深入解析-周刊-04" class="headerlink" title="【Step-By-Step】一周面试题深入解析 / 周刊 04"></a>【Step-By-Step】一周面试题深入解析 / 周刊 04</h2><blockquote>
<p>本周面试题一览:</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Blog/issues/34">什么是闭包？闭包的作用是什么？</a></li>
<li>实现 Promise.all 方法</li>
<li>异步加载 js 脚本的方法有哪些？</li>
<li>请实现一个 flattenDeep 函数，把嵌套的数组扁平化</li>
<li>可迭代对象有什么特点？</li>
</ul>
<h3 id="15-什么是闭包？闭包的作用是什么？-（2019-10-09）"><a href="#15-什么是闭包？闭包的作用是什么？-（2019-10-09）" class="headerlink" title="15. 什么是闭包？闭包的作用是什么？ （2019-10-09）"></a>15. 什么是闭包？闭包的作用是什么？ （2019-10-09）</h3><p><strong>什么是闭包？</strong></p>
<p>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包最常用的方式就是在一个函数内部创建另一个函数。</p>
<p><strong>闭包的作用：</strong></p>
<ol>
<li>能够访问函数定义时所在的词法作用域(阻止其被回收)。</li>
<li>私有化变量</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">10</span>; <span class="comment">//私有变量</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getX: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = base();</span><br><span class="line"><span class="built_in">console</span>.log(obj.getX()); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>模拟块级作用域</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建模块</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;Yvette&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">20</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    sayName,</span><br><span class="line">    sayAge,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> info = coolModule();</span><br><span class="line">info.sayName(); <span class="comment">//&#x27;Yvette&#x27;</span></span><br></pre></td></tr></table></figure>

<p>模块模式具有两个必备的条件(来自《你不知道的 JavaScript》)</p>
<ul>
<li>必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)</li>
<li>封闭函数必须返回至少<strong>一个</strong>内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li>
</ul>
<p>闭包的缺点</p>
<p>闭包会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p>
<h3 id="16-实现-Promise-all-方法-（2019-10-10）"><a href="#16-实现-Promise-all-方法-（2019-10-10）" class="headerlink" title="16. 实现 Promise.all 方法 （2019-10-10）"></a>16. 实现 Promise.all 方法 （2019-10-10）</h3><p>在实现 Promise.all 方法之前，我们首先要知道 Promise.all 的功能和特点，因为在清楚了 Promise.all 功能和特点的情况下，我们才能进一步去写实现。</p>
<p><strong>Promise.all 功能</strong></p>
<p><code>Promise.all(iterable)</code> 返回一个新的 Promise 实例。此实例在 <code>iterable</code> 参数内所有的 <code>promise</code> 都 <code>fulfilled</code> 或者参数中不包含 <code>promise</code> 时，状态变成 <code>fulfilled</code>；如果参数中 <code>promise</code> 有一个失败<code>rejected</code>，此实例回调失败，失败原因的是第一个失败 <code>promise</code> 的返回结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>p 的状态由 p1,p2,p3 决定，分成以下；两种情况：</p>
<p>（1）只有 p1、p2、p3 的状态都变成 <code>fulfilled</code>，p 的状态才会变成 <code>fulfilled</code>，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</p>
<p>（2）只要 p1、p2、p3 之中有一个被 <code>rejected</code>，p 的状态就变成 <code>rejected</code>，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</p>
<p><strong>Promise.all 的特点</strong></p>
<blockquote>
<p>Promise.all 的返回值是一个 promise 实例</p>
</blockquote>
<ul>
<li>如果传入的参数为空的可迭代对象，<code>Promise.all</code> 会 <strong>同步</strong> 返回一个已完成状态的 <code>promise</code></li>
<li>如果传入的参数中不包含任何 promise,<code>Promise.all</code> 会 <strong>异步</strong> 返回一个已完成状态的 <code>promise</code></li>
<li>其它情况下，<code>Promise.all</code> 返回一个 <strong>处理中（pending）</strong> 状态的 <code>promise</code>.</li>
</ul>
<blockquote>
<p>Promise.all 返回的 promise 的状态</p>
</blockquote>
<ul>
<li>如果传入的参数中的 promise 都变成完成状态，<code>Promise.all</code> 返回的 <code>promise</code> 异步地变为完成。</li>
<li>如果传入的参数中，有一个 <code>promise</code> 失败，<code>Promise.all</code> 异步地将失败的那个结果给失败状态的回调函数，而不管其它 <code>promise</code> 是否完成</li>
<li>在任何情况下，<code>Promise.all</code> 返回的 <code>promise</code> 的完成状态的结果都是一个数组</li>
</ul>
<p><strong>Promise.all 实现</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//Array.from 将可迭代对象转换成数组</span></span><br><span class="line">    promises = <span class="built_in">Array</span>.from(promises);</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve([]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> result = [];</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        <span class="comment">//考虑到 i 可能是 thenable 对象也可能是普通值</span></span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i]).then(</span><br><span class="line">          (data) =&gt; &#123;</span><br><span class="line">            result[i] = data;</span><br><span class="line">            <span class="keyword">if</span> (++index === promises.length) &#123;</span><br><span class="line">              <span class="comment">//所有的 promises 状态都是 fulfilled，promise.all返回的实例才变成 fulfilled 态</span></span><br><span class="line">              resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          (err) =&gt; &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="17-异步加载-js-脚本的方法有哪些？-（2019-10-11）"><a href="#17-异步加载-js-脚本的方法有哪些？-（2019-10-11）" class="headerlink" title="17. 异步加载 js 脚本的方法有哪些？ （2019-10-11）"></a>17. 异步加载 js 脚本的方法有哪些？ （2019-10-11）</h3><ol>
<li><code>&lt;script&gt;</code> 标签中增加 <code>async</code>(html5) 或者 <code>defer</code>(html4) 属性,脚本就会异步加载。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;../XXX.js&quot;</span> defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>defer</code> 和 <code>async</code> 的区别在于：</p>
<ul>
<li><code>defer</code> 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），在 window.onload 之前执行；</li>
<li><code>async</code> 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。</li>
<li>如果有多个 <code>defer</code> 脚本，会按照它们在页面出现的顺序加载</li>
<li>多个 <code>async</code> 脚本不能保证加载顺序</li>
</ul>
<ol start="2">
<li>动态创建 <code>script</code> 标签</li>
</ol>
<p>动态创建的 <code>script</code> ，设置 <code>src</code> 并不会开始下载，而是要添加到文档中，JS 文件才会开始下载。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.src = <span class="string">&quot;XXX.js&quot;</span>;</span><br><span class="line"><span class="comment">// 添加到html文件中才会开始下载</span></span><br><span class="line"><span class="built_in">document</span>.body.append(script);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>XHR 异步加载 JS</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;js/xxx.js&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">eval</span>(xhr.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="18-请实现一个-flattenDeep-函数，把嵌套的数组扁平化-（2019-10-13）"><a href="#18-请实现一个-flattenDeep-函数，把嵌套的数组扁平化-（2019-10-13）" class="headerlink" title="18. 请实现一个 flattenDeep 函数，把嵌套的数组扁平化 （2019-10-13）"></a>18. 请实现一个 flattenDeep 函数，把嵌套的数组扁平化 （2019-10-13）</h3><p><strong>解析：</strong></p>
<ol>
<li>利用 <code>Array.prototype.flat</code></li>
</ol>
<p>ES6 为数组实例新增了 <code>flat</code> 方法，用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数组没有影响。</p>
<p><code>flat</code> 默认只会 “拉平” 一层，如果想要 “拉平” 多层的嵌套数组，需要给 <code>flat</code> 传递一个整数，表示想要拉平的层数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDeep</span>(<span class="params">arr, deepLength</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.flat(deepLength);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flattenDeep([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]], <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDeep</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return arr.join(&#x27;,&#x27;).split(&#x27;,&#x27;).map(Number);</span></span><br><span class="line">  <span class="keyword">return</span> arr.toString().split(<span class="string">&quot;,&quot;</span>).map(<span class="built_in">Number</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flattenDeep([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]]));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用 reduce 和 concat:</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDeep</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(</span><br><span class="line">    (acc, val) =&gt;</span><br><span class="line">      <span class="built_in">Array</span>.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flattenDeep([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]]));</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 stack 无限反嵌套多层嵌套数组</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDeep</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [...input];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="comment">// 使用 pop 从 stack 中取出并移除值</span></span><br><span class="line">    <span class="keyword">const</span> next = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(next)) &#123;</span><br><span class="line">      <span class="comment">// 使用 push 送回内层数组中的元素，不会改动原始输入 original input</span></span><br><span class="line">      stack.push(...next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.push(next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用 reverse 恢复原数组的顺序</span></span><br><span class="line">  <span class="keyword">return</span> res.reverse();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flattenDeep([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]]));</span><br></pre></td></tr></table></figure>

<h3 id="19-可迭代对象有什么特点-（2019-10-14）"><a href="#19-可迭代对象有什么特点-（2019-10-14）" class="headerlink" title="19. 可迭代对象有什么特点 （2019-10-14）"></a>19. 可迭代对象有什么特点 （2019-10-14）</h3><p>ES6 规定，默认的 <code>Iterator</code> 接口部署在数据结构的 <code>Symbol.iterator</code> 属性，换个角度，也可以认为，一个数据结构只要具有 <code>Symbol.iterator</code> 属性(<code>Symbol.iterator</code> 方法对应的是遍历器生成函数，返回的是一个遍历器对象)，那么就可以其认为是可迭代的。</p>
<p><strong>可迭代对象的特点</strong></p>
<ul>
<li>具有 <code>Symbol.iterator</code> 属性，<code>Symbol.iterator()</code> 返回的是一个遍历器对象</li>
<li>可以使用 <code>for ... of</code> 进行循环</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> iter = array[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">//&#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">//&#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">//&#123; value: 3, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>原生具有 <code>Iterator</code> 接口的数据结构：</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<h4 id="自定义一个可迭代对象"><a href="#自定义一个可迭代对象" class="headerlink" title="自定义一个可迭代对象"></a>自定义一个可迭代对象</h4><p>上面我们说，一个对象只有具有正确的 <code>Symbol.iterator</code> 属性，那么其就是可迭代的，因此，我们可以通过给对象新增 <code>Symbol.iterator</code> 使其可迭代</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  job: <span class="string">&quot;engineer&quot;</span>,</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(self);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; keys.length; index++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> self[keys[index]]; <span class="comment">//yield表达式仅能使用在 Generator 函数中</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">//Yvette 18 engineer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="【Step-By-Step】高频面试题深入解析-周刊-05-本周面试题一览"><a href="#【Step-By-Step】高频面试题深入解析-周刊-05-本周面试题一览" class="headerlink" title="【Step-By-Step】高频面试题深入解析 / 周刊 05 本周面试题一览:"></a>【Step-By-Step】高频面试题深入解析 / 周刊 05 本周面试题一览:</h2><blockquote>
<p>本周面试题一览:</p>
<p>####</p>
</blockquote>
<ul>
<li>实现 Promise.race 方法</li>
<li>JSONP 原理及简单实现</li>
<li>实现一个数组去重的方法</li>
<li>清楚浮动的方法有哪些</li>
<li>编写一个通用的柯里化函数 currying</li>
</ul>
<h3 id="20-实现-Promise-race-方法（2019-10-16）"><a href="#20-实现-Promise-race-方法（2019-10-16）" class="headerlink" title="20. 实现 Promise.race 方法（2019-10-16）"></a>20. 实现 Promise.race 方法（2019-10-16）</h3><p>在实现 <code>Promise.race</code> 方法之前，我们首先要知道 <code>Promise.race</code> 的功能和特点，因为在清楚了 <code>Promise.race</code> 功能和特点的情况下，我们才能进一步去写实现。</p>
<p><strong>Promise.race 功能</strong></p>
<p><code>Promise.race(iterable)</code> 返回一个 promise，一旦 <code>iterable</code> 中的一个 <code>promise</code> 状态是 <code>fulfilled</code> / <code>rejected</code> ，那么 <code>Promise.race</code> 返回的 <code>promise</code> 状态是 <code>fulfilled</code> / <code>rejected</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 <code>Promise</code> 实例的返回值，就传递给 p 的回调函数。</p>
<p><strong>Promise.race 的特点</strong></p>
<blockquote>
<p>Promise.race 的返回值是一个 promise 实例</p>
</blockquote>
<ul>
<li>如果传入的参数为空的可迭代对象，那么 <code>Promise.race</code> 返回的 <code>promise</code> 永远是 <code>pending</code> 态</li>
<li>如果传入的参数中不包含任何 <code>promise</code>，<code>Promise.race</code> 会返回一个处理中（pending）的 <code>promise</code></li>
<li>如果 <code>iterable</code> 包含一个或多个非 <code>promise</code> 值或已经解决的 promise，则 <code>Promise.race</code> 将解析为 <code>iterable</code> 中找到的第一个值。</li>
</ul>
<p><strong>Promise.race 的实现</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//promises传入的是可迭代对象(省略参数合法性判断)</span></span><br><span class="line">  promises = <span class="built_in">Array</span>.from(promises); <span class="comment">//将可迭代对象转换为数组</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//空的可迭代对象;</span></span><br><span class="line">      <span class="comment">//用于在pending态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i])</span><br><span class="line">          .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="21-JSONP-原理及简单实现-2019-10-17"><a href="#21-JSONP-原理及简单实现-2019-10-17" class="headerlink" title="21. JSONP 原理及简单实现 (2019-10-17)"></a>21. JSONP 原理及简单实现 (2019-10-17)</h3><p>尽管浏览器有同源策略，但是 <code>&lt;script&gt;</code> 标签的 <code>src</code> 属性不会被同源策略所约束，可以获取任意服务器上的脚本并执行。<code>jsonp</code> 通过插入 <code>script</code> 标签的方式来实现跨域，参数只能通过 <code>url</code> 传入，仅能支持 <code>get</code> 请求。</p>
<p><strong>实现原理:</strong></p>
<ul>
<li>Step1: 创建 callback 方法</li>
<li>Step2: 插入 script 标签</li>
<li>Step3: 后台接受到请求，解析前端传过去的 callback 方法，返回该方法的调用，并且数据作为参数传入该方法</li>
<li>Step4: 前端执行服务端返回的方法调用</li>
</ul>
<p><strong>jsonp 源码实现</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">&#123; url, params, callback &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//创建script标签</span></span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">    <span class="comment">//将回调函数挂在 window 上</span></span><br><span class="line">    <span class="built_in">window</span>[callback] = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      resolve(data);</span><br><span class="line">      <span class="comment">//代码执行后，删除插入的script标签</span></span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(script);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//回调函数加在请求地址上</span></span><br><span class="line">    params = &#123; ...params, callback &#125;; <span class="comment">//wb=b&amp;callback=show</span></span><br><span class="line">    <span class="keyword">let</span> arrs = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      arrs.push(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arrs.join(<span class="string">&quot;&amp;&quot;</span>)&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: <span class="string">&quot;http://localhost:3000/show&quot;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">  &#125;,</span><br><span class="line">  callback: <span class="string">&quot;show&quot;</span>,</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>服务端代码(node):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//express启动一个后台服务</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/show&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; callback &#125; = req.query; <span class="comment">//获取传来的callback函数名，callback是key</span></span><br><span class="line">  res.send(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;Hello!&#x27;)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="22、实现一个数组去重的方法-2019-10-18"><a href="#22、实现一个数组去重的方法-2019-10-18" class="headerlink" title="22、实现一个数组去重的方法 (2019-10-18)"></a>22、实现一个数组去重的方法 (2019-10-18)</h3><ol>
<li>法 1: 利用 ES6 新增数据类型 <code>Set </code> ：[…new Set(arry)</li>
<li>利用 <code>indexOf</code> <code>includes</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">arry</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arry.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.indexOf(arry[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">//如 result 中没有 arry[i],则添加到数组中</span></span><br><span class="line">      result.push(arry[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>利用 <code>reduce</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">arry</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arry.reduce(</span><br><span class="line">    (prev, cur) =&gt; (prev.includes(cur) ? prev : [...prev, cur]),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>利用 <code>Map</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">arry</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arry.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(arry[i])) &#123;</span><br><span class="line">      map.set(arry[i], <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map.set(arry[i], <span class="literal">false</span>);</span><br><span class="line">      result.push(arry[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23、清除浮动的方法有哪些？-2019-10-20"><a href="#23、清除浮动的方法有哪些？-2019-10-20" class="headerlink" title="23、清除浮动的方法有哪些？ (2019-10-20)"></a>23、清除浮动的方法有哪些？ (2019-10-20)</h3><p><strong>解析：</strong></p>
<p>总体来说就两点吧：</p>
<ol>
<li>利用 clear 元素</li>
<li>利用 BFC 布局规则</li>
</ol>
<h3 id="24-编写一个通用的柯里化函数-currying-2019-10-20"><a href="#24-编写一个通用的柯里化函数-currying-2019-10-20" class="headerlink" title="24. 编写一个通用的柯里化函数 currying (2019-10-20)"></a>24. 编写一个通用的柯里化函数 currying (2019-10-20)</h3><p>在开始之前，我们首先需要搞清楚函数<a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/42">柯里化</a>的概念。</p>
<blockquote>
<p>curry 的这种用途可以理解为：参数复用。本质上是降低通用性，提高适用性。</p>
</blockquote>
<p>函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currying = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span></span><br><span class="line">  args.length &lt; fn.length</span><br><span class="line">    ? <span class="comment">//参数长度不足时，重新柯里化该函数，等待接受新参数</span></span><br><span class="line">      (...arguments) =&gt; currying(fn, ...args, ...arguments)</span><br><span class="line">    : <span class="comment">//参数长度满足时，执行函数</span></span><br><span class="line">      fn(...args);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumFn</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = currying(sumFn);</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">5</span>)); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>)(<span class="number">3</span>, <span class="number">5</span>)); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>, <span class="number">3</span>)(<span class="number">5</span>)); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数柯里化的主要作用：</p>
</blockquote>
<ul>
<li>参数复用</li>
<li>提前返回 – 返回接受余下的参数且返回结果的新函数</li>
<li>延迟执行 – 返回新函数，等待执行</li>
</ul>
<h2 id="【Step-By-Step】高频面试题深入解析-周刊-06"><a href="#【Step-By-Step】高频面试题深入解析-周刊-06" class="headerlink" title="【Step-By-Step】高频面试题深入解析 / 周刊 06"></a>【Step-By-Step】高频面试题深入解析 / 周刊 06</h2><blockquote>
<p>本周面试题一览:</p>
</blockquote>
<ul>
<li>原型链继承的基本思路是什么？有什么优缺点？</li>
<li>借用构造函数和组合继承基本思路是什么？有什么优缺点？</li>
<li>原型式继承的基本思路是什么？有什么优缺点？</li>
<li>寄生式继承的基本思路是什么？有什么优缺点？</li>
<li>寄生组合式继承的基本思路是什么？有什么优缺点？</li>
</ul>
<p>本周是继承专题，在开始之前，需要先了解构造函数、原型和原型链的相关知识。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>构造函数和普通函数的区别仅在于调用它们的方式不同，任何函数，只要通过 <code>new</code> 操作符来调用，那它就可以作为构造函数；任何函数，如果不通过 <code>new</code> 操作符来调用，那么它就是一个普通函数。</p>
<p>实例拥有 <code>constructor(构造函数)</code> 属性，该属性返回创建实例对象的构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Yvette = <span class="keyword">new</span> Person(<span class="string">&quot;刘小夕&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Yvette.constructor === Person); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>有一点需要说明的是，除了基本数据类型的 <code>constructor</code> 外( <code>null</code> 和 <code>undefined</code> 无 <code>constructor</code> 属性)，<code>constructor</code> 属性是可以被重写的。因此检测对象类型时，<code>instanceof</code> 操作符比 <code>contsrutor</code> 更可靠一些。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> Yvette = <span class="keyword">new</span> Person(<span class="string">&quot;刘小夕&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Yvette.constructor); <span class="comment">//[Function: Person]</span></span><br><span class="line">Yvette.constructor = SuperType;</span><br><span class="line"><span class="built_in">console</span>.log(Yvette.constructor); <span class="comment">//[Function: SuperType]</span></span><br></pre></td></tr></table></figure>

<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>我们创建的每个函数都有 <code>prototype</code> 属性，这个属性指向函数的原型对象。原型对象的<strong>用途</strong>是包含可以由特定类型的所有实例共享的属性和方法。</p>
<p>在默认情况下，所有原型对象都会自动获得一个 <code>constructor</code> 属性，这个属性包含一个指向 <code>prototype</code> 属性所在函数的指针。</p>
<p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针，指向构造函数的原型对象(可以通过实例的 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/34183746"><code>__proto__</code></a> 来访问构造函数的原型对象)。 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/34183746">参考</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f.prototype.sayhi = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> f();</span><br><span class="line"><span class="built_in">console</span>.log(f.prototype); <span class="comment">//f &#123; sayhi: [Function] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.prototype.constructor); <span class="comment">//[Function: f]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__); <span class="comment">//f &#123; sayhi: [Function] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.__proto__); <span class="comment">//[Function]</span></span><br></pre></td></tr></table></figure>

<p>总结： 1.对象有属性<strong>proto</strong>,指向该对象的构造函数的原型对象。 2.方法除了有属性<strong>proto</strong>,还有属性 prototype，prototype 指向该方法的原型对象。</p>
<p>讲完啦，欢迎各种批评指正完善探讨，共同进步~</p>
<p><img src="https://camo.githubusercontent.com/16602b6909621ce63a882221389c062c4d032256/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f7075626c69632f7265736f757263652f66343537303163633431303530346537316462626362643838363165386430632f786d6c6e6f74652f5745425245534f5552434534366564343366333030363430353439383465356332346466373930393962312f3239353432"></p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>简单回顾一下构造函数、原型和实例的关系：</p>
<p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个可以执行原型对象的内部指针(可以通过 <code>__proto</code> 访问)。</p>
<p>假如我们让原型对象等于另一个类型的实例，那么此时原型对象包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。加入另一个原型又是另一个类型的实例，那么上述关系仍然成立，如此层层递进，就构成了实例与原型的链条，这就是原型链的基本概念</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&quot;animal&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getType = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.type);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SimType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">SimType.prototype = <span class="keyword">new</span> SubType();</span><br><span class="line">SimType.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SimType(<span class="string">&quot;刘小夕&quot;</span>);</span><br><span class="line">instance.getType(); <span class="comment">//animal</span></span><br></pre></td></tr></table></figure>

<p><img src="https://camo.githubusercontent.com/bb69ed50e52bf2d899a093cbe685074f28cacc0f/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f7075626c69632f7265736f757263652f66343537303163633431303530346537316462626362643838363165386430632f786d6c6e6f74652f5745425245534f5552434565333233613738316338613737653239363833373531643965333236653139342f3239353434"></p>
<p>调用 <code>instance.getType()</code> 会调用以下的搜索步骤:</p>
<ol>
<li>搜索 <code>instance</code> 实例</li>
<li>搜索 <code>SimType.prototype</code></li>
<li>搜索 <code>SubType.prototype</code></li>
<li>搜索 <code>SuperType.prototype</code>，找到了 <code>getType</code> 方法</li>
</ol>
<p>在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链的末端才会停下来。</p>
<p>所有引用类型都继承了 <code>Object</code>，这个继承也是通过原型链实现的。如果在 <code>SuperType.prototype</code> 还没有找到 <code>getType</code>，就会到 <code>Object.prototype</code>中找(图中少画了一环)。</p>
<h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>原型链继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<p>如 <code>SubType.prototype = new SuperType()</code>;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;Yvette&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(SubType.prototype.constructor) //[Function: SuperType]</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.getName()); <span class="comment">//&#x27;Yvette&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>可以看出 <code>colors</code> 属性会被所有的实例共享(instance1、instance2、…)。</p>
<blockquote>
<p>缺点：</p>
</blockquote>
<ol>
<li>通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享。</li>
<li>在创建子类型的实例时，没有办法在不影响所有对象实例的情况下给超类型的构造函数中传递参数。</li>
</ol>
<h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><p><strong>借用构造函数</strong>的技术，其基本思想为:</p>
<p>在子类型的构造函数中调用超类型构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> intance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;zc&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(intance1.name); <span class="comment">//zc</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>优点:</p>
</blockquote>
<ol>
<li>可以向超类传递参数</li>
<li>解决了原型中包含引用类型值被所有实例共享的问题</li>
</ol>
<blockquote>
<p>缺点:</p>
</blockquote>
<ol>
<li>方法都在构造函数中定义，函数复用无从谈起，另外超类型原型中定义的方法对于子类型而言都是不可见的。</li>
</ol>
<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>组合继承指的是将原型链和借用构造函数技术组合到一块，从而发挥二者之长的一种继承模式。基本思路：</p>
<p>使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// console.log(SuperType)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuberType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuberType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SuberType.prototype.constructor = SuberType;</span><br><span class="line">SuberType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SuberType(<span class="string">&quot;Yvette&quot;</span>, <span class="number">20</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27; ]</span></span><br><span class="line">instance1.sayName(); <span class="comment">//Yvette</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SuberType(<span class="string">&quot;Jack&quot;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ]</span></span><br><span class="line">instance2.sayName(); <span class="comment">//Jack</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>缺点:</p>
</blockquote>
<ul>
<li>无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</li>
</ul>
<blockquote>
<p>优点:</p>
</blockquote>
<ul>
<li>可以向超类传递参数</li>
<li>每个实例都有自己的属性</li>
<li>实现了函数复用</li>
</ul>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b5dcf8351882519790c9a2e">浅拷贝与深拷贝</a></p>
</blockquote>
<p>原型继承的基本思想：</p>
<p>借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>object()</code> 函数内部，先穿甲一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例，从本质上讲，<code>object()</code> 对传入的对象执行了一次浅拷贝。</p>
<p>ECMAScript5 通过新增 <code>Object.create()</code>方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象(可以覆盖原型对象上的同名属性)，在传入一个参数的情况下，<code>Object.create()</code> 和 <code>object()</code> 方法的行为相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="built_in">Object</span>.create(person);</span><br><span class="line">person1.name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">person1.hobbies.push(<span class="string">&quot;coding&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person);</span><br><span class="line">person2.name = <span class="string">&quot;Echo&quot;</span>;</span><br><span class="line">person2.hobbies.push(<span class="string">&quot;running&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.hobbies); <span class="comment">//[ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27;, &#x27;running&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hobbies); <span class="comment">//[ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27;, &#x27;running&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>在没有必要创建构造函数，仅让一个对象与另一个对象保持相似的情况下，原型式继承是可以胜任的。</p>
<blockquote>
<p>缺点:</p>
</blockquote>
<p>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。</p>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//以某种方式增强这个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = createAnother(person);</span><br><span class="line">person2.sayHi(); <span class="comment">//hi</span></span><br></pre></td></tr></table></figure>

<p>基于 <code>person</code> 返回了一个新对象 -—— <code>person2</code>，新对象不仅具有 <code>person</code> 的所有属性和方法，而且还有自己的 <code>sayHi()</code> 方法。在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。</p>
<blockquote>
<p>缺点：</p>
</blockquote>
<ul>
<li>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。</li>
<li>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。</li>
</ul>
<h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，基本思路：</p>
<p>不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">  prototype.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">  subType.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一步：创建超类型原型的一个副本</li>
<li>第二步：为创建的副本添加 <code>constructor</code> 属性</li>
<li>第三步：将新创建的对象赋值给子类型的原型</li>
</ul>
<p>至此，我们就可以通过调用 <code>inheritPrototype</code> 来替换为子类型原型赋值的语句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...code</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuberType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SuberType, SuperType);</span><br><span class="line"><span class="comment">//...code</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>优点:</p>
</blockquote>
<p>只调用了一次超类构造函数，效率更高。避免在<code>SuberType.prototype</code>上面创建不必要的、多余的属性，与其同时，原型链还能保持不变。</p>
<p>因此寄生组合继承是引用类型最理性的继承范式。</p>
<h4 id="ES6-继承"><a href="#ES6-继承" class="headerlink" title="ES6 继承"></a>ES6 继承</h4><p><code>Class</code> 可以通过 extends 关键字实现继承，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age) &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age, name) &#123;</span><br><span class="line">    <span class="built_in">super</span>(age); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType(<span class="number">22</span>, <span class="string">&quot;刘小夕&quot;</span>);</span><br><span class="line">instance.getAge(); <span class="comment">//22</span></span><br></pre></td></tr></table></figure>

<p>对于 ES6 的 <code>class</code> 需要做以下几点说明：</p>
<ol>
<li>类的数据类型就是函数，类本身就指向构造函数。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> SuperType); <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(SuperType === SuperType.prototype.constructor); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>类的内部所有定义的方法，都是不可枚举的。(ES5 原型上的方法默认是可枚举的)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(SuperType.prototype);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>constructor</code> 方法是类的默认方法，通过 <code>new</code> 命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code> 方法，如果没有显式定义，一个空的 <code>constructor</code> 方法会被默认添加。</li>
<li><code>Class</code> 不能像构造函数那样直接调用，会抛出错误。</li>
</ol>
<p>使用 <code>extends</code> 关键字实现继承，有一点需要特别说明：</p>
<ul>
<li>子类必须在 <code>constructor</code> 中调用 <code>super</code> 方法，否则新建实例时会报错。如果没有子类没有定义 <code>constructor</code> 方法，那么这个方法会被默认添加。在子类的构造函数中，只有调用 <code>super</code> 之后，才能使用 <code>this</code>关键字，否则报错。这是因为子类实例的构建，基于父类实例，只有 super 方法才能调用父类实例。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="built_in">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="【Step-By-Step】高频面试题深入解析-周刊-07"><a href="#【Step-By-Step】高频面试题深入解析-周刊-07" class="headerlink" title="【Step-By-Step】高频面试题深入解析 / 周刊 07"></a>【Step-By-Step】高频面试题深入解析 / 周刊 07</h2><blockquote>
<p>本周面试题一览:</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/39">实现一个 JSON.stringify</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/40">实现一个 JSON.parse</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/41">实现一个观察者模式</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/42">使用 CSS 让一个元素水平垂直居中有哪些方式</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Step-By-Step/issues/43">ES6 模块和 CommonJS 模块有哪些差异？</a></li>
</ul>
<h3 id="1-实现一个-JSON-stringify-（2019-10-27）"><a href="#1-实现一个-JSON-stringify-（2019-10-27）" class="headerlink" title="1. 实现一个 JSON.stringify （2019-10-27）"></a>1. 实现一个 <code>JSON.stringify</code> （2019-10-27）</h3><p><code>JSON.stringify([, replacer [, space])</code> 方法是将一个 JavaScript 值(对象或者数组)转换为一个 JSON 字符串。此处模拟实现，不考虑可选的第二个参数 <code>replacer</code> 和第三个参数 <code>space</code>，如果对这两个参数的作用还不了解，建议阅读 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">MDN</a> 文档。</p>
<blockquote>
<p><code>JSON.stringify()</code> 将值转换成对应的 <code>JSON</code> 格式:</p>
</blockquote>
<p>1、基本数据类型：</p>
<ul>
<li>undefined 转换之后仍是 undefined(类型也是 <code>undefined</code>)</li>
<li>boolean 值转换之后是字符串 <code>&quot;false&quot;/&quot;true&quot;</code></li>
<li>number 类型(除了 <code>NaN</code> 和 <code>Infinity</code>)转换之后是字符串类型的数值</li>
<li>symbol 转换之后是 <code>undefined</code></li>
<li>null 转换之后是字符串 <code>&quot;null&quot;</code></li>
<li>string 转换之后仍是 string</li>
<li><code>NaN</code> 和 <code>Infinity</code> 转换之后是字符串 <code>&quot;null&quot;</code></li>
</ul>
<p>2、如果是函数类型</p>
<ul>
<li>转换之后是 <code>undefined</code></li>
</ul>
<p>3、如果是对象类型(非函数)</p>
<ul>
<li>如果有 <code>toJSON()</code> 方法，那么序列化 <code>toJSON()</code> 的返回值。</li>
<li>如果是一个数组<ul>
<li>如果属性值中出现了 <code>undefined</code>、任意的函数以及 <code>symbol</code>，转换成字符串 <code>&quot;null&quot;</code></li>
</ul>
</li>
<li>如果是 <code>RegExp</code> 对象。<br>返回 <code>&#123;&#125;</code> (类型是 string)</li>
<li>如果是 <code>Date</code> 对象，返回 <code>Date</code> 的 <code>toJSON</code> 字符串值</li>
<li>如果是普通对象；<ul>
<li>如果属性值中出现了 <code>undefined</code>、任意的函数以及 symbol 值，忽略。</li>
<li>所有以 <code>symbol</code> 为属性键的属性都会被完全忽略掉。</li>
</ul>
</li>
</ul>
<p>4、对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。</p>
<blockquote>
<p>模拟实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonStringify</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dataType = <span class="keyword">typeof</span> data;</span><br><span class="line">  <span class="keyword">if</span> (dataType !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = data;</span><br><span class="line">    <span class="comment">//data 可能是 string/number/null/undefined/boolean</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(data) || data === <span class="literal">Infinity</span>) &#123;</span><br><span class="line">      <span class="comment">//NaN 和 Infinity 序列化返回 &quot;null&quot;</span></span><br><span class="line">      result = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      dataType === <span class="string">&quot;function&quot;</span> ||</span><br><span class="line">      dataType === <span class="string">&quot;undefined&quot;</span> ||</span><br><span class="line">      dataType === <span class="string">&quot;symbol&quot;</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">//function 、undefined 、symbol 序列化返回 undefined</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataType === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      result = <span class="string">&#x27;&quot;&#x27;</span> + data + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//boolean 返回 String()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(result);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataType === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.toJSON &amp;&amp; <span class="keyword">typeof</span> data.toJSON === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> jsonStringify(data.toJSON());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> result = [];</span><br><span class="line">      <span class="comment">//如果是数组</span></span><br><span class="line">      <span class="comment">//toJSON 方法可以存在于原型链中</span></span><br><span class="line">      data.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          <span class="keyword">typeof</span> item === <span class="string">&quot;undefined&quot;</span> ||</span><br><span class="line">          <span class="keyword">typeof</span> item === <span class="string">&quot;function&quot;</span> ||</span><br><span class="line">          <span class="keyword">typeof</span> item === <span class="string">&quot;symbol&quot;</span></span><br><span class="line">        ) &#123;</span><br><span class="line">          result[index] = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          result[index] = jsonStringify(item);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      result = <span class="string">&quot;[&quot;</span> + result + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> result.replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//普通对象</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 循环引用抛错(暂未检测，循环引用时，堆栈溢出)</span></span><br><span class="line"><span class="comment">       * symbol key 忽略</span></span><br><span class="line"><span class="comment">       * undefined、函数、symbol 为属性值，被忽略</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">let</span> result = [];</span><br><span class="line">      <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&quot;symbol&quot;</span>) &#123;</span><br><span class="line">          <span class="comment">//key 如果是symbol对象，忽略</span></span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            data[item] !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">            <span class="keyword">typeof</span> data[item] !== <span class="string">&quot;function&quot;</span> &amp;&amp;</span><br><span class="line">            <span class="keyword">typeof</span> data[item] !== <span class="string">&quot;symbol&quot;</span></span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="comment">//键值如果是 undefined、函数、symbol 为属性值，忽略</span></span><br><span class="line">            result.push(<span class="string">&#x27;&quot;&#x27;</span> + item + <span class="string">&#x27;&quot;&#x27;</span> + <span class="string">&quot;:&quot;</span> + jsonStringify(data[item]));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> (<span class="string">&quot;&#123;&quot;</span> + result + <span class="string">&quot;&#125;&quot;</span>).replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-实现一个-JSON-parse-（2019-10-28）"><a href="#2-实现一个-JSON-parse-（2019-10-28）" class="headerlink" title="2. 实现一个 JSON.parse  （2019-10-28）"></a>2. 实现一个 <code>JSON.parse </code> （2019-10-28）</h3><p><code>JSON.parse(JSON.parse(text[, reviver])</code> 方法用来解析 JSON 字符串，构造由字符串描述的 JavaScript 值或对象。提供可选的 reviver 函数用以在返回之前对所得到的对象执行变换。此处模拟实现，不考虑可选的第二个参数 <code>reviver</code> ，如果对这个参数的作用还不了解，建议阅读 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">MDN</a> 文档。</p>
<p><strong>第一种方式 eval</strong></p>
<p>最简单，最直观的方式就是调用 <code>eval</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;小姐姐&quot;, &quot;age&quot;:20&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> + json + <span class="string">&quot;)&quot;</span>); <span class="comment">// obj 就是 json 反序列化之后得到的对象</span></span><br></pre></td></tr></table></figure>

<p>直接调用 <code>eval</code> 存在 <code>XSS</code> 漏洞，数据中可能不是 <code>json</code> 数据，而是可执行的 <code>JavaScript</code> 代码。因此，在调用 <code>eval</code> 之前，需要对数据进行校验。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rx_one = <span class="regexp">/^[\],:&#123;&#125;\s]*$/</span>;</span><br><span class="line"><span class="keyword">var</span> rx_two = <span class="regexp">/\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_three = <span class="regexp">/&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_four = <span class="regexp">/(?:^|:|,)(?:\s*\[)+/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  rx_one.test(</span><br><span class="line">    json.replace(rx_two, <span class="string">&quot;@&quot;</span>).replace(rx_three, <span class="string">&quot;]&quot;</span>).replace(rx_four, <span class="string">&quot;&quot;</span>)</span><br><span class="line">  )</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> + json + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JSON</code> 是 JS 的子集，可以直接交给 <code>eval</code> 运行。</p>
<p><strong>第二种方式 <code>new Function</code></strong></p>
<p><code>Function</code> 与 <code>eval</code> 有相同的字符串参数特性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;小姐姐&quot;, &quot;age&quot;:20&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;return &quot;</span> + json)();</span><br></pre></td></tr></table></figure>

<h3 id="3-实现一个观察者模式-（2019-10-29）"><a href="#3-实现一个观察者模式-（2019-10-29）" class="headerlink" title="3. 实现一个观察者模式 （2019-10-29）"></a>3. 实现一个观察者模式 （2019-10-29）</h3><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯。</p>
<p>观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有一家猎人工会，其中每个猎人都具有发布任务(publish)，订阅任务(subscribe)的功能</span></span><br><span class="line"><span class="comment">//他们都有一个订阅列表来记录谁订阅了自己</span></span><br><span class="line"><span class="comment">//定义一个猎人类</span></span><br><span class="line"><span class="comment">//包括姓名，级别，订阅列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hunter</span>(<span class="params">name, level</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.level = level;</span><br><span class="line">  <span class="built_in">this</span>.list = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Hunter.prototype.publish = <span class="function"><span class="keyword">function</span> (<span class="params">money</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.level + <span class="string">&quot;猎人&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;寻求帮助&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.list.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">    item(money);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Hunter.prototype.subscribe = <span class="function"><span class="keyword">function</span> (<span class="params">targrt, fn</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.level + <span class="string">&quot;猎人&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;订阅了&quot;</span> + targrt.name);</span><br><span class="line">  targrt.list.push(fn);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//猎人工会走来了几个猎人</span></span><br><span class="line"><span class="keyword">let</span> hunterMing = <span class="keyword">new</span> Hunter(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;黄金&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hunterJin = <span class="keyword">new</span> Hunter(<span class="string">&quot;小金&quot;</span>, <span class="string">&quot;白银&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hunterZhang = <span class="keyword">new</span> Hunter(<span class="string">&quot;小张&quot;</span>, <span class="string">&quot;黄金&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hunterPeter = <span class="keyword">new</span> Hunter(<span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;青铜&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Peter等级较低，可能需要帮助，所以小明，小金，小张都订阅了Peter</span></span><br><span class="line">hunterMing.subscribe(hunterPeter, <span class="function"><span class="keyword">function</span> (<span class="params">money</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&quot;小明表示：&quot;</span> + (money &gt; <span class="number">200</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;暂时很忙，不能&quot;</span>) + <span class="string">&quot;给予帮助&quot;</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line">hunterJin.subscribe(hunterPeter, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;小金表示：给予帮助&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">hunterZhang.subscribe(hunterPeter, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;小张表示：给予帮助&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Peter遇到困难，赏金198寻求帮助</span></span><br><span class="line">hunterPeter.publish(<span class="number">198</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//猎人们(观察者)关联他们感兴趣的猎人(目标对象)，如Peter，当Peter有困难时，会自动通知给他们（观察者）</span></span><br></pre></td></tr></table></figure>

<h3 id="5-ES6-模块和-CommonJS-模块有哪些差异？（2019-10-30）"><a href="#5-ES6-模块和-CommonJS-模块有哪些差异？（2019-10-30）" class="headerlink" title="5. ES6 模块和 CommonJS 模块有哪些差异？（2019-10-30）"></a>5. ES6 模块和 <code>CommonJS</code> 模块有哪些差异？（2019-10-30）</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/YvetteLau/Blog/issues/38">参考</a></p>
</blockquote>
<ol>
<li><code>CommonJS</code> 模块是运行时加载，ES6 模块是编译时输出接口。</li>
</ol>
<ul>
<li>ES6 模块在编译时，就能确定模块的依赖关系，以及输入和输出的变量。ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>
<li><code>CommonJS</code> 加载的是一个对象，该对象只有在脚本运行完才会生成。</li>
</ul>
<ol start="2">
<li><code>CommonJS</code> 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
</ol>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- `CommonJS` 输出的是一个值的拷贝(注意基本数据类型/复杂数据类型)</span><br><span class="line"></span><br><span class="line">- ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>ES6 模块自动采用严格模式，无论模块头部是否写了 <code>&quot;use strict&quot;;</code></li>
<li>require 可以做动态加载，<code>import</code> 语句做不到，<code>import</code> 语句必须位于顶层作用域中。</li>
<li>ES6 模块的输入变量是只读的，不能对其进行重新赋值</li>
<li>当使用 require 命令加载某个模块时，就会运行整个模块的代码。</li>
<li>当使用 require 命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%89%9B%E4%BA%BA%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">牛人面试题</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-ComplexityAnalysis"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/09/11/ComplexityAnalysis/"
    >面试中的复杂度分析</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/09/11/ComplexityAnalysis/" class="article-date">
  <time datetime="2019-09-11T11:56:35.000Z" itemprop="datePublished">2019-09-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/">玩转算法面试</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="面试中的复杂度分析"><a href="#面试中的复杂度分析" class="headerlink" title="面试中的复杂度分析"></a>面试中的复杂度分析</h1><blockquote>
<p>很多同学一提起复杂度分析就头疼，马上想起了《算法导论》中复杂的数学推导。但其实在一般的企业面试中，对复杂度的分析要求并没有那么高，但也是绕不过去的坎儿。在这一章，和大家介绍一下，面试中需要掌握的复杂度分析。…</p>
</blockquote>
<h2 id="2-1-究竟什么是大-O（Big-O）"><a href="#2-1-究竟什么是大-O（Big-O）" class="headerlink" title="2-1 究竟什么是大 O（Big O）"></a>2-1 究竟什么是大 O（Big O）</h2><h4 id="大-O？"><a href="#大-O？" class="headerlink" title="大 O？"></a>大 O？</h4><ul>
<li>n 表示数据规模</li>
<li>O（f(n)）表示运行算法所需要执行的指令数，和 f(n) 成正比</li>
</ul>
<h4 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h4><ul>
<li>二分查找法 O(logn) — 所需执行指令数 ：a * logn</li>
<li>寻找 数组中的最大/最小值 O(n) — 所需执行指令数 ：b * n</li>
<li>归并排序算法 O(nlogn) — 所需执行指令数 ：c * nlogn</li>
<li>选择排序法 O(n^2) — 所需执行指令数 ：d * n^2</li>
</ul>
<h3 id="到底什么是-Big-O？"><a href="#到底什么是-Big-O？" class="headerlink" title="到底什么是 Big O？"></a>到底什么是 Big O？</h3><p><img src="http://static.zxinc520.com/blog/20190909/61aLQ2wE8prQ.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190909/2PO7UfwEDOpW.png?imageslim" alt="mark"></p>
<p><strong>在学术界</strong>，严格来讲，O(f(n)) 表示算法执行的上界</p>
<p>归并排序算法的时间复杂度是 O(nlogn)的，同时也是 O（n^2）</p>
<p><strong>在业界</strong>，我们就使用 O 来表示算法执行的最低上界</p>
<p>我们一般不会说归并排序是 O(n^2)的</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>O（nlogn + n）= O （nlogn）</li>
<li>O（nlogn + n^2）=O（n^2）</li>
</ul>
<h4 id="无法判断"><a href="#无法判断" class="headerlink" title="无法判断"></a>无法判断</h4><ul>
<li><p>O（AlogA + B） – A 与 B 无法确定</p>
</li>
<li><p>O（AlogA + B ^2）</p>
</li>
<li><p>对邻接表实现的图进行遍历</p>
<ul>
<li>时间复杂度：O（ V + E ）</li>
</ul>
</li>
</ul>
<h3 id="一个时间复杂度的问题"><a href="#一个时间复杂度的问题" class="headerlink" title="一个时间复杂度的问题"></a>一个时间复杂度的问题</h3><p>有一个字符串数组，将数组中的每一个字符串按照字母序排序；之后再将整个字符串数组按照字典序排序。整个操作的时间复杂度？</p>
<p><img src="http://static.zxinc520.com/blog/20190909/8cfiXUHkirne.png?imageslim" alt="mark"></p>
<p>正确解答：</p>
<ul>
<li>假设最长的字符串长度为 s ；数组中有 n 个字符串</li>
<li>对每个字符串排序：O（slogs）</li>
<li>将数组中的每一个字符串按照字母序排序：O（n * slog(s) ）</li>
<li>将整个字符串数组按照字典序排序：O（s * nlog(n) ）</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190909/Q5nKtKe1dCi7.png?imageslim" alt="mark"></p>
<h3 id="算法复杂度在有些情况是用例相关的"><a href="#算法复杂度在有些情况是用例相关的" class="headerlink" title="算法复杂度在有些情况是用例相关的"></a>算法复杂度在有些情况是用例相关的</h3><ul>
<li><p>插入排序 O（n ^ 2）</p>
<ul>
<li>最差情况：O（n ^ 2）</li>
<li>最好情况：O（n）</li>
<li>平均情况：O（n ^ 2）</li>
</ul>
</li>
<li><p>快速排序算法 O （nlogn）</p>
<ul>
<li>最差情况：O（n ^ 2）</li>
<li>最好情况：O（ nlogn ）</li>
<li>平均情况：O（ nlogn ）</li>
</ul>
</li>
</ul>
<h2 id="2-2-对数据规模有一个概念"><a href="#2-2-对数据规模有一个概念" class="headerlink" title="2-2 对数据规模有一个概念"></a>2-2 对数据规模有一个概念</h2><h3 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h3><p>对 10 ^ 5 的数据进行选择排序，结果计算机假死？</p>
<ul>
<li>如果要想在 1s 之内解决问题：<ul>
<li>O（n ^ 2）的算法可以处理大约 10 ^ 4 级别的数据</li>
<li>O（ n ）的算法可以处理大约 10 ^ 8 级别的数据</li>
<li>O（ nlogn ）的算法可以处理大约 10 ^7 级别的数据</li>
</ul>
</li>
</ul>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul>
<li>多开一个辅助的数组：O（n）</li>
<li>多开一个辅助的二维数组：O（n ^ 2）</li>
<li>多开常数空间：O（1）</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190909/7uFcA2L2OHhI.png?imageslim" alt="mark"></p>
<h2 id="2-3-简单的复杂度分析"><a href="#2-3-简单的复杂度分析" class="headerlink" title="2-3 简单的复杂度分析"></a>2-3 简单的复杂度分析</h2><h3 id="O（1）："><a href="#O（1）：" class="headerlink" title="O（1）："></a>O（1）：</h3><p><img src="http://static.zxinc520.com/blog/20190909/wmyLLvW5hvGh.png?imageslim" alt="mark"></p>
<h3 id="O（-n-）："><a href="#O（-n-）：" class="headerlink" title="O（ n ）："></a>O（ n ）：</h3><p><img src="http://static.zxinc520.com/blog/20190909/R4zqgJ9zJqqs.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190909/fujJT4N78Ybh.png?imageslim" alt="mark"></p>
<p>1/2 *n 次 swap 操作也是：O(n) 。</p>
<h3 id="O（n-2）-选择排序"><a href="#O（n-2）-选择排序" class="headerlink" title="O（n ^ 2）: ( 选择排序 )"></a>O（n ^ 2）: ( 选择排序 )</h3><p><img src="http://static.zxinc520.com/blog/20190909/HPtrTeSx6DsB.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190909/rh5JcB9dA8ux.png?imageslim" alt="mark"></p>
<p>并不是所有双重循环都是 O（n ^ 2）：例如 【因为里面的循环次数是固定的 】</p>
<p><img src="http://static.zxinc520.com/blog/20190909/Vs0lBjzBPEi9.png?imageslim" alt="mark"></p>
<p>下面算法是 O（logn）级别的： 【 自增并不是每次都加 1 】</p>
<p><img src="http://static.zxinc520.com/blog/20190909/QJC2YLSAOdAk.png?imageslim" alt="mark"></p>
<p>下面算法是 O（ sqrt (n) ）【 判断 n 是不是 一个素数】</p>
<p><img src="http://static.zxinc520.com/blog/20190909/QeClcFN8EsWa.png?imageslim" alt="mark"></p>
<h3 id="O（logn）：（-二分查找法-）"><a href="#O（logn）：（-二分查找法-）" class="headerlink" title="O（logn）：（ 二分查找法 ）"></a>O（logn）：（ 二分查找法 ）</h3><p><img src="http://static.zxinc520.com/blog/20190909/HCC3KITFnmlL.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190909/Y18HXPKRMICe.png?imageslim" alt="mark"></p>
<h4 id="整形转成字符串"><a href="#整形转成字符串" class="headerlink" title="整形转成字符串"></a>整形转成字符串</h4><p><img src="http://static.zxinc520.com/blog/20190909/gDCAKNS0NtKo.png?imageslim" alt="mark"></p>
<h3 id="log-以-2-为底-和-以-10-为底有区别吗"><a href="#log-以-2-为底-和-以-10-为底有区别吗" class="headerlink" title="log 以 2 为底 和 以 10 为底有区别吗"></a>log 以 2 为底 和 以 10 为底有区别吗</h3><p><img src="http://static.zxinc520.com/blog/20190909/hhkkzyo7uTJM.png?imageslim" alt="mark"></p>
<h2 id="2-4-亲自试验自己算法的时间复杂度"><a href="#2-4-亲自试验自己算法的时间复杂度" class="headerlink" title="2-4 亲自试验自己算法的时间复杂度"></a>2-4 亲自试验自己算法的时间复杂度</h2><h3 id="复杂度实验"><a href="#复杂度实验" class="headerlink" title="复杂度实验"></a>复杂度实验</h3><p>实验，观察趋势</p>
<p>每次 将数据规模提高两倍，看时间的变化</p>
<h2 id="2-5-递归算法的复杂度分析"><a href="#2-5-递归算法的复杂度分析" class="headerlink" title="2-5 递归算法的复杂度分析"></a>2-5 递归算法的复杂度分析</h2><blockquote>
<p>不是有递归的函数就一定是 O（ nlogn ）！</p>
</blockquote>
<h3 id="递归中进行一次递归调用的复杂度分析"><a href="#递归中进行一次递归调用的复杂度分析" class="headerlink" title="递归中进行一次递归调用的复杂度分析"></a>递归中进行一次递归调用的复杂度分析</h3><p>二分法使用递归：</p>
<p><img src="http://static.zxinc520.com/blog/20190911/Vrm1PVyknLyf.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190911/HKc9QUhHzufd.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190911/Mrr5oypWBxGk.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190911/1hAzDU4ifP7w.png?imageslim" alt="mark"></p>
<p>引申：上述 函数增加求 负次幂？</p>
<h3 id="递归中进行多次递归调用"><a href="#递归中进行多次递归调用" class="headerlink" title="递归中进行多次递归调用"></a>递归中进行多次递归调用</h3><p><img src="http://static.zxinc520.com/blog/20190911/DmVGKhPNOvil.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190911/vlrGbmrXl4uo.png?imageslim" alt="mark"></p>
<p>深度不一样，并不是所有 多次递归调用 的时间复杂度 为：O（2 ^ n）</p>
<p><img src="http://static.zxinc520.com/blog/20190911/copG1I1hd0ya.png?imageslim" alt="mark"></p>
<h4 id="递归函数的时间复杂度"><a href="#递归函数的时间复杂度" class="headerlink" title="递归函数的时间复杂度"></a>递归函数的时间复杂度</h4><p>查阅 <strong>主定理</strong> （面试一般不考察）</p>
<h2 id="2-6-均摊时间复杂度分析（Amortized-Time-Analysis）"><a href="#2-6-均摊时间复杂度分析（Amortized-Time-Analysis）" class="headerlink" title="2-6 均摊时间复杂度分析（Amortized Time Analysis）"></a>2-6 均摊时间复杂度分析（Amortized Time Analysis）</h2><p><img src="http://static.zxinc520.com/blog/20190911/lH5rYQsGwqtN.png?imageslim" alt="mark"></p>
<h2 id="2-7-避免复杂度的震荡"><a href="#2-7-避免复杂度的震荡" class="headerlink" title="2-7 避免复杂度的震荡"></a>2-7 避免复杂度的震荡</h2><p><img src="http://static.zxinc520.com/blog/20190911/glngyIU8g3Mi.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190911/AFsH4CLIkIE3.png?imageslim" alt="mark"></p>
<h3 id="复杂度的震荡的解决方案"><a href="#复杂度的震荡的解决方案" class="headerlink" title="复杂度的震荡的解决方案"></a>复杂度的震荡的解决方案</h3><p><img src="http://static.zxinc520.com/blog/20190911/hwAvgAw9rUM1.png?imageslim" alt="mark"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/" rel="tag">复杂度分析</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7-O%EF%BC%9F/" rel="tag">大 O？</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/" rel="tag">算法面试</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-AlgorithmForTheInterview01"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/09/09/AlgorithmForTheInterview01/"
    >算法面试到底是什么鬼</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/09/09/AlgorithmForTheInterview01/" class="article-date">
  <time datetime="2019-09-09T02:43:24.000Z" itemprop="datePublished">2019-09-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/">玩转算法面试</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="算法面试到底是什么鬼"><a href="#算法面试到底是什么鬼" class="headerlink" title="算法面试到底是什么鬼?"></a>算法面试到底是什么鬼?</h1><blockquote>
<p>玩转算法面试 从真题到思维全面提升算法思维</p>
<p>为了面试，更为了提升你的算法思维</p>
<p>一提起算法面试，很多同学就会心有余悸。可其实，大多数企业的算法面试，并没有那么可怕。并不是一定要啃完整本《算法导论》，才能玩儿转算法面试；也并不是只有 ACM 参赛选手，才能笑傲算法面试。恰恰相反，大多数算法面试关注的算法思维，其实很基础。在这一章，和大家聊一聊，算法面试，到底是什么鬼？…</p>
</blockquote>
<h2 id="1-1-算法面试不仅仅是正确的回答问题"><a href="#1-1-算法面试不仅仅是正确的回答问题" class="headerlink" title="1-1 算法面试不仅仅是正确的回答问题"></a>1-1 算法面试不仅仅是正确的回答问题</h2><h4 id="算法面试是什么？"><a href="#算法面试是什么？" class="headerlink" title="算法面试是什么？"></a>算法面试是什么？</h4><ul>
<li>让大家在面对面试中的算法问题时，有一个合理的思考路径<ul>
<li>不代表能够“正确”回答每一个算法问题，但是合理的思考方向其实更重要，这也是正确完成算法面试问题的前提</li>
<li>算法面试优秀不意味着技术面试优秀</li>
<li>技术面试优秀不意味着能够拿到 Offer</li>
</ul>
</li>
</ul>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><h4 id="问题：对一组数据进行排序"><a href="#问题：对一组数据进行排序" class="headerlink" title="问题：对一组数据进行排序"></a>问题：对一组数据进行排序</h4><p>不假思索思考方向：</p>
<ul>
<li>快速排序算法 O（nlogn）</li>
</ul>
<p><strong>正确的方式</strong>是：应该和面试官探讨（ <strong>思考路径</strong> ）：</p>
<ul>
<li>这组数据有什么样的特征？<ul>
<li>有没有可能包含有大量重复的元素？</li>
<li>如果有这种可能的话，三路快排是更好的选择。</li>
</ul>
</li>
<li>这组数据有什么样的特征？<ul>
<li>是否大部分数据距离它正确的位置很近？是否近乎有序？</li>
<li>如果是这样的话，插入排序是更好的选择</li>
</ul>
</li>
<li>这组数据有什么样的特征？<ul>
<li>是否数据的取值范围非常有限？比如对学生成绩排序</li>
<li>如果是这样的话，计数排序是更好的选择</li>
</ul>
</li>
<li>对排序有什么额外的要求？<ul>
<li>是否需要稳定排序？</li>
<li>如果是的话，归并排序是更好的选择</li>
</ul>
</li>
<li>数据的存储状况是怎么样的？<ul>
<li>是否是使用链表存储的？</li>
<li>如果是的话，归并排序是更好的选择</li>
</ul>
</li>
<li>数据的存储状态是怎样的？<ul>
<li>数据的大小是否可以装载在内存里？</li>
<li>数据量很大，或者内存很小，不足以装载在内存里，需要使用外排序算法</li>
</ul>
</li>
</ul>
<h2 id="1-2-什么是“正确”的回答一个算法问题"><a href="#1-2-什么是“正确”的回答一个算法问题" class="headerlink" title="1-2 什么是“正确”的回答一个算法问题"></a>1-2 什么是“正确”的回答一个算法问题</h2><p><strong>正确</strong> 还包含对问题的独到见解；优化；代码规范；容错性</p>
<p>如果是 非常难的问题，对你的竞争对手来说，也是难的。</p>
<p>关键在于你所表达出的解决问题的思路</p>
<p>甚至通过表达解题思路的方向，得出结论：这个问题的解决方案，应该在哪一个领域，我可以通过查阅或者进一步学习解决问题</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul>
<li>项目经历 和 项目中遇到的实际问题</li>
<li>你遇到的印象最深的 bug 是什么？</li>
<li>面向对象</li>
<li>设计模式</li>
<li>网络相关；安全相关；内存相关；并发相关</li>
<li>系统设计；scalability</li>
</ul>
<p>技术面试只是面试的一部分。面试不仅仅是考察你的技术水平，还是了解你的过去以及形成的思考行为方式</p>
<p>关于过去：参与项目至关重要</p>
<h4 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h4><ul>
<li>本科生<ul>
<li>毕业设计</li>
<li>其它课程设计(大作业，大一点的程序设计等等)</li>
</ul>
</li>
<li>如何找到项目？<ul>
<li>实习</li>
<li>参与实战课程学习<ul>
<li>慕课网</li>
<li>Coursera</li>
</ul>
</li>
</ul>
</li>
<li>创建自己的项目<ul>
<li>自己做小应用：计划表；备忘录；播放器…</li>
<li>自己解决小问题：爬虫；数据分析；词频统计</li>
<li>“不是项目” 的项目：一本优秀的技术书籍的代码整理等…</li>
<li>分享：自己的技术博客；github 等等…</li>
</ul>
</li>
</ul>
<h4 id="行为类问题"><a href="#行为类问题" class="headerlink" title="行为类问题"></a>行为类问题</h4><p>通过过去了解你的思考行为方式？</p>
<ul>
<li>遇到的最大的挑战？</li>
<li>犯过的错误？</li>
<li>遭遇的失败？</li>
<li>最享受的工作内容？</li>
<li>遇到冲突的处理方式？</li>
<li>做的最与众不同的事儿？</li>
</ul>
<h4 id="准备好合适的问题问面试官"><a href="#准备好合适的问题问面试官" class="headerlink" title="准备好合适的问题问面试官"></a>准备好合适的问题问面试官</h4><ul>
<li>整个小组的大概运行模式是怎样的？</li>
<li>整个项目的后续规划是如何的？</li>
<li>这个产品中的某个问题是如何解决的？</li>
<li>为什么会选择某些技术？标准？</li>
<li>我对某个技术很感兴趣，在你的小组中我会有怎样的机会深入这种技术？</li>
</ul>
<p><strong>算法面试仍然是非常重要的一部分</strong></p>
<h2 id="1-3-如何准备算法面试"><a href="#1-3-如何准备算法面试" class="headerlink" title="1-3 如何准备算法面试"></a>1-3 如何准备算法面试</h2><p>准备面试 和 准备算法面试 是两个概念</p>
<p>算法面试 ，只是面试中的一个环节</p>
<h2 id="算法面试并没有那么难"><a href="#算法面试并没有那么难" class="headerlink" title="算法面试并没有那么难"></a>算法面试并没有那么难</h2><ul>
<li>远远不需要啃完一本 《算法导论》<ul>
<li>过于强调理论证明</li>
</ul>
</li>
<li>高级数据结构 和 算法面试提及的概率很低<ul>
<li>红黑树</li>
<li>计算几何</li>
<li>B - Tree</li>
<li>数论</li>
<li>斐波那契堆</li>
<li>FFT</li>
</ul>
</li>
</ul>
<p><strong>算法面试远远不需要达到信息学竞赛的水平</strong> 。</p>
<p><img src="http://static.zxinc520.com/blog/20190908/CNmOn2PupuUn.png?imageslim" alt="mark"></p>
<h3 id="算法面试的准备范围"><a href="#算法面试的准备范围" class="headerlink" title="算法面试的准备范围"></a>算法面试的准备范围</h3><ul>
<li>不要轻视基础算法 和 数据结构，而只关注 “有意思” 的题目</li>
</ul>
<p>重点关注：</p>
<ul>
<li>各种排序算法</li>
<li>基础数据结构和算法的实现：如堆、二叉树、图….</li>
<li>基础数据结构的使用：如链表、栈、队列、哈希表、图、Trie、并查集…</li>
<li>基础算法：深度优先、广度优先、二分查找、递归…</li>
<li>基本算法思想：递归、分治、回溯搜索、贪心、动态规划…</li>
</ul>
<h3 id="选择合适的-OJ"><a href="#选择合适的-OJ" class="headerlink" title="选择合适的 OJ"></a>选择合适的 OJ</h3><blockquote>
<p>OJ：online judge</p>
<p>在线判题系统</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190908/iW0zhuflnMIs.png?imageslim" alt="mark"></p>
<h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/">LeetCode</a> （ 源于真实的面试问题 ）</li>
<li><a target="_blank" rel="noopener" href="https://www.hackerrank.com/">HackerRank</a> （ 对问题分类很详细 ，更难一点，辅助作用）</li>
</ul>
<p><strong>注意</strong>： 在学习和实践做题之间，要掌握平衡</p>
<h2 id="1-4-解决算法面试问题的整体思路"><a href="#1-4-解决算法面试问题的整体思路" class="headerlink" title="1-4 解决算法面试问题的整体思路"></a>1-4 解决算法面试问题的整体思路</h2><h3 id="注意题目中的条件"><a href="#注意题目中的条件" class="headerlink" title="注意题目中的条件"></a>注意题目中的条件</h3><ul>
<li>给定一个有序数组…<ul>
<li><strong>有序</strong>： 是不是可以使用二分查找法</li>
</ul>
</li>
<li>有一些题目中的条件本质是暗示：<ul>
<li>设计一个 O（nlogn）的算法<ul>
<li>分治法</li>
</ul>
</li>
<li>无需考虑额外的空间<ul>
<li>开辟额外的空间</li>
</ul>
</li>
<li>数据规模大概是 10000<ul>
<li>O（n 的二次方）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="当没有思路的时候"><a href="#当没有思路的时候" class="headerlink" title="当没有思路的时候"></a>当没有思路的时候</h3><ul>
<li>自己给自己几个简单的测试用例，试验一下</li>
<li>不要忽视暴力解法。暴力解法通常是思考的起点</li>
</ul>
<h4 id="不要忽视暴力法"><a href="#不要忽视暴力法" class="headerlink" title="不要忽视暴力法"></a>不要忽视暴力法</h4><p><img src="http://static.zxinc520.com/blog/20190908/4H4HSG2k68nE.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190908/DTm490pyX7Vm.png?imageslim" alt="mark"></p>
<h2 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h2><h3 id="无头绪的思路"><a href="#无头绪的思路" class="headerlink" title="无头绪的思路"></a>无头绪的思路</h3><ul>
<li>遍历常见的算法思路</li>
<li>遍历常见的数据结构</li>
<li>空间 和 时间的 交换 （ 哈希表 ）</li>
<li>预处理信息 （ 排序 ）</li>
<li>在瓶颈处寻找答案：O（nlogn）+ O（n ∧ 2）；O（n∧3）</li>
</ul>
<h3 id="实际编写问题"><a href="#实际编写问题" class="headerlink" title="实际编写问题"></a>实际编写问题</h3><ul>
<li>极端条件的判断<ul>
<li>数组为空？字符串为空？数量为 0? 指针为 NULL ？</li>
</ul>
</li>
<li>变量名</li>
<li>模块化，复用性</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/" rel="tag">算法面试</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> zhou chen
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="琛"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://zxinc520.com">个人博客</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友情链接</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="http://static.zxinc520.com/blog/20190512/p4IWzLUrorWK.jpg?imageslim">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="http://static.zxinc520.com/blog/20190512/pGHOMdDF79sb.jpg?imageslim">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>


<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>