{
    "version": "https://jsonfeed.org/version/1",
    "title": "sunflower • All posts by \"es6 语法\" category",
    "description": "周琛的博客",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2020/03/23/getOfferES6/",
            "url": "http://example.com/2020/03/23/getOfferES6/",
            "title": "ES6 知识点",
            "date_published": "2020-03-23T09:38:45.000Z",
            "content_html": "<h2 id=\"面试专题总结es6-知识点\"><a class=\"markdownIt-Anchor\" href=\"#面试专题总结es6-知识点\">#</a> 面试专题总结：ES6 知识点</h2>\n<blockquote>\n<p>希望读者依此构建自己的知识树（思维导图）</p>\n<p>偷懒一下：可参考我自己总结思维导图 : <a href=\"https://github.com/ZhChen7/Interview-mind-map\">点这里</a></p>\n<p>附带：高频面试题积累文档。 来自于（学长、牛客网等平台）</p>\n<p>自己开发的博客地址：<a href=\"http://zxinc520.com/\">zxinc520.com</a></p>\n<p>github 地址: <a href=\"https://github.com/ZhChen7\">点击</a></p>\n</blockquote>\n<blockquote>\n<p>此篇 js - 【ES6 知识总结】 知识点： 全部弄懂了，面试很容易。</p>\n</blockquote>\n<blockquote>\n<p>详细可参考： <a href=\"https://es6.ruanyifeng.com/\">ECMAScript 6 入门</a></p>\n</blockquote>\n<h3 id=\"1-es6-是什么\"><a class=\"markdownIt-Anchor\" href=\"#1-es6-是什么\">#</a> 1、es6 是什么</h3>\n<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。 ECMA 是标准，Javascript 是 ECMA 的实现。因为 js 也是一种语言，但凡语言都有一套标准，而 ECMA 就是 javascript 的标准。在 2015 年正式发布了 ECMAscript6.0，简称 ES6，又称为 ECMAscript2015。</p>\n<h3 id=\"2-var-let-const声明方式\"><a class=\"markdownIt-Anchor\" href=\"#2-var-let-const声明方式\">#</a> 2、var、let、const（声明方式）</h3>\n<ul>\n<li>类别\n<ol>\n<li>变量提升</li>\n<li>暂时性死区</li>\n<li>重复声明</li>\n<li>块作用域有效</li>\n<li>初始值</li>\n<li>重新赋值</li>\n</ol>\n</li>\n<li>区别\n<ol>\n<li>let/const 定义的变量不会出现变量提升，而 var 定义的变量会提升。</li>\n<li>相同作用域中，let 和 const 不允许重复声明，var 允许重复声明。</li>\n<li>const 声明变量时必须设置初始值</li>\n<li>const 声明一个只读的常量，这个常量不可改变</li>\n<li>let/const 声明的变量仅在块级作用域中有效。而 var 声明的变量在块级作用域外仍能访问到。</li>\n<li>顶层作用域中 var 声明的变量挂在 window 上 (浏览器环境)</li>\n<li>let/const 有暂时性死区的问题，即 let/const 声明的变量，在定义之前都是不可用的。如果使用会抛出错误。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"3-变量的解构赋值\"><a class=\"markdownIt-Anchor\" href=\"#3-变量的解构赋值\">#</a> 3、 变量的解构赋值</h3>\n<ul>\n<li>\n<p>数组解构赋值</p>\n<p>let [aa, bb, cc] = [0, 1, 2];</p>\n</li>\n<li>\n<p>对象解构赋值</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> <span class=\"token punctuation\">&#123;</span> cnName<span class=\"token punctuation\">,</span> enName <span class=\"token punctuation\">&#125;</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n  id<span class=\"token operator\">:</span> <span class=\"token string\">\"151521574\"</span><span class=\"token punctuation\">,</span>\n  cnName<span class=\"token operator\">:</span> <span class=\"token string\">\"张生\"</span><span class=\"token punctuation\">,</span>\n  enName<span class=\"token operator\">:</span> <span class=\"token string\">\"Ronnie\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>cnName<span class=\"token punctuation\">,</span> enName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//'张生'，'Ronnie'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<h3 id=\"4-箭头函数\"><a class=\"markdownIt-Anchor\" href=\"#4-箭头函数\">#</a> 4、箭头函数</h3>\n<blockquote>\n<p>es6 之前的函数的 this 指向调用函数时所在的对象，而箭头函数的 this 指向函数定义时所在的对象</p>\n</blockquote>\n<h4 id=\"箭头函数及其-this-问题\"><a class=\"markdownIt-Anchor\" href=\"#箭头函数及其-this-问题\">#</a> 箭头函数及其 this 问题</h4>\n<ol>\n<li>this 对象的指向是可变的，但是在箭头函数中，它是固定的。</li>\n<li>this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this。正是因为它没有 this，所以也就不能用作构造函数。</li>\n<li>箭头函数里面根本没有自己的 this，而是引用外层的 this。</li>\n<li>由于箭头函数没有自己的 this，所以当然也就不能用 call ()、apply ()、bind () 这些方法去改变 this 的指向</li>\n</ol>\n<h3 id=\"5-symbol\"><a class=\"markdownIt-Anchor\" href=\"#5-symbol\">#</a> 5、Symbol</h3>\n<ul>\n<li>\n<p>是什么？</p>\n<p>symbols 是一种无法被重建的基本类型。这时 symbols 有点类似与对象创建的实例互相不相等的情况，但同时 symbols 又是一种无法被改变的基本类型数据。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> s1 <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> s2 <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>s1 <span class=\"token operator\">===</span> s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li>\n<p>作用</p>\n<ol>\n<li>symbols 作为对象的属性</li>\n<li>阻止对象属性名冲突 （扩展对象属性很有用）</li>\n<li>模拟私有属性</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"6-module-模块\"><a class=\"markdownIt-Anchor\" href=\"#6-module-模块\">#</a> 6、Module 模块</h3>\n<blockquote>\n<p>可从 IIFE、AMD、CMD、CommonJS、UMD、webpack (require.ensure)、ES Module、&lt;<em>script type=“module”</em> &gt; 这几个角度考虑。</p>\n<p><strong>作用</strong> ：模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。</p>\n</blockquote>\n<h4 id=\"模块化发展历程\"><a class=\"markdownIt-Anchor\" href=\"#模块化发展历程\">#</a> 模块化发展历程</h4>\n<ol>\n<li>\n<p>IIFE</p>\n<ul>\n<li>\n<p>使用自执行函数来编写模块化</p>\n</li>\n<li>\n<p>特点：</p>\n<p>在一个单独的函数作用域中执行代码，避免变量冲突。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>AMD</p>\n<ul>\n<li>\n<p>使用 requireJS 来编写模块化</p>\n</li>\n<li>\n<p>特点：依赖必须提前声明好</p>\n</li>\n<li>\n<p>简单实现</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token function\">define</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./index.js\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">code</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\">// code 就是index.js 返回的内容</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>CMD</p>\n<ul>\n<li>\n<p>使用 seaJS 来编写模块化</p>\n</li>\n<li>\n<p>特点：支持动态引入依赖文件</p>\n</li>\n<li>\n<p>简单实现</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token function\">define</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">require<span class=\"token punctuation\">,</span> exports<span class=\"token punctuation\">,</span> module</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">var</span> indexCode <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./index.js\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>CommonJS</p>\n<ul>\n<li>nodejs 中自带的模块化</li>\n<li>var fs = require(‘fs’);</li>\n</ul>\n</li>\n<li>\n<p>UMD</p>\n<ul>\n<li>兼容 AMD，CommonJS 模块化语法</li>\n</ul>\n</li>\n<li>\n<p>webpack(require.ensure)</p>\n<ul>\n<li>webpack 2.x 版本中的代码分割</li>\n</ul>\n</li>\n<li>\n<p>ES Modules</p>\n<ul>\n<li>ES6 引入的模块化，支持 import 来引入另一个 js</li>\n<li>import a from ‘a’;</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"61-amd-与-cmd-的比较\"><a class=\"markdownIt-Anchor\" href=\"#61-amd-与-cmd-的比较\">#</a> 6.1、AMD 与 CMD 的比较</h4>\n<ul>\n<li>\n<p>定义</p>\n<p>AMD 和 CMD 都是用于浏览器端的模块规范</p>\n</li>\n<li>\n<p>AMD</p>\n<ul>\n<li>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出</li>\n<li>其主要内容就是定义了 define 函数该如何书写，只要你按照这个规范书写模块和依赖，require.js 就能正确的进行解析。</li>\n</ul>\n</li>\n<li>\n<p>CMD</p>\n<ul>\n<li>CMD 其实就是 SeaJS 在推广过程中对模块定义的规范化产出</li>\n<li>主要内容就是描述该如何定义模块，如何引入模块，如何导出模块，只要你按照这个规范书写代码，sea.js 就能正确的进行解析</li>\n</ul>\n</li>\n<li>\n<p>AMD 与 CMD 的区别</p>\n<ol>\n<li>AMD 推崇依赖前置，CMD 推崇依赖就近</li>\n<li>AMD 是提前执行，CMD 是延迟执行。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"62-commonjs-与-amd-的比较\"><a class=\"markdownIt-Anchor\" href=\"#62-commonjs-与-amd-的比较\">#</a> 6.2、CommonJS 与 AMD 的比较</h4>\n<blockquote>\n<p>在服务器端比如 node，采用的则是 CommonJS 规范。</p>\n<p>AMD 和 CMD 都是用于浏览器端的模块规范</p>\n</blockquote>\n<ol>\n<li>\n<p>CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。</p>\n</li>\n<li>\n<p>AMD 规范则是非同步加载模块，允许指定回调函数。</p>\n<p>由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。</p>\n</li>\n<li>\n<p>但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。</p>\n</li>\n</ol>\n<h4 id=\"63-es6-与-commonjs-的比较\"><a class=\"markdownIt-Anchor\" href=\"#63-es6-与-commonjs-的比较\">#</a> 6.3、ES6 与 CommonJS 的比较</h4>\n<blockquote>\n<p>注意！浏览器加载 ES6 模块，也使用 &lt;<em>script</em> &gt; 标签，但是要加入 type=“module” 属性。</p>\n</blockquote>\n<ol>\n<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>\n<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</li>\n</ol>\n<h3 id=\"7-异步编程-6-种解决方案\"><a class=\"markdownIt-Anchor\" href=\"#7-异步编程-6-种解决方案\">#</a> 7、异步编程 6 种解决方案</h3>\n<ol>\n<li>\n<p>回调函数（Callback）</p>\n<ul>\n<li>\n<p>回调函数是异步操作最基本的方法</p>\n</li>\n<li>\n<p>ajax(url, () =&gt; {</p>\n<p>​ // 处理逻辑</p>\n<p>})</p>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>容易写出回调地狱（Callback hell）</li>\n<li>不能使用 try catch 捕获错误，不能直接 return</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>事件监听</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">f1<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"done\"</span><span class=\"token punctuation\">,</span> f2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li>\n<p>发布订阅</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">jQuery<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"done\"</span><span class=\"token punctuation\">,</span> f2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li>\n<p>Promise</p>\n<ul>\n<li>\n<p>是什么？</p>\n<ul>\n<li>promise 是目前 JS 异步编程的主流解决方案，遵循 Promises/A+ 方案。Promise 用于异步操作，表示一个还未完成但是预期会完成的操作。</li>\n<li>Promise 是 ES6 引入的一个新的对象，他的主要作用是用来解决 JS 异步机制里，回调机制产生的 “回调地狱”。它并不是什么突破性的 API，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用。</li>\n</ul>\n</li>\n<li>\n<p>剖析</p>\n<ul>\n<li>\n<p>promise 本身相当于一个状态机，拥有三种状态</p>\n<ul>\n<li>pending</li>\n<li>fulfilled</li>\n<li>rejected</li>\n</ul>\n<p>一个 promise 对象初始化时的状态是 pending，调用了 resolve 后会将 promise 的状态扭转为 fulfilled，调用 reject 后会将 promise 的状态扭转为 rejected，这两种扭转一旦发生便不能再扭转该 promise 到其他状态。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Promise 如何使用</p>\n<p>构造一个 promise 对象，并将要执行的异步函数传入到 promise 的参数中执行，并且在异步执行结束后调用 resolve ( ) 函数，就可以在 promise 的 then 方法中获取到异步函数的执行结果</p>\n</li>\n<li>\n<p>Promise 原型上的方法</p>\n<ol>\n<li>Promise.prototype.then(onFulfilled, onRejected)</li>\n<li>Promise.prototype.catch(onRejected)</li>\n<li>Promise.prototype.finally(onFinally)</li>\n</ol>\n</li>\n<li>\n<p>Promise 静态方法</p>\n<ol>\n<li>\n<p>Promise.all()</p>\n<p>Promise.all 接收一个 promise 对象数组作为参数，只有全部的 promise 都已经变为 fulfilled 状态后才会继续后面的处理</p>\n</li>\n<li>\n<p>Promise.race()</p>\n<p>这个函数会在 promises 中第一个 promise 的状态扭转后就开始后面的处理（fulfilled、rejected 均可）</p>\n</li>\n<li>\n<p>Promise.resolve()</p>\n</li>\n<li>\n<p>Promise.reject()</p>\n</li>\n</ol>\n</li>\n<li>\n<p>优点</p>\n<p>将异步操作以同步操作的流程表达出来，promise 链式调用，更好地解决了层层嵌套的回调地狱</p>\n</li>\n<li>\n<p>缺点</p>\n<ol>\n<li>不能取消执行。</li>\n<li>无法获取当前执行的进度信息（比如，要在用户界面展示进度条）。</li>\n<li>外部无法捕捉 Promise 内部抛出的错误</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>generator 函数</p>\n<ul>\n<li>\n<p>是什么</p>\n<ul>\n<li>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</li>\n<li>如果说 JavaScript 是 ECMAScript 标准的一种具体实现、Iterator 遍历器是 Iterator 的具体实现，那么 Generator 函数可以说是 Iterator 接口的具体实现方式。</li>\n<li>Generator 函数可以通过配合 Thunk 函数更轻松更优雅的实现异步编程和控制流管理</li>\n</ul>\n</li>\n<li>\n<p>描述</p>\n<ul>\n<li>执行 Generator 函数会返回一个遍历器对象，每一次 Generator 函数里面的 yield 都相当一次遍历器对象的 next () 方法，并且可以通过 next (value) 方法传入自定义的 value, 来改变 Generator 函数的行为。</li>\n</ul>\n</li>\n<li>\n<p>能封装异步任务的根本原因</p>\n<ul>\n<li>最大特点就是可以交出函数的执行权（即暂停执行）。Generator 函数可以暂停执行和恢复执行</li>\n</ul>\n</li>\n<li>\n<p>两个特征</p>\n<ul>\n<li>function 关键字与函数名之间有一个星号</li>\n<li>函数体内部使用 yield 表达式，定义不同的内部状态（yield 在英语里的意思就是 “产出”）。</li>\n</ul>\n</li>\n<li>\n<p>过程</p>\n<p>Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）</p>\n</li>\n<li>\n<p>Generator 及其异步方面的应用</p>\n<ul>\n<li>Generator 函数将 JavaScript 异步编程带入了一个全新的阶段</li>\n</ul>\n</li>\n<li>\n<p>总结</p>\n<p>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值；done 属性是一个布尔值，表示是否遍历结束。</p>\n</li>\n<li>\n<p>demo</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> fetch <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"node-fetch\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">var</span> url <span class=\"token operator\">=</span> <span class=\"token string\">\"https://api.github.com/users/github\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>bio<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>async 和 await</p>\n<ul>\n<li>\n<p>含义</p>\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\n</li>\n<li>\n<p>是什么？</p>\n<ul>\n<li>一句话，它就是 Generator 函数的语法糖。</li>\n<li>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。</li>\n<li>async 函数可以理解为内置自动执行器的 Generator 函数语法糖，它配合 ES6 的 Promise 近乎完美的实现了异步编程解决方案。</li>\n</ul>\n</li>\n<li>\n<p>相对于 Promise，优势体现在</p>\n<ol>\n<li>处理 then 的调用链，能够更清晰准确的写出代码</li>\n<li>并且也能优雅地解决回调地狱问题</li>\n</ol>\n</li>\n<li>\n<p>相对 Generator 函数，体现在以下 4 点</p>\n<ol>\n<li>内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行</li>\n<li>更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果</li>\n<li>更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）</li>\n<li>返回值是 Promise。async 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用 then 方法指定下一步的操作。</li>\n</ol>\n</li>\n<li>\n<p>缺点</p>\n<p>当然 async/await 函数也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise.all 的方式。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h4>\n<ol>\n<li>JS 异步编程进化史：callback -&gt; promise -&gt; generator -&gt; async + await</li>\n<li>async/await 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里</li>\n<li>async/await 可以说是异步终极解决方案了</li>\n</ol>\n<h3 id=\"8-class\"><a class=\"markdownIt-Anchor\" href=\"#8-class\">#</a> 8、Class</h3>\n<blockquote>\n<p>ES6 的 class 可以看作只是一个 ES5 生成实例对象的构造函数的语法糖。它参考了 java 语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。Class 类可以通过 extends 实现继承。</p>\n</blockquote>\n<ul>\n<li>\n<p>语法</p>\n<ul>\n<li>super 关键字的使用</li>\n<li>static 关键字</li>\n</ul>\n</li>\n<li>\n<p>ES5/ES6 的继承除了写法以外还有什么区别？</p>\n<ol>\n<li>class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。</li>\n<li>class 声明内部会启用严格模式</li>\n<li>class 的所有方法（包括静态方法和实例方法）都是不可枚举的</li>\n<li>class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有 [[construct]]，不能使用 new 来调用</li>\n<li>必须使用 new 调用 class</li>\n<li>class 内部无法重写类名</li>\n</ol>\n<p>ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this</p>\n</li>\n<li>\n<p>优点</p>\n<p>但是某些时候，我们使用 es6 的类可以让我们的代码的可读性更高</p>\n</li>\n</ul>\n<h3 id=\"9-set-和-map\"><a class=\"markdownIt-Anchor\" href=\"#9-set-和-map\">#</a> 9、Set 和 Map</h3>\n<ul>\n<li>Set\n<ul>\n<li>是什么\n<ul>\n<li>Set 是一种叫做集合的数据结构</li>\n<li>Set 是 ES6 引入的一种类似 Array 的新的数据结构，Set 实例的成员类似于数组 item 成员，区别是 Set 实例的成员都是唯一，不重复的。这个特性可以轻松地实现数组去重。</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>数组去重</li>\n</ul>\n</li>\n<li>特点\n<ol>\n<li>成员唯一、无序且不重复</li>\n<li>[value, value]，键值与键名是一致的（或者说只有键值，没有键名）</li>\n<li>可以遍历，方法有：add、delete、has</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>WeakSet\n<ul>\n<li>特点\n<ol>\n<li>成员都是对象</li>\n<li>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏</li>\n<li>不能遍历，方法有 add、delete、has</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>Map\n<ul>\n<li>是什么\n<ul>\n<li>Map 是一种叫做字典的数据结构</li>\n<li>Map 是 ES6 引入的一种类似 Object 的新的数据结构，Map 可以理解为是 Object 的超集，打破了以传统键值对形式定义对象，对象的 key 不再局限于字符串，也可以是 Object。可以更加全面的描述对象的属性。</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>数据存储</li>\n</ul>\n</li>\n<li>特点\n<ul>\n<li>本质上是键值对的集合，类似集合</li>\n<li>可以遍历，方法很多可以跟各种数据格式转换</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>WeakMap\n<ul>\n<li>特点\n<ul>\n<li>只接受对象作为键名（null 除外），不接受其他类型的值作为键名</li>\n<li>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的</li>\n<li>不能遍历，方法有 get、set、has、delete</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Set 和 Map\n<ul>\n<li>Set 和 Map 主要的应用场景在于数组去重和数据存储</li>\n<li>原来 Set 是一种叫做集合的数据结构，Map 是一种叫做字典的数据结构</li>\n</ul>\n</li>\n<li>Set 与 WeakSet 区别\n<ol>\n<li>WeakSet 只能存放对象</li>\n<li>WeakSet 不支持遍历，没有 size 属性</li>\n<li>WeakSet 存放的对象不会计入到对象的引用技术，因此不会影响 GC 的回收</li>\n<li>WeakSet 存在的对象如果在外界消失了，那么在 WeakSet 里面也会不存在</li>\n</ol>\n</li>\n<li>Map 与 WeakMap 区别\n<ol>\n<li>WeakMap 只能接受对象作为键名字 (null 除外)</li>\n<li>WeakMap 键名指向对象不会计入对象的引用数</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"10-es6-对-string-字符串类型做的常用升级优化\"><a class=\"markdownIt-Anchor\" href=\"#10-es6-对-string-字符串类型做的常用升级优化\">#</a> 10、ES6 对 String 字符串类型做的常用升级优化</h3>\n<ul>\n<li>优化部分\n<ul>\n<li>ES6 新增了字符串模板，在拼接大段字符串时，用反斜杠 (`) 取代以往的字符串相加的形式，能保留所有空格和换行，使得字符串拼接看起来更加直观，更加优雅。</li>\n</ul>\n</li>\n<li>升级部分\n<ul>\n<li>ES6 在 String 原型上新增了 includes () 方法，用于取代传统的只能用 indexOf 查找包含字符的方法 (indexOf 返回 - 1 表示没查到不如 includes 方法返回 false 更明确，语义更清晰), 此外还新增了 startsWith (), endsWith (), padStart (),padEnd (),repeat () 等方法，可方便的用于查找，补全字符串。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"11-es6-对-number-数字类型做的常用升级优化\"><a class=\"markdownIt-Anchor\" href=\"#11-es6-对-number-数字类型做的常用升级优化\">#</a> 11、ES6 对 Number 数字类型做的常用升级优化？</h3>\n<ul>\n<li>优化部分\n<ul>\n<li>ES6 在 Number 原型上新增了 isFinite (), isNaN () 方法，用来取代传统的全局 isFinite (), isNaN () 方法检测数值是否有限、是否是 NaN。ES5 的 isFinite (), isNaN () 方法都会先将非数值类型的参数转化为 Number 类型再做判断，这其实是不合理的，最造成 isNaN (‘NaN’) === true 的奇怪行为–'NaN’是一个字符串，但是 isNaN 却说这就是 NaN。而 Number.isFinite () 和 Number.isNaN () 则不会有此类问题 (Number.isNaN (‘NaN’) === false)。</li>\n</ul>\n</li>\n<li>升级部分\n<ul>\n<li>ES6 在 Math 对象上新增了 Math.cbrt ()，trunc ()，hypot () 等等较多的科学计数法运算方法，可以更加全面的进行立方根、求和立方根等等科学计算。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"12-es6-对-array-数组类型做的常用升级优化\"><a class=\"markdownIt-Anchor\" href=\"#12-es6-对-array-数组类型做的常用升级优化\">#</a> 12、ES6 对 Array 数组类型做的常用升级优化</h3>\n<ul>\n<li>优化部分\n<ul>\n<li>数组解构赋值。ES6 可以直接以 let [a,b,c] = [1,2,3] 形式进行变量赋值，在声明较多变量时，不用再写很多 let (var), 且映射关系清晰，且支持赋默认值</li>\n<li>扩展运算符。ES6 新增的扩展运算符 (…)(重要), 可以轻松的实现数组和松散序列的相互转化，可以取代 arguments 对象和 apply 方法，轻松获取未知参数个数情况下的参数集合。（尤其是在 ES5 中，arguments 并不是一个真正的数组，而是一个类数组的对象，但是扩展运算符的逆运算却可以返回一个真正的数组）。扩展运算符还可以轻松方便的实现数组的复制和解构赋值（let a = [2,3,4]; let b = […a]）</li>\n</ul>\n</li>\n<li>升级部分\n<ul>\n<li>ES6 在 Array 原型上新增了 find () 方法，用于取代传统的只能用 indexOf 查找包含数组项目的方法，且修复了 indexOf 查找不到 NaN 的 bug ([NaN].indexOf (NaN) === -1). 此外还新增了 copyWithin (), includes (), fill (),flat () 等方法，可方便的用于字符串的查找，补全，转换等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"13-es6-对-object-类型做的常用升级优化\"><a class=\"markdownIt-Anchor\" href=\"#13-es6-对-object-类型做的常用升级优化\">#</a> 13、ES6 对 Object 类型做的常用升级优化</h3>\n<ul>\n<li>\n<p>优化部分</p>\n<ol>\n<li>对象属性变量式声明。ES6 可以直接以变量形式声明对象属性或者方法，。比传统的键值对形式声明更加简洁，更加方便，语义更加清晰。</li>\n<li>对象的解构赋值</li>\n<li>对象的扩展运算符 (…)</li>\n<li>super 关键字。ES6 在 Class 类里新增了类似 this 的关键字 super。同 this 总是指向当前函数所在的对象不同，super 关键字总是指向当前函数所在对象的原型对象。</li>\n</ol>\n</li>\n<li>\n<p>升级部分</p>\n<ol>\n<li>\n<p>ES6 在 Object 原型上新增了 is () 方法，做两个目标对象的相等比较，用来完善’=<mark>‘方法。’</mark>=' 方法中 NaN === NaN //false 其实是不合理的，<a href=\"http://Object.is\">Object.is</a> 修复了这个小 bug。(<a href=\"http://Object.is\">Object.is</a>(NaN, NaN) // true)</p>\n</li>\n<li>\n<p>ES6 在 Object 原型上新增了 assign () 方法，用于对象新增属性或者多个对象合并。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> a<span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> b<span class=\"token operator\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> source2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> c<span class=\"token operator\">:</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> source1<span class=\"token punctuation\">,</span> source2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ntarget<span class=\"token punctuation\">;</span> <span class=\"token comment\">// &#123;a:1, b:2, c:3&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li>\n<p>ES6 在 Object 原型上新增了 getOwnPropertyDescriptors () 方法，此方法增强了 ES5 中 getOwnPropertyDescriptor () 方法，可以获取指定对象所有自身属性的描述对象。结合 defineProperties () 方法，可以完美复制对象，包括复制 get 和 set 属性。</p>\n</li>\n<li>\n<p>ES6 在 Object 原型上新增了 getPrototypeOf () 和 setPrototypeOf () 方法，用来获取或设置当前对象的 prototype 对象。获取或设置当前对象的 prototype 对象时，都应该采用 ES6 新增的标准用法。</p>\n</li>\n<li>\n<p>ES6 在 Object 原型上还新增了 Object.keys ()，Object.values ()，Object.entries () 方法，用来获取对象的所有键、所有值和所有键值对数组。</p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"14-es6-对-function-函数类型做的常用升级优化\"><a class=\"markdownIt-Anchor\" href=\"#14-es6-对-function-函数类型做的常用升级优化\">#</a> 14、ES6 对 Function 函数类型做的常用升级优化</h3>\n<ul>\n<li>\n<p>优化部分</p>\n<ul>\n<li>箭头函数 (核心)。箭头函数里没有自己的 this, 这改变了以往 JS 函数中最让人难以理解的 this 运行机制\n<ol>\n<li>箭头函数内的 this 指向的是函数定义时所在的对象，而不是函数执行时所在的对象。</li>\n<li>箭头函数不能用作构造函数，因为它没有自己的 this，无法实例化。</li>\n<li>也是因为箭头函数没有自己的 this, 所以箭头函数 内也不存在 arguments 对象。（可以用扩展运算符代替）</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>升级部分</p>\n<ul>\n<li>\n<p>ES6 新增了双冒号运算符，用来取代以往的 bind，call, 和 apply (浏览器暂不支持，Babel 已经支持转码)</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">foo<span class=\"token operator\">:</span><span class=\"token operator\">:</span>bar<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 等同于</span>\n<span class=\"token function\">bar</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nfoo<span class=\"token operator\">:</span><span class=\"token operator\">:</span><span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 等同于</span>\n<span class=\"token function\">bar</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">,</span> arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"15-proxy\"><a class=\"markdownIt-Anchor\" href=\"#15-proxy\">#</a> 15、Proxy</h3>\n<p>Proxy 是 ES6 新增的一个构造函数，这个词的原意是代理，用在这里表示由它来 “代理” 某些操作，可以译为 “代理器”。Proxy 可以理解成，在目标对象之前架设一层 “拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>\n<h3 id=\"16-reflect\"><a class=\"markdownIt-Anchor\" href=\"#16-reflect\">#</a> 16、Reflect</h3>\n<ul>\n<li>是什么\n<ul>\n<li>Reflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API</li>\n</ul>\n</li>\n<li>作用\n<ol>\n<li>一是将原生的一些零散分布在 Object、Function 或者全局函数里的方法 (如 apply、delete、get、set 等等)，统一整合到 Reflect 上，这样可以更加方便更加统一的管理一些原生 API。</li>\n<li>其次就是因为 Proxy 可以改写默认的原生 API，如果一旦原生 API 别改写可能就找不到了，所以 Reflect 也可以起到备份原生 API 的作用，使得即使原生 API 被改写了之后，也可以在被改写之后的 API 用上默认的 API。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"17-iterator\"><a class=\"markdownIt-Anchor\" href=\"#17-iterator\">#</a> 17、Iterator</h3>\n<ul>\n<li>是什么\n<ul>\n<li>一种设计标准，来统一所有可遍历类型的遍历方式。Iterator 正是这样一种标准。或者说是一种规范理念</li>\n</ul>\n</li>\n<li>解决的问题\n<ul>\n<li>Set、Map 都不能用 for 循环遍历，解决这个问题有两种方案，一种是为 Set、Map 单独新增一个用来遍历的 API，另一种是为 Set、Map、Array、Object 新增一个统一的遍历 API，显然，第二种更好，ES6 也就顺其自然的需要一种设计标准，来统一所有可遍历类型的遍历方式。</li>\n</ul>\n</li>\n<li>Iterator 标准的具体实现\n<ul>\n<li>Iterator 标准的具体实现是 Iterator 遍历器。Iterator 标准规定，所有部署了 key 值为 [Symbol.iterator]，且 [Symbol.iterator] 的 value 是标准的 Iterator 接口函数 (标准的 Iterator 接口函数：该函数必须返回一个对象，且对象中包含 next 方法，且执行 next () 能返回包含 value/done 属性的 Iterator 对象) 的对象，都称之为可遍历对象，next () 后返回的 Iterator 对象也就是 Iterator 遍历器。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"18-forin-和-forof-有什么区别\"><a class=\"markdownIt-Anchor\" href=\"#18-forin-和-forof-有什么区别\">#</a> 18、for…in 和 for…of 有什么区别</h3>\n<ul>\n<li>\n<p>ES6 规定，有所部署了载了 Iterator 接口的对象 (可遍历对象) 都可以通过 for…of 去遍历，而 for…in 仅仅可以遍历对象。</p>\n</li>\n<li>\n<p>使用 for…of 的好处</p>\n<ul>\n<li>\n<p>这也就意味着，数组也可以用 for…of 遍历，这极大地方便了数组的取值，且避免了很多程序用 for…in 去遍历数组的恶习。</p>\n<p>上面提到的扩展运算符本质上也就是 for…of 循环的一种实现。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"19-module-export-import\"><a class=\"markdownIt-Anchor\" href=\"#19-module-export-import\">#</a> 19、module、export、import</h3>\n<ul>\n<li>module、export、import 是 ES6 用来统一前端模块化方案的设计思路和实现方案</li>\n<li>作用\n<ul>\n<li>export、import 的出现统一了前端模块化的实现方案，整合规范了浏览器 / 服务端的模块化方法，用来取代传统的 AMD/CMD、requireJS、seaJS、commondJS 等等一系列前端模块不同的实现方案，使前端模块化更加统一规范，JS 也能更加能实现大型的应用程序开发。</li>\n</ul>\n</li>\n<li>注意\n<ul>\n<li>import 引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）</li>\n<li>import 引入 export 导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的值</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"20-iterator-和-forofiterator-遍历器的实现\"><a class=\"markdownIt-Anchor\" href=\"#20-iterator-和-forofiterator-遍历器的实现\">#</a> 20、 Iterator 和 for…of（Iterator 遍历器的实现）</h3>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token comment\">//自定义迭代器</span>\n<span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token function\">makeiterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">makeiterator</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">var</span> nextindex <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function-variable function\">next</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">return</span> nextindex <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">.</span>length\n        <span class=\"token operator\">?</span> <span class=\"token punctuation\">&#123;</span> value<span class=\"token operator\">:</span> arr<span class=\"token punctuation\">[</span>nextindex<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> done<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span> value<span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span> done<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token comment\">// Symbol.iterator遍历器接口</span>\n<span class=\"token keyword\">let</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"c\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> iter <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\niter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &#123; value: 'a', done: false &#125;</span>\niter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &#123; value: 'b', done: false &#125;</span>\niter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &#123; value: 'c', done: false &#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"21-循环语法比较及使用场景for-foreach-forin-forof\"><a class=\"markdownIt-Anchor\" href=\"#21-循环语法比较及使用场景for-foreach-forin-forof\">#</a> 21、循环语法比较及使用场景（for、forEach、for…in、for…of）</h3>\n<p>for 循环的速度是最快的，是最老的循环，也是优化得最好的，其次是 for-of 这个是 es6 才新增的循环非常好用，最慢是 for-in 我们可以作一下速度排序</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token keyword\">for</span> <span class=\"token operator\">></span> <span class=\"token keyword\">for</span><span class=\"token operator\">-</span><span class=\"token keyword\">of</span> <span class=\"token operator\">></span> forEach <span class=\"token operator\">></span> filter <span class=\"token operator\">></span> map <span class=\"token operator\">></span> <span class=\"token keyword\">for</span><span class=\"token operator\">-</span><span class=\"token keyword\">in</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n",
            "tags": [
                "ES6",
                "面试全面总结"
            ]
        },
        {
            "id": "http://example.com/2019/08/04/ES6intro/",
            "url": "http://example.com/2019/08/04/ES6intro/",
            "title": "ES6 语法",
            "date_published": "2019-08-04T08:46:35.000Z",
            "content_html": "<h1 id=\"es6-语法\"><a class=\"markdownIt-Anchor\" href=\"#es6-语法\">#</a> ES6 语法</h1>\n<blockquote>\n<p>本章主要讲解工作中最常用的 ES6 语法，包括 <strong>Module Class Promise</strong> 等语法，还会介绍使用 <strong>babel webpack rollup</strong> 来搭建 ES6 编译环境。</p>\n<p><a href=\"http://es6.ruanyifeng.com/\">ECMAScript 6 入门</a></p>\n</blockquote>\n<h2 id=\"es6-使用\"><a class=\"markdownIt-Anchor\" href=\"#es6-使用\">#</a> ES6 使用</h2>\n<ul>\n<li>开发环境已经普及使用</li>\n<li>浏览器环境却支持不好（ 需要开发环境编译 ）</li>\n<li>内容很多，重点了解常用语法</li>\n<li>面试：开发环境的使用 + 重点语法的掌握</li>\n</ul>\n<h3 id=\"问题\"><a class=\"markdownIt-Anchor\" href=\"#问题\">#</a> 问题</h3>\n<ul>\n<li>ES6 模块化如何使用，开发环境如何打包</li>\n<li>Class 和 普通构造函数 有何区别 ？</li>\n<li>Promise 的基本使用和原理</li>\n<li>总结一下 ES6 其它常用功能</li>\n</ul>\n<h2 id=\"2-1-es6-模块化语法\"><a class=\"markdownIt-Anchor\" href=\"#2-1-es6-模块化语法\">#</a> 2-1 ES6 模块化语法</h2>\n<blockquote>\n<p>ES6 模块化如何使用，开发环境如何打包</p>\n</blockquote>\n<h3 id=\"知识点\"><a class=\"markdownIt-Anchor\" href=\"#知识点\">#</a> 知识点</h3>\n<p><strong>ES6 模块化如何使用，开发环境如何打包:</strong></p>\n<ul>\n<li>模块化的基本语法</li>\n<li>开发环境的配置</li>\n<li>关于 JS 众多 模块化标准</li>\n</ul>\n<h4 id=\"export-语法\"><a class=\"markdownIt-Anchor\" href=\"#export-语法\">#</a> export 语法</h4>\n<blockquote>\n<p>export 语法</p>\n</blockquote>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token comment\">/*util1.js*/</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">&#123;</span>\n  a<span class=\"token operator\">:</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/*util2.js*/</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fn1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fn2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">/*index.js*/</span>\n<span class=\"token keyword\">import</span> util1 <span class=\"token keyword\">from</span> <span class=\"token string\">\"./util1.js\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">&#123;</span> fn1<span class=\"token punctuation\">,</span> fn2 <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./util2.js\"</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>util1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">fn1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">fn2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"开发环境-babel\"><a class=\"markdownIt-Anchor\" href=\"#开发环境-babel\">#</a> 开发环境 - babel</h4>\n<blockquote>\n<p>Babel 是一个 JavaScript 编译器。<a href=\"https://babeljs.io/\">官网</a></p>\n<p>使用技巧 可参考 <a href=\"http://zxinc520.com/lcj/%225cc4640d9b3032095d9e5754%22\">React 学习第一天 ：webpack 中使用 Babel 配置</a></p>\n<p>和 <a href=\"http://zxinc520.com/lcj/%225cb72a04009ae94788aa0d7f%22\">Vue 第六天学习 ：webpack 中 babel 的配置</a></p>\n</blockquote>\n<h4 id=\"开发环境-webpack\"><a class=\"markdownIt-Anchor\" href=\"#开发环境-webpack\">#</a> 开发环境 - webpack</h4>\n<blockquote>\n<p>开发环境 - webpack - <em>webpack</em> 是一个模块打包器 <a href=\"https://webpack.js.org/\">官网</a></p>\n<p>详情 可参考我的博客：<a href=\"http://zxinc520.com/lcj/%225cb181596d3d4a5cb52b65c9%22\">Vue 第五天：webpack</a> 和 <a href=\"http://zxinc520.com/lcj/%225cb72a04009ae94788aa0d7f%22\">Vue 第六天学习：深入 webpack</a> 以及 <a href=\"http://zxinc520.com/lcj/%225cc4640d9b3032095d9e5754%22\">React 学习第一天：创建基本的 webpack4.x 项目 </a></p>\n</blockquote>\n<h4 id=\"rollupjs\"><a class=\"markdownIt-Anchor\" href=\"#rollupjs\">#</a> rollup.js</h4>\n<blockquote>\n<p>概述 (Overview) <a href=\"https://www.rollupjs.com/guide/zh\">中文文档</a> <a href=\"https://rollupjs.org/guide/en/\">官网</a></p>\n<p>Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。Rollup 对代码模块使用新的标准化格式，这些标准都包含在 JavaScript 的 ES6 版本中，而不是以前的特殊解决方案，如 CommonJS 和 AMD。ES6 模块可以使你自由、无缝地使用你最喜爱的 library 中那些最有用独立函数，而你的项目不必携带其他未使用的代码。ES6 模块最终还是要由浏览器原生实现，但当前 Rollup 可以使你提前体验</p>\n<p><strong>rollup 功能单一（极致） ，webpack 功能强大</strong></p>\n</blockquote>\n<h4 id=\"关于-js-众多-模块化标准\"><a class=\"markdownIt-Anchor\" href=\"#关于-js-众多-模块化标准\">#</a> 关于 JS 众多 模块化标准</h4>\n<blockquote>\n<p>关于 JS 众多 模块化标准</p>\n<p>详情可参考我的博客：<a href=\"http://zxinc520.com/lcj/%225d31940b724e8113740499b3%22\">开发环境： 模块化</a></p>\n</blockquote>\n<p><strong>发展过程</strong></p>\n<ul>\n<li>没有模块化</li>\n<li>AMD 成为 标准，require.js （也有 CMD【<strong>用的不多</strong> 】）</li>\n<li>前端打包工具，nodejs 模块化可以被使用</li>\n<li>ES6 出现 ，想统一现在所有的模块化标准</li>\n<li>nodejs 积极支持，浏览器尚未统一</li>\n<li>你可以自造 lib，但是不要自造标准</li>\n</ul>\n<h3 id=\"问题解答\"><a class=\"markdownIt-Anchor\" href=\"#问题解答\">#</a> 问题解答</h3>\n<ul>\n<li>语法：import export （注意有无 default）</li>\n<li>环境：babel 编译 ES6 语法，模块化可用 webpack 和 rollup</li>\n<li>扩展：说一下自己对模块化标准统一的期待</li>\n</ul>\n<h2 id=\"2-2-class-和-普通构造函数有何区别\"><a class=\"markdownIt-Anchor\" href=\"#2-2-class-和-普通构造函数有何区别\">#</a> 2-2 Class 和 普通构造函数有何区别</h2>\n<blockquote>\n<p>Class 和 普通构造函数有何区别</p>\n<p><a href=\"http://zxinc520.com/lcj/%225cd03896bd482e21ac46a9d4%22\">我的博客：React 学习第二天：了解 class</a></p>\n</blockquote>\n<h3 id=\"知识点-2\"><a class=\"markdownIt-Anchor\" href=\"#知识点-2\">#</a> 知识点</h3>\n<ul>\n<li>JS 构造函数</li>\n<li>Class 基本语法</li>\n<li>语法糖</li>\n<li>继承</li>\n</ul>\n<h3 id=\"问题解答-2\"><a class=\"markdownIt-Anchor\" href=\"#问题解答-2\">#</a> 问题解答</h3>\n<ul>\n<li>Class 和 普通构造函数 有何区别 ？\n<ul>\n<li>Class 在语法上更加贴合面向对象的写法</li>\n<li>Class 实现继承更加易读、易理解</li>\n<li>更易于写 java 等后端语言的使用</li>\n<li>本质还是语法糖， 使用 prototype</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-3-promise-的基本使用\"><a class=\"markdownIt-Anchor\" href=\"#2-3-promise-的基本使用\">#</a> 2-3 Promise 的基本使用</h2>\n<h3 id=\"promise-的基本使用\"><a class=\"markdownIt-Anchor\" href=\"#promise-的基本使用\">#</a> Promise 的基本使用</h3>\n<blockquote>\n<p>可参考我的博客：<a href=\"http://zxinc520.com/lcj/%225cbb3bf05733fa0a66088c80%22\">Promise 详细分析</a></p>\n</blockquote>\n<ul>\n<li>Callback Hell</li>\n<li>Promise 语法</li>\n</ul>\n<h4 id=\"callback-hell\"><a class=\"markdownIt-Anchor\" href=\"#callback-hell\">#</a> Callback Hell</h4>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">loadImg</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">src<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">,</span> fail</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">var</span> img <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"img\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  img<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onload</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n  img<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onerror</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">fail</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n  img<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> src<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">var</span> src <span class=\"token operator\">=</span>\n  <span class=\"token string\">\"https://edu-image.nosdn.127.net/B34DC36428D2D51B8EF5EE2C83CE9BF2.png?imageView&amp;thumbnail=241y34&amp;quality=100\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">loadImg</span><span class=\"token punctuation\">(</span>\n  src<span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">img</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"failed\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"promise-语法\"><a class=\"markdownIt-Anchor\" href=\"#promise-语法\">#</a> Promise 语法</h4>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">loadImg</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">src</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">const</span> promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">var</span> img <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"img\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    img<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onload</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    img<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onerror</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    img<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> src<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> promise<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">var</span> src <span class=\"token operator\">=</span>\n  <span class=\"token string\">\"https://edu-image.nosdn.127.net/B34DC36428D2D51B8EF5EE2C83CE9BF2.png?imageView&amp;thumbnail=241y34&amp;quality=100\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> <span class=\"token function\">loadImg</span><span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nresult<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>\n  <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">img</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"faild\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nresult<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">img</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"问题解答-3\"><a class=\"markdownIt-Anchor\" href=\"#问题解答-3\">#</a> 问题解答</h3>\n<ul>\n<li>Promise 的基本使用和原理？\n<ul>\n<li>new Promise 实例，而且要 return</li>\n<li>new Promise 时要传入函数，函数有 resolve, reject 两个参数</li>\n<li>成功时执行 resolve () 失败时执行 reject ()</li>\n<li>then 监听结果</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-4-总结一下-es6-其它常用功能\"><a class=\"markdownIt-Anchor\" href=\"#2-4-总结一下-es6-其它常用功能\">#</a> 2-4 总结一下 ES6 其它常用功能</h2>\n<h3 id=\"知识点-3\"><a class=\"markdownIt-Anchor\" href=\"#知识点-3\">#</a> 知识点</h3>\n<ul>\n<li>let/const</li>\n<li>多行字符串 / 模板变量</li>\n<li>解构赋值</li>\n<li>块级作用域</li>\n<li>函数默认参数</li>\n<li>箭头函数</li>\n</ul>\n<h4 id=\"letconst\"><a class=\"markdownIt-Anchor\" href=\"#letconst\">#</a> let/const</h4>\n<p><img src=\"http://static.zxinc520.com/blog/20190804/IjRCPysI3ja5.png?imageslim\" alt=\"mark\"></p>\n<h4 id=\"多行字符串模板变量\"><a class=\"markdownIt-Anchor\" href=\"#多行字符串模板变量\">#</a> 多行字符串 / 模板变量</h4>\n<p><img src=\"http://static.zxinc520.com/blog/20190804/cmkreCVTvB3f.png?imageslim\" alt=\"mark\"></p>\n<h4 id=\"解构赋值\"><a class=\"markdownIt-Anchor\" href=\"#解构赋值\">#</a> 解构赋值</h4>\n<p><img src=\"http://static.zxinc520.com/blog/20190804/tkv3jll7XPJG.png?imageslim\" alt=\"mark\"></p>\n<h4 id=\"块级作用域\"><a class=\"markdownIt-Anchor\" href=\"#块级作用域\">#</a> 块级作用域</h4>\n<p><img src=\"http://static.zxinc520.com/blog/20190804/vqFw5Cyt1Okg.png?imageslim\" alt=\"mark\"></p>\n<h4 id=\"函数默认参数\"><a class=\"markdownIt-Anchor\" href=\"#函数默认参数\">#</a> 函数默认参数</h4>\n<p><img src=\"http://static.zxinc520.com/blog/20190804/rDHBLwq6djzQ.png?imageslim\" alt=\"mark\"></p>\n<h4 id=\"箭头函数\"><a class=\"markdownIt-Anchor\" href=\"#箭头函数\">#</a> 箭头函数</h4>\n<p><img src=\"http://static.zxinc520.com/blog/20190804/26aXyJj3eE8M.png?imageslim\" alt=\"mark\"></p>\n<p><img src=\"http://static.zxinc520.com/blog/20190804/XppPYlgRUceY.png?imageslim\" alt=\"mark\"></p>\n",
            "tags": [
                "ES6 模块化语法",
                "babel",
                "webpack",
                "rollup",
                "ES6"
            ]
        }
    ]
}