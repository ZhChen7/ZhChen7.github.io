<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>sunflower • Posts by &#34;玩转算法面试&#34; category</title>
        <link>http://example.com</link>
        <description>周琛的博客</description>
        <language>en</language>
        <pubDate>Wed, 11 Sep 2019 19:56:35 +0800</pubDate>
        <lastBuildDate>Wed, 11 Sep 2019 19:56:35 +0800</lastBuildDate>
        <category>blog</category>
        <category>个人博客</category>
        <category>rem</category>
        <category>less</category>
        <category>art-template</category>
        <category>算法面试</category>
        <category>算法</category>
        <category>大 O？</category>
        <category>复杂度分析</category>
        <category>大二</category>
        <category>数据库实训</category>
        <category>IDE</category>
        <category>Git</category>
        <category>模块化</category>
        <category>构建工具</category>
        <category>上线和回滚</category>
        <category>ES6 模块化语法</category>
        <category>babel</category>
        <category>webpack</category>
        <category>rollup</category>
        <category>ES6</category>
        <category>hybrid</category>
        <category>虚拟 DOM</category>
        <category>知识点概述</category>
        <category>JS</category>
        <category>实用工具</category>
        <category>面试全面总结</category>
        <category>JS 三座大山</category>
        <category>学习实训</category>
        <category>性能优化</category>
        <category>加载过程</category>
        <category>promise</category>
        <category>异步解决方案</category>
        <category>回调地狱</category>
        <category>React</category>
        <category>React源码</category>
        <category>Vue3</category>
        <category>vue</category>
        <category>跑马灯</category>
        <category>父子组件间通信</category>
        <category>路由</category>
        <category>监听事件（keyup ，watch ，computed ）</category>
        <category>nrm</category>
        <category>Mint-UI</category>
        <category>MUI</category>
        <category>MVVM</category>
        <category>响应式、模板解析、渲染</category>
        <category>微信小程序</category>
        <category>单线程</category>
        <category>event loop</category>
        <category>异步的 Deferred</category>
        <category>Promise</category>
        <category>html</category>
        <category>hexo</category>
        <category>redux</category>
        <category>UTC时间问题</category>
        <category>正则表达式</category>
        <category>虚拟DOM</category>
        <category>博文</category>
        <category>React-Router</category>
        <category>React-Hooks</category>
        <category>DOM</category>
        <category>BOM</category>
        <category>事件绑定</category>
        <category>ajax 请求</category>
        <category>储存</category>
        <category>进程调度</category>
        <category>过滤器</category>
        <category>按键修饰符</category>
        <category>指令</category>
        <category>生命周期</category>
        <category>过渡效果</category>
        <category>组件</category>
        <category>webpack 后续问题</category>
        <category>数组</category>
        <category>API</category>
        <category>跨域</category>
        <category>动画</category>
        <category>事件</category>
        <category>React基础面试题-50</category>
        <category>数组相关操作</category>
        <category>手撕代码</category>
        <category>牛人面试题</category>
        <item>
            <guid isPermalink="true">http://example.com/2019/09/11/ComplexityAnalysis/</guid>
            <title>面试中的复杂度分析</title>
            <link>http://example.com/2019/09/11/ComplexityAnalysis/</link>
            <category>算法面试</category>
            <category>算法</category>
            <category>大 O？</category>
            <category>复杂度分析</category>
            <pubDate>Wed, 11 Sep 2019 19:56:35 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;面试中的复杂度分析&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#面试中的复杂度分析&#34;&gt;#&lt;/a&gt; 面试中的复杂度分析&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;很多同学一提起复杂度分析就头疼，马上想起了《算法导论》中复杂的数学推导。但其实在一般的企业面试中，对复杂度的分析要求并没有那么高，但也是绕不过去的坎儿。在这一章，和大家介绍一下，面试中需要掌握的复杂度分析。…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-1-究竟什么是大-obig-o&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-1-究竟什么是大-obig-o&#34;&gt;#&lt;/a&gt; 2-1 究竟什么是大 O（Big O）&lt;/h2&gt;
&lt;h4 id=&#34;大-o&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#大-o&#34;&gt;#&lt;/a&gt; 大 O？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;n 表示数据规模&lt;/li&gt;
&lt;li&gt;O（f (n)）表示运行算法所需要执行的指令数，和 f (n) 成正比&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;例如&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#例如&#34;&gt;#&lt;/a&gt; 例如&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;二分查找法 O (logn) — 所需执行指令数 ：a * logn&lt;/li&gt;
&lt;li&gt;寻找 数组中的最大 / 最小值 O (n) — 所需执行指令数 ：b * n&lt;/li&gt;
&lt;li&gt;归并排序算法 O (nlogn) — 所需执行指令数 ：c * nlogn&lt;/li&gt;
&lt;li&gt;选择排序法 O (n^2) — 所需执行指令数 ：d * n^2&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;到底什么是-big-o&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#到底什么是-big-o&#34;&gt;#&lt;/a&gt; 到底什么是 Big O？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190909/61aLQ2wE8prQ.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190909/2PO7UfwEDOpW.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在学术界&lt;/strong&gt;，严格来讲，O (f (n)) 表示算法执行的上界&lt;/p&gt;
&lt;p&gt;归并排序算法的时间复杂度是 O (nlogn) 的，同时也是 O（n^2）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在业界&lt;/strong&gt;，我们就使用 O 来表示算法执行的最低上界&lt;/p&gt;
&lt;p&gt;我们一般不会说归并排序是 O (n^2) 的&lt;/p&gt;
&lt;h4 id=&#34;例子&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#例子&#34;&gt;#&lt;/a&gt; 例子&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;O（nlogn + n）= O （nlogn）&lt;/li&gt;
&lt;li&gt;O（nlogn + n&lt;sup&gt;2）=O（n&lt;/sup&gt;2）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;无法判断&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#无法判断&#34;&gt;#&lt;/a&gt; 无法判断&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;O（AlogA + B） – A 与 B 无法确定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O（AlogA + B ^2）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对邻接表实现的图进行遍历&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O（ V + E ）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一个时间复杂度的问题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一个时间复杂度的问题&#34;&gt;#&lt;/a&gt; 一个时间复杂度的问题&lt;/h3&gt;
&lt;p&gt;有一个字符串数组，将数组中的每一个字符串按照字母序排序；之后再将整个字符串数组按照字典序排序。整个操作的时间复杂度？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190909/8cfiXUHkirne.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;正确解答：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设最长的字符串长度为 s ；数组中有 n 个字符串&lt;/li&gt;
&lt;li&gt;对每个字符串排序：O（slogs）&lt;/li&gt;
&lt;li&gt;将数组中的每一个字符串按照字母序排序：O（n * slog (s) ）&lt;/li&gt;
&lt;li&gt;将整个字符串数组按照字典序排序：O（s * nlog (n) ）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190909/Q5nKtKe1dCi7.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;算法复杂度在有些情况是用例相关的&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#算法复杂度在有些情况是用例相关的&#34;&gt;#&lt;/a&gt; 算法复杂度在有些情况是用例相关的&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;插入排序 O（n ^ 2）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差情况：O（n ^ 2）&lt;/li&gt;
&lt;li&gt;最好情况：O（n）&lt;/li&gt;
&lt;li&gt;平均情况：O（n ^ 2）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快速排序算法 O （nlogn）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差情况：O（n ^ 2）&lt;/li&gt;
&lt;li&gt;最好情况：O（ nlogn ）&lt;/li&gt;
&lt;li&gt;平均情况：O（ nlogn ）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-2-对数据规模有一个概念&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-2-对数据规模有一个概念&#34;&gt;#&lt;/a&gt; 2-2 对数据规模有一个概念&lt;/h2&gt;
&lt;h3 id=&#34;抛出问题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#抛出问题&#34;&gt;#&lt;/a&gt; 抛出问题&lt;/h3&gt;
&lt;p&gt;对 10 ^ 5 的数据进行选择排序，结果计算机假死？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果要想在 1s 之内解决问题：
&lt;ul&gt;
&lt;li&gt;O（n ^ 2）的算法可以处理大约 10 ^ 4 级别的数据&lt;/li&gt;
&lt;li&gt;O（ n ）的算法可以处理大约 10 ^ 8 级别的数据&lt;/li&gt;
&lt;li&gt;O（ nlogn ）的算法可以处理大约 10 ^7 级别的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;空间复杂度&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#空间复杂度&#34;&gt;#&lt;/a&gt; 空间复杂度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;多开一个辅助的数组：O（n）&lt;/li&gt;
&lt;li&gt;多开一个辅助的二维数组：O（n ^ 2）&lt;/li&gt;
&lt;li&gt;多开常数空间：O（1）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190909/7uFcA2L2OHhI.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-3-简单的复杂度分析&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-3-简单的复杂度分析&#34;&gt;#&lt;/a&gt; 2-3 简单的复杂度分析&lt;/h2&gt;
&lt;h3 id=&#34;o1&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#o1&#34;&gt;#&lt;/a&gt; O（1）：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190909/wmyLLvW5hvGh.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;o-n&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#o-n&#34;&gt;#&lt;/a&gt; O（ n ）：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190909/R4zqgJ9zJqqs.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190909/fujJT4N78Ybh.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;1/2 *n 次 swap 操作也是：O (n) 。&lt;/p&gt;
&lt;h3 id=&#34;on-2-选择排序&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#on-2-选择排序&#34;&gt;#&lt;/a&gt; O（n ^ 2）: (选择排序)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190909/HPtrTeSx6DsB.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190909/rh5JcB9dA8ux.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;并不是所有双重循环都是 O（n ^ 2）：例如 【因为里面的循环次数是固定的 】&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190909/Vs0lBjzBPEi9.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面算法是 O（logn）级别的： 【 自增并不是每次都加 1 】&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190909/QJC2YLSAOdAk.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面算法是 O（ sqrt (n) ）【 判断 n 是不是 一个素数】&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190909/QeClcFN8EsWa.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ologn-二分查找法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ologn-二分查找法&#34;&gt;#&lt;/a&gt; O（logn）：（ 二分查找法 ）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190909/HCC3KITFnmlL.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190909/Y18HXPKRMICe.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;整形转成字符串&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#整形转成字符串&#34;&gt;#&lt;/a&gt; 整形转成字符串&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190909/gDCAKNS0NtKo.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;log-以-2-为底-和-以-10-为底有区别吗&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#log-以-2-为底-和-以-10-为底有区别吗&#34;&gt;#&lt;/a&gt; log 以 2 为底 和 以 10 为底有区别吗&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190909/hhkkzyo7uTJM.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-4-亲自试验自己算法的时间复杂度&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-4-亲自试验自己算法的时间复杂度&#34;&gt;#&lt;/a&gt; 2-4 亲自试验自己算法的时间复杂度&lt;/h2&gt;
&lt;h3 id=&#34;复杂度实验&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#复杂度实验&#34;&gt;#&lt;/a&gt; 复杂度实验&lt;/h3&gt;
&lt;p&gt;实验，观察趋势&lt;/p&gt;
&lt;p&gt;每次 将数据规模提高两倍，看时间的变化&lt;/p&gt;
&lt;h2 id=&#34;2-5-递归算法的复杂度分析&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-5-递归算法的复杂度分析&#34;&gt;#&lt;/a&gt; 2-5 递归算法的复杂度分析&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;不是有递归的函数就一定是 O（ nlogn ）！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;递归中进行一次递归调用的复杂度分析&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#递归中进行一次递归调用的复杂度分析&#34;&gt;#&lt;/a&gt; 递归中进行一次递归调用的复杂度分析&lt;/h3&gt;
&lt;p&gt;二分法使用递归：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190911/Vrm1PVyknLyf.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190911/HKc9QUhHzufd.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190911/Mrr5oypWBxGk.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190911/1hAzDU4ifP7w.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;引申：上述 函数增加求 负次幂？&lt;/p&gt;
&lt;h3 id=&#34;递归中进行多次递归调用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#递归中进行多次递归调用&#34;&gt;#&lt;/a&gt; 递归中进行多次递归调用&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190911/DmVGKhPNOvil.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190911/vlrGbmrXl4uo.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;深度不一样，并不是所有 多次递归调用 的时间复杂度 为：O（2 ^ n）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190911/copG1I1hd0ya.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;递归函数的时间复杂度&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#递归函数的时间复杂度&#34;&gt;#&lt;/a&gt; 递归函数的时间复杂度&lt;/h4&gt;
&lt;p&gt;查阅 &lt;strong&gt;主定理&lt;/strong&gt; （面试一般不考察）&lt;/p&gt;
&lt;h2 id=&#34;2-6-均摊时间复杂度分析amortized-time-analysis&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-6-均摊时间复杂度分析amortized-time-analysis&#34;&gt;#&lt;/a&gt; 2-6 均摊时间复杂度分析（Amortized Time Analysis）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190911/lH5rYQsGwqtN.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-7-避免复杂度的震荡&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-7-避免复杂度的震荡&#34;&gt;#&lt;/a&gt; 2-7 避免复杂度的震荡&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190911/glngyIU8g3Mi.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190911/AFsH4CLIkIE3.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;复杂度的震荡的解决方案&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#复杂度的震荡的解决方案&#34;&gt;#&lt;/a&gt; 复杂度的震荡的解决方案&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190911/hwAvgAw9rUM1.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2019/09/09/AlgorithmForTheInterview01/</guid>
            <title>算法面试到底是什么鬼</title>
            <link>http://example.com/2019/09/09/AlgorithmForTheInterview01/</link>
            <category>算法面试</category>
            <category>算法</category>
            <pubDate>Mon, 09 Sep 2019 10:43:24 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;算法面试到底是什么鬼&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#算法面试到底是什么鬼&#34;&gt;#&lt;/a&gt; 算法面试到底是什么鬼？&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;玩转算法面试 从真题到思维全面提升算法思维&lt;/p&gt;
&lt;p&gt;为了面试，更为了提升你的算法思维&lt;/p&gt;
&lt;p&gt;一提起算法面试，很多同学就会心有余悸。可其实，大多数企业的算法面试，并没有那么可怕。并不是一定要啃完整本《算法导论》，才能玩儿转算法面试；也并不是只有 ACM 参赛选手，才能笑傲算法面试。恰恰相反，大多数算法面试关注的算法思维，其实很基础。在这一章，和大家聊一聊，算法面试，到底是什么鬼？…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-1-算法面试不仅仅是正确的回答问题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-1-算法面试不仅仅是正确的回答问题&#34;&gt;#&lt;/a&gt; 1-1 算法面试不仅仅是正确的回答问题&lt;/h2&gt;
&lt;h4 id=&#34;算法面试是什么&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#算法面试是什么&#34;&gt;#&lt;/a&gt; 算法面试是什么？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;让大家在面对面试中的算法问题时，有一个合理的思考路径
&lt;ul&gt;
&lt;li&gt;不代表能够 “正确” 回答每一个算法问题，但是合理的思考方向其实更重要，这也是正确完成算法面试问题的前提&lt;/li&gt;
&lt;li&gt;算法面试优秀不意味着技术面试优秀&lt;/li&gt;
&lt;li&gt;技术面试优秀不意味着能够拿到 Offer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;引言&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#引言&#34;&gt;#&lt;/a&gt; 引言&lt;/h3&gt;
&lt;h4 id=&#34;问题对一组数据进行排序&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#问题对一组数据进行排序&#34;&gt;#&lt;/a&gt; 问题：对一组数据进行排序&lt;/h4&gt;
&lt;p&gt;不假思索思考方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速排序算法 O（nlogn）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;正确的方式&lt;/strong&gt;是：应该和面试官探讨（ &lt;strong&gt;思考路径&lt;/strong&gt; ）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这组数据有什么样的特征？
&lt;ul&gt;
&lt;li&gt;有没有可能包含有大量重复的元素？&lt;/li&gt;
&lt;li&gt;如果有这种可能的话，三路快排是更好的选择。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;这组数据有什么样的特征？
&lt;ul&gt;
&lt;li&gt;是否大部分数据距离它正确的位置很近？是否近乎有序？&lt;/li&gt;
&lt;li&gt;如果是这样的话，插入排序是更好的选择&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;这组数据有什么样的特征？
&lt;ul&gt;
&lt;li&gt;是否数据的取值范围非常有限？比如对学生成绩排序&lt;/li&gt;
&lt;li&gt;如果是这样的话，计数排序是更好的选择&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对排序有什么额外的要求？
&lt;ul&gt;
&lt;li&gt;是否需要稳定排序？&lt;/li&gt;
&lt;li&gt;如果是的话，归并排序是更好的选择&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据的存储状况是怎么样的？
&lt;ul&gt;
&lt;li&gt;是否是使用链表存储的？&lt;/li&gt;
&lt;li&gt;如果是的话，归并排序是更好的选择&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据的存储状态是怎样的？
&lt;ul&gt;
&lt;li&gt;数据的大小是否可以装载在内存里？&lt;/li&gt;
&lt;li&gt;数据量很大，或者内存很小，不足以装载在内存里，需要使用外排序算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-2-什么是正确的回答一个算法问题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-2-什么是正确的回答一个算法问题&#34;&gt;#&lt;/a&gt; 1-2 什么是 “正确” 的回答一个算法问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;正确&lt;/strong&gt; 还包含对问题的独到见解；优化；代码规范；容错性&lt;/p&gt;
&lt;p&gt;如果是 非常难的问题，对你的竞争对手来说，也是难的。&lt;/p&gt;
&lt;p&gt;关键在于你所表达出的解决问题的思路&lt;/p&gt;
&lt;p&gt;甚至通过表达解题思路的方向，得出结论：这个问题的解决方案，应该在哪一个领域，我可以通过查阅或者进一步学习解决问题&lt;/p&gt;
&lt;h3 id=&#34;常见问题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#常见问题&#34;&gt;#&lt;/a&gt; 常见问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;项目经历 和 项目中遇到的实际问题&lt;/li&gt;
&lt;li&gt;你遇到的印象最深的 bug 是什么？&lt;/li&gt;
&lt;li&gt;面向对象&lt;/li&gt;
&lt;li&gt;设计模式&lt;/li&gt;
&lt;li&gt;网络相关；安全相关；内存相关；并发相关&lt;/li&gt;
&lt;li&gt;系统设计；scalability&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;技术面试只是面试的一部分。面试不仅仅是考察你的技术水平，还是了解你的过去以及形成的思考行为方式&lt;/p&gt;
&lt;p&gt;关于过去：参与项目至关重要&lt;/p&gt;
&lt;h4 id=&#34;项目经历&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#项目经历&#34;&gt;#&lt;/a&gt; 项目经历&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;本科生
&lt;ul&gt;
&lt;li&gt;毕业设计&lt;/li&gt;
&lt;li&gt;其它课程设计 (大作业，大一点的程序设计等等)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如何找到项目？
&lt;ul&gt;
&lt;li&gt;实习&lt;/li&gt;
&lt;li&gt;参与实战课程学习
&lt;ul&gt;
&lt;li&gt;慕课网&lt;/li&gt;
&lt;li&gt;Coursera&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;创建自己的项目
&lt;ul&gt;
&lt;li&gt;自己做小应用：计划表；备忘录；播放器…&lt;/li&gt;
&lt;li&gt;自己解决小问题：爬虫；数据分析；词频统计&lt;/li&gt;
&lt;li&gt;“不是项目” 的项目：一本优秀的技术书籍的代码整理等…&lt;/li&gt;
&lt;li&gt;分享：自己的技术博客；github 等等…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;行为类问题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#行为类问题&#34;&gt;#&lt;/a&gt; 行为类问题&lt;/h4&gt;
&lt;p&gt;通过过去了解你的思考行为方式？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遇到的最大的挑战？&lt;/li&gt;
&lt;li&gt;犯过的错误？&lt;/li&gt;
&lt;li&gt;遭遇的失败？&lt;/li&gt;
&lt;li&gt;最享受的工作内容？&lt;/li&gt;
&lt;li&gt;遇到冲突的处理方式？&lt;/li&gt;
&lt;li&gt;做的最与众不同的事儿？&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;准备好合适的问题问面试官&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#准备好合适的问题问面试官&#34;&gt;#&lt;/a&gt; 准备好合适的问题问面试官&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;整个小组的大概运行模式是怎样的？&lt;/li&gt;
&lt;li&gt;整个项目的后续规划是如何的？&lt;/li&gt;
&lt;li&gt;这个产品中的某个问题是如何解决的？&lt;/li&gt;
&lt;li&gt;为什么会选择某些技术？标准？&lt;/li&gt;
&lt;li&gt;我对某个技术很感兴趣，在你的小组中我会有怎样的机会深入这种技术？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;算法面试仍然是非常重要的一部分&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-3-如何准备算法面试&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-3-如何准备算法面试&#34;&gt;#&lt;/a&gt; 1-3 如何准备算法面试&lt;/h2&gt;
&lt;p&gt;准备面试 和 准备算法面试 是两个概念&lt;/p&gt;
&lt;p&gt;算法面试 ，只是面试中的一个环节&lt;/p&gt;
&lt;h2 id=&#34;算法面试并没有那么难&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#算法面试并没有那么难&#34;&gt;#&lt;/a&gt; 算法面试并没有那么难&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;远远不需要啃完一本 《算法导论》
&lt;ul&gt;
&lt;li&gt;过于强调理论证明&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高级数据结构 和 算法面试提及的概率很低
&lt;ul&gt;
&lt;li&gt;红黑树&lt;/li&gt;
&lt;li&gt;计算几何&lt;/li&gt;
&lt;li&gt;B - Tree&lt;/li&gt;
&lt;li&gt;数论&lt;/li&gt;
&lt;li&gt;斐波那契堆&lt;/li&gt;
&lt;li&gt;FFT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;算法面试远远不需要达到信息学竞赛的水平&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190908/CNmOn2PupuUn.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;算法面试的准备范围&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#算法面试的准备范围&#34;&gt;#&lt;/a&gt; 算法面试的准备范围&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不要轻视基础算法 和 数据结构，而只关注 “有意思” 的题目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重点关注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;各种排序算法&lt;/li&gt;
&lt;li&gt;基础数据结构和算法的实现：如堆、二叉树、图…&lt;/li&gt;
&lt;li&gt;基础数据结构的使用：如链表、栈、队列、哈希表、图、Trie、并查集…&lt;/li&gt;
&lt;li&gt;基础算法：深度优先、广度优先、二分查找、递归…&lt;/li&gt;
&lt;li&gt;基本算法思想：递归、分治、回溯搜索、贪心、动态规划…&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;选择合适的-oj&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#选择合适的-oj&#34;&gt;#&lt;/a&gt; 选择合适的 OJ&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;OJ：online judge&lt;/p&gt;
&lt;p&gt;在线判题系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190908/iW0zhuflnMIs.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;推荐&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#推荐&#34;&gt;#&lt;/a&gt; 推荐&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/&#34;&gt;LeetCode&lt;/a&gt; （ 源于真实的面试问题 ）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hackerrank.com/&#34;&gt;HackerRank&lt;/a&gt; （ 对问题分类很详细 ，更难一点，辅助作用）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;： 在学习和实践做题之间，要掌握平衡&lt;/p&gt;
&lt;h2 id=&#34;1-4-解决算法面试问题的整体思路&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-4-解决算法面试问题的整体思路&#34;&gt;#&lt;/a&gt; 1-4 解决算法面试问题的整体思路&lt;/h2&gt;
&lt;h3 id=&#34;注意题目中的条件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注意题目中的条件&#34;&gt;#&lt;/a&gt; 注意题目中的条件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;给定一个有序数组…
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;有序&lt;/strong&gt;： 是不是可以使用二分查找法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有一些题目中的条件本质是暗示：
&lt;ul&gt;
&lt;li&gt;设计一个 O（nlogn）的算法
&lt;ul&gt;
&lt;li&gt;分治法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无需考虑额外的空间
&lt;ul&gt;
&lt;li&gt;开辟额外的空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据规模大概是 10000
&lt;ul&gt;
&lt;li&gt;O（n 的二次方）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;当没有思路的时候&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#当没有思路的时候&#34;&gt;#&lt;/a&gt; 当没有思路的时候&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;自己给自己几个简单的测试用例，试验一下&lt;/li&gt;
&lt;li&gt;不要忽视暴力解法。暴力解法通常是思考的起点&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;不要忽视暴力法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#不要忽视暴力法&#34;&gt;#&lt;/a&gt; 不要忽视暴力法&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190908/4H4HSG2k68nE.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.zxinc520.com/blog/20190908/DTm490pyX7Vm.png?imageslim&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;优化算法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#优化算法&#34;&gt;#&lt;/a&gt; 优化算法&lt;/h2&gt;
&lt;h3 id=&#34;无头绪的思路&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#无头绪的思路&#34;&gt;#&lt;/a&gt; 无头绪的思路&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;遍历常见的算法思路&lt;/li&gt;
&lt;li&gt;遍历常见的数据结构&lt;/li&gt;
&lt;li&gt;空间 和 时间的 交换 （ 哈希表 ）&lt;/li&gt;
&lt;li&gt;预处理信息 （ 排序 ）&lt;/li&gt;
&lt;li&gt;在瓶颈处寻找答案：O（nlogn）+ O（n ∧ 2）；O（n∧3）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实际编写问题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#实际编写问题&#34;&gt;#&lt;/a&gt; 实际编写问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;极端条件的判断
&lt;ul&gt;
&lt;li&gt;数组为空？字符串为空？数量为 0? 指针为 NULL ？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;变量名&lt;/li&gt;
&lt;li&gt;模块化，复用性&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
