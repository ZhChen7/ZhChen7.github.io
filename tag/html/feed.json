{
    "version": "https://jsonfeed.org/version/1",
    "title": "sunflower • All posts by \"html\" tag",
    "description": "周琛的博客",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2020/03/23/getOfferhtml2/",
            "url": "http://example.com/2020/03/23/getOfferhtml2/",
            "title": "html 面试考点全面总结下篇",
            "date_published": "2020-03-23T09:18:21.000Z",
            "content_html": "<h2 id=\"html-面试考点全面总结下篇\"><a class=\"markdownIt-Anchor\" href=\"#html-面试考点全面总结下篇\">#</a> html 面试考点全面总结下篇</h2>\n<blockquote>\n<p>拿到 字节跳动实习生 offer 总结</p>\n<p>回馈分享一波自己的知识点总结</p>\n</blockquote>\n<blockquote>\n<p>希望读者依此构建自己的知识树（思维导图）</p>\n<p>偷懒一下：可参考我自己总结思维导图 : <a href=\"https://github.com/ZhChen7/Interview-mind-map\">点这里</a></p>\n<p>附带：高频面试题积累文档。 来自于（学长、牛客网等平台）</p>\n<p>自己开发的博客地址：<a href=\"http://zxinc520.com/\">zxinc520.com</a></p>\n<p>github 地址: <a href=\"https://github.com/ZhChen7\">点击</a></p>\n</blockquote>\n<blockquote>\n<p>此篇 html 共总结 22 大知识点： 全部弄懂了，面试很容易。</p>\n</blockquote>\n<h3 id=\"11-label-标签\"><a class=\"markdownIt-Anchor\" href=\"#11-label-标签\">#</a> 11、label 标签</h3>\n<blockquote>\n<p>作用：用于定义表单控件的关系，点击时自动将焦点移至相关联的控件。</p>\n</blockquote>\n<h4 id=\"两个有用属性\"><a class=\"markdownIt-Anchor\" href=\"#两个有用属性\">#</a> 两个有用属性</h4>\n<ul>\n<li>for\n<ul>\n<li>关联相关控件</li>\n<li>通过控件 id 关联</li>\n</ul>\n</li>\n<li>accessKey ：设置访问快捷键 例如：accesskey=“h”</li>\n</ul>\n<blockquote>\n<p><strong>注意</strong> ：该标签不能为 a 和 button 标签的后代</p>\n</blockquote>\n<h3 id=\"12-link-与-import\"><a class=\"markdownIt-Anchor\" href=\"#12-link-与-import\">#</a> 12、link 与 @import</h3>\n<blockquote>\n<p>link ：建议使用</p>\n<p>@import ：慎用 【会造成 “无样式内容闪烁”】</p>\n</blockquote>\n<h4 id=\"link-与-import-区别\"><a class=\"markdownIt-Anchor\" href=\"#link-与-import-区别\">#</a> link 与 @import 区别</h4>\n<ol>\n<li>从属和作用\n<ul>\n<li>link 是 HTML 提供的标签\n<ul>\n<li>可以加载 css</li>\n<li>可以定义 rel 等属性（rel 属性规定当前文档与被链接文档之间的关系。） 【技巧：这里引申到 预加载知识：可以关注 Resource Hint 标准 — <strong>页面加载性能利器</strong>】</li>\n</ul>\n</li>\n<li>@import 是 css 提供的语法\n<ul>\n<li>只有导入样式表的作用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>加载顺序\n<ul>\n<li>link 在页面加载时 css 同时被加载</li>\n<li>@import 引入的 css 需要等页面加载后再加载</li>\n</ul>\n</li>\n<li>兼容性问题\n<ul>\n<li>link 是 HTML 提供的语法，没有兼容性问题</li>\n<li>@import 是 css2.1 提供的语法，ie5 以上才兼容</li>\n</ul>\n</li>\n<li>DOM 可控性\n<ul>\n<li>js 可以通过插入 link 标签来改变样式</li>\n<li>js 不可以通过 @import 去引入新的 css 文件来改变样式</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"13-target\"><a class=\"markdownIt-Anchor\" href=\"#13-target\">#</a> 13、target</h3>\n<blockquote>\n<p>属性作用：指定所连接的页面在浏览器窗口中的打开方式</p>\n</blockquote>\n<h5 id=\"属性\"><a class=\"markdownIt-Anchor\" href=\"#属性\">#</a> 属性</h5>\n<ul>\n<li>_self（默认值）：在当前窗口打开</li>\n<li>_blank： 在新窗口中打开</li>\n<li>_parent ： 在父级窗口打开</li>\n<li>_top ： 在顶级窗口打开</li>\n</ul>\n<h3 id=\"14-部分标签属性区别\"><a class=\"markdownIt-Anchor\" href=\"#14-部分标签属性区别\">#</a> 14、部分标签 / 属性区别</h3>\n<h4 id=\"标签区别\"><a class=\"markdownIt-Anchor\" href=\"#标签区别\">#</a> 标签区别</h4>\n<ul>\n<li>title 和 h1\n<ul>\n<li>title ：只表示是个标题</li>\n<li>h1-h7\n<ul>\n<li>表示层次明确的标题</li>\n<li>对页面信息的抓取有帮助</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>b 与 strong\n<ul>\n<li>b：展示为粗体</li>\n<li>strong\n<ul>\n<li>标明重点内容，有语气加强的含义 u</li>\n<li>使用阅读设备时，会重读</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>i 与 em\n<ul>\n<li>i：展示为斜体</li>\n<li>em：表示强调的文本</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"属性区别\"><a class=\"markdownIt-Anchor\" href=\"#属性区别\">#</a> 属性区别</h4>\n<ul>\n<li>src 与 href\n<ul>\n<li>src：引入；将指定资源应用到文档内.</li>\n<li>href：引用；建立与当前文档之间的链接.</li>\n</ul>\n</li>\n<li>【img】title 和 alt\n<ul>\n<li>title\n<ul>\n<li>全局属性</li>\n<li>提供关于元素的额外信息</li>\n<li>鼠标移至显示</li>\n</ul>\n</li>\n<li>alt\n<ul>\n<li>用于图片无法加载时显示</li>\n<li>web Quality（无障碍）易访问的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"15-shadow-dom影子-dom\"><a class=\"markdownIt-Anchor\" href=\"#15-shadow-dom影子-dom\">#</a> 15、Shadow DOM（影子 DOM）</h3>\n<h4 id=\"是什么\"><a class=\"markdownIt-Anchor\" href=\"#是什么\">#</a> 是什么？</h4>\n<blockquote>\n<p>浏览器的一种能力 ：渲染时插入独立的 DOM 树</p>\n</blockquote>\n<h4 id=\"特点\"><a class=\"markdownIt-Anchor\" href=\"#特点\">#</a> 特点？</h4>\n<ul>\n<li>与原始 DOM 完全隔离</li>\n<li>具有自己的元素和样式</li>\n</ul>\n<h4 id=\"作用\"><a class=\"markdownIt-Anchor\" href=\"#作用\">#</a> 作用？</h4>\n<ul>\n<li>封装需要隔离外部的文档细节 / 组件</li>\n<li>防止开发人员随意修改样式</li>\n</ul>\n<h4 id=\"使用方式\"><a class=\"markdownIt-Anchor\" href=\"#使用方式\">#</a> 使用方式？</h4>\n<ul>\n<li>Node1.attachShadow(Node2)</li>\n<li>Node2.innerHTML = …</li>\n</ul>\n<h3 id=\"16-浏览器的数据存储方式有哪些\"><a class=\"markdownIt-Anchor\" href=\"#16-浏览器的数据存储方式有哪些\">#</a> 16、浏览器的数据存储方式有哪些</h3>\n<blockquote>\n<p>分为三类来讲：</p>\n<p>cookie 、localStorage 和 sessionStorage 、userData。</p>\n</blockquote>\n<h4 id=\"cookie\"><a class=\"markdownIt-Anchor\" href=\"#cookie\">#</a> cookie</h4>\n<blockquote>\n<p>h5 之前，存储主要用 cookies，缺点是在请求头上带着数据，导致流量增加。大小限制 4k</p>\n</blockquote>\n<h5 id=\"创建目的\"><a class=\"markdownIt-Anchor\" href=\"#创建目的\">#</a> 创建目的</h5>\n<ul>\n<li>为了保持 HTTP 的状态</li>\n<li>为了识别用户信息而储存在本地上的数据</li>\n</ul>\n<h5 id=\"特点-2\"><a class=\"markdownIt-Anchor\" href=\"#特点-2\">#</a> 特点</h5>\n<ol>\n<li>可储存大小为 4k</li>\n<li>储存个数有限制（各浏览器不同）</li>\n<li>有效时间在设置的 cookie 过期时间之前一直有效</li>\n</ol>\n<h4 id=\"localstorage-和-sessionstorage\"><a class=\"markdownIt-Anchor\" href=\"#localstorage-和-sessionstorage\">#</a> localStorage 和 sessionStorage</h4>\n<blockquote>\n<p>创建目的：便于客户端储存数据</p>\n</blockquote>\n<h5 id=\"相同点\"><a class=\"markdownIt-Anchor\" href=\"#相同点\">#</a> 相同点</h5>\n<ul>\n<li>都由 HTML5 Web Storage API 提供</li>\n<li>在本地保存</li>\n<li>可储存大小 5M 以上</li>\n</ul>\n<h5 id=\"不同点\"><a class=\"markdownIt-Anchor\" href=\"#不同点\">#</a> 不同点</h5>\n<ul>\n<li>有效时间不同\n<ul>\n<li>localStorage（以键值对 (Key-Value) 的方式存储）\n<ul>\n<li>储存持久数据</li>\n<li>浏览器关闭后数据不丢失除非主动清除数据</li>\n</ul>\n</li>\n<li>sessionStorage\n<ul>\n<li>数据在当前浏览器关闭后自动删除</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>作用域不同\n<ul>\n<li>localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。</li>\n<li>sessionStorage 不在不同的浏览器页面中共享，即使是同一个页面</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>安全性：需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的，因为它们保存在本地容易被篡改，使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。所以千万不要用它们存储你系统中的敏感数据。</p>\n</blockquote>\n<h4 id=\"userdata\"><a class=\"markdownIt-Anchor\" href=\"#userdata\">#</a> userData</h4>\n<h5 id=\"特点-3\"><a class=\"markdownIt-Anchor\" href=\"#特点-3\">#</a> 特点</h5>\n<ul>\n<li>IE 专属 ：早期 IE 浏览器用来本地储存数据用的</li>\n<li>以文件的形式保存在磁盘上 ：持久化储存方式</li>\n<li>可以设置失效日期</li>\n<li>可储存大小 1MB 左右</li>\n</ul>\n<blockquote>\n<p>注意：使用 IE 条件注释来避免其它浏览器载入上述代码 &lt;<em>!–[if IE]&gt;&lt;[end If]–</em> &gt;</p>\n</blockquote>\n<h3 id=\"17-如何实现标签页面的通信\"><a class=\"markdownIt-Anchor\" href=\"#17-如何实现标签页面的通信\">#</a> 17、如何实现标签页面的通信</h3>\n<ol>\n<li>\n<p>方法一 ：使用 localStorage</p>\n<ul>\n<li>\n<p>使用 localStorage.setItem (key,value) 添加内容</p>\n</li>\n<li>\n<p>使用 Storage 事件监听添加、修改、删除的动作</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">window<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onstorage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">// 或者这样</span>\nwindow<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'storage'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>方法二：使用 cookie+setInterval</p>\n<ul>\n<li>将要传递的信息储存在 cookie 中</li>\n<li>每隔一定时间读取 cookie 信息，获取要传递的信息</li>\n<li><strong>具体描述</strong> ：1、在页面 A 设置一个使用 setInterval 定时器不断刷新，检查 Cookies 的值是否发生变化，如果变化就进行刷新的操作。 2、由于 Cookies 是在同域可读的，所以在页面 B 审核的时候改变 Cookies 的值，页面 A 自然是可以拿到的。这样做确实可以实现我想要的功能，但是这样的方法相当浪费资源。虽然在这个性能过盛的时代，浪费不浪费也感觉不出来，但是这种实现方案，确实不够优雅。</li>\n</ul>\n</li>\n<li>\n<p>方法三 ：websocket 通讯（HTML5）</p>\n<ul>\n<li>定义：WebSocket 是 HTML5 新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。</li>\n<li>WebSocket 连接必须由浏览器发起，特点\n<ul>\n<li>建立在 TCP 协议之上，服务器端的实现比较容易。</li>\n<li>与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>\n<li>数据格式比较轻量，性能开销小，通信高效。</li>\n<li>可以发送文本，也可以发送二进制数据。</li>\n<li>没有同源限制，客户端可以与任意服务器通信。</li>\n<li>协议标识符是 ws（如果加密，则为 wss），服务器网址就是</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>SharedWorker（html5 浏览器的新特性 SharedWorker）</p>\n<ul>\n<li>本质还是单线程，只是利用了浏览器不同 JS 引擎</li>\n<li>必须在服务器上才跑得动</li>\n<li>IE 未兼容</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"18-谈谈-cookie-和-session-的区别\"><a class=\"markdownIt-Anchor\" href=\"#18-谈谈-cookie-和-session-的区别\">#</a> 18、谈谈 cookie 和 session 的区别</h3>\n<blockquote>\n<p>共同点：记录用户状态</p>\n</blockquote>\n<h4 id=\"区别\"><a class=\"markdownIt-Anchor\" href=\"#区别\">#</a> 区别：</h4>\n<h5 id=\"cookie-2\"><a class=\"markdownIt-Anchor\" href=\"#cookie-2\">#</a> cookie</h5>\n<ul>\n<li>\n<p>什么是 Cookie？</p>\n<p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>\n</li>\n<li>\n<p>采用的是在客户端保持状态的方案 ： 即运行在客户端</p>\n</li>\n<li>\n<p>有大小限制，存储个数有限</p>\n</li>\n<li>\n<p>有安全隐患 ：通过某些手法可以篡改本地储存的信息来欺骗客户端</p>\n</li>\n<li>\n<p>支持跨域名访问</p>\n</li>\n</ul>\n<h5 id=\"session\"><a class=\"markdownIt-Anchor\" href=\"#session\">#</a> session</h5>\n<ul>\n<li>\n<p>什么是 Session？</p>\n<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>\n</li>\n<li>\n<p>采用的是在服务端保持状态的方案： 即运行在服务端</p>\n</li>\n<li>\n<p>没有大小限制和服务器内存大小有关</p>\n</li>\n<li>\n<p>过多会增加服务器压力</p>\n</li>\n<li>\n<p>仅在他所在的域名内有效</p>\n</li>\n</ul>\n<h4 id=\"cookie-和-session-流程介绍\"><a class=\"markdownIt-Anchor\" href=\"#cookie-和-session-流程介绍\">#</a> cookie 和 session 流程介绍</h4>\n<blockquote>\n<p>1、用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>\n<p>2、当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>\n<p>3、根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p>\n</blockquote>\n<h4 id=\"181-既然服务端是根据-cookie-中的信息判断用户是否登录那么如果浏览器中禁止了-cookie如何保障整个机制的正常运转\"><a class=\"markdownIt-Anchor\" href=\"#181-既然服务端是根据-cookie-中的信息判断用户是否登录那么如果浏览器中禁止了-cookie如何保障整个机制的正常运转\">#</a> 18.1、既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转</h4>\n<ul>\n<li>\n<p>第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 xxx?SessionID=123456…。</p>\n</li>\n<li>\n<p>第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。</p>\n<p>Token 的意思是 “令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。</p>\n<p>当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。</p>\n</li>\n</ul>\n<h4 id=\"182-如何考虑分布式-session-问题\"><a class=\"markdownIt-Anchor\" href=\"#182-如何考虑分布式-session-问题\">#</a> 18.2、如何考虑分布式 Session 问题？</h4>\n<ul>\n<li>在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。</li>\n<li>分布式 Session 一般会有以下几种解决方案\n<ul>\n<li>Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</li>\n<li>Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</li>\n<li>共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"183-cookie-和-session-各自优势\"><a class=\"markdownIt-Anchor\" href=\"#183-cookie-和-session-各自优势\">#</a> 18.3、cookie 和 session 各自优势</h4>\n<h5 id=\"cookie-3\"><a class=\"markdownIt-Anchor\" href=\"#cookie-3\">#</a> cookie</h5>\n<ul>\n<li>极高的扩展性和可用性</li>\n<li>不需要使用大量服务器资源</li>\n<li>简单性 Cookie 是一种基于文本的轻量结构，包含简单的键值对，结构简单。</li>\n</ul>\n<h5 id=\"session-2\"><a class=\"markdownIt-Anchor\" href=\"#session-2\">#</a> session</h5>\n<ul>\n<li>易于读写</li>\n<li>易于站点的用户化</li>\n</ul>\n<h4 id=\"184cookie-和-session-常见攻击方式及解决方案\"><a class=\"markdownIt-Anchor\" href=\"#184cookie-和-session-常见攻击方式及解决方案\">#</a> 18.4：cookie 和 session 常见攻击方式及解决方案</h4>\n<h5 id=\"cookie-4\"><a class=\"markdownIt-Anchor\" href=\"#cookie-4\">#</a> cookie</h5>\n<ul>\n<li>具体\n<ul>\n<li>直接访问 Cookie 文件查找想要的机密文件</li>\n<li>进行 Cookie 信息传递时被截取</li>\n<li>攻击者伪造 Cookie 信息，客户端获取后进行操作</li>\n</ul>\n</li>\n<li>解决方案\n<ul>\n<li>不要早 Cookie 中保存敏感信息</li>\n<li>不要早 Cookie 中保存没有经过加密的或者容易被解密的敏感信息</li>\n<li>对从客户端获取得的 Cookie 信息进行严格校验</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"session-3\"><a class=\"markdownIt-Anchor\" href=\"#session-3\">#</a> session</h5>\n<ul>\n<li>具体\n<ul>\n<li>会话劫持（通过获取用户 Session ID 后，使用该 Session ID 登录目标账号）</li>\n<li>会话固定（诱骗受害者使用攻击者指定的会话标识 Session ID 的攻击手段）</li>\n</ul>\n</li>\n<li>解决方案\n<ul>\n<li>使用 User-Agent 检测请求的一致性，设置 HttpOnly，可以防止客户端脚本访问这个 Cookie，从而有效的防止 XSS 攻击；关闭透明化 Session ID；更改 Session 名称</li>\n<li>用户登录时生成新的 Session ID</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"19-谈谈对-websocket-的认识\"><a class=\"markdownIt-Anchor\" href=\"#19-谈谈对-websocket-的认识\">#</a> 19、谈谈对 WebSocket 的认识</h3>\n<blockquote>\n<p>创建原因：HTTP 协议只能由客户端发起 单向连接</p>\n</blockquote>\n<h4 id=\"191-是什么\"><a class=\"markdownIt-Anchor\" href=\"#191-是什么\">#</a> 19.1、是什么？</h4>\n<ul>\n<li>HTML5 中的协议，支持持久连接</li>\n<li>WebSocket 是基于 HTTP 协议的 ： 借用了 Http 协议来完成一部分握手</li>\n<li>是真正意义上的双向绑定</li>\n</ul>\n<h4 id=\"192-websocket-区别-http-协议\"><a class=\"markdownIt-Anchor\" href=\"#192-websocket-区别-http-协议\">#</a> 19.2、WebSocket 区别 http 协议</h4>\n<ul>\n<li>http 协议 不支持持久性连接</li>\n<li>HTTP1.1 中出现 keep-alive，合并多个 http 请求</li>\n<li>HTTP 的生命周期通过 Request 来界定 ： 一个 Request 对应一个 Response</li>\n<li>Response 是被动的，不能主动发起</li>\n</ul>\n<h4 id=\"193-如何模拟双向通信\"><a class=\"markdownIt-Anchor\" href=\"#193-如何模拟双向通信\">#</a> 19.3、如何模拟双向通信</h4>\n<ul>\n<li>短轮询\n<ul>\n<li>客户端定时向服务器发送 Ajax 请求，服务器接到请求后马上返回响应信息并关闭连接。</li>\n<li>优点 ： 后端编写容易</li>\n<li>缺点 ： 请求中大半是无用，浪费宽带和服务器资源</li>\n<li>适用 ： 小型应用</li>\n</ul>\n</li>\n<li>长轮询\n<ul>\n<li>客户端向服务器发送 Ajax 请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。</li>\n<li>优点 ：在无消息的情况下不会频繁的请求，耗费资源小</li>\n<li>缺点\n<ul>\n<li>服务器 hold 连接会消耗资源</li>\n<li>返回数据顺序无保证，难于管理维护</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>长连接\n<ul>\n<li>在页面嵌入一个隐藏 iframe，将这个隐藏 iframe 的 src 属性设为对一个长连接的请求或是采用 xhr 请求，服务器端就能源源不断的往客户端输入数据</li>\n<li>优点\n<ul>\n<li>消息及时到达，不发无用请求</li>\n<li>管理起来也相对方便</li>\n</ul>\n</li>\n<li>缺点：服务器维护一个长连接会增加开销</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"20-渲染-了解网页渲染流程与优化技巧\"><a class=\"markdownIt-Anchor\" href=\"#20-渲染-了解网页渲染流程与优化技巧\">#</a> 20、渲染 | 了解网页渲染流程与优化技巧</h3>\n<h4 id=\"201-生成网页步骤\"><a class=\"markdownIt-Anchor\" href=\"#201-生成网页步骤\">#</a> 20.1、生成网页步骤</h4>\n<ul>\n<li>HTML 代码转成 DOM（Document Object Model）： 解析 HTML 生成</li>\n<li>CSS 代码转化成 CSSOM（CSS Object Model）： 解析 CSS 生成</li>\n<li>结合 DOM 和 CSSOM 生成一颗渲染树： 包含每个节点的视觉信息</li>\n<li>生成布局（layout）： 将所有渲染树的所有节点进行平面合成</li>\n<li>将布局绘制（paint）在屏幕上</li>\n</ul>\n<h4 id=\"202-重新渲染-重排回流和重绘\"><a class=\"markdownIt-Anchor\" href=\"#202-重新渲染-重排回流和重绘\">#</a> 20.2、重新渲染 （重排【回流】和重绘）</h4>\n<h5 id=\"重排回流\"><a class=\"markdownIt-Anchor\" href=\"#重排回流\">#</a> 重排（回流）</h5>\n<blockquote>\n<p>重新生成布局</p>\n</blockquote>\n<h5 id=\"布局改了就一定会重排\"><a class=\"markdownIt-Anchor\" href=\"#布局改了就一定会重排\">#</a> 布局改了就一定会重排</h5>\n<ol>\n<li>添加或删除可见的 DOM 元素</li>\n<li>元素位置改变</li>\n<li>元素尺寸改变 —— 边距、填充、边框、宽度和高度</li>\n<li>内容改变 —— 比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；</li>\n<li>页面渲染器初始化</li>\n<li>浏览器窗口尺寸改变 ——resize 事件发生时；</li>\n</ol>\n<blockquote>\n<p>重排一定需要重绘</p>\n</blockquote>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">var s = document.body.style<span class=\"token punctuation\">;</span>\ns.padding = <span class=\"token string\">\"2px\"</span><span class=\"token punctuation\">;</span> // 回流+重绘\ns.border = <span class=\"token string\">\"1px solid red\"</span><span class=\"token punctuation\">;</span> // 再一次 回流+重绘\ns.color = <span class=\"token string\">\"blue\"</span><span class=\"token punctuation\">;</span> // 重绘\ns.backgroundColor = <span class=\"token string\">\"#ccc\"</span><span class=\"token punctuation\">;</span> // 重绘\ns.fontSize = <span class=\"token string\">\"14px\"</span><span class=\"token punctuation\">;</span> // 再一次 回流+重绘\ndocument.body.<span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>document.<span class=\"token function\">createTextNode</span><span class=\"token punctuation\">(</span><span class=\"token string\">'abc!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>// 添加node，再一次 回流+重绘<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"重绘\"><a class=\"markdownIt-Anchor\" href=\"#重绘\">#</a> 重绘</h4>\n<blockquote>\n<p>只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫称为重绘。</p>\n</blockquote>\n<h4 id=\"重新渲染出现情况\"><a class=\"markdownIt-Anchor\" href=\"#重新渲染出现情况\">#</a> 重新渲染出现情况</h4>\n<ul>\n<li>修改 DOM</li>\n<li>修改样式表</li>\n<li>用户事件\n<ul>\n<li>鼠标悬停</li>\n<li>页面滚动</li>\n<li>输入框输入文字</li>\n<li>改变窗口等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"21-性能优化技巧\"><a class=\"markdownIt-Anchor\" href=\"#21-性能优化技巧\">#</a> 21、性能优化技巧</h3>\n<blockquote>\n<p>回答性能优化问题时：分两层阐述：</p>\n<p>1、底层：重排【回流】和重绘层级 — 下面针对此层</p>\n<p>2、应用层（雅虎军规 35 条）— 在性能优化专题会仔细分析。</p>\n</blockquote>\n<h4 id=\"211-减少重新渲染频率\"><a class=\"markdownIt-Anchor\" href=\"#211-减少重新渲染频率\">#</a> 21.1、减少重新渲染频率</h4>\n<ol>\n<li>\n<p>DOM 的多个读 / 写操作应该放在一起。</p>\n<ul>\n<li>不要两个读操作之间，加入一个写操作</li>\n</ul>\n</li>\n<li>\n<p>如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候又要重排</p>\n</li>\n<li>\n<p>不要一条条地改变样式</p>\n<ul>\n<li>通过改变 class，csstext，一次改变样式</li>\n</ul>\n</li>\n<li>\n<p>尽量使用离线 DOM，而不是真实的网页 DOM，来改变元素样式</p>\n<ul>\n<li>\n<p>例如</p>\n<ul>\n<li>\n<p>操作 Document Fragment 对象</p>\n</li>\n<li>\n<p>cloneNode 克隆节点操作后替换</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>使用虚拟 DOM 的脚本库，比如 React，vue 等</p>\n</li>\n<li>\n<p>很新颖（嘻嘻）</p>\n</li>\n</ol>\n<ul>\n<li>设为 dispaly：none（需要一次重排和重绘）后进行 n 次操作，最后再恢复显示（需要一次重排和重绘）</li>\n<li>用两次重新渲染，取代了可能 n（可能是个大树）次的重新渲染</li>\n<li>只有在必要的时候，才将元素的 display 属性为可见</li>\n<li>visibility:hidden 的元素只对重绘有影响，不影响重排</li>\n<li>隐藏后不可见的元素读写不影响重排和重绘</li>\n</ul>\n<ol start=\"7\">\n<li>\n<p>使用调整重新渲染的方法 ： 可以大幅度提高网页性能</p>\n<ul>\n<li>使用 window.requestAnimationFrame () 方法\n<ul>\n<li>作用：将某些代码放到下一次重新渲染时执行</li>\n<li>适用\n<ul>\n<li>页面滚动事件的监听函数</li>\n<li>网页动画</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>使用 window.requestdleCallback () 方法\n<ul>\n<li>暂时就 Chrome 支持</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"212-减少渲染成本\"><a class=\"markdownIt-Anchor\" href=\"#212-减少渲染成本\">#</a> 21.2、减少渲染成本</h4>\n<ul>\n<li>\n<p>position 属性为 absolute 或 fixed 的元素，重排的开销会比较小</p>\n<p>因为它们脱离文档，不用考虑他们对其他元素的影响，所以用 absolute，而少用 float</p>\n</li>\n</ul>\n<h3 id=\"22-html5-概括\"><a class=\"markdownIt-Anchor\" href=\"#22-html5-概括\">#</a> 22、HTML5 概括</h3>\n<blockquote>\n<p>HTML（超文本标记语言 HyperText Markup Language）的最新本版本</p>\n</blockquote>\n<h4 id=\"新增特性\"><a class=\"markdownIt-Anchor\" href=\"#新增特性\">#</a> 新增特性</h4>\n<ol>\n<li>\n<p>语义化元素 推荐使用</p>\n</li>\n<li>\n<p>新的通讯方式</p>\n<ul>\n<li>WebSockets</li>\n<li>重新绘制界面 布局没改，样式改了，需要重绘，不一定重排</li>\n</ul>\n</li>\n<li>\n<p>缓存</p>\n<ul>\n<li>应用程序缓存\n<ul>\n<li>使用方式\n<ul>\n<li>&lt;<em>html manifest=“demo.appcache”</em> &gt;</li>\n<li>manifest 文件的建议的文件扩展名是：&quot;.appcache&quot;</li>\n</ul>\n</li>\n<li>优点\n<ul>\n<li>离线浏览 - 用户可在应用离线时使用它们</li>\n<li>更快速度 - 已缓存资源加载得更快</li>\n<li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>浏览器缓存\n<ul>\n<li>Web Storage\n<ul>\n<li>localStorage</li>\n<li>sessionStorage</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>多媒体</p>\n<ul>\n<li>audio</li>\n<li>video</li>\n</ul>\n</li>\n<li>\n<p>3D &amp; 图像</p>\n<ul>\n<li>canvas</li>\n<li>WebGL：用 canvas 元素中的 API 实现 3D 图像功能</li>\n<li>svg ：基于 XML 直接嵌入到 HTML 中的矢量图形格式</li>\n</ul>\n</li>\n<li>\n<p>性能 &amp; 集成</p>\n<ul>\n<li>\n<p>Web workers</p>\n<p>Web Worker 是为了解决 JavaScript 在浏览器环境中没有多线程的问题。正常形况下，浏览器执行某段程序的时候会阻塞直到运行结束后在恢复到正常状态，而 HTML5 的 Web Worker 就是为了解决这个问题，提升程序的执行效率。 所以 Web Worker 的最佳使用场景是执行一些开销较大的数据处理或计算任务。</p>\n</li>\n<li>\n<p>web worker 的创建</p>\n<ul>\n<li>worker 是一个对象，通过构造函数 Worker 创建，参数就是一个 js 文件的路径；文件中的 js 代码将运行在主线程之外的 worker 线程；</li>\n<li>例如：var myWorker = new Worker (‘worker.js’);</li>\n</ul>\n</li>\n<li>\n<p>History API ：允许对浏览器历史记录进行操作</p>\n</li>\n<li>\n<p>XMLHttpRequest Level 2 (（XHR）对象可以与服务器交互。)</p>\n<p>新版本功能：</p>\n<ul>\n<li>可以设置 HTTP 请求的时限</li>\n<li>可以使用 FormData 对象管理表单数据。</li>\n<li>可以上传文件。</li>\n<li>可以请求不同域名下的数据（跨域请求）</li>\n<li>可以获取服务器端的二进制数据</li>\n<li>可以获得数据传输的进度信息</li>\n</ul>\n<p>老版本的缺点：</p>\n<ul>\n<li>只支持文本数据的传送，无法用来读取和上传二进制文件。</li>\n<li>传送和接收数据时，没有进度信息，只能提示有没有完成。</li>\n<li>受到 &quot;同域限制&quot;（Same Origin Policy），只能向同一域名的服务器请求数据。</li>\n</ul>\n</li>\n<li>\n<p>contentEditable</p>\n<ul>\n<li>让元素的区域可编辑</li>\n<li>已标准化</li>\n</ul>\n</li>\n<li>\n<p>requestAnimationFrame ： 允许控制动画渲染以获得更优性能</p>\n</li>\n<li>\n<p>拖放 API draggable 属性、拖放事件 (dragstart、drag、dragenter、dragleave、dragover、drap、dragend)、dataTransfer 对象</p>\n</li>\n<li>\n<p>全屏 API</p>\n</li>\n<li>\n<p>在线和离线事件</p>\n</li>\n</ul>\n</li>\n<li>\n<p>设备访问</p>\n<ul>\n<li>carnera ：能够操作计算机的摄像头</li>\n<li>地理位置定位 Geolocation</li>\n<li>触控事件</li>\n<li>检测设备方向 ：横向还是竖向</li>\n</ul>\n</li>\n</ol>\n",
            "tags": [
                "面试全面总结",
                "html"
            ]
        },
        {
            "id": "http://example.com/2020/03/23/getOfferhtml1/",
            "url": "http://example.com/2020/03/23/getOfferhtml1/",
            "title": "html 面试考点全面总结上篇",
            "date_published": "2020-03-23T09:14:53.000Z",
            "content_html": "<h2 id=\"html-面试考点全面总结上篇\"><a class=\"markdownIt-Anchor\" href=\"#html-面试考点全面总结上篇\">#</a> html 面试考点全面总结上篇</h2>\n<blockquote>\n<p>拿到 字节跳动实习生 offer 总结</p>\n<p>回馈分享一波自己的知识点总结</p>\n</blockquote>\n<blockquote>\n<p>希望读者依此构建自己的知识树（思维导图）</p>\n<p>偷懒一下：可参考我自己总结思维导图 : <a href=\"https://github.com/ZhChen7/Interview-mind-map\">点这里</a></p>\n<p>附带：高频面试题积累文档。 来自于（学长、牛客网等平台）</p>\n<p>自己开发的博客地址：<a href=\"http://zxinc520.com/\">zxinc520.com</a></p>\n<p>github 地址: <a href=\"https://github.com/ZhChen7\">点击</a></p>\n</blockquote>\n<blockquote>\n<p>此篇 html 共总结 22 大知识点： 全部弄懂了，面试很容易。</p>\n</blockquote>\n<h3 id=\"1-浏览器页面由哪三层构成\"><a class=\"markdownIt-Anchor\" href=\"#1-浏览器页面由哪三层构成\">#</a> 1、浏览器页面由哪三层构成</h3>\n<ul>\n<li>结构层\n<ul>\n<li>HTML</li>\n<li>构建文件结构</li>\n</ul>\n</li>\n<li>表示层\n<ul>\n<li>css</li>\n<li>设置文档呈现效果</li>\n</ul>\n</li>\n<li>行为层\n<ul>\n<li>JS 和 DOM 脚本</li>\n<li>实现文档的行为</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-语义化-谈谈-html5-语义化\"><a class=\"markdownIt-Anchor\" href=\"#2-语义化-谈谈-html5-语义化\">#</a> 2、语义化 | 谈谈 html5 语义化</h3>\n<h4 id=\"21-什么是语义化\"><a class=\"markdownIt-Anchor\" href=\"#21-什么是语义化\">#</a> 2.1、什么是语义化？</h4>\n<p>HTML5 的语义化指的是合理使用语义化的标签来创建页面结构，如 header,footer,nav，从标签上即可以直观的知道这个标签的作用，而不是滥用 div。</p>\n<h4 id=\"22-语义化的优点有\"><a class=\"markdownIt-Anchor\" href=\"#22-语义化的优点有\">#</a> 2.2、语义化的优点有</h4>\n<ol>\n<li>代码结构清晰，易于阅读，利于开发和维护</li>\n<li>提高用户体验，在样式加载失败时，页面结构清晰</li>\n<li>方便其他设备解析（如屏幕阅读器）根据语义渲染网页。</li>\n<li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</li>\n</ol>\n<h4 id=\"23-常用语义化标签有哪些\"><a class=\"markdownIt-Anchor\" href=\"#23-常用语义化标签有哪些\">#</a> 2.3、常用语义化标签有哪些</h4>\n<blockquote>\n<p>article | aside | nav | section | header | footer</p>\n</blockquote>\n<h3 id=\"3-html5-元素分类\"><a class=\"markdownIt-Anchor\" href=\"#3-html5-元素分类\">#</a> 3、HTML5 元素分类</h3>\n<ol>\n<li>结构性元素\n<ul>\n<li>section：在 web 页面应用中，该元素也可以用于区域章节表述；</li>\n<li>header：页面主题上的头部，注意区别于 head 元素；</li>\n<li>footer：页面的底部（页脚）；</li>\n<li>nav：是专门用于菜单导航、链接导航的元素，是 navigator 的缩写；</li>\n<li>article：用于表示一篇文章的主题部分，一般为文字集中显示的区域；</li>\n</ul>\n</li>\n<li>级块性元素\n<ul>\n<li>aside：用以表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容；</li>\n<li>figure：是对多个元素进行组合并展示的元素，通常与 figcaption 联合使用；</li>\n<li>code：表示一段代码块；</li>\n<li>dialog：用于表达人与人之间的对话，该元素还包括 dt 和 dd 这两个组合元素，他们常常同时使用。dt 用于表示说话者，而 dd 用来表示说话者的内容。</li>\n</ul>\n</li>\n<li>行内语义性元素\n<ul>\n<li>meter：表示特定范围内的数值，可用于工资、数量、百分比等；</li>\n<li>time：表示时间值；</li>\n<li>progress：用来表示进度条，可通过对其 max、min、step 等属性进行控制，完成对进度的表示和监视；</li>\n<li>video：视频元素，用于支持和实现视频（含视频流）文件的直接播放，支持缓冲预载和多种视频媒体格式；</li>\n<li>audio：音频元素，用于支持和实现音频（音频流）文件的直接播放，支持缓冲预载和多种音频媒体格式；</li>\n</ul>\n</li>\n<li>交互性元素\n<ul>\n<li>details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来；</li>\n<li>datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新；</li>\n<li>menu：主要用于交互菜单；</li>\n<li>command：用来处理命令按钮。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-常见空元素\"><a class=\"markdownIt-Anchor\" href=\"#4-常见空元素\">#</a> 4、常见空元素</h3>\n<p><strong>含义</strong> ：没有元素内容标记的内容【也称自闭合元素】</p>\n<p>常用的空元素：</p>\n<meta> <br> <hr> <input> <img> <link>\n<h3 id=\"5-表单增强-新增的-input-类型及属性\"><a class=\"markdownIt-Anchor\" href=\"#5-表单增强-新增的-input-类型及属性\">#</a> 5、表单增强 | 新增的 input 类型及属性</h3>\n<h4 id=\"51-新类型\"><a class=\"markdownIt-Anchor\" href=\"#51-新类型\">#</a> 5.1、新类型</h4>\n<ul>\n<li>color ：用于指定颜色的控件</li>\n<li>number：用于输入浮点数的控件</li>\n<li>tel：用于输入电话号码的控件；换行会被自动从输入的值中移除 A，但不会执行其他语法。可以使用属性，比如 pattern 和 maxlength 来约束控件输入的值。恰当的时候，可以应用 :valid 和 :invalid CSS 伪类。</li>\n<li>email：用于编辑 e-mail 的字段。 合适的时候可以使用 :valid 和 :invalid CSS 伪类。</li>\n<li>url ：用于编辑 URL 的字段</li>\n<li>range ：用于输入不精确值控件</li>\n<li>search ：用于输入搜索字符串的单行文本字段。换行会被从输入的值中自动移除。</li>\n<li>与时间相关\n<ul>\n<li>date ： 用于输入日期的控件（年，月，日，不包括时间）</li>\n<li>time ： 用于输入不含时区的时间控件</li>\n<li>datatime 【已弃用】 ： 用于输入日期和时间的控件（小时，分钟， 秒，基于 UTC 时区的一小部分。 此功能已从 WHATWG HTML 中删除。</li>\n<li>datetime-local ： 用于输入日期时间控件，不包含时区</li>\n<li>month ： 用于输入年月的控件，不带时区</li>\n<li>week ： 用于输入一个由星期 - 年组成的日期，日期不包括时</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"52-新属性\"><a class=\"markdownIt-Anchor\" href=\"#52-新属性\">#</a> 5.2、新属性</h4>\n<ul>\n<li>\n<p>placeholder</p>\n</li>\n<li>\n<p>required 必填项</p>\n</li>\n<li>\n<p>list 属性规定输入域的 datalist。datalist 是输入域的选项列表</p>\n</li>\n<li>\n<p>pattern 定义正则</p>\n</li>\n<li>\n<p>autofocus 属性规定在页面加载时，域自动地获得焦点。</p>\n</li>\n<li>\n<p>readonly 该字段只读，不能修改</p>\n</li>\n<li>\n<p>autocomplete 属性规定 form 或 input 域应该拥有自动完成功能。</p>\n</li>\n<li>\n<p>min/max / step</p>\n<ul>\n<li>\n<p>min、max 和 step 属性用于为包含数字或日期的 input 类型规定限定（约束）。</p>\n<p>max 属性规定输入域所允许的最大值。</p>\n<p>min 属性规定输入域所允许的最小值。</p>\n<p>step 属性为输入域规定合法的数字间隔（如果 step=“3”，则合法的数是 -3,0,3,6 等）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-认识-svg\"><a class=\"markdownIt-Anchor\" href=\"#6-认识-svg\">#</a> 6、认识 SVG</h3>\n<p><strong>含义</strong> ：可缩放矢量图形（Scalable Vector Graphics，SVG），是一种用于描述基于二维的矢量图形的，基于 XML 的标记语言。</p>\n<p><strong>关键词</strong>：【基于 XML】【矢量】 【图像格式】</p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>矢量\n<ul>\n<li>可以任意缩放</li>\n<li>不会破坏图像的清晰度和细节</li>\n<li>边缘清晰，适用任何分辨率</li>\n</ul>\n</li>\n<li>文本独立 文字独立于图像</li>\n<li>文件小 下载快</li>\n<li>颜色控制</li>\n</ul>\n<h4 id=\"61-svg-与-html5-的-canvas-各有什么优点哪个更有前途\"><a class=\"markdownIt-Anchor\" href=\"#61-svg-与-html5-的-canvas-各有什么优点哪个更有前途\">#</a> 6.1、SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途？</h4>\n<blockquote>\n<p>Canvas 是使用 JavaScript 程序绘图 (动态生成)，SVG 是使用 XML 文档描述来绘图。<br>\n从这点来看：SVG 更适合用来做动态交互，而且 SVG 绘图很容易编辑，只需要增加或移除相应的元素就可以了。<br>\n同时 SVG 是基于矢量的，所有它能够很好的处理图形大小的改变。Canvas 是基于位图的图像，它不能够改变大小，只能缩放显示；所以说 Canvas 更适合用来实现类似于 Flash 能做的事情 (当然现在 Canvas 与 Flash 相比还有一些不够完善的地方)。<br>\n关于最后一点二者谁更有前途：从上面我们可以知道二者是有不同用途的，作为一个开发者，你应该做的是理解应用程序的具体需求并选择正确的技术来实现它。</p>\n</blockquote>\n<h3 id=\"7-浏览器内核\"><a class=\"markdownIt-Anchor\" href=\"#7-浏览器内核\">#</a> 7、浏览器内核</h3>\n<h4 id=\"71-认识内核\"><a class=\"markdownIt-Anchor\" href=\"#71-认识内核\">#</a> 7.1、认识内核</h4>\n<ul>\n<li>渲染引擎 ：渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息</li>\n<li>JS 引擎\n<ul>\n<li>解析和执行 JavaScript 来实现网页的动态效果</li>\n<li>引擎越来越独立，内核就倾向于只指渲染引擎</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"72-主流浏览器所用的内核\"><a class=\"markdownIt-Anchor\" href=\"#72-主流浏览器所用的内核\">#</a> 7.2、主流浏览器所用的内核</h4>\n<ul>\n<li>IE 浏览器 Trident 内核</li>\n<li>谷歌浏览器（chrome）\n<ul>\n<li>Webkit（之前使用）</li>\n<li>blink 内核</li>\n</ul>\n</li>\n<li>Opera 浏览器\n<ul>\n<li>blink 内核</li>\n<li>Presto 内核（之前使用）\n<ul>\n<li>渲染速度的优化达到了极致</li>\n<li>牺牲了兼容性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>火狐浏览器（Firefox）\n<ul>\n<li>Gecko 内核 ： 代码完全公开，可开发程度很高</li>\n</ul>\n</li>\n<li>Safari 浏览器 ：苹果公司 webkit 内核</li>\n<li>国产浏览器\n<ul>\n<li>双内核（一个负责兼容，一个负责速度）</li>\n<li>常用\n<ul>\n<li>Trident + webkit</li>\n<li>Trident + blink</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"8-web-标准以及-w3c\"><a class=\"markdownIt-Anchor\" href=\"#8-web-标准以及-w3c\">#</a> 8、WEB 标准以及 W3C</h3>\n<h4 id=\"81-web-标准\"><a class=\"markdownIt-Anchor\" href=\"#81-web-标准\">#</a> 8.1、web 标准</h4>\n<blockquote>\n<p>分为结构、表现、行为</p>\n</blockquote>\n<h5 id=\"web-标准是什么\"><a class=\"markdownIt-Anchor\" href=\"#web-标准是什么\">#</a> web 标准是什么？</h5>\n<blockquote>\n<p>一系列标准的集合：</p>\n</blockquote>\n<ul>\n<li>结构化标准语言</li>\n<li>表现标准语言</li>\n<li>行为标准语言</li>\n</ul>\n<h5 id=\"web-标准诞生原因\"><a class=\"markdownIt-Anchor\" href=\"#web-标准诞生原因\">#</a> web 标准诞生原因？</h5>\n<blockquote>\n<p>为了解决因浏览器版本不同、软硬件设备不同导致的需多版本开发的问题。</p>\n</blockquote>\n<h4 id=\"82-w3c\"><a class=\"markdownIt-Anchor\" href=\"#82-w3c\">#</a> 8.2、W3C</h4>\n<blockquote>\n<p>W3C 对 web 标准提出规范化要求</p>\n</blockquote>\n<h5 id=\"一结构要求\"><a class=\"markdownIt-Anchor\" href=\"#一结构要求\">#</a> 一：结构要求：</h5>\n<ul>\n<li>遵循的好处\n<ul>\n<li>提升搜索引擎对页面的抓取效率</li>\n<li>对 SEO 很有帮助</li>\n</ul>\n</li>\n<li>具体\n<ul>\n<li>标签字母要小写</li>\n<li>标签要闭合</li>\n<li>标签不允许随便嵌套</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"二表现与行为要求\"><a class=\"markdownIt-Anchor\" href=\"#二表现与行为要求\">#</a> 二：表现与行为要求：</h5>\n<ul>\n<li>遵循的好处\n<ul>\n<li>使用户浏览者更方便的阅读</li>\n<li>使网页开发者之间更好的交流</li>\n</ul>\n</li>\n<li>具体\n<ul>\n<li>尽量使用外链 css 样式表和 js 脚本：提高页面渲染速度</li>\n<li>页面尽量少用行间样式表 ： 使结构和表现分离</li>\n<li>标签 id 和 class 等属性名要见文知义</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"9-doctypedtd\"><a class=\"markdownIt-Anchor\" href=\"#9-doctypedtd\">#</a> 9、Doctype（DTD）</h3>\n<blockquote>\n<p>作用 ： 声明文档的类型风格</p>\n<p>告诉浏览器采用何种渲染模式解析页面</p>\n</blockquote>\n<h4 id=\"91-渲染模式\"><a class=\"markdownIt-Anchor\" href=\"#91-渲染模式\">#</a> 9.1、渲染模式</h4>\n<ul>\n<li>怪异模式（兼容模式、混杂模式）\n<ul>\n<li>服务于旧式规则</li>\n<li>页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</li>\n</ul>\n</li>\n<li>标准模式（严格模式）\n<ul>\n<li>服务于标准规则</li>\n<li>标准模式的排版 和 JS 运作模式都是以该浏览器支持的最高标准运行</li>\n</ul>\n</li>\n<li>近似标准模式\n<ul>\n<li>基本是标准模型</li>\n<li>有一些是自己的调整</li>\n</ul>\n</li>\n</ul>\n<p><strong>意义</strong>：严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。</p>\n<h4 id=\"92-标准模式和混杂模式的区别\"><a class=\"markdownIt-Anchor\" href=\"#92-标准模式和混杂模式的区别\">#</a> 9.2、标准模式和混杂模式的区别？</h4>\n<ul>\n<li>\n<p>** 盒模型的处理差异：** 标准 CSS 盒模型的宽度和高度等于内容区的高度和宽度，不包含内边距和边框，而 IE6 之前的浏览器实现的盒模型的宽高计算方式是包含内边距和边框的。因此，对于 IE，怪异模式和标准模式下的盒模型宽高计算方式是不一样的；</p>\n</li>\n<li>\n<p>** 行内元素的垂直对齐：** 很多早期的浏览器对齐图片至包含它们的盒子的下边框，虽然 CSS 的规范要求它们被对齐至盒内文本的基线。标准模式下，基于 Gecko 的浏览器将会对齐至基线，而在 quirks 模式下它们会对齐至底部。最直接的例子就是图片的显示。在标准模式下，图片并不是与父元素的下边框对齐的，如果仔细观察，你会发现图片与父元素下边框之间存在一点小空隙。那是因为标准模式下，图片是基线对齐的。而怪异模式下，则不存在这个问题。具体请看这篇文章 <a href=\"https://link.jianshu.com?t=http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/\">CSS 深入理解 vertical-align 和 line-height 的基友关系</a>。</p>\n</li>\n</ul>\n<h4 id=\"93-标准模式和严格模式的区别\"><a class=\"markdownIt-Anchor\" href=\"#93-标准模式和严格模式的区别\">#</a> 9.3、标准模式和严格模式的区别？</h4>\n<p>严格模式主要有以下限制：</p>\n<ul>\n<li>变量必须声明后再使用</li>\n<li>函数的参数不能有同名属性，否则报错</li>\n<li>不能使用 with 语句</li>\n<li>不能对只读属性赋值，否则报错</li>\n<li>不能使用前缀 0 表示八进制数，否则报错</li>\n<li>不能删除不可删除的属性，否则报错</li>\n<li>不能删除变量 delete prop，会报错，只能删除属性 delete global [prop]</li>\n<li>eval 不会在它的外层作用域引入变量</li>\n<li>eval 和 arguments 不能被重新赋值</li>\n<li>arguments 不会自动反映函数参数的变化</li>\n<li>不能使用 arguments.callee</li>\n<li>不能使用 arguments.caller</li>\n<li>禁止 this 指向全局对象</li>\n<li>不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈</li>\n</ul>\n<h3 id=\"10-meta-标签\"><a class=\"markdownIt-Anchor\" href=\"#10-meta-标签\">#</a> 10、meta 标签</h3>\n<blockquote>\n<p>&lt;<em>meta</em> &gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。</p>\n</blockquote>\n<h4 id=\"101-四个属性\"><a class=\"markdownIt-Anchor\" href=\"#101-四个属性\">#</a> 10.1、四个属性</h4>\n<ul>\n<li>http-equiv 【重要关键词】\n<ul>\n<li>content-type\n<ul>\n<li>定义字符编码</li>\n<li>不推荐使用 改用 charset 属性</li>\n</ul>\n</li>\n<li>refresh：指定以秒为单位，执行重载和重定向</li>\n</ul>\n</li>\n<li>name 【 重要关键词】\n<ul>\n<li>application-name：应用程序名称</li>\n<li>keywords ： keywords 用来告诉搜索引擎你网页的关键字是什么</li>\n<li>author ： 当前页的作者名</li>\n<li>viewport\n<ul>\n<li>设置浏览器视口</li>\n<li>重要关键字\n<ul>\n<li>width ： 视口宽度</li>\n<li>*-scale （initial-scale）： 缩放相关</li>\n<li>user-scalable ： 是否可以手动缩放</li>\n<li>例如：&lt;<em>meta name=“viewport” content=“width=device-width, initial-scale=1, maximum-scale=1”</em> &gt;</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>description description 用来告诉搜索引擎你的网站主要内容</li>\n<li>content ：具体描述 、不能单独存在</li>\n<li>charset（HTML5）：推荐使用 utf-8 简化了不同脚本对文件中字符的处理</li>\n</ul>\n<h4 id=\"102-meta-标签的作用\"><a class=\"markdownIt-Anchor\" href=\"#102-meta-标签的作用\">#</a> 10.2、meta 标签的作用</h4>\n<ol>\n<li>\n<p>搜索引擎优化（SEO）</p>\n</li>\n<li>\n<p>定义页面使用语言</p>\n</li>\n<li>\n<p>自动刷新并指向新的页面</p>\n</li>\n<li>\n<p>实现网页转换时的动态效果</p>\n</li>\n<li>\n<p>控制页面缓冲</p>\n</li>\n<li>\n<p>网页定级评价</p>\n</li>\n<li>\n<p>控制网页显示的窗口</p>\n</li>\n</ol>\n<h6 id=\"\"><a class=\"markdownIt-Anchor\" href=\"#\">#</a> </h6>\n<h6 id=\"-2\"><a class=\"markdownIt-Anchor\" href=\"#-2\">#</a> </h6>\n",
            "tags": [
                "面试全面总结",
                "html"
            ]
        }
    ]
}