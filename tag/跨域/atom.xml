<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>sunflower • Posts by &#34;跨域&#34; tag</title>
    <link href="http://example.com" />
    <updated>2020-03-23T09:40:43.000Z</updated>
    <category term="blog" />
    <category term="个人博客" />
    <category term="rem" />
    <category term="less" />
    <category term="art-template" />
    <category term="算法面试" />
    <category term="算法" />
    <category term="大 O？" />
    <category term="复杂度分析" />
    <category term="大二" />
    <category term="数据库实训" />
    <category term="IDE" />
    <category term="Git" />
    <category term="模块化" />
    <category term="构建工具" />
    <category term="上线和回滚" />
    <category term="ES6 模块化语法" />
    <category term="babel" />
    <category term="webpack" />
    <category term="rollup" />
    <category term="ES6" />
    <category term="hybrid" />
    <category term="虚拟 DOM" />
    <category term="知识点概述" />
    <category term="JS" />
    <category term="实用工具" />
    <category term="面试全面总结" />
    <category term="JS 三座大山" />
    <category term="学习实训" />
    <category term="性能优化" />
    <category term="加载过程" />
    <category term="promise" />
    <category term="异步解决方案" />
    <category term="回调地狱" />
    <category term="React" />
    <category term="React源码" />
    <category term="Vue3" />
    <category term="vue" />
    <category term="跑马灯" />
    <category term="父子组件间通信" />
    <category term="路由" />
    <category term="监听事件（keyup ，watch ，computed ）" />
    <category term="nrm" />
    <category term="Mint-UI" />
    <category term="MUI" />
    <category term="MVVM" />
    <category term="响应式、模板解析、渲染" />
    <category term="微信小程序" />
    <category term="单线程" />
    <category term="event loop" />
    <category term="异步的 Deferred" />
    <category term="Promise" />
    <category term="html" />
    <category term="hexo" />
    <category term="redux" />
    <category term="UTC时间问题" />
    <category term="正则表达式" />
    <category term="虚拟DOM" />
    <category term="博文" />
    <category term="React-Router" />
    <category term="React-Hooks" />
    <category term="DOM" />
    <category term="BOM" />
    <category term="事件绑定" />
    <category term="ajax 请求" />
    <category term="储存" />
    <category term="进程调度" />
    <category term="过滤器" />
    <category term="按键修饰符" />
    <category term="指令" />
    <category term="生命周期" />
    <category term="过渡效果" />
    <category term="组件" />
    <category term="webpack 后续问题" />
    <category term="数组" />
    <category term="API" />
    <category term="跨域" />
    <category term="动画" />
    <category term="事件" />
    <category term="React基础面试题-50" />
    <category term="数组相关操作" />
    <category term="手撕代码" />
    <category term="牛人面试题" />
    <entry>
        <id>http://example.com/2020/03/23/getOfferAPI/</id>
        <title>API、数组、跨域、动画、事件</title>
        <link rel="alternate" href="http://example.com/2020/03/23/getOfferAPI/"/>
        <content type="html">&lt;h4 id=&#34;面试专题总结-api-数组-跨域-动画-事件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#面试专题总结-api-数组-跨域-动画-事件&#34;&gt;#&lt;/a&gt; 面试专题总结： API、数组、跨域、动画、事件&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;希望读者依此构建自己的知识树（思维导图）&lt;/p&gt;
&lt;p&gt;偷懒一下：可参考我自己总结思维导图 : &lt;a href=&#34;https://github.com/ZhChen7/Interview-mind-map&#34;&gt;点这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;附带：高频面试题积累文档。 来自于（学长、牛客网等平台）&lt;/p&gt;
&lt;p&gt;自己开发的博客地址：&lt;a href=&#34;http://zxinc520.com/&#34;&gt;zxinc520.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;github 地址: &lt;a href=&#34;https://github.com/ZhChen7&#34;&gt;点击&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;此篇 js - 【API、数组、跨域、动画、事件】 知识点： 全部弄懂了，面试很容易。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-数组&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-数组&#34;&gt;#&lt;/a&gt; 1、数组&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;改变原数组的 API
&lt;ol&gt;
&lt;li&gt;push()&lt;/li&gt;
&lt;li&gt;unshift()&lt;/li&gt;
&lt;li&gt;pop()&lt;/li&gt;
&lt;li&gt;shift()&lt;/li&gt;
&lt;li&gt;reverse()&lt;/li&gt;
&lt;li&gt;splice(index, count, value1, value2…)
&lt;ul&gt;
&lt;li&gt;从索引位 index 处删除 count 个元素，插入 value1, value2 等元素，返回被删除的元素组成的新数组 (改变原数组)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;sort()&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;不改变原数组的 API
&lt;ol&gt;
&lt;li&gt;join(value)
&lt;ul&gt;
&lt;li&gt;将数组用 value 连接为字符串，返回被连接后的字符串 (不改变原数组)&lt;/li&gt;
&lt;li&gt;将数组用 value 连接为字符串，返回被连接后的字符串 (不改变原数组)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;获取子数组，包含原数组索引 start 的值到索引 end 的值，不包含 end，返回获取的子数组 (不改变原数组)&lt;/li&gt;
&lt;li&gt;toString()
&lt;ul&gt;
&lt;li&gt;将数组中的元素用逗号拼接成字符串，返回拼接后的字符串 (不改变原数组)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;indexOf(value)
&lt;ul&gt;
&lt;li&gt;从索引为 0 开始，检查数组中是否包含有 value，有则返回匹配到的第一个索引，没有则返回 - 1 (不改变原数组)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;lastIndexOf(value)
&lt;ul&gt;
&lt;li&gt;从最后的索引开始，检查数组找那个是否包含 value，有则返回匹配到的第一个索引，没有返回 - 1 (不改变原数组)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;concat(value)
&lt;ul&gt;
&lt;li&gt;将数组和 (或) 值连接成新数组，返回新数组 (不改变原数组)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;forEach()
&lt;ul&gt;
&lt;li&gt;对数组进行遍历循环，对数组中每一项运行给定函数，参数都是 function 类型，默认有传参，参数分别为：遍历数组内容、对应的数组索引、数组本身。没有返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;map()
&lt;ul&gt;
&lt;li&gt;指 “映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的新数组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;filter()
&lt;ul&gt;
&lt;li&gt;“过滤” 功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;every()
&lt;ul&gt;
&lt;li&gt;判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回 true&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;some()
&lt;ul&gt;
&lt;li&gt;判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回 true&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;reduce()
&lt;ul&gt;
&lt;li&gt;接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-类数组转变为数组的方法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-类数组转变为数组的方法&#34;&gt;#&lt;/a&gt; 2、类数组转变为数组的方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;类数组的定义
&lt;ul&gt;
&lt;li&gt;可以通过索引访问元素，并且拥有 length 属性&lt;/li&gt;
&lt;li&gt;没有数组的其他方法，例如 push ， forEach ， indexOf 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ES5
&lt;ul&gt;
&lt;li&gt;Array.prototype.slice.call () 等同于 [].slice.call (arguments)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ES6
&lt;ul&gt;
&lt;li&gt;Array.from()&lt;/li&gt;
&lt;li&gt;… 扩展运算符&lt;/li&gt;
&lt;li&gt;for of 直接遍历类数组（iterator 接口）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-稀疏数组和密集数组&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#3-稀疏数组和密集数组&#34;&gt;#&lt;/a&gt; 3、稀疏数组和密集数组&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;稀疏数组
&lt;ul&gt;
&lt;li&gt;是什么
&lt;ul&gt;
&lt;li&gt;具有不连续索引的数组，其 length 属性值大于元素的个数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;造成稀疏数组的操作
&lt;ol&gt;
&lt;li&gt;delete 操作符&lt;/li&gt;
&lt;li&gt;构造函数&lt;/li&gt;
&lt;li&gt;在数组字面量中省略值&lt;/li&gt;
&lt;li&gt;指定数组索引大于数组长度&lt;/li&gt;
&lt;li&gt;指定数组长度大于当前数组长度&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;操作的不统一&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;密集数组
&lt;ul&gt;
&lt;li&gt;是什么
&lt;ul&gt;
&lt;li&gt;具有连续索引的数组，其 length 属性值等于元素的个数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;创建方式
&lt;ol&gt;
&lt;li&gt;Array.apply(null, Array(3)) || Array.apply(null, {length: 3})&lt;/li&gt;
&lt;li&gt;Array.from({length: 3})&lt;/li&gt;
&lt;li&gt;[…Array(4)]&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-柯里化函数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#4-柯里化函数&#34;&gt;#&lt;/a&gt; 4、柯里化函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;柯里化，即 Currying 的音译。 Currying 是编译原理层面实现多参函数的一个技术。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;手写柯里化函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ES5 写法&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-js&#34; data-language=&#34;js&#34;&gt;&lt;code class=&#34;language-js&#34;&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token function-variable function&#34;&gt;currying&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token parameter&#34;&gt;fn&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;...&lt;/span&gt;args&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;
  &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;args&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;length &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt; fn&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;length&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;
    &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;
      &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;currying&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;fn&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;...&lt;/span&gt;args&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;...&lt;/span&gt;arguments&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;
    &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;...&lt;/span&gt;args&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;
&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ES6 写法（箭头函数）&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-js&#34; data-language=&#34;js&#34;&gt;&lt;code class=&#34;language-js&#34;&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token function-variable function&#34;&gt;currying&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token parameter&#34;&gt;fn&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;...&lt;/span&gt;args&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;=&gt;&lt;/span&gt;
  args&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;length &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt; fn&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;length
    &lt;span class=&#34;token operator&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token parameter&#34;&gt;&lt;span class=&#34;token operator&#34;&gt;...&lt;/span&gt;argments&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;=&gt;&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;currying&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;fn&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;...&lt;/span&gt;args&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;...&lt;/span&gt;argments&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;...&lt;/span&gt;args&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-window-全局对象bom&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#5-window-全局对象bom&#34;&gt;#&lt;/a&gt; 5、window 全局对象（BOM）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;navigator 导航器对象
&lt;ul&gt;
&lt;li&gt;Navigator 对象包含有关浏览器的信息&lt;/li&gt;
&lt;li&gt;appCodeName 返回浏览器的代码名&lt;/li&gt;
&lt;li&gt;appName 返回浏览器的名称&lt;/li&gt;
&lt;li&gt;appVersion 返回浏览器的平台和版本信息&lt;/li&gt;
&lt;li&gt;cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值&lt;/li&gt;
&lt;li&gt;platform 返回运行浏览器的操作系统平台&lt;/li&gt;
&lt;li&gt;userAgent 返回由客户机发送服务器的 user-agent 头部的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;screen 显示器对象&lt;/li&gt;
&lt;li&gt;history 历史对象
&lt;ul&gt;
&lt;li&gt;back () 返回前一个 URL&lt;/li&gt;
&lt;li&gt;forward () 返回下一个 URL&lt;/li&gt;
&lt;li&gt;go () 返回某个具体页面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;location 位置对象
&lt;ul&gt;
&lt;li&gt;属性
&lt;ul&gt;
&lt;li&gt;hash 设置或返回从井号 (#) 开始的 URL（锚）。&lt;/li&gt;
&lt;li&gt;host 设置或返回主机名和当前 URL 的端口号。&lt;/li&gt;
&lt;li&gt;hostname 设置或返回当前 URL 的主机名&lt;/li&gt;
&lt;li&gt;href 设置或返回完整的 URL&lt;/li&gt;
&lt;li&gt;pathname 设置或返回当前 URL 的路径部分。&lt;/li&gt;
&lt;li&gt;port 设置或返回当前 URL 的端口号。&lt;/li&gt;
&lt;li&gt;protocol 设置或返回当前 URL 的协议。&lt;/li&gt;
&lt;li&gt;search 设置或返回从问号 (?) 开始的 URL（查询部分）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方法
&lt;ul&gt;
&lt;li&gt;assign (URL) 加载新的文档&lt;/li&gt;
&lt;li&gt;reload () 重新加载当前页面&lt;/li&gt;
&lt;li&gt;replace (newURL) 用新的文档替换当前文档&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;document 文档对象【DOM】&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;6-ajax-和-fetch&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#6-ajax-和-fetch&#34;&gt;#&lt;/a&gt; 6、ajax 和 fetch&lt;/h3&gt;
&lt;h4 id=&#34;61-ajax&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#61-ajax&#34;&gt;#&lt;/a&gt; 6.1、Ajax&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本质&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是在 HTTP 协议的基础上以异步的方式与服务器进行通信.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;封装原生 Ajax 请求&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-js&#34; data-language=&#34;js&#34;&gt;&lt;code class=&#34;language-js&#34;&gt;&lt;span class=&#34;token keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;ajaxGet&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token parameter&#34;&gt;url&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; callback&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;
  &lt;span class=&#34;token keyword&#34;&gt;var&lt;/span&gt; xhr &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;XMLHttpRequest&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
  xhr&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;GET&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; url&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token boolean&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
  xhr&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;

  xhr&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function-variable function&#34;&gt;onreadystatechange&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;
    &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;xhr&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;readyState &lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; xhr&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;status &lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;
      &lt;span class=&#34;token function&#34;&gt;callback&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;xhr&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;responseText&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;
  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;62-fetch&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#62-fetch&#34;&gt;#&lt;/a&gt; 6.2、fetch&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;fetch 是什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fetch 是浏览器提供的原生 AJAX 接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fetch 为何出现？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于原来的 XMLHttpRequest 不符合关注分离原则，且基于事件的模型在处理异步上已经没有现代的 Promise 等那么有优势。因此 Fetch 出现来解决这种问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fetch API&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Fetch API 提供了能够用于操作一部分 HTTP 的 JavaScript 接口，比如 requests 和 responses。它同时也提供了一个全局的 fetch () 方法 —— 能够简单的异步的获取资源。&lt;/p&gt;
&lt;p&gt;使用 window.fetch 函数可以代替以前的 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mtext&gt;、&lt;/mtext&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;. ajax、&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8777699999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;.get 和 $.post。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-js&#34; data-language=&#34;js&#34;&gt;&lt;code class=&#34;language-js&#34;&gt;&lt;span class=&#34;token function&#34;&gt;fetch&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;http://example.com/movies.json&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;then&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token parameter&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;
    &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; response&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;json&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;then&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token parameter&#34;&gt;myJson&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;
    console&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;myJson&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;63-readystate状态值&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#63-readystate状态值&#34;&gt;#&lt;/a&gt; 6.3、readyState（状态值）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;readyState 是什么
&lt;ul&gt;
&lt;li&gt;readyState 是 XMLHttpRequest 对象的一个属性，用来标识当前 XMLHttpRequest 对象处于什么状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;5 个状态值
&lt;ul&gt;
&lt;li&gt;0: 请求未初始化&lt;/li&gt;
&lt;li&gt;1: 载入，XMLHttpRequest 对象开始发送请求&lt;/li&gt;
&lt;li&gt;2: 载入完成，XMLHttpRequest 对象的请求发送完成&lt;/li&gt;
&lt;li&gt;3: 解析，XMLHttpRequest 对象开始读取服务器的响应&lt;/li&gt;
&lt;li&gt;4: 完成，XMLHttpRequest 对象读取服务器响应结束&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;64-status状态码&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#64-status状态码&#34;&gt;#&lt;/a&gt; 6.4、status（状态码&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;status 是什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;status 是 XMLHttpRequest 对象的一个属性，表示响应的 http 状态码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 http1.1 协议下，http 状态码总共可分为 5 大类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1xx：信息响应类，表示接收到请求并且继续处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2xx：处理成功响应类，表示动作被成功接收、理解和接受&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3xx：重定向响应类，为了完成指定的动作，必须接受进一步处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4xx：客户端错误，客户请求包含语法错误或者是不能正确执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5xx：服务端错误，服务器不能正确执行一个正确的请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些常见的状态码为&lt;/p&gt;
&lt;p&gt;200 OK：成功，很棒。&lt;/p&gt;
&lt;p&gt;301 永久移动：已永久移动到新位置。&lt;/p&gt;
&lt;p&gt;302（临时移动）：暂时移到新位置。&lt;/p&gt;
&lt;p&gt;304 未修改：东西跟之前长一样，可以从快取拿就好。&lt;/p&gt;
&lt;p&gt;400 错误的请求：明显的用户端错误，伺服器无法处理这个请求。&lt;/p&gt;
&lt;p&gt;401 未经授权：未认证，可能需要登录或 Token。&lt;/p&gt;
&lt;p&gt;403 Forbidden：没有权限。&lt;/p&gt;
&lt;p&gt;404 未找到：找不到资源。&lt;/p&gt;
&lt;p&gt;500 内部服务器错误：伺服器端错误。&lt;/p&gt;
&lt;p&gt;502 错误的网关：通常是伺服器的某个服务没有正确执行。&lt;/p&gt;
&lt;p&gt;503 服务不可用：伺服器临时维护或快挂了，暂时无法处理请求。&lt;/p&gt;
&lt;p&gt;504 网关超时：伺服器上的服务没有回应。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7-web-端即时通讯技术&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#7-web-端即时通讯技术&#34;&gt;#&lt;/a&gt; 7、Web 端即时通讯技术&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Web 端即时通讯技术是什么&lt;/p&gt;
&lt;p&gt;即时通讯技术简单的说就是实现这样一种功能：服务器端可以即时地将数据的更新或变化反应到客户端，例如消息即时推送等功能都是通过这种技术实现的。但是在 Web 中，由于浏览器的限制，实现即时通讯需要借助一些方法。这种限制出现的主要原因是，一般的 Web 通信都是浏览器先发送请求到服务器，服务器再进行响应完成数据的现实更新。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大体可以分为两类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一种是在 HTTP 基础上实现的
&lt;ul&gt;
&lt;li&gt;短轮询、comet 和 SSE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不是在 HTTP 基础上实现
&lt;ul&gt;
&lt;li&gt;WebSocket&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何模拟双向通信（四种方式）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;短轮询
&lt;ul&gt;
&lt;li&gt;客户端定时向服务器发送 Ajax 请求，服务器接到请求后马上返回响应信息并关闭连接。&lt;/li&gt;
&lt;li&gt;优点 ： 后端编写容易&lt;/li&gt;
&lt;li&gt;缺点 ： 请求中大半是无用，浪费宽带和服务器资源&lt;/li&gt;
&lt;li&gt;适用 ： 小型应用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;长轮询
&lt;ul&gt;
&lt;li&gt;客户端向服务器发送 Ajax 请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。&lt;/li&gt;
&lt;li&gt;优点 ：在无消息的情况下不会频繁的请求，耗费资源小&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;服务器 hold 连接会消耗资源&lt;/li&gt;
&lt;li&gt;返回数据顺序无保证，难于管理维护&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;长连接
&lt;ul&gt;
&lt;li&gt;在页面嵌入一个隐藏 iframe，将这个隐藏 iframe 的 src 属性设为对一个长连接的请求或是采用 xhr 请求，服务器端就能源源不断的往客户端输入数据&lt;/li&gt;
&lt;li&gt;优点
&lt;ul&gt;
&lt;li&gt;消息及时到达，不发无用请求&lt;/li&gt;
&lt;li&gt;管理起来也相对方便&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：服务器维护一个长连接会增加开销&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;WebSocket
&lt;ul&gt;
&lt;li&gt;WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议可以实现服务器与客户端之间全双工通信。简单来说，首先需要在客户端和服务器端建立起一个连接，这部分需要 http。连接一旦建立，客户端和服务器端就处于平等的地位，可以相互发送数据，不存在请求和响应的区别。&lt;/li&gt;
&lt;li&gt;优点：实现了双向通信&lt;/li&gt;
&lt;li&gt;缺点：服务器端的逻辑非常复杂&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;四种-web-即时通信技术比较&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#四种-web-即时通信技术比较&#34;&gt;#&lt;/a&gt; 四种 Web 即时通信技术比较&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;从兼容性角度考虑，短轮询 &amp;gt; 长轮询 &amp;gt; 长连接 SSE&amp;gt;WebSocket；&lt;/li&gt;
&lt;li&gt;从性能方面考虑，WebSocket &amp;gt; 长连接 SSE &amp;gt; 长轮询 &amp;gt; 短轮询。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;8-跨域&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#8-跨域&#34;&gt;#&lt;/a&gt; 8、跨域&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;跨域是什么
&lt;ul&gt;
&lt;li&gt;跨域是指从一个域名的网页去请求另一个域名的资源。&lt;/li&gt;
&lt;li&gt;跨域的严格一点的定义是：只要 协议，域名，端口有任何一个的不同，就被当作是跨域&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;6-种解决方案&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#6-种解决方案&#34;&gt;#&lt;/a&gt; 6 种解决方案&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;跨域资源共享（CORS）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本思想&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CORS 背后的基本思想就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两种请求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单请求
&lt;ul&gt;
&lt;li&gt;就是在头信息之中，增加一个 Origin 字段。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非简单请求
&lt;ul&gt;
&lt;li&gt;会在正式通信之前，增加一次 HTTP 查询请求，称为 &amp;quot;预检&amp;quot; 请求（preflight）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;服务器端对于 CORS 的支持，主要就是通过设置 Access-Control-Allow-Origin 来进行的。如果浏览器检测到相应的设置，就可以允许 Ajax 进行跨域的访问&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-js&#34; data-language=&#34;js&#34;&gt;&lt;code class=&#34;language-js&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;//指定允许其他域名访问&lt;/span&gt;
&lt;span class=&#34;token string&#34;&gt;&#34;Access-Control-Allow-Origin:*&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;//或指定域&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;//响应类型&lt;/span&gt;
&lt;span class=&#34;token string&#34;&gt;&#34;Access-Control-Allow-Methods:GET,POST&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;//响应头设置&lt;/span&gt;
&lt;span class=&#34;token string&#34;&gt;&#34;Access-Control-Allow-Headers:x-requested-with,content-type&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;jsonp&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;jsonp 是什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSONP (JSON with Padding 填充式 json) 是 JSON 的一种 “使用模式”，可用于解决主流浏览器的跨域数据访问的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两部分组成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回调函数
&lt;ul&gt;
&lt;li&gt;回调函数是当响应到来时应该在页面中调用的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据
&lt;ul&gt;
&lt;li&gt;而数据就是传入回调函数中的 JSON 数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原理&lt;/p&gt;
&lt;p&gt;通过 script 标签引入一个 js 文件，这个 js 文件载入成功后会执行我们在 url 参数中指定的函数，并且会把我们需要的 json 数据作为参数传入。所以 jsonp 是需要服务器端的页面进行相应的配合的。（即用 javascript 动态加载一个 script 文件，同时定义一个 callback 函数给 script 执行而已。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模拟&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-js&#34; data-language=&#34;js&#34;&gt;&lt;code class=&#34;language-js&#34;&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;script type&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;text/javascript&#34;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;
    &lt;span class=&#34;token keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;dosomething&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token parameter&#34;&gt;jsondata&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;
        &lt;span class=&#34;token comment&#34;&gt;//处理获得的json数据&lt;/span&gt;
    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;
&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;/&lt;/span&gt;script&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;
&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;script src&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;http://example.com/data.php?callback=dosomething&#34;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;/&lt;/span&gt;script&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们都知道 JSONP 可以实现解决 GET 请求的跨域问题，但是不能解决 POST 请求的跨域问题.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;document.domain&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过修改 document.domain 来跨子域&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;域必须相我们只能把 document.domain 设置成自身或更高一级的父域，且主同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-js&#34; data-language=&#34;js&#34;&gt;&lt;code class=&#34;language-js&#34;&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;iframe id &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;iframe&#34;&lt;/span&gt; src&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;http://example.com/b.html&#34;&lt;/span&gt; onload &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;test()&#34;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;/&lt;/span&gt;iframe&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;
&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;script type&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;text/javascript&#34;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;
    document&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;domain &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;example.com&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;//设置成主域&lt;/span&gt;
    &lt;span class=&#34;token keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;
    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;
&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;/&lt;/span&gt;script&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作用域&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改 document.domain 的方法只适用于不同子域的框架间的交互。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://window.name&#34;&gt;window.name&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://window.name&#34;&gt;window.name&lt;/a&gt; 是什么
&lt;ul&gt;
&lt;li&gt;是一个可读可写的属性，有个很有意思的跨页面特性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方法
&lt;ul&gt;
&lt;li&gt;页面如果设置了 &lt;a href=&#34;http://window.name&#34;&gt;window.name&lt;/a&gt;，即使进行了页面跳转到了其他页面，这个 &lt;a href=&#34;http://window.name&#34;&gt;window.name&lt;/a&gt; 还是会保留。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;postMessage&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;p&gt;postMessage 是 html5 引入的 API,postMessage () 方法允许来自不同源的脚本采用异步方式进行有效的通信，可以实现跨文本文档，多窗口，跨域消息传递。多用于窗口间数据通信，这也使它成为跨域通信的一种有效的解决方案.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发送数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;otherWindow.postMessage(message, targetOrigin, [transfer]);&lt;/li&gt;
&lt;li&gt;otherWindow 【窗口的一个引用，比如 iframe 的 contentWindow 属性】&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接收数据&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-js&#34; data-language=&#34;js&#34;&gt;&lt;code class=&#34;language-js&#34;&gt;window&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;addEventListener&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;message&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; receiveMessage&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token boolean&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;token keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;receiveMessage&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token parameter&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;
  &lt;span class=&#34;token keyword&#34;&gt;var&lt;/span&gt; origin &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; event&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;origin&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
  console&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;event&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;postMessage 的使用场景&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;跨域通信 (包括 GET 请求和 POST 请求)&lt;/li&gt;
&lt;li&gt;WebWorker
&lt;ul&gt;
&lt;li&gt;Web Worker 的使用场景
&lt;ul&gt;
&lt;li&gt;用于收集埋点数据，可以用于大量复杂的数据计算，复杂的图像处理，大数据的处理。因为它不会阻碍主线程的正常执行和页面 UI 的渲染.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Service Worker
&lt;ul&gt;
&lt;li&gt;离线存储的一个最佳的解决方案&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;webworker-和-service-worker-的关系&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#webworker-和-service-worker-的关系&#34;&gt;#&lt;/a&gt; WebWorker 和 Service Worker 的关系&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;相同点
&lt;ul&gt;
&lt;li&gt;相同点是在常规的 js 引擎线程以外开辟了新的 js 线程去处理一些不适合在主线程上处理的业务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不同点
&lt;ul&gt;
&lt;li&gt;Web Worker 式服务于特定页面的，而 Service Worker 在被注册安装之后能够在多个页面使用&lt;/li&gt;
&lt;li&gt;Service Worker 常驻在浏览器中，不会因为页面的关闭而被销毁。本质上，它是一个后台线程，只有你主动终结，或者浏览器回收，这个线程才会结束.&lt;/li&gt;
&lt;li&gt;生命周期，可调用的 API 也不同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;代理服务器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;p&gt;代理，也称正向代理，是指一个位于客户端和目标服务器 (target server) 之间的服务器，为了从目标服务器取得内容，客户端向代理发送一个请求并指定目标 (目标服务器)，然后代理向目标服务器转交请求并将获得的内容返回给客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代理服务器，需要做以下几个步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接受客户端 请求 。&lt;/li&gt;
&lt;li&gt;将 请求 转发给服务器&lt;/li&gt;
&lt;li&gt;拿到服务器 响应 数据&lt;/li&gt;
&lt;li&gt;将 响应 转发给客户端&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;cors-和-jsonp-对比&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#cors-和-jsonp-对比&#34;&gt;#&lt;/a&gt; CORS 和 JSONP 对比&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;CORS 与 JSONP 相比，无疑更为先进、方便和可靠。&lt;/li&gt;
&lt;li&gt;区别
&lt;ol&gt;
&lt;li&gt;JSONP 只能实现 GET 请求，而 CORS 支持所有类型的 HTTP 请求。&lt;/li&gt;
&lt;li&gt;使用 CORS，开发者可以使用普通的 XMLHttpRequest 发起请求和获得数据，比起 JSONP 有更好的错误处理。&lt;/li&gt;
&lt;li&gt;JSONP 主要被老的浏览器支持，它们往往不支持 CORS，而绝大多数现代浏览器都已经支持了 CORS）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;9-动画&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#9-动画&#34;&gt;#&lt;/a&gt; 9、动画&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;requestanimationframe 的出现替代 setTimeout 完成动画。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;setTimeout
&lt;ul&gt;
&lt;li&gt;setTimeout 其实就是通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的。但利用 seTimeout 实现的动画在某些低端机上会出现卡顿、抖动的现象。导致 setTimeout 的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。&lt;/li&gt;
&lt;li&gt;原因
&lt;ol&gt;
&lt;li&gt;setTimeout 的执行时间并不是确定的。setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此 setTimeout 的实际执行时间一般要比其设定的时间晚一些。&lt;/li&gt;
&lt;li&gt;刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout 只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;requestanimationframe
&lt;ul&gt;
&lt;li&gt;html5 为了满足高性能动画的需求而提供的 API，表意是请求动画帧。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;requestanimationframe-相比-settimeout&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#requestanimationframe-相比-settimeout&#34;&gt;#&lt;/a&gt; requestanimationframe 相比 setTimeout&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;优势
&lt;ol&gt;
&lt;li&gt;与 setTimeout 相比，requestAnimationFrame 最大的优势是由系统来决定回调函数的执行时机。&lt;/li&gt;
&lt;li&gt;它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;10-事件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#10-事件&#34;&gt;#&lt;/a&gt; 10、事件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事件流&lt;/p&gt;
&lt;p&gt;事件流描述的是从页面中接收事件的顺序，IE 和 Netscape 提出来差不多完全相反的事件流的概念，IE 事件流是事件冒泡流，Netscape 事件流是事件捕获流。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DOM 事件级别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DOM0 事件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;p&gt;通过文档对象（document）获取元素引用，使用 DOM0 级方法指定的事件处理程序被认为是元素的方法，处理程序是在元素的作用域进行的，程序中 this 是引用的是当前元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3 个特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;触发时机：DOM0 级的事件处理程式只能在事件冒泡阶段触发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个属性只能绑定一个事件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;this 指针的指向&lt;/p&gt;
&lt;p&gt;用 DOM0 级的方式绑定事件是在元素对象的作用域内运行，因此在事件函数内的 this 属性不是引用全局对象，而是引用当前元素对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DOM2 事件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;p&gt;’DOM2 级事件’定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener () 和 removeEventListener (); 所有的 DOM 节点都包含这两种方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DOM2 级事件规定的事件流包括三个阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件捕获阶段&lt;/li&gt;
&lt;li&gt;处于目标阶段&lt;/li&gt;
&lt;li&gt;事件冒泡阶段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;p&gt;可以添加多个事件处理程序&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DOM3 级&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DOM3 级事件就是在 DOM2 基础上增加了更多的事件类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UI 事件，当用户与页面上的元素交互时触发，如：load、scroll&lt;/p&gt;
&lt;p&gt;焦点事件，当元素获得或失去焦点时触发，如：blur、focus&lt;/p&gt;
&lt;p&gt;鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup&lt;/p&gt;
&lt;p&gt;滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel&lt;/p&gt;
&lt;p&gt;文本事件，当在文档中输入文本时触发，如：textInput&lt;/p&gt;
&lt;p&gt;键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress&lt;/p&gt;
&lt;p&gt;合成事件，当为 IME（输入法编辑器）输入字符时触发，如：compositionstart&lt;/p&gt;
&lt;p&gt;变动事件，当底层 DOM 结构发生变化时触发，如：DOMsubtreeModified&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;机制&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;冒泡机制&lt;/p&gt;
&lt;p&gt;事件会从最内层的元素开始发生，一直向上传播，直到 document 对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;捕获机制&lt;/p&gt;
&lt;p&gt;网景提出另一种事件流名为事件捕获 (event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件代理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;p&gt;JavaScript 高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关键&lt;/p&gt;
&lt;p&gt;Event 对象提供了一个属性叫 target，可以返回事件的目标节点，我们成为事件源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;适合用事件委托的事件&lt;/p&gt;
&lt;p&gt;click，mousedown，mouseup，keydown，keyup，keypress&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不合适&lt;/p&gt;
&lt;p&gt;mousemove，每次都要计算它的位置，非常不好把控，在不如说 focus，blur 之类的，本身就没用冒泡的特性，自然就不能用事件委托了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="面试全面总结" />
        <category term="数组" />
        <category term="API" />
        <category term="跨域" />
        <category term="动画" />
        <category term="事件" />
        <updated>2020-03-23T09:40:43.000Z</updated>
    </entry>
</feed>
