<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mac 实用工具</title>
    <url>/2020/09/22/Mactoolinto/</url>
    <content><![CDATA[<h1 id="mac-实用工具"><a href="#mac-实用工具" class="headerlink" title="mac 实用工具"></a>mac 实用工具</h1><h2 id="macOS-图床客户端-uPic"><a href="#macOS-图床客户端-uPic" class="headerlink" title="macOS 图床客户端 uPic"></a>macOS 图床客户端 uPic</h2><p><strong>uPic 介绍</strong></p>
<p>uPic 采用 Swift 原生开发，通过调用各个服务商的 API 接口实现。体积小、速度快。支持多种图床：<a href="https://sm.ms/">smms</a>, <a href="https://www.upyun.com/products/file-storage">又拍云 USS</a>, <a href="https://www.qiniu.com/products/kodo">七牛云 KODO</a>, <a href="https://www.aliyun.com/product/oss/">阿里云 OSS</a>, <a href="https://cloud.tencent.com/product/cos">腾讯云 COS</a>, <a href="https://cloud.baidu.com/product/bos.html">百度云 BOS</a>, <a href="https://weibo.com/">微博</a>, <a href="https://github.com/settings/tokens">Github</a>, <a href="https://gitee.com/profile/personal_access_tokens">码云 Gitee</a>, <a href="https://aws.amazon.com/cn/s3/">Amazon S3</a>, <a href="https://imgur.com/">Imgur</a>, <a href="https://blog.svend.cc/upic/tutorials/custom">自定义上传服务</a>。</p>
<p>支持多种常用的输出格式，并且提供上传前图片压缩功能(支持 JPG、PNG)。等等一些小功能…</p>
<p>用法介绍：<a href="https://blog.svend.cc/upic/">https://blog.svend.cc/upic/</a></p>
<p>下载方式：从 <a href="https://github.com/gee1k/uPic/releases">Github release</a> 下载。<br><strong>如果访问 Github 下载困难的，可以从<a href="https://gitee.com/gee1k/uPic/releases">Gitee release</a>下载。</strong></p>
<p><img src="http://static.zxinc520.com/uPic/0usjjR.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>开机必备软件</category>
      </categories>
      <tags>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕代码</title>
    <url>/2020/03/23/getOfferHandcode/</url>
    <content><![CDATA[<h2 id="面试专题总结：手撕代码"><a href="#面试专题总结：手撕代码" class="headerlink" title="面试专题总结：手撕代码"></a>面试专题总结：手撕代码</h2><blockquote>
<p>希望读者依此构建自己的知识树（思维导图）</p>
<p>偷懒一下：可参考我自己总结思维导图 : <a href="https://github.com/ZhChen7/Interview-mind-map">点这里</a></p>
<p>手撕代码地址：<a href="https://github.com/ZhChen7/Technical-interview">地址</a></p>
<p>附带：高频面试题积累文档。 来自于（学长、牛客网等平台）</p>
<p>自己开发的博客地址：<a href="http://zxinc520.com/">zxinc520.com</a></p>
<p>github 地址: <a href="https://github.com/ZhChen7">点击</a></p>
</blockquote>
<blockquote>
<p>此篇 js - 【手撕代码】 知识点： 全部弄懂了，面试很容易。</p>
</blockquote>
<h3 id="1、Promise（A-规范）、then、all-方法"><a href="#1、Promise（A-规范）、then、all-方法" class="headerlink" title="1、Promise（A+规范）、then、all 方法"></a>1、Promise（A+规范）、then、all 方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     Promise：构造 Promise 函数对象</span></span><br><span class="line"><span class="comment">     excutor: 执行构造器 （同步执行）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">excutor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _that = <span class="built_in">this</span>;</span><br><span class="line">  _that.status = <span class="string">&quot;pending&quot;</span>; <span class="comment">// 给 promise对象指定 status属性,初始值为 pending</span></span><br><span class="line">  _that.data = <span class="literal">undefined</span>; <span class="comment">//给 promise 对象指定一个用于储存结果数据的属性</span></span><br><span class="line">  _that.callbacks = []; <span class="comment">// 每个元素的结构：&#123; onFulfilled()&#123;&#125;, onRejected()&#123;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前状态不是 pending，直接结束</span></span><br><span class="line">    <span class="keyword">if</span> (_that.status !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 状态改为 resolved</span></span><br><span class="line">    _that.status = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存 value 数据</span></span><br><span class="line">    _that.data = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有待执行callback 函数，立刻异步执行回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (_that.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        _that.callbacks.forEach(<span class="function">(<span class="params">callbacksObj</span>) =&gt;</span> &#123;</span><br><span class="line">          callbacksObj.onFulfilled(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前状态不是 pending，直接结束</span></span><br><span class="line">    <span class="keyword">if</span> (_that.status !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 状态改为 rejected</span></span><br><span class="line">    _that.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存 value 数据</span></span><br><span class="line">    _that.data = reason;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有待执行callback 函数，立刻异步执行回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (_that.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        _that.callbacks.forEach(<span class="function">(<span class="params">callbacksObj</span>) =&gt;</span> &#123;</span><br><span class="line">          callbacksObj.onRejected(reason);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//立刻同步执行 excutor</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    excutor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">//如果执行器抛出异常，promise对象变为 rejected 状态</span></span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">          Promise原型对象的 then() --- *思路*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            1、指定成功和失败的回调函数</span></span><br><span class="line"><span class="comment">            2、返回一个新的 promise 对象</span></span><br><span class="line"><span class="comment">            3、返回promise的结果由 onFulfilled/onRejected执行结果决定</span></span><br><span class="line"><span class="comment">            4、指定 onFulfilled/onRejected的默认值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  onFulfilled =</span><br><span class="line">    <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : <span class="function">(<span class="params">reason</span>) =&gt;</span> reason; <span class="comment">//向后传递成功的value</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//指定默认的失败的回调（实现错误/异常穿透的关键点）</span></span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">//向后传递失败的reason</span></span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> _that = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回一个新的promise 对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    调用指定的回调函数处理，根据执行结果，改变return的promise的状态</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                           1. 如果抛出异常，return 的promise就会失败，reason 就是 error</span></span><br><span class="line"><span class="comment">                           2. 如果回调函数返回的不是promise，return的promise就会成功，value就是返回的值</span></span><br><span class="line"><span class="comment">                           3.如果回调函数返回的是promise，return的promise的结果就是这个promise的结果</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = callback(_that.data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.如果回调函数返回的是promise，return的promise的结果就是这个promise的结果</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// result.then(</span></span><br><span class="line">          <span class="comment">//     value =&gt; resolve(value), //当result成功时，让return的promise也成功</span></span><br><span class="line">          <span class="comment">//     reason =&gt; reject(reason)  //当result失败时，让return的promise也失败</span></span><br><span class="line">          <span class="comment">// )</span></span><br><span class="line"></span><br><span class="line">          result.then(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//  2. 如果回调函数返回的不是promise，return的promise就会成功，value就是返回的值</span></span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="comment">//1. 如果抛出异常，return 的promise就会失败，reason 就是 error</span></span><br><span class="line"></span><br><span class="line">        reject(error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_that.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">//假设当前状态还是 pending 状态，将回调函数 保存起来</span></span><br><span class="line">      _that.callbacks.push(&#123;</span><br><span class="line">        onFulfilled(value) &#123;</span><br><span class="line">          handle(onFulfilled); <span class="comment">//改promise的状态为 onFulfilled状态</span></span><br><span class="line">        &#125;,</span><br><span class="line">        onRejected(reason) &#123;</span><br><span class="line">          handle(onRejected); <span class="comment">//改promise的状态为 onRejected状态</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_that.status === <span class="string">&quot;resolved&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">//如果当前是resolved状态，异步执行onresolved并改变return的promise状态</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        handle(onFulfilled);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//onRejected</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前是rejected状态，异步执行onRejected并改变return的promise状态</span></span><br><span class="line">        handle(onRejected);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            Promise原型对象的 catch()</span></span><br><span class="line"><span class="comment">            指定失败的回调函数</span></span><br><span class="line"><span class="comment">            返回一个新的 promise 对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">    (value) =&gt; &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(callback(value));</span><br><span class="line">    &#125;,</span><br><span class="line">    (reason) =&gt; &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(callback(reason));</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            Promise函数对象的 resolve()</span></span><br><span class="line"><span class="comment">            返回 指定结果的 &quot;成功&quot; 的 promise 对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//返回 一个 成功/失败 的promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      <span class="comment">//使用value的结果作为 promise 的结果</span></span><br><span class="line">      value.then(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//value不是promise =&gt; promise变为成功，数据是 value</span></span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            Promise函数对象的 reject()</span></span><br><span class="line"><span class="comment">            返回 指定结果的 &quot;失败&quot; 的 promise 对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//返回 一个失败的 promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            Promise函数对象的 all()</span></span><br><span class="line"><span class="comment">            返回 一个promise，只有当所有promise都成功时才成功，否则只要有一个失败就 失败</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> values = <span class="built_in">Array</span>.apply(<span class="literal">null</span>, &#123; <span class="attr">length</span>: promises.length &#125;); <span class="comment">//用来保存所有成功 value的数组</span></span><br><span class="line">  <span class="keyword">let</span> resolvedCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//遍历获取每一个 promise的结果</span></span><br><span class="line">    promises.forEach(<span class="function">(<span class="params">p, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(p).then(</span><br><span class="line">        <span class="comment">//p成功，将成功的 value 保存 values</span></span><br><span class="line">        <span class="comment">// values.push(value)  =&gt; 不能这样</span></span><br><span class="line">        (value) =&gt; &#123;</span><br><span class="line">          resolvedCount++; <span class="comment">//成功的次数</span></span><br><span class="line"></span><br><span class="line">          values[index] = value;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//如果全部成功了，将return的 promise 改为成功</span></span><br><span class="line">          <span class="keyword">if</span> (resolvedCount === promises.length) &#123;</span><br><span class="line">            resolve(values);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        (reason) =&gt; &#123;</span><br><span class="line">          <span class="comment">//只要一个失败了，return 的promise就失败</span></span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            Promise函数对象的 race()</span></span><br><span class="line"><span class="comment">            返回 一个promise，其结果由第一个完成的promise来决定</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//遍历获取每一个 promise的结果</span></span><br><span class="line">    promises.forEach(<span class="function">(<span class="params">p, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(p).then(</span><br><span class="line">        (value) =&gt; &#123;</span><br><span class="line">          <span class="comment">// 一旦由成功了，将return 变为失败</span></span><br><span class="line">          resolve(value);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        (reason) =&gt; &#123;</span><br><span class="line">          <span class="comment">//只要一个失败了，return 的promise就失败</span></span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2、手写-call-apply-bind"><a href="#2、手写-call-apply-bind" class="headerlink" title="2、手写 call apply bind"></a>2、手写 call apply bind</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义apply函数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply1 = <span class="function"><span class="keyword">function</span> (<span class="params">obj, arg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//context为null或者是undefined时,设置默认值</span></span><br><span class="line">  <span class="keyword">if</span> (!obj) &#123;</span><br><span class="line">    obj = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">&quot;undefined&quot;</span> ? <span class="built_in">global</span> : <span class="built_in">window</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//undefined 或者 是 null 不是 Iterator 对象，不能被 ...</span></span><br><span class="line">  <span class="keyword">if</span> (arg === <span class="literal">undefined</span> || arg === <span class="literal">null</span>) &#123;</span><br><span class="line">    result = obj.fn(arg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = obj.fn(...arg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> obj.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 call 函数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.call1 = <span class="function"><span class="keyword">function</span> (<span class="params">obj, ...arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj) &#123;</span><br><span class="line">    obj = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">&quot;undefined&quot;</span> ? <span class="built_in">global</span> : <span class="built_in">window</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  result = obj.fn(...arg);</span><br><span class="line">  <span class="keyword">delete</span> obj.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 bind 函数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">obj, ...arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj) &#123;</span><br><span class="line">    obj = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">&quot;undefined&quot;</span> ? <span class="built_in">global</span> : <span class="built_in">window</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = arg;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  f.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">  <span class="keyword">let</span> bound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [...args, ...arguments];</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="built_in">this</span> <span class="keyword">instanceof</span> f ? <span class="built_in">this</span> : obj;</span><br><span class="line">    <span class="keyword">return</span> self.apply(obj, res);</span><br><span class="line">  &#125;;</span><br><span class="line">  bound.prototype = <span class="keyword">new</span> f();</span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3、Promise-封装-Ajax-方法"><a href="#3、Promise-封装-Ajax-方法" class="headerlink" title="3、Promise 封装 Ajax 方法"></a>3、Promise 封装 Ajax 方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, methods, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(methods, url, <span class="literal">true</span>);</span><br><span class="line">    xhr.send(data);</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(xhr.responseText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(xhr.status);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、异步加载图片"><a href="#4、异步加载图片" class="headerlink" title="4、异步加载图片"></a>4、异步加载图片</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(image);</span><br><span class="line">    &#125;;</span><br><span class="line">    image.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Could not load image at &quot;</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line">    image.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、防抖，节流"><a href="#5、防抖，节流" class="headerlink" title="5、防抖，节流"></a>5、防抖，节流</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//防抖</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节流</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) <span class="keyword">return</span>;</span><br><span class="line">    canRun = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、圣杯、双飞翼"><a href="#6、圣杯、双飞翼" class="headerlink" title="6、圣杯、双飞翼"></a>6、圣杯、双飞翼</h3><h4 id="圣杯"><a href="#圣杯" class="headerlink" title="圣杯"></a>圣杯</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line">            padding: 0;</span><br><span class="line">            margin: 0;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span>&#123;</span></span><br><span class="line">            overflow: hidden;</span><br><span class="line">            padding: 0 100px 0 100px;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.middle</span>,<span class="selector-class">.left</span>,<span class="selector-class">.right</span>&#123;</span></span><br><span class="line">            position: relative;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: red;</span><br><span class="line">            margin-left: -100%;</span><br><span class="line">            left: -100px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: green;</span><br><span class="line">            margin-left: -100px;</span><br><span class="line">            right: -100px;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.middle</span>&#123;</span></span><br><span class="line">            background: blue;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="双飞翼"><a href="#双飞翼" class="headerlink" title="双飞翼"></a>双飞翼</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.middle</span>, <span class="selector-class">.left</span>, <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            height: 100px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            background: red;</span><br><span class="line">            margin-left: -100%;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            background: blue;</span><br><span class="line">            margin-left: -100px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line">            width: 100%;</span><br><span class="line">            background: aqua;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line">            margin: 0 100px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>middle<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7、继承相关"><a href="#7、继承相关" class="headerlink" title="7、继承相关"></a>7、继承相关</h3><h4 id="7-1、原型链继承"><a href="#7-1、原型链继承" class="headerlink" title="7.1、原型链继承"></a>7.1、原型链继承</h4><ul>
<li><p>原型链继承的基本思想：是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<p>如 SubType.prototype = new SuperType();</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;Yvette&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br></pre></td></tr></table></figure>
</li>
<li><p>缺点</p>
<ol>
<li>通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享</li>
<li>在创建子类型的实例时，不能向超类型的构造函数中传递参数</li>
</ol>
</li>
</ul>
<h4 id="7-2、借用构造函数"><a href="#7-2、借用构造函数" class="headerlink" title="7.2、借用构造函数"></a>7.2、借用构造函数</h4><ul>
<li><p>其基本思想为:在子类型的构造函数中调用超类型构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点</p>
<ol>
<li>可以向超类传递参数</li>
<li>解决了原型中包含引用类型值被所有实例共享的问题</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>方法都在构造函数中定义，函数复用无从谈起</li>
<li>另外超类型原型中定义的方法对于子类型而言都是不可见的</li>
</ol>
</li>
</ul>
<h4 id="7-3、组合继承"><a href="#7-3、组合继承" class="headerlink" title="7.3、组合继承"></a>7.3、组合继承</h4><ul>
<li><p>组合继承指的是将原型链和借用构造函数技术组合到一块，从而发挥二者之长的一种继承模式。基本思路：使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;zc&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> SubType();</span><br><span class="line"></span><br><span class="line">a.colors.push(<span class="string">&quot;red&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.colors); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;red&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(b.colors); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>优点</p>
<ol>
<li>可以向超类传递参数</li>
<li>每个实例都有自己的属性</li>
<li>实现了函数复用</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</li>
</ol>
</li>
</ul>
<h4 id="7-4、原型式继承"><a href="#7-4、原型式继承" class="headerlink" title="7.4、原型式继承"></a>7.4、原型式继承</h4><ul>
<li><p>原型式继承继承的基本思想：在 object() 函数内部，先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例，从本质上讲，object() 对传入的对象执行了一次浅拷贝。</p>
<p>ECMAScript5 通过新增 Object.create()方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象(可以覆盖原型对象上的同名属性)，在传入一个参数的情况下，Object.create() 和 object() 方法的行为相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缺点</p>
<ol>
<li>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享</li>
</ol>
</li>
</ul>
<h4 id="7-5、寄生式继承"><a href="#7-5、寄生式继承" class="headerlink" title="7.5、寄生式继承"></a>7.5、寄生式继承</h4><ul>
<li><p>寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//以某种方式增强这个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点</p>
<ol>
<li>基于 person 返回了一个新对象 -—— person2，新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi() 方法。在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。</li>
<li>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。</li>
</ol>
</li>
</ul>
<h4 id="7-6、寄生组合式继承"><a href="#7-6、寄生组合式继承" class="headerlink" title="7.6、寄生组合式继承"></a>7.6、寄生组合式继承</h4><ul>
<li><p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，基本思路：</p>
<p>不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">  prototype.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">  subType.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuberType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SuberType, SuperType);</span><br></pre></td></tr></table></figure>
</li>
<li><p>步骤</p>
<p>第一步：创建超类型原型的一个副本</p>
<p>第二步：为创建的副本添加 constructor 属性</p>
<p>第三步：将新创建的对象赋值给子类型的原型</p>
</li>
<li><p>优点</p>
<ol>
<li>只调用了一次超类构造函数，效率更高。避免在 SuberType.prototype 上面创建不必要的、多余的属性，与其同时，原型链还能保持不变。因此寄生组合继承是引用类型最理性的继承范式。</li>
</ol>
</li>
</ul>
<h4 id="7-7、ES6-继承"><a href="#7-7、ES6-继承" class="headerlink" title="7.7、ES6 继承"></a>7.7、ES6 继承</h4><ul>
<li><p>Class 可以通过 extends 关键字实现继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age) &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age, name) &#123;</span><br><span class="line">    <span class="built_in">super</span>(age); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于 ES6 的 class 需要做以下几点说明</p>
<ol>
<li>class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。</li>
<li>class 声明内部会启用严格模式。</li>
<li>class 的所有方法（包括静态方法和实例方法）都是不可枚举的。</li>
<li>class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。</li>
<li>必须使用 new 调用 class</li>
<li>class 内部无法重写类名</li>
</ol>
</li>
</ul>
<h4 id="使用-extends-关键字实现继承，有几点需要特别说明"><a href="#使用-extends-关键字实现继承，有几点需要特别说明" class="headerlink" title="使用 extends 关键字实现继承，有几点需要特别说明"></a>使用 extends 关键字实现继承，有几点需要特别说明</h4><ul>
<li>子类必须在 constructor 中调用 super 方法，否则新建实例时会报错。如果没有子类没有定义 constructor 方法，那么这个方法会被默认添加。在子类的构造函数中，只有调用 super 之后，才能使用 this 关键字，否则报错。这是因为子类实例的构建，基于父类实例，只有 super 方法才能调用父类实例。</li>
<li>ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this</li>
</ul>
<h3 id="8、自定义-new-过程"><a href="#8、自定义-new-过程" class="headerlink" title="8、自定义 new 过程"></a>8、自定义 new 过程</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">fn, ...arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  obj.__proto__ = fn.prototype;</span><br><span class="line">  <span class="keyword">let</span> ret = fn.apply(obj, arg);</span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9、手写递归方法实现深拷贝"><a href="#9、手写递归方法实现深拷贝" class="headerlink" title="9、手写递归方法实现深拷贝"></a>9、手写递归方法实现深拷贝</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手写实现深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkedType</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> targrtType = checkedType(target);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (targrtType === <span class="string">&quot;Object&quot;</span>) &#123;</span><br><span class="line">    result = &#123;&#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targrtType === <span class="string">&quot;Array&quot;</span>) &#123;</span><br><span class="line">    result = [];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = target[item];</span><br><span class="line">    <span class="keyword">if</span> (checkedType(value) === <span class="string">&quot;Object&quot;</span> || checkedType(value) === <span class="string">&quot;Array&quot;</span>) &#123;</span><br><span class="line">      result[item] = clone(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result[item] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10、实现一个柯里化函数"><a href="#10、实现一个柯里化函数" class="headerlink" title="10、实现一个柯里化函数"></a>10、实现一个柯里化函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES5写法</span></span><br><span class="line"><span class="keyword">const</span> currying = <span class="function"><span class="keyword">function</span> (<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (args.length &lt; fn.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> currying(fn, ...args, ...arguments);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6写法</span></span><br><span class="line"><span class="keyword">const</span> currying = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span></span><br><span class="line">  args.length &lt; fn.length</span><br><span class="line">    ? <span class="function">(<span class="params">...argments</span>) =&gt;</span> currying(fn, ...args, ...argments)</span><br><span class="line">    : fn(...args);</span><br></pre></td></tr></table></figure>

<h3 id="11、双向绑定（手写）"><a href="#11、双向绑定（手写）" class="headerlink" title="11、双向绑定（手写）"></a>11、双向绑定（手写）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object.defineProperty 写法</span></span><br><span class="line"><span class="keyword">let</span> vm = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;zc&quot;</span>,</span><br><span class="line">  age: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(vm, key, &#123;</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj[key];</span><br><span class="line">      &#125;,</span><br><span class="line">      set: <span class="function"><span class="keyword">function</span> (<span class="params">newvalue</span>) </span>&#123;</span><br><span class="line">        obj[key] = newvalue;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.age = <span class="string">&quot;111&quot;</span>;</span><br><span class="line">vm.age = <span class="string">&quot;112221&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(vm.age);</span><br><span class="line"><span class="built_in">console</span>.log(obj.age);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Proxy 写法</span></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, propKey, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">target, propKey, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, propKey, value, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="10、JS-发布订阅模式"><a href="#10、JS-发布订阅模式" class="headerlink" title="10、JS 发布订阅模式"></a>10、JS 发布订阅模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pubSub = &#123;</span><br><span class="line">  list: &#123;&#125;,</span><br><span class="line">  subscribe: <span class="function"><span class="keyword">function</span> (<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//订阅</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.list[key]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.list[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.list[key].push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  publish: <span class="function"><span class="keyword">function</span> (<span class="params">key, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//发布</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> <span class="built_in">this</span>.list[key]) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  unSubscribe: <span class="function"><span class="keyword">function</span> (<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//取消订阅</span></span><br><span class="line">    <span class="keyword">let</span> fnlist = <span class="built_in">this</span>.list[key];</span><br><span class="line">    <span class="keyword">if</span> (!fnlist) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">      fnlist.length = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fnlist.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item === index) &#123;</span><br><span class="line">          fnlist.splice(index, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pubSub.subscribe(<span class="string">&quot;onwork&quot;</span>, <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`上班了：<span class="subst">$&#123;time&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">pubSub.subscribe(<span class="string">&quot;offwork&quot;</span>, <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`下班了：<span class="subst">$&#123;time&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">pubSub.subscribe(<span class="string">&quot;launch&quot;</span>, <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`吃饭了：<span class="subst">$&#123;time&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 发布</span></span><br><span class="line">pubSub.publish(<span class="string">&quot;offwork&quot;</span>, <span class="string">&quot;18:00:00&quot;</span>);</span><br><span class="line">pubSub.publish(<span class="string">&quot;launch&quot;</span>, <span class="string">&quot;12:00:00&quot;</span>);</span><br><span class="line"></span><br><span class="line">pubSub.unSubscribe(<span class="string">&quot;onwork&quot;</span>);</span><br><span class="line">pubSub.publish(<span class="string">&quot;onwork&quot;</span>, <span class="string">&quot;1222:00:00&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="11、JS-获取-url-参数"><a href="#11、JS-获取-url-参数" class="headerlink" title="11、JS 获取 url 参数"></a>11、JS 获取 url 参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test =</span><br><span class="line">  <span class="string">&quot;?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=21331&amp;rsv_pq=b8627e62001efbb9&amp;rsv_t=eef5sqIQ98s66yOwueYH5BWlFUARj0PkHBdCA4ahbSVYQA5qO9MBoZPC0mU&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=5&amp;rsv_sug1=1&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;inputT=509&amp;rsv_sug4=509&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str1 = str.slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> arr = str1.split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(arr);</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">  arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [key, value] = item.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">    map.set(key, <span class="built_in">decodeURIComponent</span>(value));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> f(test)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12、二叉树"><a href="#12、二叉树" class="headerlink" title="12、二叉树"></a>12、二叉树</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、求二叉树中的节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNodenum</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getNodenum(root.left) + getNodenum(root.right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、求二叉树的最大深度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxDepth</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.二叉树的最小深度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minDepth</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> left = minDepth(root.left);</span><br><span class="line">  <span class="keyword">let</span> right = minDepth(root.right);</span><br><span class="line">  <span class="keyword">return</span> left == <span class="number">0</span> || right == <span class="number">0</span> ? left + right + <span class="number">1</span> : <span class="built_in">Math</span>.min(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.先序遍历（递归）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preroot</span>(<span class="params">root, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">    callback(root.key);</span><br><span class="line">    preroot(root.left, callback);</span><br><span class="line">    preroot(root.right, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历（非递归）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preroot</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [],</span><br><span class="line">    result = [];</span><br><span class="line">  <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">    stack.push(root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (stack.length != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = stack.pop();</span><br><span class="line">    result.push(temp.key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">      stack.push(temp.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">      stack.push(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5 中序遍历（递归）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleroot</span>(<span class="params">root, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">    preroot(root.left, callback);</span><br><span class="line">    callback(root.key);</span><br><span class="line">    preroot(root.right, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.1 中序遍历（非递归）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleroot</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [],</span><br><span class="line">    result = [];</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">      stack.push(root);</span><br><span class="line">      root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> temp = stack.pop();</span><br><span class="line">    result.push(temp.key);</span><br><span class="line">    stack.push(temp.right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分层遍历（递归）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bfs</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> queue = [],</span><br><span class="line">    result = [];</span><br><span class="line">  <span class="keyword">let</span> pointer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">    queue.push(root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> bfsFun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = queue[pointer];</span><br><span class="line">    <span class="keyword">if</span> (temp) &#123;</span><br><span class="line">      result.push(temp.key);</span><br><span class="line">      <span class="keyword">if</span> (temp.left) &#123;</span><br><span class="line">        queue.push(temp.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (temp.right) &#123;</span><br><span class="line">        queue.push(temp.right);</span><br><span class="line">      &#125;</span><br><span class="line">      pointer++;</span><br><span class="line">      bfsFun();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  bfsFun();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分层遍历（非递归）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bfs</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> queue = [],</span><br><span class="line">    result = [];</span><br><span class="line">  <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">    queue.push(root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> pointer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (pointer &lt; queue.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = queue[pointer++];</span><br><span class="line">    result.push(temp.key);</span><br><span class="line">    temp.left &amp;&amp; queue.push(temp.left);</span><br><span class="line">    temp.right &amp;&amp; queue.push(temp.right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按之字形顺序打印二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zhiRoot</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stack1 = [],</span><br><span class="line">    stack2 = [],</span><br><span class="line">    result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">    stack1.push(root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (stack1.length != <span class="number">0</span> || stack2.length != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> list = [];</span><br><span class="line">    <span class="keyword">if</span> (flag % <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (stack1.length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = stack2.pop();</span><br><span class="line">        list.push(temp.key);</span><br><span class="line">        temp.left &amp;&amp; stack2.push(temp.left);</span><br><span class="line">        temp.right &amp;&amp; stack2.push(temp.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (stack2.length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = stack1.pop();</span><br><span class="line">        list.push(temp.key);</span><br><span class="line">        temp.left &amp;&amp; stack1.push(temp.left);</span><br><span class="line">        temp.right &amp;&amp; stack1.push(temp.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">    result.push(list);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Print</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> stack1 = [];</span><br><span class="line">  <span class="keyword">const</span> stack2 = [];</span><br><span class="line"></span><br><span class="line">  stack1.push(root);</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (stack1.length !== <span class="number">0</span> || stack2.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> list = [];</span><br><span class="line">    <span class="keyword">if</span> (flag % <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (stack1.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = stack2.pop();</span><br><span class="line">        list.push(temp.val);</span><br><span class="line">        temp.left &amp;&amp; stack2.push(temp.left);</span><br><span class="line">        temp.right &amp;&amp; stack2.push(temp.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (stack2.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = stack1.pop();</span><br><span class="line">        list.push(tmp.val);</span><br><span class="line">        temp.left &amp;&amp; stack1.push(temp.left);</span><br><span class="line">        temp.right &amp;&amp; stack1.push(temp.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">    result.push(list);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7、求二叉树第K层的节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getknum</span>(<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span> || k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root !== <span class="literal">null</span> &amp;&amp; k == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getknum(root.left, k - <span class="number">1</span>) + getknum(root.right, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.求二叉树第K层的叶子节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getksonnum</span>(<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span> || k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; k == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getksonnum(root, k - <span class="number">1</span>) + getksonnum(root, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseRoot</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> temp = root.left;</span><br><span class="line">  root.left = reverseRoot(root.right);</span><br><span class="line">  root.right = reverseRoot(temp);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求二叉树的直径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longerlength</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> path = <span class="number">0</span>;</span><br><span class="line">  getlongerlength(root);</span><br><span class="line">  <span class="keyword">return</span> path;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getlongerlength</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left = longerlength(root.left);</span><br><span class="line">    <span class="keyword">let</span> right = longerlength(root.right);</span><br><span class="line">    path = <span class="built_in">Math</span>.max(path, left + right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树中和为某一值的路径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPath</span>(<span class="params">root, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    findPath(root, target, [], <span class="number">0</span>, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">findPath</span>(<span class="params">root, target, stack, sum, result</span>) </span>&#123;</span><br><span class="line">    stack.push(root.key);</span><br><span class="line">    sum += root.key;</span><br><span class="line">    <span class="keyword">if</span> (!root.left &amp;&amp; !root.right &amp;&amp; sum === target) &#123;</span><br><span class="line">      result.push(stack.slice(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left) &#123;</span><br><span class="line">      findPath(root.left, target, stack, sum, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right) &#123;</span><br><span class="line">      findPath(root.right, target, stack, sum, result);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定一棵二叉搜索树，请找出其中的第k小的结点。(中序遍历+ k小)</span></span><br></pre></td></tr></table></figure>

<h3 id="13、实现一个链表"><a href="#13、实现一个链表" class="headerlink" title="13、实现一个链表"></a>13、实现一个链表</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">linkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">node</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  linkedList.prototype.append = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newnode = <span class="keyword">new</span> node(data);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.head = newnode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">      <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">        current = current.next;</span><br><span class="line">      &#125;</span><br><span class="line">      current.next = newnode;</span><br><span class="line">      <span class="built_in">this</span>.length++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  linkedList.prototype.find = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (current.data === data) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  linkedList.prototype.fixed = <span class="function"><span class="keyword">function</span> (<span class="params">data, newdata</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.find(data);</span><br><span class="line">    current.data = newdata;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  linkedList.prototype.prefind = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (current.next.data === data) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  linkedList.prototype.delete = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.head.data === data) &#123;</span><br><span class="line">      <span class="built_in">this</span>.head = <span class="built_in">this</span>.head.next;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> prenode = <span class="built_in">this</span>.prefind(data);</span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.find(data);</span><br><span class="line">    prenode = current.next;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  linkedList.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      result += current.data + <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> linkedList();</span><br><span class="line">a.append(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">a.append(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">a.append(<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.toString());</span><br><span class="line"></span><br><span class="line">a.fixed(<span class="string">&quot;abc&quot;</span>, <span class="number">11111</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.toString());</span><br></pre></td></tr></table></figure>

<h3 id="14、哈希表"><a href="#14、哈希表" class="headerlink" title="14、哈希表"></a>14、哈希表</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链地址法</span></span><br><span class="line"><span class="comment">//装载因子（0.25，0.75）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//属性</span></span><br><span class="line">  <span class="built_in">this</span>.storage = []; <span class="comment">//存储的位置</span></span><br><span class="line">  <span class="built_in">this</span>.count = <span class="number">0</span>; <span class="comment">// 数目</span></span><br><span class="line">  <span class="built_in">this</span>.limit = <span class="number">7</span>; <span class="comment">//最终限制数组的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="comment">// 哈希函数</span></span><br><span class="line">  HashTable.prototype.hashFunc = <span class="function"><span class="keyword">function</span> (<span class="params">str, size</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//1、定义 hashCode变量</span></span><br><span class="line">    <span class="keyword">let</span> hashCode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">      <span class="comment">//2、霍纳算法，来计算hashCode的值</span></span><br><span class="line">      hashCode = <span class="number">37</span> * hashCode + str.charCodeAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、取余操作</span></span><br><span class="line">    <span class="keyword">let</span> index = hashCode % size;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//插入&amp;修改操作</span></span><br><span class="line">  HashTable.prototype.put = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//1.根据key获取对应的 index</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="built_in">this</span>.hashFunc(key, <span class="built_in">this</span>.limit);</span><br><span class="line">    <span class="comment">// 2、根据 index 取出对应的 bucket</span></span><br><span class="line">    <span class="keyword">let</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、判断 bucket是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">      bucket = [];</span><br><span class="line">      <span class="built_in">this</span>.storage[index] = bucket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4、判断是否是修改数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">      <span class="keyword">if</span> (tuple[<span class="number">0</span>] == key) &#123;</span><br><span class="line">        tuple[<span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.添加操作</span></span><br><span class="line">    bucket.push([key, value]);</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.count &gt; <span class="built_in">this</span>.limit * <span class="number">0.75</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.resize(<span class="built_in">this</span>.limit * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取操作</span></span><br><span class="line">  HashTable.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="built_in">this</span>.hashFunc(key, <span class="built_in">this</span>.limit);</span><br><span class="line">    <span class="keyword">let</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line">    <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">      <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">        <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  HashTable.prototype.remove = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="built_in">this</span>.hashFunc(key, <span class="built_in">this</span>.limit);</span><br><span class="line">    <span class="keyword">let</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line">    <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">      <span class="keyword">if</span> (tuple[<span class="number">0</span>] == key) &#123;</span><br><span class="line">        bucket.splice(i, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.count--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缩小容量</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.limit &gt; <span class="number">7</span> &amp;&amp; <span class="built_in">this</span>.count &lt; <span class="built_in">this</span>.limit * <span class="number">0.75</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.resize(<span class="built_in">Math</span>.floor(<span class="built_in">this</span>.limit / <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//哈希表的扩容、</span></span><br><span class="line">  HashTable.prototype.resize = <span class="function"><span class="keyword">function</span> (<span class="params">newLimit</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//1.保存旧的数据内容</span></span><br><span class="line">    <span class="keyword">let</span> oldStorage = <span class="built_in">this</span>.storage;</span><br><span class="line">    <span class="comment">//2. 重置所有的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.storage = [];</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.limit = newLimit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.遍历 oldStorage 所有的 bucket</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; oldStorage.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> bucket = oldStorage[i];</span><br><span class="line">      <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">        <span class="built_in">this</span>.put(tuple[<span class="number">0</span>], tuple[<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> HashTable();</span><br><span class="line">a.put(<span class="string">&quot;zc&quot;</span>, <span class="string">&quot;15&quot;</span>);</span><br><span class="line">a.put(<span class="string">&quot;zc1&quot;</span>, <span class="string">&quot;115&quot;</span>);</span><br><span class="line">a.put(<span class="string">&quot;z1&quot;</span>, <span class="string">&quot;115&quot;</span>);</span><br><span class="line">a.put(<span class="string">&quot;asd&quot;</span>, <span class="string">&quot;115&quot;</span>);</span><br><span class="line">a.put(<span class="string">&quot;wew&quot;</span>, <span class="string">&quot;115&quot;</span>);</span><br><span class="line">a.remove(<span class="string">&quot;wew&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.get(<span class="string">&quot;wew&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="15、图"><a href="#15、图" class="headerlink" title="15、图"></a>15、图</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//栈中的属性</span></span><br><span class="line">  <span class="built_in">this</span>.items = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.压入栈push()</span></span><br><span class="line">  Queue.prototype.enqueue = <span class="function"><span class="keyword">function</span> (<span class="params">...element</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.items.push(...element);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.从队列中删除前端元素</span></span><br><span class="line">  Queue.prototype.dequeue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.shift();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.查看一下前端元素</span></span><br><span class="line">  Queue.prototype.front = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="number">0</span>];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4.判断栈是否为空</span></span><br><span class="line">  Queue.prototype.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//5.获取栈中元素的个数</span></span><br><span class="line">  Queue.prototype.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.length;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//6.toString方法</span></span><br><span class="line">  Queue.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.toString().split(<span class="string">&quot;,&quot;</span>).join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//属性： 顶点（数组）/边（字典）</span></span><br><span class="line">  <span class="built_in">this</span>.vertexes = []; <span class="comment">//顶点</span></span><br><span class="line">  <span class="built_in">this</span>.edges = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">//边</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="comment">//增加对应顶点的方法</span></span><br><span class="line">  Graph.prototype.addVertex = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vertexes.push(v);</span><br><span class="line">    <span class="built_in">this</span>.edges.set(v, []);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Graph.prototype.addEdge = <span class="function"><span class="keyword">function</span> (<span class="params">v1, v2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.edges.get(v1).push(v2);</span><br><span class="line">    <span class="built_in">this</span>.edges.get(v2).push(v1);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实现toString 方法</span></span><br><span class="line">  Graph.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//定义字符转，保存最终的结构</span></span><br><span class="line">    <span class="keyword">let</span> resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.vertexes.length; i++) &#123;</span><br><span class="line">      resultString += <span class="built_in">this</span>.vertexes[i] + <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">      <span class="keyword">let</span> vEdges = <span class="built_in">this</span>.edges.get(<span class="built_in">this</span>.vertexes[i]);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; vEdges.length; j++) &#123;</span><br><span class="line">        resultString += vEdges[j] + <span class="string">&quot; &quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      resultString += <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultString;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//图的遍历</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化状态颜色</span></span><br><span class="line">  Graph.prototype.initializeColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> colors = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.vertexes.length; i++) &#123;</span><br><span class="line">      colors[<span class="built_in">this</span>.vertexes[i]] = <span class="string">&quot;white&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> colors;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//广度优先搜索算法(BFS)  基于队列完成</span></span><br><span class="line">  Graph.prototype.bfs = <span class="function"><span class="keyword">function</span> (<span class="params">initV, handler</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//1.初始化颜色</span></span><br><span class="line">    <span class="keyword">let</span> colors = <span class="built_in">this</span>.initializeColor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建队列</span></span><br><span class="line">    <span class="keyword">let</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.将顶点加入队列中</span></span><br><span class="line">    queue.enqueue(initV);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.循环从队列中取出元素</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 4.1从队列取出一个顶点</span></span><br><span class="line">      <span class="keyword">let</span> v = queue.dequeue();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.2 获取和顶点相连的另外顶点</span></span><br><span class="line">      <span class="keyword">let</span> vList = <span class="built_in">this</span>.edges.get(v);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.3 将v的颜色设置为灰色</span></span><br><span class="line">      colors[v] = <span class="string">&quot;gray&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.4  遍历所有的顶点，并且加入到队列中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vList.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> e = vList[i];</span><br><span class="line">        <span class="keyword">if</span> (colors[e] == <span class="string">&quot;white&quot;</span>) &#123;</span><br><span class="line">          colors[e] = <span class="string">&quot;gray&quot;</span>;</span><br><span class="line">          queue.enqueue(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.5 访问顶点</span></span><br><span class="line">      handler(v);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.6 将顶点设置为黑色</span></span><br><span class="line">      colors[v] = <span class="string">&quot;black&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//广度优先搜索算法（DFS）</span></span><br><span class="line">  Graph.prototype.dfs = <span class="function"><span class="keyword">function</span> (<span class="params">initV, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> colors = <span class="built_in">this</span>.initializeColor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归访问</span></span><br><span class="line">    <span class="built_in">this</span>.dfsVisit(initV, colors, handler);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Graph.prototype.dfsVisit = <span class="function"><span class="keyword">function</span> (<span class="params">v, colors, handler</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//1.将颜色设置为灰色</span></span><br><span class="line">    colors[v] = <span class="string">&quot;gray&quot;</span>;</span><br><span class="line">    <span class="comment">//2.处理V节点</span></span><br><span class="line">    handler(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.访问v相连的顶点</span></span><br><span class="line">    <span class="keyword">let</span> vList = <span class="built_in">this</span>.edges.get(v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vList.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> e = vList[i];</span><br><span class="line">      <span class="keyword">if</span> (colors[e] === <span class="string">&quot;white&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.dfsVisit(e, colors, handler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.将v设置为黑色</span></span><br><span class="line">    colors[v] = <span class="string">&quot;black&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16、几种排序算法的实现"><a href="#16、几种排序算法的实现" class="headerlink" title="16、几种排序算法的实现"></a>16、几种排序算法的实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.array = [];</span><br><span class="line"></span><br><span class="line">  ArrayList.prototype.insert = <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.array.push(item);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ArrayList.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.array.join(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ArrayList.prototype.swap = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">this</span>.array[m];</span><br><span class="line">    <span class="built_in">this</span>.array[m] = <span class="built_in">this</span>.array[n];</span><br><span class="line">    <span class="built_in">this</span>.array[n] = temp;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//实现排序算法</span></span><br><span class="line">  <span class="comment">//冒泡排序</span></span><br><span class="line">  ArrayList.prototype.bubbles = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.array === <span class="literal">null</span> || <span class="built_in">this</span>.array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">this</span>.array;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="built_in">this</span>.array.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.array[j] &gt; <span class="built_in">this</span>.array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="built_in">this</span>.swap(j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//选择排序</span></span><br><span class="line">  ArrayList.prototype.selectSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.array === <span class="literal">null</span> || <span class="built_in">this</span>.array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">this</span>.array;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="built_in">this</span>.array.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> min = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.array[min] &gt; <span class="built_in">this</span>.array[j]) &#123;</span><br><span class="line">          min = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.swap(min, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//插入排序</span></span><br><span class="line">  ArrayList.prototype.insertSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.array === <span class="literal">null</span> || <span class="built_in">this</span>.array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">this</span>.array;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="built_in">this</span>.array.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> temp = <span class="built_in">this</span>.array[i];</span><br><span class="line">      <span class="keyword">let</span> j = i;</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">this</span>.array[j - <span class="number">1</span>] &gt; temp &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.array[j] = <span class="built_in">this</span>.array[j - <span class="number">1</span>];</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//高级排序</span></span><br><span class="line">  <span class="comment">//希尔排序 (对插入排序的升级)</span></span><br><span class="line">  ArrayList.prototype.shellSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.array === <span class="literal">null</span> || <span class="built_in">this</span>.array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">this</span>.array;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="built_in">this</span>.array.length;</span><br><span class="line">    <span class="comment">//初始化增量</span></span><br><span class="line">    <span class="keyword">var</span> gap = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// whlie循环</span></span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = <span class="built_in">this</span>.array[i];</span><br><span class="line">        <span class="keyword">let</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.array[j - gap] &gt; temp &amp;&amp; j &gt; gap - <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.array[j] = <span class="built_in">this</span>.array[j - gap];</span><br><span class="line">          j -= gap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.array[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">      gap = <span class="built_in">Math</span>.floor(gap / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快排</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">median</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> center = <span class="built_in">Math</span>.floor(left + (right - left) / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (arr[left] &gt; arr[center]) &#123;</span><br><span class="line">    swap(arr, left, right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[center] &gt; arr[right]) &#123;</span><br><span class="line">    swap(arr, center, right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[left] &gt; arr[right]) &#123;</span><br><span class="line">    swap(arr, left, right);</span><br><span class="line">  &#125;</span><br><span class="line">  swap(center, right - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> arr[right - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, m, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = arr[m];</span><br><span class="line">  arr[m] = arr[n];</span><br><span class="line">  arr[n] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> quickSortFun(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSortFun</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">let</span> pivot = median(arr, left, right);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> j = right - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (arr[++i] &lt; pivot) &#123;&#125;</span><br><span class="line">      <span class="keyword">while</span> (arr[--j] &gt; pivot &amp;&amp; j &gt; left) &#123;&#125;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">        swap(arr, i, j);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; right) &#123;</span><br><span class="line">      swap(arr, i, right - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    quickSortFun(arr, left, i - <span class="number">1</span>);</span><br><span class="line">    quickSortFun(arr, i + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(quickSort([<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]));</span><br></pre></td></tr></table></figure>

<h3 id="17、手写迭代器"><a href="#17、手写迭代器" class="headerlink" title="17、手写迭代器"></a>17、手写迭代器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(it.next());</span><br><span class="line"><span class="built_in">console</span>.log(it.next());</span><br><span class="line"><span class="built_in">console</span>.log(it.next());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nextindex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (nextindex &lt; array.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: array[nextindex++], <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18、最大连续子序列"><a href="#18、最大连续子序列" class="headerlink" title="18、最大连续子序列"></a>18、最大连续子序列</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">-5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">-4</span>, <span class="number">15</span>, <span class="number">-8</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// function getNum(arr) &#123;</span></span><br><span class="line"><span class="comment">//     let length = arr.length</span></span><br><span class="line"><span class="comment">//     let maxmun=0</span></span><br><span class="line"><span class="comment">//     for (let i = 0; i &lt;length ; i++) &#123;</span></span><br><span class="line"><span class="comment">//         let sum=arr[i]</span></span><br><span class="line"><span class="comment">//         for (let j = i+1; j &lt; length; j++) &#123;</span></span><br><span class="line"><span class="comment">//             sum+=arr[j]</span></span><br><span class="line"><span class="comment">//             if(sum&gt;maxmun)&#123;</span></span><br><span class="line"><span class="comment">//                 maxmun = sum</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return maxmun</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += num;</span><br><span class="line">    max = <span class="built_in">Math</span>.max(max, sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getNum(arr));</span><br></pre></td></tr></table></figure>

<h3 id="19、实现一个-EventListener-类，包含-on，off，emit-方法"><a href="#19、实现一个-EventListener-类，包含-on，off，emit-方法" class="headerlink" title="19、实现一个 EventListener 类，包含 on，off，emit 方法"></a>19、实现一个 EventListener 类，包含 on，off，emit 方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现一个EventListener类，包含on，off，emit方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.list = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on(key, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.list[key]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.list[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.list[key].push(fn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit(key, ...args) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> <span class="built_in">this</span>.list[key]) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  off(key, fn) &#123;</span><br><span class="line">    <span class="keyword">let</span> fnlist = <span class="built_in">this</span>.list[key];</span><br><span class="line">    <span class="keyword">if</span> (!fnlist) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">      fnlist.length = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fnlist.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item === fn) &#123;</span><br><span class="line">          fnlist.splice(index, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> EventListener();</span><br><span class="line"></span><br><span class="line">obj1.on(<span class="string">&quot;work&quot;</span>, <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我是<span class="subst">$&#123;value&#125;</span>啊`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj1.on(<span class="string">&quot;eat&quot;</span>, <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我在<span class="subst">$&#123;value&#125;</span>啊`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj1.emit(<span class="string">&quot;work&quot;</span>, <span class="string">&quot;zc&quot;</span>);</span><br><span class="line"></span><br><span class="line">obj1.off(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line"></span><br><span class="line">obj1.emit(<span class="string">&quot;eat&quot;</span>, <span class="string">&quot;吃西瓜&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="20、sleep-函数"><a href="#20、sleep-函数" class="headerlink" title="20、sleep 函数"></a>20、sleep 函数</h3><blockquote>
<p>用 promise 写一个 delay 函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;11111&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="21、手写斐波那契"><a href="#21、手写斐波那契" class="headerlink" title="21、手写斐波那契"></a>21、手写斐波那契</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getnum</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> getnum(num - <span class="number">1</span>) + getnum(num - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getnum(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// ----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getnum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = [];</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    temp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    temp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt; n; i++) &#123;</span><br><span class="line">      temp[i] = temp[i - <span class="number">1</span>] + temp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22、只包含’-‘-‘-’-‘-‘-‘-’-‘-‘-‘-’-的字符串，判断是否有效。"><a href="#22、只包含’-‘-‘-’-‘-‘-‘-’-‘-‘-‘-’-的字符串，判断是否有效。" class="headerlink" title="22、只包含’(‘, ‘)’, ‘[‘, ‘]’, ‘{‘, ‘}’ 的字符串，判断是否有效。"></a>22、只包含’(‘, ‘)’, ‘[‘, ‘]’, ‘{‘, ‘}’ 的字符串，判断是否有效。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> rightSymbols = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">      rightSymbols.push(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&quot;&#123;&quot;</span>) &#123;</span><br><span class="line">      rightSymbols.push(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&quot;[&quot;</span>) &#123;</span><br><span class="line">      rightSymbols.push(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightSymbols.pop() != s[i]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !rightSymbols.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="23、数组中只出现一次的数字"><a href="#23、数组中只出现一次的数字" class="headerlink" title="23、数组中只出现一次的数字"></a>23、数组中只出现一次的数字</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> p = arr.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a ^ b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br></pre></td></tr></table></figure>

<h3 id="24、数组最大深度"><a href="#24、数组最大深度" class="headerlink" title="24、数组最大深度"></a>24、数组最大深度</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">1</span>, [<span class="number">3</span>], <span class="number">2</span>], <span class="number">2</span>, [<span class="number">1</span>], <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDep</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="literal">false</span>;</span><br><span class="line">  p = arr.some(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.length &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    getDep(arr.flat());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getDep(arr));</span><br></pre></td></tr></table></figure>

<h3 id="25、递归数组扁平化"><a href="#25、递归数组扁平化" class="headerlink" title="25、递归数组扁平化"></a>25、递归数组扁平化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, [<span class="number">1</span>], <span class="number">2</span>]];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ret = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.constructor === <span class="built_in">Array</span>) &#123;</span><br><span class="line">        ret.concat(flatten(item));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret.push(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(wrap()(arr));</span><br></pre></td></tr></table></figure>

<h3 id="26、模拟-js-精度丢失问题"><a href="#26、模拟-js-精度丢失问题" class="headerlink" title="26、模拟 js 精度丢失问题"></a>26、模拟 js 精度丢失问题</h3><blockquote>
<p>IEEE 754 标准</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> num1Digits = (num1.toString().split(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>] || <span class="string">&quot;&quot;</span>).length;</span><br><span class="line">  <span class="keyword">const</span> num2Digits = (num2.toString().split(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>] || <span class="string">&quot;&quot;</span>).length;</span><br><span class="line">  <span class="keyword">const</span> baseNum = <span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="built_in">Math</span>.max(num1Digits, num2Digits));</span><br><span class="line">  <span class="keyword">return</span> (num1 * baseNum + num2 * baseNum) / baseNum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">0.1</span>, <span class="number">0.2</span>));</span><br></pre></td></tr></table></figure>

<h3 id="27、单例模式"><a href="#27、单例模式" class="headerlink" title="27、单例模式"></a>27、单例模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单例模式不透明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">singleTon</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.instance = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">singleTon.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">singleTon.getInstance = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.instance) &#123;</span><br><span class="line">    <span class="built_in">this</span>.instance = <span class="keyword">new</span> singleTon(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = singleTon.getInstance(<span class="string">&quot;bbbbb&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> a = singleTon.getInstance(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例模式不透明（闭包）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">singleTon</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">singleTon.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">singleTon.getInstance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance || (instance = <span class="keyword">new</span> singleTon(name));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = singleTon.getInstance(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = singleTon.getInstance(<span class="string">&quot;bbbbb&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> c = singleTon.getInstance(<span class="string">&quot;cccccc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	单例模式透明</span></span><br><span class="line"><span class="keyword">let</span> getInstance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="keyword">return</span> (instance = <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> getInstance(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> getInstance(<span class="string">&quot;bbbb&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let getSingle = function (fn) &#123;</span></span><br><span class="line"><span class="comment">//     let result= null</span></span><br><span class="line"><span class="comment">//     return function () &#123;</span></span><br><span class="line"><span class="comment">//        return result || (result = fn.call(this,...arguments))</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用的单例验证方法</span></span><br><span class="line"><span class="keyword">const</span> getSingle = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result || (result = fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = getSingle(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = b(<span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;yyyyy&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> c = b(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(d);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure>

<h3 id="28、策略模式"><a href="#28、策略模式" class="headerlink" title="28、策略模式"></a>28、策略模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略类（开发人员）</span></span><br><span class="line"><span class="keyword">var</span> Strategies = &#123;</span><br><span class="line">  backend: <span class="function"><span class="keyword">function</span> (<span class="params">task</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;进行后端任务：&quot;</span>, task);</span><br><span class="line">  &#125;,</span><br><span class="line">  frontend: <span class="function"><span class="keyword">function</span> (<span class="params">task</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;进行前端任务：&quot;</span>, task);</span><br><span class="line">  &#125;,</span><br><span class="line">  testend: <span class="function"><span class="keyword">function</span> (<span class="params">task</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;进行测试任务：&quot;</span>, task);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  环境类（开发组长）</span></span><br><span class="line"><span class="keyword">var</span> Context = <span class="function"><span class="keyword">function</span> (<span class="params">type, task</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">typeof</span> Strategies[type] === <span class="string">&quot;function&quot;</span> &amp;&amp; Strategies[type](task);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="29、代理模式"><a href="#29、代理模式" class="headerlink" title="29、代理模式"></a>29、代理模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//【图片预加载 -- 代理模式】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义本体</span></span><br><span class="line"><span class="keyword">let</span> myImg = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  <span class="built_in">document</span>.body.append(img);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setsrc(src) &#123;</span><br><span class="line">      <span class="built_in">this</span>.src = src;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理函数</span></span><br><span class="line"><span class="keyword">let</span> Proxysetimg = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    myImg.setsrc(<span class="built_in">this</span>.src);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setsrc(src) &#123;</span><br><span class="line">      myImg.setsrc(<span class="string">&quot;./loading.gif&quot;</span>);</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">Proxysetimg(<span class="string">&quot;./111.png&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="30、观察者模式"><a href="#30、观察者模式" class="headerlink" title="30、观察者模式"></a>30、观察者模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.observers = []; <span class="comment">// 观察者列表</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加</span></span><br><span class="line">  add(observer) &#123;</span><br><span class="line">    <span class="built_in">this</span>.observers.push(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line">  remove(observer) &#123;</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="built_in">this</span>.observers.findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> item === observer);</span><br><span class="line">    idx &gt; <span class="number">-1</span> &amp;&amp; <span class="built_in">this</span>.observers.splice(idx, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> observer <span class="keyword">of</span> <span class="built_in">this</span>.observers) &#123;</span><br><span class="line">      observer.update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 目标对象更新时触发的回调</span></span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`目标者通知我更新了，我是：<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化目标者</span></span><br><span class="line"><span class="keyword">let</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化两个观察者</span></span><br><span class="line"><span class="keyword">let</span> obs1 = <span class="keyword">new</span> Observer(<span class="string">&quot;前端开发者&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> obs2 = <span class="keyword">new</span> Observer(<span class="string">&quot;后端开发者&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向目标者添加观察者</span></span><br><span class="line">subject.add(obs1);</span><br><span class="line">subject.add(obs2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标者通知更新</span></span><br><span class="line">subject.notify();</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 目标者通知我更新了，我是前端开发者</span></span><br><span class="line"><span class="comment">// 目标者通知我更新了，我是后端开发者</span></span><br></pre></td></tr></table></figure>

<h3 id="31、命令模式"><a href="#31、命令模式" class="headerlink" title="31、命令模式"></a>31、命令模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 接收者类</span></span><br><span class="line">  execute() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;接收者执行请求&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 命令对象类</span></span><br><span class="line">  <span class="keyword">constructor</span>(receiver) &#123;</span><br><span class="line">    <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">  &#125;</span><br><span class="line">  execute() &#123;</span><br><span class="line">    <span class="comment">// 调用接收者对应接口执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;命令对象-&gt;接收者-&gt;对应接口执行&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.receiver.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 发布者类</span></span><br><span class="line">  <span class="keyword">constructor</span>(command) &#123;</span><br><span class="line">    <span class="built_in">this</span>.command = command;</span><br><span class="line">  &#125;</span><br><span class="line">  invoke() &#123;</span><br><span class="line">    <span class="comment">// 发布请求，调用命令对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;发布者发布请求&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.command.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> warehouse = <span class="keyword">new</span> Receiver(); <span class="comment">// 仓库</span></span><br><span class="line"><span class="keyword">const</span> order = <span class="keyword">new</span> Command(warehouse); <span class="comment">// 订单</span></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> Invoker(order); <span class="comment">// 客户</span></span><br><span class="line">client.invoke();</span><br></pre></td></tr></table></figure>

<h3 id="32、Promise-处理文件读取"><a href="#32、Promise-处理文件读取" class="headerlink" title="32、Promise 处理文件读取"></a>32、Promise 处理文件读取</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readfile = <span class="function"><span class="keyword">function</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(path.join(__dirname, filename), <span class="string">&quot;utf-8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      error,</span></span></span><br><span class="line"><span class="function"><span class="params">      data</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">readfile(<span class="string">&quot;./01.txt&quot;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> readfile(<span class="string">&quot;./02.txt&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> readfile(<span class="string">&quot;./03.txt&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="33、-Generator-函数文件读取"><a href="#33、-Generator-函数文件读取" class="headerlink" title="33、 Generator 函数文件读取"></a>33、 Generator 函数文件读取</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readfile = <span class="function"><span class="keyword">function</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(path.join(__dirname, filename), <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> readfile(<span class="string">&quot;./01.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">yield</span> readfile(<span class="string">&quot;./02.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">yield</span> readfile(<span class="string">&quot;./03.txt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = gen();</span><br><span class="line"></span><br><span class="line">result</span><br><span class="line">  .next()</span><br><span class="line">  .value.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> result.next().value;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> result.next().value;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="34、async-函数文件读取"><a href="#34、async-函数文件读取" class="headerlink" title="34、async 函数文件读取"></a>34、async 函数文件读取</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readfile = <span class="function"><span class="keyword">function</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(path.join(__dirname, filename), <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> f1 = <span class="keyword">await</span> readfile(<span class="string">&quot;./01.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">await</span> readfile(<span class="string">&quot;./02.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> f3 = <span class="keyword">await</span> readfile(<span class="string">&quot;./03.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1);</span><br><span class="line">    <span class="built_in">console</span>.log(f2);</span><br><span class="line">    <span class="built_in">console</span>.log(f3);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">gen();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Offer</category>
        <category>字节跳动</category>
      </categories>
      <tags>
        <tag>面试全面总结</tag>
        <tag>promise</tag>
        <tag>手撕代码</tag>
      </tags>
  </entry>
  <entry>
    <title>API、数组、跨域、动画、事件</title>
    <url>/2020/03/23/getOfferAPI/</url>
    <content><![CDATA[<h4 id="面试专题总结：-API、数组、跨域、动画、事件"><a href="#面试专题总结：-API、数组、跨域、动画、事件" class="headerlink" title="面试专题总结： API、数组、跨域、动画、事件"></a>面试专题总结： API、数组、跨域、动画、事件</h4><blockquote>
<p>希望读者依此构建自己的知识树（思维导图）</p>
<p>偷懒一下：可参考我自己总结思维导图 : <a href="https://github.com/ZhChen7/Interview-mind-map">点这里</a></p>
<p>附带：高频面试题积累文档。 来自于（学长、牛客网等平台）</p>
<p>自己开发的博客地址：<a href="http://zxinc520.com/">zxinc520.com</a></p>
<p>github 地址: <a href="https://github.com/ZhChen7">点击</a></p>
</blockquote>
<blockquote>
<p>此篇 js - 【API、数组、跨域、动画、事件】 知识点： 全部弄懂了，面试很容易。</p>
</blockquote>
<h3 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h3><ul>
<li>改变原数组的 API<ol>
<li>push()</li>
<li>unshift()</li>
<li>pop()</li>
<li>shift()</li>
<li>reverse()</li>
<li>splice(index, count, value1, value2….)<ul>
<li>从索引位 index 处删除 count 个元素，插入 value1, value2 等元素，返回被删除的元素组成的新数组(改变原数组)</li>
</ul>
</li>
<li>sort()</li>
</ol>
</li>
<li>不改变原数组的 API<ol>
<li>join(value)<ul>
<li>将数组用 value 连接为字符串，返回被连接后的字符串(不改变原数组)</li>
<li>将数组用 value 连接为字符串，返回被连接后的字符串(不改变原数组)</li>
</ul>
</li>
<li>获取子数组，包含原数组索引 start 的值到索引 end 的值，不包含 end，返回获取的子数组(不改变原数组)</li>
<li>toString()<ul>
<li>将数组中的元素用逗号拼接成字符串，返回拼接后的字符串(不改变原数组)</li>
</ul>
</li>
<li>indexOf(value)<ul>
<li>从索引为 0 开始，检查数组中是否包含有 value，有则返回匹配到的第一个索引，没有则返回-1(不改变原数组)</li>
</ul>
</li>
<li>lastIndexOf(value)<ul>
<li>从最后的索引开始，检查数组找那个是否包含 value，有则返回匹配到的第一个索引，没有返回-1(不改变原数组)</li>
</ul>
</li>
<li>concat(value)<ul>
<li>将数组和(或)值连接成新数组，返回新数组(不改变原数组)</li>
</ul>
</li>
<li>forEach()<ul>
<li>对数组进行遍历循环，对数组中每一项运行给定函数，参数都是 function 类型，默认有传参，参数分别为：遍历数组内容、对应的数组索引、数组本身。没有返回值</li>
</ul>
</li>
<li>map()<ul>
<li>指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的新数组</li>
</ul>
</li>
<li>filter()<ul>
<li>“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组</li>
</ul>
</li>
<li>every()<ul>
<li>判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回 true</li>
</ul>
</li>
<li>some()<ul>
<li>判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回 true</li>
</ul>
</li>
<li>reduce()<ul>
<li>接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="2、类数组转变为数组的方法"><a href="#2、类数组转变为数组的方法" class="headerlink" title="2、类数组转变为数组的方法"></a>2、类数组转变为数组的方法</h3><ul>
<li>类数组的定义<ul>
<li>可以通过索引访问元素，并且拥有 length 属性</li>
<li>没有数组的其他方法，例如 push ， forEach ， indexOf 等。</li>
</ul>
</li>
<li>ES5<ul>
<li>Array.prototype.slice.call() 等同于 [].slice.call(arguments)</li>
</ul>
</li>
<li>ES6<ul>
<li>Array.from()</li>
<li>…扩展运算符</li>
<li>for of 直接遍历类数组（iterator 接口）</li>
</ul>
</li>
</ul>
<h3 id="3、稀疏数组和密集数组"><a href="#3、稀疏数组和密集数组" class="headerlink" title="3、稀疏数组和密集数组"></a>3、稀疏数组和密集数组</h3><ul>
<li>稀疏数组<ul>
<li>是什么<ul>
<li>具有不连续索引的数组，其 length 属性值大于元素的个数。</li>
</ul>
</li>
<li>造成稀疏数组的操作<ol>
<li>delete 操作符</li>
<li>构造函数</li>
<li>在数组字面量中省略值</li>
<li>指定数组索引大于数组长度</li>
<li>指定数组长度大于当前数组长度</li>
</ol>
</li>
<li>缺点<ul>
<li>操作的不统一</li>
</ul>
</li>
</ul>
</li>
<li>密集数组<ul>
<li>是什么<ul>
<li>具有连续索引的数组，其 length 属性值等于元素的个数。</li>
</ul>
</li>
<li>创建方式<ol>
<li>Array.apply(null, Array(3)) || Array.apply(null, {length: 3})</li>
<li>Array.from({length: 3})</li>
<li>[…Array(4)]</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="4、柯里化函数"><a href="#4、柯里化函数" class="headerlink" title="4、柯里化函数"></a>4、柯里化函数</h3><ul>
<li><p>定义</p>
<ul>
<li>柯里化, 即 Currying 的音译。 Currying 是编译原理层面实现多参函数的一个技术。</li>
</ul>
</li>
<li><p>手写柯里化函数</p>
<ul>
<li><p>ES5 写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> currying = <span class="function"><span class="keyword">function</span> (<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (args.length &lt; fn.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> currying(fn, ...args, ...arguments);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6 写法（箭头函数）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> currying = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span></span><br><span class="line">  args.length &lt; fn.length</span><br><span class="line">    ? <span class="function">(<span class="params">...argments</span>) =&gt;</span> currying(fn, ...args, ...argments)</span><br><span class="line">    : fn(...args);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="5、window-全局对象（BOM）"><a href="#5、window-全局对象（BOM）" class="headerlink" title="5、window 全局对象（BOM）"></a>5、window 全局对象（BOM）</h3><ol>
<li>navigator 导航器对象<ul>
<li>Navigator 对象包含有关浏览器的信息</li>
<li>appCodeName 返回浏览器的代码名</li>
<li>appName 返回浏览器的名称</li>
<li>appVersion 返回浏览器的平台和版本信息</li>
<li>cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值</li>
<li>platform 返回运行浏览器的操作系统平台</li>
<li>userAgent 返回由客户机发送服务器的 user-agent 头部的值</li>
</ul>
</li>
<li>screen 显示器对象</li>
<li>history 历史对象<ul>
<li>back() 返回前一个 URL</li>
<li>forward() 返回下一个 URL</li>
<li>go() 返回某个具体页面</li>
</ul>
</li>
<li>location 位置对象<ul>
<li>属性<ul>
<li>hash 设置或返回从井号 (#) 开始的 URL（锚）。</li>
<li>host 设置或返回主机名和当前 URL 的端口号。</li>
<li>hostname 设置或返回当前 URL 的主机名</li>
<li>href 设置或返回完整的 URL</li>
<li>pathname 设置或返回当前 URL 的路径部分。</li>
<li>port 设置或返回当前 URL 的端口号。</li>
<li>protocol 设置或返回当前 URL 的协议。</li>
<li>search 设置或返回从问号 (?) 开始的 URL（查询部分）。</li>
</ul>
</li>
<li>方法<ul>
<li>assign(URL) 加载新的文档</li>
<li>reload() 重新加载当前页面</li>
<li>replace(newURL) 用新的文档替换当前文档</li>
</ul>
</li>
</ul>
</li>
<li>document 文档对象【DOM】</li>
</ol>
<h3 id="6、ajax-和-fetch"><a href="#6、ajax-和-fetch" class="headerlink" title="6、ajax 和 fetch"></a>6、ajax 和 fetch</h3><h4 id="6-1、Ajax"><a href="#6-1、Ajax" class="headerlink" title="6.1、Ajax"></a>6.1、Ajax</h4><ul>
<li><p>本质</p>
<ul>
<li>是在 HTTP 协议的基础上以异步的方式与服务器进行通信.</li>
</ul>
</li>
<li><p>封装原生 Ajax 请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxGet</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">  xhr.send();</span><br><span class="line"></span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">      callback(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-2、fetch"><a href="#6-2、fetch" class="headerlink" title="6.2、fetch"></a>6.2、fetch</h4><ul>
<li><p>fetch 是什么</p>
<ul>
<li>Fetch 是浏览器提供的原生 AJAX 接口。</li>
</ul>
</li>
<li><p>Fetch 为何出现？</p>
<ul>
<li>由于原来的 XMLHttpRequest 不符合关注分离原则，且基于事件的模型在处理异步上已经没有现代的 Promise 等那么有优势。因此 Fetch 出现来解决这种问题。</li>
</ul>
</li>
<li><p>Fetch API</p>
<ul>
<li><p>Fetch API 提供了能够用于操作一部分 HTTP 的 JavaScript 接口，比如 requests 和 responses。它同时也提供了一个全局的 fetch() 方法——能够简单的异步的获取资源。</p>
<p>使用 window.fetch 函数可以代替以前的 $. ajax、$.get 和 $.post。</p>
</li>
</ul>
</li>
<li><p>用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&quot;http://example.com/movies.json&quot;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> response.json();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">myJson</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myJson);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-3、readyState（状态值）"><a href="#6-3、readyState（状态值）" class="headerlink" title="6.3、readyState（状态值）"></a>6.3、readyState（状态值）</h4><ul>
<li>readyState 是什么<ul>
<li>readyState 是 XMLHttpRequest 对象的一个属性，用来标识当前 XMLHttpRequest 对象处于什么状态</li>
</ul>
</li>
<li>5 个状态值<ul>
<li>0: 请求未初始化</li>
<li>1: 载入，XMLHttpRequest 对象开始发送请求</li>
<li>2: 载入完成，XMLHttpRequest 对象的请求发送完成</li>
<li>3: 解析，XMLHttpRequest 对象开始读取服务器的响应</li>
<li>4: 完成，XMLHttpRequest 对象读取服务器响应结束</li>
</ul>
</li>
</ul>
<h4 id="6-4、status（状态码"><a href="#6-4、status（状态码" class="headerlink" title="6.4、status（状态码"></a>6.4、status（状态码</h4><ul>
<li><p>status 是什么</p>
<ul>
<li>status 是 XMLHttpRequest 对象的一个属性，表示响应的 http 状态码</li>
</ul>
</li>
<li><p>在 http1.1 协议下，http 状态码总共可分为 5 大类</p>
<ul>
<li><p>1xx：信息响应类，表示接收到请求并且继续处理</p>
</li>
<li><p>2xx：处理成功响应类，表示动作被成功接收、理解和接受</p>
</li>
<li><p>3xx：重定向响应类，为了完成指定的动作，必须接受进一步处理</p>
</li>
<li><p>4xx：客户端错误，客户请求包含语法错误或者是不能正确执行</p>
</li>
<li><p>5xx：服务端错误，服务器不能正确执行一个正确的请求</p>
</li>
<li><p>一些常见的状态码为</p>
<p>200 OK：成功，很棒。</p>
<p>301 永久移动：已永久移动到新位置。</p>
<p>302（临时移动）：暂时移到新位置。</p>
<p>304 未修改：东西跟之前长一样，可以从快取拿就好。</p>
<p>400 错误的请求：明显的用户端错误，伺服器无法处理这个请求。</p>
<p>401 未经授权：未认证，可能需要登录或 Token。</p>
<p>403 Forbidden：没有权限。</p>
<p>404 未找到：找不到资源。</p>
<p>500 内部服务器错误：伺服器端错误。</p>
<p>502 错误的网关：通常是伺服器的某个服务没有正确执行。</p>
<p>503 服务不可用：伺服器临时维护或快挂了，暂时无法处理请求。</p>
<p>504 网关超时：伺服器上的服务没有回应。</p>
</li>
</ul>
</li>
</ul>
<h3 id="7、Web-端即时通讯技术"><a href="#7、Web-端即时通讯技术" class="headerlink" title="7、Web 端即时通讯技术"></a>7、Web 端即时通讯技术</h3><ul>
<li><p>Web 端即时通讯技术是什么</p>
<p>即时通讯技术简单的说就是实现这样一种功能：服务器端可以即时地将数据的更新或变化反应到客户端，例如消息即时推送等功能都是通过这种技术实现的。但是在 Web 中，由于浏览器的限制，实现即时通讯需要借助一些方法。这种限制出现的主要原因是，一般的 Web 通信都是浏览器先发送请求到服务器，服务器再进行响应完成数据的现实更新。</p>
</li>
<li><p>大体可以分为两类</p>
<ol>
<li>一种是在 HTTP 基础上实现的<ul>
<li>短轮询、comet 和 SSE</li>
</ul>
</li>
<li>不是在 HTTP 基础上实现<ul>
<li>WebSocket</li>
</ul>
</li>
</ol>
</li>
<li><p>如何模拟双向通信（四种方式）</p>
<ul>
<li>短轮询<ul>
<li>客户端定时向服务器发送 Ajax 请求，服务器接到请求后马上返回响应信息并关闭连接。</li>
<li>优点 ： 后端编写容易</li>
<li>缺点 ： 请求中大半是无用，浪费宽带和服务器资源</li>
<li>适用 ： 小型应用</li>
</ul>
</li>
<li>长轮询<ul>
<li>客户端向服务器发送 Ajax 请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。</li>
<li>优点 ：在无消息的情况下不会频繁的请求，耗费资源小</li>
<li>缺点<ul>
<li>服务器 hold 连接会消耗资源</li>
<li>返回数据顺序无保证，难于管理维护</li>
</ul>
</li>
</ul>
</li>
<li>长连接<ul>
<li>在页面嵌入一个隐藏 iframe，将这个隐藏 iframe 的 src 属性设为对一个长连接的请求或是采用 xhr 请求，服务器端就能源源不断的往客户端输入数据</li>
<li>优点<ul>
<li>消息及时到达，不发无用请求</li>
<li>管理起来也相对方便</li>
</ul>
</li>
<li>缺点：服务器维护一个长连接会增加开销</li>
</ul>
</li>
<li>WebSocket<ul>
<li>WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议可以实现服务器与客户端之间全双工通信。简单来说，首先需要在客户端和服务器端建立起一个连接，这部分需要 http。连接一旦建立，客户端和服务器端就处于平等的地位，可以相互发送数据，不存在请求和响应的区别。</li>
<li>优点：实现了双向通信</li>
<li>缺点：服务器端的逻辑非常复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="四种-Web-即时通信技术比较"><a href="#四种-Web-即时通信技术比较" class="headerlink" title="四种 Web 即时通信技术比较"></a>四种 Web 即时通信技术比较</h4><ul>
<li>从兼容性角度考虑，短轮询&gt;长轮询&gt;长连接 SSE&gt;WebSocket；</li>
<li>从性能方面考虑，WebSocket&gt;长连接 SSE&gt;长轮询&gt;短轮询。</li>
</ul>
<h3 id="8、跨域"><a href="#8、跨域" class="headerlink" title="8、跨域"></a>8、跨域</h3><ul>
<li>跨域是什么<ul>
<li>跨域是指从一个域名的网页去请求另一个域名的资源。</li>
<li>跨域的严格一点的定义是：只要 协议，域名，端口有任何一个的不同，就被当作是跨域</li>
</ul>
</li>
</ul>
<h4 id="6-种解决方案"><a href="#6-种解决方案" class="headerlink" title="6 种解决方案"></a>6 种解决方案</h4><ol>
<li><p>跨域资源共享（CORS）</p>
<ul>
<li><p>定义</p>
<ul>
<li>定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。</li>
</ul>
</li>
<li><p>基本思想</p>
<ul>
<li>CORS 背后的基本思想就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败</li>
</ul>
</li>
<li><p>两种请求</p>
<ul>
<li>简单请求<ul>
<li>就是在头信息之中，增加一个 Origin 字段。</li>
</ul>
</li>
<li>非简单请求<ul>
<li>会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求（preflight）</li>
</ul>
</li>
</ul>
</li>
<li><p>服务端</p>
<ul>
<li><p>服务器端对于 CORS 的支持，主要就是通过设置 Access-Control-Allow-Origin 来进行的。如果浏览器检测到相应的设置，就可以允许 Ajax 进行跨域的访问</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定允许其他域名访问</span></span><br><span class="line"><span class="string">&quot;Access-Control-Allow-Origin:*&quot;</span>; <span class="comment">//或指定域</span></span><br><span class="line"><span class="comment">//响应类型</span></span><br><span class="line"><span class="string">&quot;Access-Control-Allow-Methods:GET,POST&quot;</span>;</span><br><span class="line"><span class="comment">//响应头设置</span></span><br><span class="line"><span class="string">&quot;Access-Control-Allow-Headers:x-requested-with,content-type&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>jsonp</p>
<ul>
<li><p>jsonp 是什么</p>
<ul>
<li>JSONP(JSON with Padding 填充式 json)是 JSON 的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。</li>
</ul>
</li>
<li><p>两部分组成</p>
<ul>
<li>回调函数<ul>
<li>回调函数是当响应到来时应该在页面中调用的函数</li>
</ul>
</li>
<li>数据<ul>
<li>而数据就是传入回调函数中的 JSON 数据。</li>
</ul>
</li>
</ul>
</li>
<li><p>原理</p>
<p>通过 script 标签引入一个 js 文件，这个 js 文件载入成功后会执行我们在 url 参数中指定的函数，并且会把我们需要的 json 数据作为参数传入。所以 jsonp 是需要服务器端的页面进行相应的配合的。（即用 javascript 动态加载一个 script 文件，同时定义一个 callback 函数给 script 执行而已。）</p>
</li>
<li><p>模拟</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dosomething</span>(<span class="params">jsondata</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//处理获得的json数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;http://example.com/data.php?callback=dosomething&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缺点</p>
<ul>
<li>我们都知道 JSONP 可以实现解决 GET 请求的跨域问题,但是不能解决 POST 请求的跨域问题.</li>
</ul>
</li>
</ul>
</li>
<li><p>document.domain</p>
<ul>
<li><p>方法</p>
<ul>
<li>通过修改 document.domain 来跨子域</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>域必须相我们只能把 document.domain 设置成自身或更高一级的父域，且主同。</li>
</ul>
</li>
<li><p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;iframe id = <span class="string">&quot;iframe&quot;</span> src=<span class="string">&quot;http://example.com/b.html&quot;</span> onload = <span class="string">&quot;test()&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="built_in">document</span>.domain = <span class="string">&#x27;example.com&#x27;</span>;<span class="comment">//设置成主域</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用域</p>
<ul>
<li>修改 document.domain 的方法只适用于不同子域的框架间的交互。</li>
</ul>
</li>
</ul>
</li>
<li><p>window.name</p>
<ul>
<li>window.name 是什么<ul>
<li>是一个可读可写的属性，有个很有意思的跨页面特性</li>
</ul>
</li>
<li>方法<ul>
<li>页面如果设置了 window.name，即使进行了页面跳转到了其他页面，这个 window.name 还是会保留。</li>
</ul>
</li>
</ul>
</li>
<li><p>postMessage</p>
<ul>
<li><p>定义</p>
<p>postMessage 是 html5 引入的 API,postMessage()方法允许来自不同源的脚本采用异步方式进行有效的通信,可以实现跨文本文档,多窗口,跨域消息传递.多用于窗口间数据通信,这也使它成为跨域通信的一种有效的解决方案.</p>
</li>
<li><p>方法使用</p>
<ul>
<li><p>发送数据</p>
<ul>
<li>otherWindow.postMessage(message, targetOrigin, [transfer]);</li>
<li>otherWindow 【窗口的一个引用,比如 iframe 的 contentWindow 属性】</li>
</ul>
</li>
<li><p>接收数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;message&quot;</span>, receiveMessage, <span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> origin = event.origin;</span><br><span class="line">  <span class="built_in">console</span>.log(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>postMessage 的使用场景</p>
<ol>
<li>跨域通信(包括 GET 请求和 POST 请求)</li>
<li>WebWorker<ul>
<li>Web Worker 的使用场景<ul>
<li>用于收集埋点数据,可以用于大量复杂的数据计算,复杂的图像处理,大数据的处理.因为它不会阻碍主线程的正常执行和页面 UI 的渲染.</li>
</ul>
</li>
</ul>
</li>
<li>Service Worker<ul>
<li>离线存储的一个最佳的解决方案</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="WebWorker-和-Service-Worker-的关系"><a href="#WebWorker-和-Service-Worker-的关系" class="headerlink" title="WebWorker 和 Service Worker 的关系"></a>WebWorker 和 Service Worker 的关系</h5><ul>
<li>相同点<ul>
<li>相同点是在常规的 js 引擎线程以外开辟了新的 js 线程去处理一些不适合在主线程上处理的业务</li>
</ul>
</li>
<li>不同点<ul>
<li>Web Worker 式服务于特定页面的,而 Service Worker 在被注册安装之后能够在多个页面使用</li>
<li>Service Worker 常驻在浏览器中,不会因为页面的关闭而被销毁.本质上,它是一个后台线程,只有你主动终结,或者浏览器回收,这个线程才会结束.</li>
<li>生命周期,可调用的 API 也不同</li>
</ul>
</li>
</ul>
<ol start="6">
<li><p>代理服务器</p>
<ul>
<li><p>定义</p>
<p>代理，也称正向代理，是指一个位于客户端和目标服务器(target server)之间的服务器，为了从目标服务器取得内容，客户端向代理发送一个请求并指定目标(目标服务器)，然后代理向目标服务器转交请求并将获得的内容返回给客户端。</p>
</li>
<li><p>代理服务器，需要做以下几个步骤</p>
<ol>
<li>接受客户端 请求 。</li>
<li>将 请求 转发给服务器</li>
<li>拿到服务器 响应 数据</li>
<li>将 响应 转发给客户端</li>
</ol>
</li>
</ul>
</li>
</ol>
<h5 id="CORS-和-JSONP-对比"><a href="#CORS-和-JSONP-对比" class="headerlink" title="CORS 和 JSONP 对比"></a>CORS 和 JSONP 对比</h5><ul>
<li>CORS 与 JSONP 相比，无疑更为先进、方便和可靠。</li>
<li>区别<ol>
<li>JSONP 只能实现 GET 请求，而 CORS 支持所有类型的 HTTP 请求。</li>
<li>使用 CORS，开发者可以使用普通的 XMLHttpRequest 发起请求和获得数据，比起 JSONP 有更好的错误处理。</li>
<li>JSONP 主要被老的浏览器支持，它们往往不支持 CORS，而绝大多数现代浏览器都已经支持了 CORS）。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="9、动画"><a href="#9、动画" class="headerlink" title="9、动画"></a>9、动画</h3><blockquote>
<p>requestanimationframe 的出现替代 setTimeout 完成动画。</p>
</blockquote>
<ul>
<li>setTimeout<ul>
<li>setTimeout 其实就是通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的。但利用 seTimeout 实现的动画在某些低端机上会出现卡顿、抖动的现象。导致 setTimeout 的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。</li>
<li>原因<ol>
<li>setTimeout 的执行时间并不是确定的。setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此 setTimeout 的实际执行时间一般要比其设定的时间晚一些。</li>
<li>刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout 只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。</li>
</ol>
</li>
</ul>
</li>
<li>requestanimationframe<ul>
<li>html5 为了满足高性能动画的需求而提供的 API，表意是请求动画帧。</li>
</ul>
</li>
</ul>
<h4 id="requestanimationframe-相比-setTimeout"><a href="#requestanimationframe-相比-setTimeout" class="headerlink" title="requestanimationframe 相比 setTimeout"></a>requestanimationframe 相比 setTimeout</h4><ul>
<li>优势<ol>
<li>与 setTimeout 相比，requestAnimationFrame 最大的优势是由系统来决定回调函数的执行时机。</li>
<li>它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</li>
</ol>
</li>
</ul>
<h3 id="10、事件"><a href="#10、事件" class="headerlink" title="10、事件"></a>10、事件</h3><ul>
<li><p>事件流</p>
<p>事件流描述的是从页面中接收事件的顺序，IE 和 Netscape 提出来差不多完全相反的事件流的概念，IE 事件流是事件冒泡流，Netscape 事件流是事件捕获流。</p>
</li>
<li><p>DOM 事件级别</p>
<ul>
<li><p>DOM0 事件</p>
<ul>
<li><p>定义</p>
<p>通过文档对象（document）获取元素引用，使用 DOM0 级方法指定的事件处理程序被认为是元素的方法，处理程序是在元素的作用域进行的，程序中 this 是引用的是当前元素。</p>
</li>
<li><p>3 个特点</p>
<ol>
<li><p>触发时机：DOM0 级的事件处理程式只能在事件冒泡阶段触发。</p>
</li>
<li><p>每个属性只能绑定一个事件</p>
</li>
<li><p>this 指针的指向</p>
<p>用 DOM0 级的方式绑定事件是在元素对象的作用域内运行，因此在事件函数内的 this 属性不是引用全局对象，而是引用当前元素对象</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>DOM2 事件</p>
<ul>
<li><p>定义</p>
<p>’DOM2 级事件’定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和 removeEventListener();所有的 DOM 节点都包含这两种方法。</p>
</li>
<li><p>DOM2 级事件规定的事件流包括三个阶段</p>
<ul>
<li>事件捕获阶段</li>
<li>处于目标阶段</li>
<li>事件冒泡阶段</li>
</ul>
</li>
<li><p>优点</p>
<p>可以添加多个事件处理程序</p>
</li>
</ul>
</li>
<li><p>DOM3 级</p>
<ul>
<li><p>DOM3 级事件就是在 DOM2 基础上增加了更多的事件类型</p>
</li>
<li><p>UI 事件，当用户与页面上的元素交互时触发，如：load、scroll</p>
<p>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</p>
<p>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup</p>
<p>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</p>
<p>文本事件，当在文档中输入文本时触发，如：textInput</p>
<p>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</p>
<p>合成事件，当为 IME（输入法编辑器）输入字符时触发，如：compositionstart</p>
<p>变动事件，当底层 DOM 结构发生变化时触发，如：DOMsubtreeModified</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>机制</p>
<ol>
<li><p>冒泡机制</p>
<p>事件会从最内层的元素开始发生，一直向上传播，直到 document 对象。</p>
</li>
<li><p>捕获机制</p>
<p>网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。</p>
</li>
</ol>
</li>
<li><p>事件代理</p>
<ul>
<li><p>定义</p>
<p>JavaScript 高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>
</li>
<li><p>关键</p>
<p>Event 对象提供了一个属性叫 target，可以返回事件的目标节点，我们成为事件源</p>
</li>
<li><p>适合用事件委托的事件</p>
<p>click，mousedown，mouseup，keydown，keyup，keypress</p>
</li>
<li><p>不合适</p>
<p>mousemove，每次都要计算它的位置，非常不好把控，在不如说 focus，blur 之类的，本身就没用冒泡的特性，自然就不能用事件委托了</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Offer</category>
        <category>字节跳动</category>
      </categories>
      <tags>
        <tag>面试全面总结</tag>
        <tag>数组</tag>
        <tag>API</tag>
        <tag>跨域</tag>
        <tag>动画</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 知识点</title>
    <url>/2020/03/23/getOfferES6/</url>
    <content><![CDATA[<h2 id="面试专题总结：ES6-知识点"><a href="#面试专题总结：ES6-知识点" class="headerlink" title="面试专题总结：ES6 知识点"></a>面试专题总结：ES6 知识点</h2><blockquote>
<p>希望读者依此构建自己的知识树（思维导图）</p>
<p>偷懒一下：可参考我自己总结思维导图 : <a href="https://github.com/ZhChen7/Interview-mind-map">点这里</a></p>
<p>附带：高频面试题积累文档。 来自于（学长、牛客网等平台）</p>
<p>自己开发的博客地址：<a href="http://zxinc520.com/">zxinc520.com</a></p>
<p>github 地址: <a href="https://github.com/ZhChen7">点击</a></p>
</blockquote>
<blockquote>
<p>此篇 js - 【ES6 知识总结】 知识点： 全部弄懂了，面试很容易。</p>
</blockquote>
<blockquote>
<p>详细可参考： <a href="https://es6.ruanyifeng.com/">ECMAScript 6 入门</a></p>
</blockquote>
<h3 id="1、es6-是什么"><a href="#1、es6-是什么" class="headerlink" title="1、es6 是什么"></a>1、es6 是什么</h3><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。 ECMA 是标准，Javascript 是 ECMA 的实现。因为 js 也是一种语言，但凡语言都有一套标准，而 ECMA 就是 javascript 的标准。在 2015 年正式发布了 ECMAscript6.0，简称 ES6，又称为 ECMAscript2015。</p>
<h3 id="2、var、let、const（声明方式）"><a href="#2、var、let、const（声明方式）" class="headerlink" title="2、var、let、const（声明方式）"></a>2、var、let、const（声明方式）</h3><ul>
<li>类别<ol>
<li>变量提升</li>
<li>暂时性死区</li>
<li>重复声明</li>
<li>块作用域有效</li>
<li>初始值</li>
<li>重新赋值</li>
</ol>
</li>
<li>区别<ol>
<li>let/const 定义的变量不会出现变量提升，而 var 定义的变量会提升。</li>
<li>相同作用域中，let 和 const 不允许重复声明，var 允许重复声明。</li>
<li>const 声明变量时必须设置初始值</li>
<li>const 声明一个只读的常量，这个常量不可改变</li>
<li>let/const 声明的变量仅在块级作用域中有效。而 var 声明的变量在块级作用域外仍能访问到。</li>
<li>顶层作用域中 var 声明的变量挂在 window 上(浏览器环境)</li>
<li>let/const 有暂时性死区的问题，即 let/const 声明的变量，在定义之前都是不可用的。如果使用会抛出错误。</li>
</ol>
</li>
</ul>
<h3 id="3、-变量的解构赋值"><a href="#3、-变量的解构赋值" class="headerlink" title="3、 变量的解构赋值"></a>3、 变量的解构赋值</h3><ul>
<li><p>数组解构赋值</p>
<p>let [aa, bb, cc] = [0, 1, 2];</p>
</li>
<li><p>对象解构赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; cnName, enName &#125; = &#123;</span><br><span class="line">  id: <span class="string">&quot;151521574&quot;</span>,</span><br><span class="line">  cnName: <span class="string">&quot;张生&quot;</span>,</span><br><span class="line">  enName: <span class="string">&quot;Ronnie&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(cnName, enName); <span class="comment">//&#x27;张生&#x27;，&#x27;Ronnie&#x27;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4、箭头函数"><a href="#4、箭头函数" class="headerlink" title="4、箭头函数"></a>4、箭头函数</h3><blockquote>
<p>es6 之前的函数的 this 指向调用函数时所在的对象，而箭头函数的 this 指向函数定义时所在的对象</p>
</blockquote>
<h4 id="箭头函数及其-this-问题"><a href="#箭头函数及其-this-问题" class="headerlink" title="箭头函数及其 this 问题"></a>箭头函数及其 this 问题</h4><ol>
<li>this 对象的指向是可变的，但是在箭头函数中，它是固定的。</li>
<li>this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this。正是因为它没有 this，所以也就不能用作构造函数。</li>
<li>箭头函数里面根本没有自己的 this，而是引用外层的 this。</li>
<li>由于箭头函数没有自己的 this，所以当然也就不能用 call()、apply()、bind()这些方法去改变 this 的指向</li>
</ol>
<h3 id="5、Symbol"><a href="#5、Symbol" class="headerlink" title="5、Symbol"></a>5、Symbol</h3><ul>
<li><p>是什么？</p>
<p>symbols 是一种无法被重建的基本类型。这时 symbols 有点类似与对象创建的实例互相不相等的情况，但同时 symbols 又是一种无法被改变的基本类型数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>作用</p>
<ol>
<li>symbols 作为对象的属性</li>
<li>阻止对象属性名冲突 （扩展对象属性很有用）</li>
<li>模拟私有属性</li>
</ol>
</li>
</ul>
<h3 id="6、Module-模块"><a href="#6、Module-模块" class="headerlink" title="6、Module 模块"></a>6、Module 模块</h3><blockquote>
<p>可从 IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module、&lt;_script type=”module”_ &gt; 这几个角度考虑。</p>
<p><strong>作用</strong> ：模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。</p>
</blockquote>
<h4 id="模块化发展历程"><a href="#模块化发展历程" class="headerlink" title="模块化发展历程"></a>模块化发展历程</h4><ol>
<li><p>IIFE</p>
<ul>
<li><p>使用自执行函数来编写模块化</p>
</li>
<li><p>特点：</p>
<p>在一个单独的函数作用域中执行代码，避免变量冲突。</p>
</li>
</ul>
</li>
<li><p>AMD</p>
<ul>
<li><p>使用 requireJS 来编写模块化</p>
</li>
<li><p>特点：依赖必须提前声明好</p>
</li>
<li><p>简单实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="string">&quot;./index.js&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// code 就是index.js 返回的内容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>CMD</p>
<ul>
<li><p>使用 seaJS 来编写模块化</p>
</li>
<li><p>特点：支持动态引入依赖文件</p>
</li>
<li><p>简单实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> indexCode = <span class="built_in">require</span>(<span class="string">&quot;./index.js&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>CommonJS</p>
<ul>
<li>nodejs 中自带的模块化</li>
<li>var fs = require(‘fs’);</li>
</ul>
</li>
<li><p>UMD</p>
<ul>
<li>兼容 AMD，CommonJS 模块化语法</li>
</ul>
</li>
<li><p>webpack(require.ensure)</p>
<ul>
<li>webpack 2.x 版本中的代码分割</li>
</ul>
</li>
<li><p>ES Modules</p>
<ul>
<li>ES6 引入的模块化，支持 import 来引入另一个 js</li>
<li>import a from ‘a’;</li>
</ul>
</li>
</ol>
<h4 id="6-1、AMD-与-CMD-的比较"><a href="#6-1、AMD-与-CMD-的比较" class="headerlink" title="6.1、AMD 与 CMD 的比较"></a>6.1、AMD 与 CMD 的比较</h4><ul>
<li><p>定义</p>
<p>AMD 和 CMD 都是用于浏览器端的模块规范</p>
</li>
<li><p>AMD</p>
<ul>
<li>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出</li>
<li>其主要内容就是定义了 define 函数该如何书写，只要你按照这个规范书写模块和依赖，require.js 就能正确的进行解析。</li>
</ul>
</li>
<li><p>CMD</p>
<ul>
<li>CMD 其实就是 SeaJS 在推广过程中对模块定义的规范化产出</li>
<li>主要内容就是描述该如何定义模块，如何引入模块，如何导出模块，只要你按照这个规范书写代码，sea.js 就能正确的进行解析</li>
</ul>
</li>
<li><p>AMD 与 CMD 的区别</p>
<ol>
<li>AMD 推崇依赖前置，CMD 推崇依赖就近</li>
<li>AMD 是提前执行，CMD 是延迟执行。</li>
</ol>
</li>
</ul>
<h4 id="6-2、CommonJS-与-AMD-的比较"><a href="#6-2、CommonJS-与-AMD-的比较" class="headerlink" title="6.2、CommonJS 与 AMD 的比较"></a>6.2、CommonJS 与 AMD 的比较</h4><blockquote>
<p>在服务器端比如 node，采用的则是 CommonJS 规范。</p>
<p>AMD 和 CMD 都是用于浏览器端的模块规范</p>
</blockquote>
<ol>
<li><p>CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。</p>
</li>
<li><p>AMD 规范则是非同步加载模块，允许指定回调函数。</p>
<p>由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。</p>
</li>
<li><p>但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。</p>
</li>
</ol>
<h4 id="6-3、ES6-与-CommonJS-的比较"><a href="#6-3、ES6-与-CommonJS-的比较" class="headerlink" title="6.3、ES6 与 CommonJS 的比较"></a>6.3、ES6 与 CommonJS 的比较</h4><blockquote>
<p>注意！浏览器加载 ES6 模块，也使用 &lt;_script_ &gt; 标签，但是要加入 type=”module” 属性。</p>
</blockquote>
<ol>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</li>
</ol>
<h3 id="7、异步编程-6-种解决方案"><a href="#7、异步编程-6-种解决方案" class="headerlink" title="7、异步编程 6 种解决方案"></a>7、异步编程 6 种解决方案</h3><ol>
<li><p>回调函数（Callback）</p>
<ul>
<li><p>回调函数是异步操作最基本的方法</p>
</li>
<li><p>ajax(url, () =&gt; {</p>
<p>​ // 处理逻辑</p>
<p>})</p>
</li>
<li><p>缺点</p>
<ul>
<li>容易写出回调地狱（Callback hell）</li>
<li>不能使用 try catch 捕获错误，不能直接 return</li>
</ul>
</li>
</ul>
</li>
<li><p>事件监听</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1.on(<span class="string">&quot;done&quot;</span>, f2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布订阅</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery.subscribe(<span class="string">&quot;done&quot;</span>, f2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise</p>
<ul>
<li><p>是什么？</p>
<ul>
<li>promise 是目前 JS 异步编程的主流解决方案，遵循 Promises/A+ 方案。Promise 用于异步操作，表示一个还未完成但是预期会完成的操作。</li>
<li>Promise 是 ES6 引入的一个新的对象，他的主要作用是用来解决 JS 异步机制里，回调机制产生的“回调地狱”。它并不是什么突破性的 API，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用。</li>
</ul>
</li>
<li><p>剖析</p>
<ul>
<li><p>promise 本身相当于一个状态机，拥有三种状态</p>
<ul>
<li>pending</li>
<li>fulfilled</li>
<li>rejected</li>
</ul>
<p>一个 promise 对象初始化时的状态是 pending，调用了 resolve 后会将 promise 的状态扭转为 fulfilled，调用 reject 后会将 promise 的状态扭转为 rejected，这两种扭转一旦发生便不能再扭转该 promise 到其他状态。</p>
</li>
</ul>
</li>
<li><p>Promise 如何使用</p>
<p>构造一个 promise 对象，并将要执行的异步函数传入到 promise 的参数中执行，并且在异步执行结束后调用 resolve( ) 函数，就可以在 promise 的 then 方法中获取到异步函数的执行结果</p>
</li>
<li><p>Promise 原型上的方法</p>
<ol>
<li>Promise.prototype.then(onFulfilled, onRejected)</li>
<li>Promise.prototype.catch(onRejected)</li>
<li>Promise.prototype.finally(onFinally)</li>
</ol>
</li>
<li><p>Promise 静态方法</p>
<ol>
<li><p>Promise.all()</p>
<p>Promise.all 接收一个 promise 对象数组作为参数，只有全部的 promise 都已经变为 fulfilled 状态后才会继续后面的处理</p>
</li>
<li><p>Promise.race()</p>
<p>这个函数会在 promises 中第一个 promise 的状态扭转后就开始后面的处理（fulfilled、rejected 均可）</p>
</li>
<li><p>Promise.resolve()</p>
</li>
<li><p>Promise.reject()</p>
</li>
</ol>
</li>
<li><p>优点</p>
<p>将异步操作以同步操作的流程表达出来，promise 链式调用，更好地解决了层层嵌套的回调地狱</p>
</li>
<li><p>缺点</p>
<ol>
<li>不能取消执行。</li>
<li>无法获取当前执行的进度信息（比如，要在用户界面展示进度条）。</li>
<li>外部无法捕捉 Promise 内部抛出的错误</li>
</ol>
</li>
</ul>
</li>
<li><p>generator 函数</p>
<ul>
<li><p>是什么</p>
<ul>
<li>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</li>
<li>如果说 JavaScript 是 ECMAScript 标准的一种具体实现、Iterator 遍历器是 Iterator 的具体实现，那么 Generator 函数可以说是 Iterator 接口的具体实现方式。</li>
<li>Generator 函数可以通过配合 Thunk 函数更轻松更优雅的实现异步编程和控制流管理</li>
</ul>
</li>
<li><p>描述</p>
<ul>
<li>执行 Generator 函数会返回一个遍历器对象，每一次 Generator 函数里面的 yield 都相当一次遍历器对象的 next()方法，并且可以通过 next(value)方法传入自定义的 value,来改变 Generator 函数的行为。</li>
</ul>
</li>
<li><p>能封装异步任务的根本原因</p>
<ul>
<li>最大特点就是可以交出函数的执行权（即暂停执行）。Generator 函数可以暂停执行和恢复执行</li>
</ul>
</li>
<li><p>两个特征</p>
<ul>
<li>function 关键字与函数名之间有一个星号</li>
<li>函数体内部使用 yield 表达式，定义不同的内部状态（yield 在英语里的意思就是“产出”）。</li>
</ul>
</li>
<li><p>过程</p>
<p>Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）</p>
</li>
<li><p>Generator 及其异步方面的应用</p>
<ul>
<li>Generator 函数将 JavaScript 异步编程带入了一个全新的阶段</li>
</ul>
</li>
<li><p>总结</p>
<p>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值；done 属性是一个布尔值，表示是否遍历结束。</p>
</li>
<li><p>demo</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&quot;node-fetch&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">&quot;https://api.github.com/users/github&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>async 和 await</p>
<ul>
<li><p>含义</p>
<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>
</li>
<li><p>是什么？</p>
<ul>
<li>一句话，它就是 Generator 函数的语法糖。</li>
<li>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。</li>
<li>async 函数可以理解为内置自动执行器的 Generator 函数语法糖，它配合 ES6 的 Promise 近乎完美的实现了异步编程解决方案。</li>
</ul>
</li>
<li><p>相对于 Promise，优势体现在</p>
<ol>
<li>处理 then 的调用链，能够更清晰准确的写出代码</li>
<li>并且也能优雅地解决回调地狱问题</li>
</ol>
</li>
<li><p>相对 Generator 函数，体现在以下 4 点</p>
<ol>
<li>内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行</li>
<li>更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果</li>
<li>更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）</li>
<li>返回值是 Promise。async 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用 then 方法指定下一步的操作。</li>
</ol>
</li>
<li><p>缺点</p>
<p>当然 async/await 函数也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise.all 的方式。</p>
</li>
</ul>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>JS 异步编程进化史：callback -&gt; promise -&gt; generator -&gt; async + await</li>
<li>async/await 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里</li>
<li>async/await 可以说是异步终极解决方案了</li>
</ol>
<h3 id="8、Class"><a href="#8、Class" class="headerlink" title="8、Class"></a>8、Class</h3><blockquote>
<p>ES6 的 class 可以看作只是一个 ES5 生成实例对象的构造函数的语法糖。它参考了 java 语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。Class 类可以通过 extends 实现继承。</p>
</blockquote>
<ul>
<li><p>语法</p>
<ul>
<li>super 关键字的使用</li>
<li>static 关键字</li>
</ul>
</li>
<li><p>ES5/ES6 的继承除了写法以外还有什么区别？</p>
<ol>
<li>class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。</li>
<li>class 声明内部会启用严格模式</li>
<li>class 的所有方法（包括静态方法和实例方法）都是不可枚举的</li>
<li>class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用</li>
<li>必须使用 new 调用 class</li>
<li>class 内部无法重写类名</li>
</ol>
<p>ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this</p>
</li>
<li><p>优点</p>
<p>但是某些时候，我们使用 es6 的类可以让我们的代码的可读性更高</p>
</li>
</ul>
<h3 id="9、Set-和-Map"><a href="#9、Set-和-Map" class="headerlink" title="9、Set 和 Map"></a>9、Set 和 Map</h3><ul>
<li>Set<ul>
<li>是什么<ul>
<li>Set 是一种叫做集合的数据结构</li>
<li>Set 是 ES6 引入的一种类似 Array 的新的数据结构，Set 实例的成员类似于数组 item 成员，区别是 Set 实例的成员都是唯一，不重复的。这个特性可以轻松地实现数组去重。</li>
</ul>
</li>
<li>应用场景<ul>
<li>数组去重</li>
</ul>
</li>
<li>特点<ol>
<li>成员唯一、无序且不重复</li>
<li>[value, value]，键值与键名是一致的（或者说只有键值，没有键名）</li>
<li>可以遍历，方法有：add、delete、has</li>
</ol>
</li>
</ul>
</li>
<li>WeakSet<ul>
<li>特点<ol>
<li>成员都是对象</li>
<li>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏</li>
<li>不能遍历，方法有 add、delete、has</li>
</ol>
</li>
</ul>
</li>
<li>Map<ul>
<li>是什么<ul>
<li>Map 是一种叫做字典的数据结构</li>
<li>Map 是 ES6 引入的一种类似 Object 的新的数据结构，Map 可以理解为是 Object 的超集，打破了以传统键值对形式定义对象，对象的 key 不再局限于字符串，也可以是 Object。可以更加全面的描述对象的属性。</li>
</ul>
</li>
<li>应用场景<ul>
<li>数据存储</li>
</ul>
</li>
<li>特点<ul>
<li>本质上是键值对的集合，类似集合</li>
<li>可以遍历，方法很多可以跟各种数据格式转换</li>
</ul>
</li>
</ul>
</li>
<li>WeakMap<ul>
<li>特点<ul>
<li>只接受对象作为键名（null 除外），不接受其他类型的值作为键名</li>
<li>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的</li>
<li>不能遍历，方法有 get、set、has、delete</li>
</ul>
</li>
</ul>
</li>
<li>Set 和 Map<ul>
<li>Set 和 Map 主要的应用场景在于数组去重和数据存储</li>
<li>原来 Set 是一种叫做集合的数据结构，Map 是一种叫做字典的数据结构</li>
</ul>
</li>
<li>Set 与 WeakSet 区别<ol>
<li>WeakSet 只能存放对象</li>
<li>WeakSet 不支持遍历, 没有 size 属性</li>
<li>WeakSet 存放的对象不会计入到对象的引用技术, 因此不会影响 GC 的回收</li>
<li>WeakSet 存在的对象如果在外界消失了, 那么在 WeakSet 里面也会不存在</li>
</ol>
</li>
<li>Map 与 WeakMap 区别<ol>
<li>WeakMap 只能接受对象作为键名字(null 除外)</li>
<li>WeakMap 键名指向对象不会计入对象的引用数</li>
</ol>
</li>
</ul>
<h3 id="10、ES6-对-String-字符串类型做的常用升级优化"><a href="#10、ES6-对-String-字符串类型做的常用升级优化" class="headerlink" title="10、ES6 对 String 字符串类型做的常用升级优化"></a>10、ES6 对 String 字符串类型做的常用升级优化</h3><ul>
<li>优化部分<ul>
<li>ES6 新增了字符串模板，在拼接大段字符串时，用反斜杠(`)取代以往的字符串相加的形式，能保留所有空格和换行，使得字符串拼接看起来更加直观，更加优雅。</li>
</ul>
</li>
<li>升级部分<ul>
<li>ES6 在 String 原型上新增了 includes()方法，用于取代传统的只能用 indexOf 查找包含字符的方法(indexOf 返回-1 表示没查到不如 includes 方法返回 false 更明确，语义更清晰), 此外还新增了 startsWith(), endsWith(), padStart(),padEnd(),repeat()等方法，可方便的用于查找，补全字符串。</li>
</ul>
</li>
</ul>
<h3 id="11、ES6-对-Number-数字类型做的常用升级优化"><a href="#11、ES6-对-Number-数字类型做的常用升级优化" class="headerlink" title="11、ES6 对 Number 数字类型做的常用升级优化?"></a>11、ES6 对 Number 数字类型做的常用升级优化?</h3><ul>
<li>优化部分<ul>
<li>ES6 在 Number 原型上新增了 isFinite(), isNaN()方法，用来取代传统的全局 isFinite(), isNaN()方法检测数值是否有限、是否是 NaN。ES5 的 isFinite(), isNaN()方法都会先将非数值类型的参数转化为 Number 类型再做判断，这其实是不合理的，最造成 isNaN(‘NaN’) === true 的奇怪行为–’NaN’是一个字符串，但是 isNaN 却说这就是 NaN。而 Number.isFinite()和 Number.isNaN()则不会有此类问题(Number.isNaN(‘NaN’) === false)。</li>
</ul>
</li>
<li>升级部分<ul>
<li>ES6 在 Math 对象上新增了 Math.cbrt()，trunc()，hypot()等等较多的科学计数法运算方法，可以更加全面的进行立方根、求和立方根等等科学计算。</li>
</ul>
</li>
</ul>
<h3 id="12、ES6-对-Array-数组类型做的常用升级优化"><a href="#12、ES6-对-Array-数组类型做的常用升级优化" class="headerlink" title="12、ES6 对 Array 数组类型做的常用升级优化"></a>12、ES6 对 Array 数组类型做的常用升级优化</h3><ul>
<li>优化部分<ul>
<li>数组解构赋值。ES6 可以直接以 let [a,b,c] = [1,2,3]形式进行变量赋值，在声明较多变量时，不用再写很多 let(var),且映射关系清晰，且支持赋默认值</li>
<li>扩展运算符。ES6 新增的扩展运算符(…)(重要),可以轻松的实现数组和松散序列的相互转化，可以取代 arguments 对象和 apply 方法，轻松获取未知参数个数情况下的参数集合。（尤其是在 ES5 中，arguments 并不是一个真正的数组，而是一个类数组的对象，但是扩展运算符的逆运算却可以返回一个真正的数组）。扩展运算符还可以轻松方便的实现数组的复制和解构赋值（let a = [2,3,4]; let b = […a]）</li>
</ul>
</li>
<li>升级部分<ul>
<li>ES6 在 Array 原型上新增了 find()方法，用于取代传统的只能用 indexOf 查找包含数组项目的方法,且修复了 indexOf 查找不到 NaN 的 bug([NaN].indexOf(NaN) === -1).此外还新增了 copyWithin(), includes(), fill(),flat()等方法，可方便的用于字符串的查找，补全,转换等</li>
</ul>
</li>
</ul>
<h3 id="13、ES6-对-Object-类型做的常用升级优化"><a href="#13、ES6-对-Object-类型做的常用升级优化" class="headerlink" title="13、ES6 对 Object 类型做的常用升级优化"></a>13、ES6 对 Object 类型做的常用升级优化</h3><ul>
<li><p>优化部分</p>
<ol>
<li>对象属性变量式声明。ES6 可以直接以变量形式声明对象属性或者方法，。比传统的键值对形式声明更加简洁，更加方便，语义更加清晰。</li>
<li>对象的解构赋值</li>
<li>对象的扩展运算符(…)</li>
<li>super 关键字。ES6 在 Class 类里新增了类似 this 的关键字 super。同 this 总是指向当前函数所在的对象不同，super 关键字总是指向当前函数所在对象的原型对象。</li>
</ol>
</li>
<li><p>升级部分</p>
<ol>
<li><p>ES6 在 Object 原型上新增了 is()方法，做两个目标对象的相等比较，用来完善’===’方法。’===’方法中 NaN === NaN //false 其实是不合理的，Object.is 修复了这个小 bug。(Object.is(NaN, NaN) // true)</p>
</li>
<li><p>ES6 在 Object 原型上新增了 assign()方法，用于对象新增属性或者多个对象合并。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target; <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6 在 Object 原型上新增了 getOwnPropertyDescriptors()方法，此方法增强了 ES5 中 getOwnPropertyDescriptor()方法，可以获取指定对象所有自身属性的描述对象。结合 defineProperties()方法，可以完美复制对象，包括复制 get 和 set 属性。</p>
</li>
<li><p>ES6 在 Object 原型上新增了 getPrototypeOf()和 setPrototypeOf()方法，用来获取或设置当前对象的 prototype 对象。获取或设置当前对象的 prototype 对象时，都应该采用 ES6 新增的标准用法。</p>
</li>
<li><p>ES6 在 Object 原型上还新增了 Object.keys()，Object.values()，Object.entries()方法，用来获取对象的所有键、所有值和所有键值对数组。</p>
</li>
</ol>
</li>
</ul>
<h3 id="14、ES6-对-Function-函数类型做的常用升级优化"><a href="#14、ES6-对-Function-函数类型做的常用升级优化" class="headerlink" title="14、ES6 对 Function 函数类型做的常用升级优化"></a>14、ES6 对 Function 函数类型做的常用升级优化</h3><ul>
<li><p>优化部分</p>
<ul>
<li>箭头函数(核心)。箭头函数里没有自己的 this,这改变了以往 JS 函数中最让人难以理解的 this 运行机制<ol>
<li>箭头函数内的 this 指向的是函数定义时所在的对象，而不是函数执行时所在的对象。</li>
<li>箭头函数不能用作构造函数，因为它没有自己的 this，无法实例化。</li>
<li>也是因为箭头函数没有自己的 this,所以箭头函数 内也不存在 arguments 对象。（可以用扩展运算符代替）</li>
</ol>
</li>
</ul>
</li>
<li><p>升级部分</p>
<ul>
<li><p>ES6 新增了双冒号运算符，用来取代以往的 bind，call,和 apply(浏览器暂不支持，Babel 已经支持转码)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo::bar;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.bind(foo);</span><br><span class="line"></span><br><span class="line">foo::bar(...arguments);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.apply(foo, <span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="15、Proxy"><a href="#15、Proxy" class="headerlink" title="15、Proxy"></a>15、Proxy</h3><p>Proxy 是 ES6 新增的一个构造函数，这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<h3 id="16、Reflect"><a href="#16、Reflect" class="headerlink" title="16、Reflect"></a>16、Reflect</h3><ul>
<li>是什么<ul>
<li>Reflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API</li>
</ul>
</li>
<li>作用<ol>
<li>一是将原生的一些零散分布在 Object、Function 或者全局函数里的方法(如 apply、delete、get、set 等等)，统一整合到 Reflect 上，这样可以更加方便更加统一的管理一些原生 API。</li>
<li>其次就是因为 Proxy 可以改写默认的原生 API，如果一旦原生 API 别改写可能就找不到了，所以 Reflect 也可以起到备份原生 API 的作用，使得即使原生 API 被改写了之后，也可以在被改写之后的 API 用上默认的 API。</li>
</ol>
</li>
</ul>
<h3 id="17、Iterator"><a href="#17、Iterator" class="headerlink" title="17、Iterator"></a>17、Iterator</h3><ul>
<li>是什么<ul>
<li>一种设计标准，来统一所有可遍历类型的遍历方式。Iterator 正是这样一种标准。或者说是一种规范理念</li>
</ul>
</li>
<li>解决的问题<ul>
<li>Set、Map 都不能用 for 循环遍历，解决这个问题有两种方案，一种是为 Set、Map 单独新增一个用来遍历的 API，另一种是为 Set、Map、Array、Object 新增一个统一的遍历 API，显然，第二种更好，ES6 也就顺其自然的需要一种设计标准，来统一所有可遍历类型的遍历方式。</li>
</ul>
</li>
<li>Iterator 标准的具体实现<ul>
<li>Iterator 标准的具体实现是 Iterator 遍历器。Iterator 标准规定，所有部署了 key 值为[Symbol.iterator]，且[Symbol.iterator]的 value 是标准的 Iterator 接口函数(标准的 Iterator 接口函数: 该函数必须返回一个对象，且对象中包含 next 方法，且执行 next()能返回包含 value/done 属性的 Iterator 对象)的对象，都称之为可遍历对象，next()后返回的 Iterator 对象也就是 Iterator 遍历器。</li>
</ul>
</li>
</ul>
<h3 id="18、for…in-和-for…of-有什么区别"><a href="#18、for…in-和-for…of-有什么区别" class="headerlink" title="18、for…in 和 for…of 有什么区别"></a>18、for…in 和 for…of 有什么区别</h3><ul>
<li><p>ES6 规定，有所部署了载了 Iterator 接口的对象(可遍历对象)都可以通过 for…of 去遍历，而 for..in 仅仅可以遍历对象。</p>
</li>
<li><p>使用 for…of 的好处</p>
<ul>
<li><p>这也就意味着，数组也可以用 for…of 遍历，这极大地方便了数组的取值，且避免了很多程序用 for..in 去遍历数组的恶习。</p>
<p>上面提到的扩展运算符本质上也就是 for..of 循环的一种实现。</p>
</li>
</ul>
</li>
</ul>
<h3 id="19、module、export、import"><a href="#19、module、export、import" class="headerlink" title="19、module、export、import"></a>19、module、export、import</h3><ul>
<li>module、export、import 是 ES6 用来统一前端模块化方案的设计思路和实现方案</li>
<li>作用<ul>
<li>export、import 的出现统一了前端模块化的实现方案，整合规范了浏览器/服务端的模块化方法，用来取代传统的 AMD/CMD、requireJS、seaJS、commondJS 等等一系列前端模块不同的实现方案，使前端模块化更加统一规范，JS 也能更加能实现大型的应用程序开发。</li>
</ul>
</li>
<li>注意<ul>
<li>import 引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）</li>
<li>import 引入 export 导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的值</li>
</ul>
</li>
</ul>
<h3 id="20、-Iterator-和-for…of（Iterator-遍历器的实现）"><a href="#20、-Iterator-和-for…of（Iterator-遍历器的实现）" class="headerlink" title="20、 Iterator 和 for…of（Iterator 遍历器的实现）"></a>20、 Iterator 和 for…of（Iterator 遍历器的实现）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义迭代器</span></span><br><span class="line"><span class="keyword">let</span> a = makeiterator([<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeiterator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextindex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextindex &lt; arr.length</span><br><span class="line">        ? &#123; <span class="attr">value</span>: arr[nextindex++], <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">        : &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Symbol.iterator遍历器接口</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iter.next(); <span class="comment">// &#123; value: &#x27;a&#x27;, done: false &#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123; value: &#x27;b&#x27;, done: false &#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123; value: &#x27;c&#x27;, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="21、循环语法比较及使用场景（for、forEach、for…in、for…of）"><a href="#21、循环语法比较及使用场景（for、forEach、for…in、for…of）" class="headerlink" title="21、循环语法比较及使用场景（for、forEach、for…in、for…of）"></a>21、循环语法比较及使用场景（for、forEach、for…in、for…of）</h3><p>for 循环的速度是最快的,是最老的循环,也是优化得最好的,其次是 for-of 这个是 es6 才新增的循环非常好用,最慢是 for-in 我们可以作一下速度排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &gt; <span class="keyword">for</span>-<span class="keyword">of</span> &gt; forEach &gt; filter &gt; map &gt; <span class="keyword">for</span>-<span class="keyword">in</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
        <category>ES6 语法</category>
        <category>Offer</category>
        <category>字节跳动</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>面试全面总结</tag>
      </tags>
  </entry>
  <entry>
    <title>变量类型和计算</title>
    <url>/2020/03/23/getOfferVariabletypesandcalculations/</url>
    <content><![CDATA[<h2 id="JavaScript-变量类型和计算"><a href="#JavaScript-变量类型和计算" class="headerlink" title="JavaScript 变量类型和计算"></a>JavaScript 变量类型和计算</h2><blockquote>
<p>拿到 字节跳动实习生 offer 总结</p>
<p>回馈分享一波自己的知识点总结</p>
</blockquote>
<blockquote>
<p>希望读者依此构建自己的知识树（思维导图）</p>
<p>偷懒一下：可参考我自己总结思维导图 : <a href="https://github.com/ZhChen7/Interview-mind-map">点这里</a></p>
<p>附带：高频面试题积累文档。 来自于（学长、牛客网等平台）</p>
<p>自己开发的博客地址：<a href="http://zxinc520.com/">zxinc520.com</a></p>
<p>github 地址: <a href="https://github.com/ZhChen7">点击</a></p>
</blockquote>
<blockquote>
<p>此篇 js - 【变量类型和计算】 知识点： 全部弄懂了，面试很容易。</p>
</blockquote>
<h2 id="一、变量类型"><a href="#一、变量类型" class="headerlink" title="一、变量类型"></a>一、变量类型</h2><h3 id="1-1、类型"><a href="#1-1、类型" class="headerlink" title="1.1、类型"></a>1.1、类型</h3><ul>
<li>值类型（基本数据类型）<ul>
<li>string,number,boolean,undefined,null,symbol 6 种</li>
</ul>
</li>
<li>引用类型<ul>
<li>Object、Array、Funtion。细分的话：有 Object、Array、Funtion、Date、RegExp 等</li>
</ul>
</li>
</ul>
<h3 id="1-2、值类型（基本数据类型）和引用类型区别"><a href="#1-2、值类型（基本数据类型）和引用类型区别" class="headerlink" title="1.2、值类型（基本数据类型）和引用类型区别"></a>1.2、值类型（基本数据类型）和引用类型区别</h3><ol>
<li>内存的分配不同<ul>
<li>基本数据类型存储在栈中。</li>
<li>复杂数据类型存储在堆中，栈中存储的变量，是指向堆中的引用地址</li>
</ul>
</li>
</ol>
<blockquote>
<p>栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值和局部变量的值等。堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收，分配方式倒是类似于链表。其实在堆中一般存放变量是一些对象类型</p>
</blockquote>
<ol start="2">
<li>访问机制不同：值类型按值访问，引用类型按引用访问</li>
<li>复变量时不同(a=b)<ul>
<li>基本数据类型：a=b;是将 b 中保存的原始值的副本赋值给新变量 a，a 和 b 完全独立，互不影响</li>
<li>复杂数据类型：a=b;将 b 保存的对象内存的引用地址赋值给了新变量 a;a 和 b 指向了同一个堆内存地址，其中一个值发生了改变，另一个也会改变。</li>
</ul>
</li>
<li>参数传递的不同(实参/形参)<ul>
<li>函数传参都是按值传递(栈中的存储的内容)：基本数据类型，拷贝的是值；复杂数据类型，拷贝的是引用地址</li>
</ul>
</li>
</ol>
<h3 id="1-3、JavaScript-判断数据类型"><a href="#1-3、JavaScript-判断数据类型" class="headerlink" title="1.3、JavaScript 判断数据类型"></a>1.3、JavaScript 判断数据类型</h3><ol>
<li><p>typeof</p>
<ul>
<li>typeof 运算符 只能 区分 值类型 的 类型，对于引用类型的 对象、数组 区分不出来</li>
<li>注意：typeof null===“object” typeof new Function(); // function 有效</li>
</ul>
</li>
<li><p>instanceof</p>
<ul>
<li>instanceof 运算符返回一个布尔值，表示对象是否为某个构造函数的实例</li>
<li>缺点：instanceof 运算符只能用于对象（纯对象和数组），不适用原始类型（Undefined、Null、Boolean、Number 和 String）的值。</li>
</ul>
</li>
<li><p>Object.prototype.toString.call()</p>
<ul>
<li>可以通过 Object.prototype.toString 方法准确判断某个对象值属于哪种内置类型。</li>
</ul>
</li>
<li><p>constructor</p>
<ul>
<li><p>constructor 属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。</p>
</li>
<li><pre><code class="js">var f = new F();
f.constructor === F; // true
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 二、变量计算（强制类型转换）</span><br><span class="line"></span><br><span class="line">### 2.1、显示强制类型转换</span><br><span class="line"></span><br><span class="line">1. 字符串和数字之间的显示转换</span><br><span class="line"></span><br><span class="line">   - String()</span><br><span class="line"></span><br><span class="line">   - Number()</span><br><span class="line"></span><br><span class="line">   - 日期显示转换为数字(+)</span><br><span class="line"></span><br><span class="line">     - 一元运算符 + 的另一个常见用途是将日期(Date)对象强制类型转换为数字，返回结果为 Unix 时间戳。</span><br><span class="line"></span><br><span class="line">     - &#96;&#96;&#96;js</span><br><span class="line">       var time &#x3D; new Date() + time;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>奇特的~运算符</p>
<ul>
<li>~x 大致等同于 -(x+1)</li>
<li><del>和 indexOf()一起可以将结果强制类型转换为真/假值，如果 indexOf()返回-1，</del>将其转换为假值 0，其他情况一律转换为真值。</li>
</ul>
</li>
<li><p>~~字位截除</p>
</li>
<li><p>显式解析数字字符串</p>
<ul>
<li>Number()</li>
<li>parseInt()</li>
<li>parseFloat()</li>
</ul>
</li>
</ul>
</li>
<li><p>显式转换为布尔值</p>
<ul>
<li>Boolean()</li>
<li>(!!)显式强制类型转换为布尔值最常用地方法是!!</li>
</ul>
</li>
<li><p>抽象值操作</p>
<ul>
<li>ToString</li>
<li>ToNumber</li>
<li>ToBoolean</li>
</ul>
</li>
</ol>
<h3 id="2-2、隐式强制类型转换"><a href="#2-2、隐式强制类型转换" class="headerlink" title="2.2、隐式强制类型转换"></a>2.2、隐式强制类型转换</h3><ol>
<li><p>转成字符串的</p>
<ul>
<li><p>字符串拼接</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">a + b; <span class="comment">//&quot;1,23,4&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>因为数组的 valueOf()操作无法得到简单基本类型值，于是调用 toString()，因此两个数组变成了”1,2”和”3,4”，+将它们拼接后返回。</p>
</li>
</ul>
</li>
<li><p>隐式强制类型转换为布尔值</p>
<ul>
<li>if()语句中的条件判断表达式</li>
<li>for(..; ..; ..)语句中的条件判断表达式</li>
<li>while()和 do .. while()</li>
<li>? : 中的条件判断表达式</li>
<li>逻辑运算符||和&amp;&amp;左边的操作数</li>
</ul>
</li>
<li><p>布尔值到数字</p>
</li>
<li><p>||和&amp;&amp;(选择器运算符)</p>
<ul>
<li>ES5 规范中说到：&amp;&amp;和||运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值。<ul>
<li>对于||来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</li>
<li>对于&amp;&amp;来说，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-3、-和-宽松相等和严格相等"><a href="#2-3、-和-宽松相等和严格相等" class="headerlink" title="2.3、== 和 ===(宽松相等和严格相等)"></a>2.3、== 和 ===(宽松相等和严格相等)</h3><blockquote>
<p>区别：==允许在相等比较中进行强制类型转换，而===不允许。</p>
</blockquote>
<h4 id="2-3-1、经典问题【-if-a-1-amp-amp-a-2-amp-amp-a-3-】"><a href="#2-3-1、经典问题【-if-a-1-amp-amp-a-2-amp-amp-a-3-】" class="headerlink" title="2.3.1、经典问题【 if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 】"></a>2.3.1、经典问题【 if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 】</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="comment">//... 使之成立</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思考方向-—-【利用隐式转换规则】"><a href="#思考方向-—-【利用隐式转换规则】" class="headerlink" title="思考方向 — 【利用隐式转换规则】"></a>思考方向 — 【<strong>利用隐式转换规则</strong>】</h4><p><code>==</code> 操作符在左右数据类型不一致时，会先进行隐式转换。</p>
<p><code>a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</code> 的值意味着其不可能是基本数据类型。因为如果 a 是 null 或者是 undefined bool 类型，都不可能返回 true。</p>
<p>因此可以推测 a 是复杂数据类型，JS 中复杂数据类型只有 <code>object</code>，回忆一下，Object 转换为原始类型会调用什么方法？</p>
<ul>
<li>如果部署了 <code>[Symbol.toPrimitive]</code> 接口，那么调用此接口，若返回的不是基本数据类型，抛出错误。</li>
<li>如果没有部署[Symbol.toPrimitive]接口，那么根据要转换的类型，先调用 valueOf/toString<ol>
<li>非 Date 类型对象，<code>hint</code> 是 <code>default</code> 时，调用顺序为：<code>valueOf</code> &gt;&gt;&gt; <code>toString</code>，即<code>valueOf</code> 返回的不是基本数据类型，才会继续调用 <code>toString</code>，如果<code>toString</code> 返回的还不是基本数据类型，那么抛出错误。</li>
<li>如果 <code>hint</code> 是 <code>string</code>(Date 对象的 hint 默认是 string) ，调用顺序为：<code>toString</code> &gt;&gt;&gt; <code>valueOf</code>，即<code>toString</code> 返回的不是基本数据类型，才会继续调用 <code>valueOf</code>，如果<code>valueOf</code> 返回的还不是基本数据类型，那么抛出错误。</li>
<li>如果 <code>hint</code> 是 <code>number</code>，调用顺序为： <code>valueOf</code> &gt;&gt;&gt; <code>toString</code></li>
</ol>
</li>
</ul>
<h3 id="7-种解决方案"><a href="#7-种解决方案" class="headerlink" title="7 种解决方案"></a>7 种解决方案</h3><ol>
<li><p>利用 [Symbol.toPrimitive] 接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]: (<span class="function"><span class="keyword">function</span> (<span class="params">hint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 valueOf 接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  valueOf: (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 正则</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  reg: <span class="regexp">/\d/g</span>,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.reg.exec(<span class="number">123</span>)[<span class="number">0</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用数据劫持</p>
<ul>
<li><p>使用 Object.defineProperty 定义的属性，在获取属性时，会调用 get 方法。利用这个特性，我们在 window 对象上定义 a 属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i++;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>利用 ES6 Proxy</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    i: <span class="number">1</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">this</span>.i++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重写数组的 join</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.join = a.shift;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 with 关键字</p>
</li>
</ol>
<blockquote>
<p>注意：0 == ‘\n’ //true</p>
</blockquote>
<h2 id="三、相关典型问题"><a href="#三、相关典型问题" class="headerlink" title="三、相关典型问题"></a>三、相关典型问题</h2><ul>
<li>JS 中使用 typeof 能得到的哪些类型</li>
<li>何时使用 === 何时使用 ==<ul>
<li>除了判断 <strong>对象属性是否为空</strong> 和 <strong>看是否函数的参数为空</strong> 的情况 ，其余的都用 === 。</li>
</ul>
</li>
<li>JS 中有哪些 内置函数</li>
<li>JS 变量按照 存储方式 分为哪些类型，并描述其特点</li>
<li>如何理解 JSON</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
        <category>Offer</category>
        <category>字节跳动</category>
        <category>变量类型和计算</category>
      </categories>
      <tags>
        <tag>面试全面总结</tag>
      </tags>
  </entry>
  <entry>
    <title>this 指向问题</title>
    <url>/2020/03/23/getOfferthis/</url>
    <content><![CDATA[<h2 id="专题总结：this-指向问题"><a href="#专题总结：this-指向问题" class="headerlink" title="专题总结：this 指向问题"></a>专题总结：this 指向问题</h2><blockquote>
<p>拿到 字节跳动实习生 offer 总结</p>
<p>回馈分享一波自己的知识点总结</p>
</blockquote>
<blockquote>
<p>希望读者依此构建自己的知识树（思维导图）</p>
<p>偷懒一下：可参考我自己总结思维导图 : <a href="https://github.com/ZhChen7/Interview-mind-map">点这里</a></p>
<p>附带：高频面试题积累文档。 来自于（学长、牛客网等平台）</p>
<p>自己开发的博客地址：<a href="http://zxinc520.com/">zxinc520.com</a></p>
<p>github 地址: <a href="https://github.com/ZhChen7">点击</a></p>
</blockquote>
<blockquote>
<p>此篇 js - 【this 指向问题】 知识点： 全部弄懂了，面试很容易。</p>
</blockquote>
<h2 id="一、this-的四条绑定规则"><a href="#一、this-的四条绑定规则" class="headerlink" title="一、this 的四条绑定规则"></a>一、this 的四条绑定规则</h2><ol>
<li><p>默认绑定</p>
<ul>
<li>独立函数调用时，this 指向全局对象（window），如果使用严格模式，那么全局对象无法使用默认绑定， this 绑定至 undefined。</li>
</ul>
</li>
<li><p>隐式绑定</p>
<ul>
<li><p>函数 this 是指向调用者 （隐式指向）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>obj1.obj2.foo(); // foo 中的 this 与 obj2 绑定</li>
</ul>
</li>
<li><p>问题：隐式丢失</p>
<ul>
<li>描述：隐式丢失指的是函数中的 this 丢失绑定对象，即它会应用第 1 条的默认绑定规则，从而将 this 绑定到全局对象或者 undefined 上，取决于是否在严格模式下运行。</li>
<li>以下情况会发生隐式丢失<ol>
<li>绑定至上下文对象的函数被赋值给一个新的函数，然后调用这个新的函数时</li>
<li>传入回调函数时</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>显式绑定</p>
<ul>
<li>显式绑定的核心是 JavaScript 内置的 call(..) 和 apply(..) 方法，call 和 apply bind 的 this 第一个参数 （显示指向）</li>
</ul>
</li>
<li><p>new 绑定</p>
<ul>
<li>构造函数的 this 是 new 之后的新对象 （构造器）</li>
</ul>
</li>
</ol>
<h2 id="二、call-bind-apply"><a href="#二、call-bind-apply" class="headerlink" title="二、call bind apply"></a>二、call bind apply</h2><blockquote>
<p>改变函数执行时的上下文（改变函数运行时的 this 指向）</p>
</blockquote>
<h3 id="2-1、apply"><a href="#2-1、apply" class="headerlink" title="2.1、apply"></a>2.1、apply</h3><ul>
<li><p>第二个参数为数组</p>
</li>
<li><p>自定义实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义apply函数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply1 = <span class="function"><span class="keyword">function</span> (<span class="params">obj, arg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//context为null或者是undefined时,设置默认值</span></span><br><span class="line">  <span class="keyword">if</span> (!obj) &#123;</span><br><span class="line">    obj = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">&quot;undefined&quot;</span> ? <span class="built_in">global</span> : <span class="built_in">window</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//undefined 或者 是 null 不是 Iterator 对象，不能被 ...</span></span><br><span class="line">  <span class="keyword">if</span> (arg === <span class="literal">undefined</span> || arg === <span class="literal">null</span>) &#123;</span><br><span class="line">    result = obj.fn(arg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = obj.fn(...arg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> obj.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-2、call"><a href="#2-2、call" class="headerlink" title="2.2、call"></a>2.2、call</h3><ul>
<li><p>第二个参数为参数列表</p>
</li>
<li><p>自定义实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call1 = <span class="function"><span class="keyword">function</span> (<span class="params">obj, ...arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj) &#123;</span><br><span class="line">    obj = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">&quot;undefined&quot;</span> ? <span class="built_in">global</span> : <span class="built_in">window</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  result = obj.fn(...arg);</span><br><span class="line">  <span class="keyword">delete</span> obj.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-3、bind"><a href="#2-3、bind" class="headerlink" title="2.3、bind"></a>2.3、bind</h3><ul>
<li><p>特点</p>
<ul>
<li>返回一个函数</li>
<li>可以传入参数（使用 bind 时和 bind 新生成的函数都可以传参）</li>
<li>当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效</li>
</ul>
</li>
<li><p>注意：bind 这个方法在 IE6~8 下不兼容</p>
</li>
<li><p>自定义实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind1 = <span class="function"><span class="keyword">function</span> (<span class="params">obj, ...arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj) &#123;</span><br><span class="line">    obj = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">&quot;undefined&quot;</span> ? <span class="built_in">global</span> : <span class="built_in">window</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = arg;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  f.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">  <span class="keyword">let</span> bound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [...args, ...arguments];</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="built_in">this</span> <span class="keyword">instanceof</span> f ? <span class="built_in">this</span> : obj;</span><br><span class="line">    <span class="keyword">return</span> self.apply(_this, res);</span><br><span class="line">  &#125;;</span><br><span class="line">  bound.prototype = <span class="keyword">new</span> f();</span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-4、区别"><a href="#2-4、区别" class="headerlink" title="2.4、区别"></a>2.4、区别</h3><blockquote>
<p>call 和 apply 改变了函数的 this 上下文后便执行该函数,而 bind 则是返回改变了上下文后的一个函数。</p>
</blockquote>
<h2 id="三、相关题目"><a href="#三、相关题目" class="headerlink" title="三、相关题目"></a>三、相关题目</h2><ol>
<li><p>怎么利用 call、apply 来求一个数组中最大或者最小值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">19</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, ...arr);</span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr);</span><br><span class="line"><span class="keyword">var</span> fn = <span class="built_in">Math</span>.max.bind(<span class="literal">null</span>, ...arr);</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何利用 call、apply 来做继承</p>
</li>
<li><p>apply、call、bind 的区别和主要应用场景</p>
<ol>
<li>将类数组/含有 length 属性的对象转化为数组</li>
<li>求数组中的最大和最小值</li>
<li>数组追加</li>
<li>利用 call 和 apply 做继承</li>
<li>判断变量类型</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
        <category>Offer</category>
        <category>字节跳动</category>
        <category>this 指向问题</category>
      </categories>
      <tags>
        <tag>面试全面总结</tag>
      </tags>
  </entry>
  <entry>
    <title>css 面试考点全面总结</title>
    <url>/2020/03/23/getOffercss/</url>
    <content><![CDATA[<h2 id="css-面试考点全面总结"><a href="#css-面试考点全面总结" class="headerlink" title="css 面试考点全面总结"></a>css 面试考点全面总结</h2><blockquote>
<p>拿到 字节跳动实习生 offer 总结</p>
<p>回馈分享一波自己的知识点总结</p>
</blockquote>
<blockquote>
<p>希望读者依此构建自己的知识树（思维导图）</p>
<p>偷懒一下：可参考我自己总结思维导图 : <a href="https://github.com/ZhChen7/Interview-mind-map">点这里</a></p>
<p>附带：高频面试题积累文档。 来自于（学长、牛客网等平台）</p>
<p>自己开发的博客地址：<a href="http://zxinc520.com/">zxinc520.com</a></p>
<p>github 地址: <a href="https://github.com/ZhChen7">点击</a></p>
</blockquote>
<blockquote>
<p>此篇 css 考点 共总结 17 大知识点： 全部弄懂了，面试很容易。</p>
</blockquote>
<h3 id="1、盒模型-box-model"><a href="#1、盒模型-box-model" class="headerlink" title="1、盒模型(box model)"></a>1、盒模型(box model)</h3><h4 id="1-1、是什么？"><a href="#1-1、是什么？" class="headerlink" title="1.1、是什么？"></a>1.1、是什么？</h4><blockquote>
<p>网页设计中 css 技术所使用的一种思维模型</p>
</blockquote>
<h4 id="1-2、为什么会出现不同模型"><a href="#1-2、为什么会出现不同模型" class="headerlink" title="1.2、为什么会出现不同模型"></a>1.2、为什么会出现不同模型</h4><p>当年微软的 IE 浏览器占据超过 80%市场份额的时候，想自己独立制定一套浏览器标准，其中就包括 IE 的盒模型，但是有很多公司不同意 IE 的做法，他们遵循的是 W3C 的标准来定制浏览器，也就造成了现在浏览器不同的 CSS 盒模型，但是仍有很多老网站采用的是老 IE 的标准(怪异模式)，因此很多浏览器保留了 IE 的怪异模式。</p>
<h4 id="1-3、盒模型的两种标准"><a href="#1-3、盒模型的两种标准" class="headerlink" title="1.3、盒模型的两种标准"></a>1.3、盒模型的两种标准</h4><ul>
<li>标准模型<ul>
<li>元素宽高＝内容（content）的宽高</li>
</ul>
</li>
<li>IE 模型<ul>
<li>元素宽高＝内容（content）＋填充（padding）＋边框 （border） 的总宽高</li>
</ul>
</li>
</ul>
<h4 id="1-4、组成"><a href="#1-4、组成" class="headerlink" title="1.4、组成"></a>1.4、组成</h4><ul>
<li>content</li>
<li>padding</li>
<li>border</li>
<li>margin</li>
</ul>
<h4 id="1-5、CSS3-中标准或者怪异模式之间的切换（box-sizing）"><a href="#1-5、CSS3-中标准或者怪异模式之间的切换（box-sizing）" class="headerlink" title="1.5、CSS3 中标准或者怪异模式之间的切换（box-sizing）"></a>1.5、CSS3 中标准或者怪异模式之间的切换（box-sizing）</h4><ul>
<li>box-sizing ： content-box 采用标准模式 也是默认样式</li>
<li>box-sizing： border-box 采用 ie 怪异模式</li>
</ul>
<h3 id="2、IFC-与-BFC"><a href="#2、IFC-与-BFC" class="headerlink" title="2、IFC 与 BFC"></a>2、IFC 与 BFC</h3><h4 id="2-1、BFC"><a href="#2-1、BFC" class="headerlink" title="2.1、BFC"></a>2.1、BFC</h4><blockquote>
<p>BFC | 块级格式化上下文（Block Formatting Context）</p>
</blockquote>
<h5 id="BFC-布局规则"><a href="#BFC-布局规则" class="headerlink" title="BFC 布局规则"></a>BFC 布局规则</h5><ol>
<li><p>内部的 Box 会在垂直方向，一个接一个地放置。</p>
</li>
<li><p>Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</p>
</li>
<li><p>每个元素的左外边缘（margin-left)， 与包含块的左边（contain box left）相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。除非这个元素自己形成了一个新的 BFC。</p>
</li>
<li><p>BFC 的区域不会与 float box 重叠。</p>
</li>
<li><p>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p>
</li>
<li><p>计算 BFC 的高度时，浮动元素也参与计算</p>
</li>
</ol>
<h5 id="BFC-使用场景"><a href="#BFC-使用场景" class="headerlink" title="BFC 使用场景"></a>BFC 使用场景</h5><ul>
<li>外边距折叠问题</li>
<li>清除浮动</li>
</ul>
<h5 id="触发-BFC-的方法"><a href="#触发-BFC-的方法" class="headerlink" title="触发 BFC 的方法"></a>触发 BFC 的方法</h5><ul>
<li>float 属性不为 none</li>
<li>元素的 position 为 absolute 或 fixed</li>
<li>display 属性为下列之一:table-cell | table-caption| inline-block | flex | inline-flex</li>
<li>overflow 属性不为 visible</li>
</ul>
<h4 id="2-2、IFC"><a href="#2-2、IFC" class="headerlink" title="2.2、IFC"></a>2.2、IFC</h4><blockquote>
<p>IFC |行内格式化上下文（Inline Formatting Context）</p>
</blockquote>
<h5 id="IFC-布局规则"><a href="#IFC-布局规则" class="headerlink" title="IFC 布局规则"></a>IFC 布局规则</h5><p>在行内格式化上下文中，框(boxes)一个接一个地水平排列，起点是包含块的顶部。水平方向上的 margin，border 和 padding 在框之间得到保留。框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐。包含那些框的长方形区域，会形成一行，叫做行框。</p>
<h3 id="3、margin-塌陷及合并问题"><a href="#3、margin-塌陷及合并问题" class="headerlink" title="3、margin 塌陷及合并问题"></a>3、margin 塌陷及合并问题</h3><blockquote>
<p>注意：margin 塌陷问题和合并问题都只对垂直方向有效</p>
</blockquote>
<h4 id="3-1、margin-塌陷问题"><a href="#3-1、margin-塌陷问题" class="headerlink" title="3.1、margin 塌陷问题"></a>3.1、margin 塌陷问题</h4><ul>
<li><p>描述</p>
<p>这个问题是一个经典的浏览器内核问题。具体表现是当两个元素嵌套到一起时，外层盒模型的 margin-top 取两个元素中 margin-top 较大的值。</p>
<p>因为在正常的情况下内层元素是相对于外层元素进行移动，但是这时内层元素却相对于整个文档进行移动，好像外层元素没有“棚顶”一样，因此叫 margin 塌陷问题。</p>
</li>
<li><p>解决方法</p>
<ol>
<li><p>给外层元素认为加一个“棚顶”:border。</p>
<p>这种方法虽然能够解决问题，但是在日常开发中我们不使用它，因为他在外观上对元素进行了改变。</p>
</li>
<li><p>触发 BFC</p>
<ul>
<li>float 属性不为 none</li>
<li>元素的 position 为 absolute 或 fixed</li>
<li>display 属性为下列之一:table-cell | table-caption| inline-block | flex | inline-flex</li>
<li>overflow 属性不为 visible</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="3-2、margin-合并问题"><a href="#3-2、margin-合并问题" class="headerlink" title="3.2、margin 合并问题"></a>3.2、margin 合并问题</h4><ul>
<li>描述：具体表现为两个元素并列时，两者相隔的外边距取的是两者所设置 margin 的最大值。</li>
<li>margin 合并问题解决办法<ul>
<li>我们仍然用 bfc 来解决。可以给其中一个元素包起来，在外层元素中设置 bfc 渲染规则。此时这个元素的渲染规则就改变了，就能够解决这个问题。</li>
</ul>
</li>
</ul>
<h3 id="4、float"><a href="#4、float" class="headerlink" title="4、float"></a>4、float</h3><h4 id="4-1、浮动模型"><a href="#4-1、浮动模型" class="headerlink" title="4.1、浮动模型"></a>4.1、浮动模型</h4><p>块状元素这么霸道都是独占一行，如果现在我们想让两个块状元素并排显示，怎么办呢？不要着急，设置元素浮动就可以实现这一愿望。</p>
<p>任何元素在默认情况下是不能浮动的，但可以通过 float 属性将元素定义为浮动，如 div、p、table、img 等元素都可以被定义为浮动。通过下面代码实现两个 div 元素在一行显示。</p>
<h4 id="4-2、清除浮动"><a href="#4-2、清除浮动" class="headerlink" title="4.2、清除浮动"></a>4.2、清除浮动</h4><ol>
<li><p>浮动元素后面的同级标签加 clear: both | left | right 属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">推荐使用：<span class="selector-tag">after</span>（伪类） 伪类原理：相当于在父元素里添加一个子元素（默认内联元素），用来清除容器内的浮动元素。                                       	<span class="selector-tag">display</span>: &quot;<span class="selector-tag">block</span>&quot;;</span><br><span class="line">    <span class="selector-tag">clear</span><span class="selector-pseudo">:both</span>;</span><br><span class="line">    <span class="selector-tag">height</span><span class="selector-pseudo">:0</span>;</span><br><span class="line">    <span class="selector-tag">content</span>: &quot;&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>触发 BFC</p>
<ul>
<li>float 属性不为 none</li>
<li>元素的 position 为 absolute 或 fixed</li>
<li>display 属性为下列之一:table-cell | table-caption| inline-block | flex | inline-flex</li>
<li>overflow 属性不为 visible</li>
</ul>
</li>
</ol>
<h3 id="5、flex"><a href="#5、flex" class="headerlink" title="5、flex"></a>5、flex</h3><h4 id="5-1、描述"><a href="#5-1、描述" class="headerlink" title="5.1、描述"></a>5.1、描述</h4><p>2009 年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>
<p>Flex 布局将成为未来布局的首选方案。</p>
<p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活。</p>
<p>任何一个容器都可以指定为 Flex 布局。</p>
<h4 id="5-2、容器的属性"><a href="#5-2、容器的属性" class="headerlink" title="5.2、容器的属性"></a>5.2、容器的属性</h4><ul>
<li>flex-direction<ul>
<li>row | row-reverse | column | column-reverse</li>
</ul>
</li>
<li>flex-wrap<ul>
<li>flex-wrap: nowrap | wrap | wrap-reverse;</li>
</ul>
</li>
<li>flex-flow<ul>
<li>属性是 flex-direction 和 flex-wrap 的简写</li>
</ul>
</li>
<li>justify-content<ul>
<li>justify-content: flex-start | flex-end | center | space-between | space-around;</li>
</ul>
</li>
<li>align-items<ul>
<li>align-items: flex-start | flex-end | center | baseline | stretch;</li>
</ul>
</li>
<li>align-content<ul>
<li>align-content: flex-start | flex-end | center | space-between | space-around | stretch;</li>
</ul>
</li>
</ul>
<h3 id="6、CSS-浏览器兼容性的-4-个解决方案"><a href="#6、CSS-浏览器兼容性的-4-个解决方案" class="headerlink" title="6、CSS 浏览器兼容性的 4 个解决方案"></a>6、CSS 浏览器兼容性的 4 个解决方案</h3><ul>
<li><p>浏览器 CSS 样式初始化</p>
</li>
<li><p>浏览器私有属性</p>
<ul>
<li><p>我们经常会在某个 CSS 的属性前添加一些前缀，比如-webkit- ，-moz- ，-ms-，这些就是浏览器的私有属性。 -webkit- (谷歌, Safari, 新版 Opera 浏览器, 以及几乎所有 iOS 系统中的浏览器(包括 iOS 系统中的火狐浏览器); 简单的说，所有基于 WebKit 内核的浏览器)</p>
<p>-moz- (火狐浏览器)</p>
<p>-o- (旧版 Opera 浏览器)</p>
<p>-ms- (IE 浏览器 和 Edge 浏览器)</p>
</li>
<li><p>对于私有属性的顺序要注意，把标准写法放到最后，兼容性写法放到前面</p>
</li>
</ul>
</li>
<li><p>CSS hack 语法</p>
<ul>
<li><p>有时我们需要针对不同的浏览器或不同版本写特定的 CSS 样式，这种针对不同的浏览器/不同版本写相应的 CSS code 的过程，叫做 CSS hack!</p>
</li>
<li><p>例如 IE：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &lt;!--[<span class="keyword">if</span> &lt;keywords&gt;? IE &lt;version&gt;?]&gt;</span><br><span class="line">	 代码块，可以是html，css，js</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>自动化插件</p>
<ul>
<li>Autoprefixer 是一款自动管理浏览器前缀的插件，它可以解析 CSS 文件并且添加浏览器前缀到 CSS 内容里，使用 Can I Use（caniuse 网站）的数据来决定哪些前缀是需要的。</li>
<li>目前 webpack、gulp、grunt 都有相应的插件，如果还没有使用，那就赶紧应用到我们的项目中吧，别再让 CSS 兼容性浪费你的时间！</li>
</ul>
</li>
</ul>
<h3 id="7、position（定位）"><a href="#7、position（定位）" class="headerlink" title="7、position（定位）"></a>7、position（定位）</h3><h4 id="7-1、文档流"><a href="#7-1、文档流" class="headerlink" title="7.1、文档流"></a>7.1、文档流</h4><p>简单说就是元素按照其在 HTML 中的位置顺序决定排布的过程。HTML 的布局机制就是用文档流模型的，即块元素（block）独占一行，内联元素（inline），不独占一行。</p>
<p>一般使用 margin 是用来隔开元素与元素的间距；padding 是用来隔开元素与内容的间隔。margin 用于布局分开元素使元素与元素互不相干；padding 用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段“距离”。</p>
<p>只要不是 float 和绝对定位方式布局的，都在文档流里面。</p>
<h4 id="7-2、属性"><a href="#7-2、属性" class="headerlink" title="7.2、属性"></a>7.2、属性</h4><ul>
<li>static</li>
<li>relative(相对定位）</li>
<li>absolute</li>
<li>fixed</li>
<li>z-index<ul>
<li>z-index 指定了一个元素及其子元素的 z-order，元素之间有重叠的时候，z-index 可以决定让哪一个元素在上方。通常来说 z-index 较大的元素会覆盖较小的一个。仅对定位的元素有效。 元素之间重叠默认的顺序是后面的元素会盖住前面的元素。如果设置了 z-index 可以改变这个顺序。但只对同级的元素有效。父元素永远在子元素后面。</li>
</ul>
</li>
</ul>
<h3 id="8、行内元素-和-块级元素"><a href="#8、行内元素-和-块级元素" class="headerlink" title="8、行内元素 和 块级元素"></a>8、行内元素 和 块级元素</h3><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul>
<li>块元素，总是在新行上开始；内联元素，和其他元素在一行</li>
<li>块元素，能容纳其他块元素或者内联元素；内联元素，只能容纳文本或其他内联元素</li>
<li>块元素中高度，行高以及顶和底边距都可以控制；内联元素中高，行高及顶和底边距不可改变。</li>
</ul>
<h3 id="9、Sass-Scss、Less、stylus"><a href="#9、Sass-Scss、Less、stylus" class="headerlink" title="9、Sass/Scss、Less、stylus"></a>9、Sass/Scss、Less、stylus</h3><h4 id="9-1、CSS-预处理器"><a href="#9-1、CSS-预处理器" class="headerlink" title="9.1、CSS 预处理器"></a>9.1、CSS 预处理器</h4><ul>
<li><p>概念</p>
<p>CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。</p>
</li>
<li><p>优点</p>
<p>虽然各种预处理器功能强大，但使用最多的，还是以下特性：变量（variables），代码混合（ mixins），嵌套（nested rules）以及 代码模块化(Modules)。</p>
</li>
</ul>
<h4 id="9-2、区别"><a href="#9-2、区别" class="headerlink" title="9.2、区别"></a>9.2、区别</h4><ul>
<li><p>编译环境不一样</p>
<p>Sass 的安装需要 Ruby 环境，是在服务端处理的，而 Less 是需要引入 less.js 来处理 Less 代码输出 css 到浏览器，也可以在开发环节使用 Less，然后编译成 css 文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app 这样的工具，也有在线编译地址。Stylus 需要安装 node，然后安装最新的 stylus 包即可使用</p>
</li>
<li><p>变量符不一样</p>
<p>Less 是@，而 Scss 是$， Stylus样式中声明变量没有任何限定，你可以使用“$”符号开始。</p>
</li>
<li><p>输出设置</p>
</li>
<li><p>处理条件语句</p>
</li>
<li><p>引用外部 CSS 文件</p>
</li>
<li><p>Sass 和 Less 的工具库不同</p>
</li>
</ul>
<h3 id="10、css3-动画"><a href="#10、css3-动画" class="headerlink" title="10、css3 动画"></a>10、css3 动画</h3><h4 id="10-1、常用特效-变换（transform）"><a href="#10-1、常用特效-变换（transform）" class="headerlink" title="10.1、常用特效/变换（transform）"></a>10.1、常用特效/变换（transform）</h4><ul>
<li>scale（2D 缩放）</li>
<li>rotate（2D 旋转）</li>
<li>translate（2D 位移）</li>
<li>skew（2D 倾斜）</li>
</ul>
<h4 id="10-2、animation"><a href="#10-2、animation" class="headerlink" title="10.2、animation"></a>10.2、animation</h4><ul>
<li><p>属性</p>
<ul>
<li>animation-name ：规定需要绑定到选择器的 keyframe 名称。</li>
<li>animation-duration：规定完成动画所花费的时间，以秒或毫秒计。</li>
<li>animation-timing-function：规定动画的速度曲线。</li>
<li>animation-delay ：规定在动画开始之前的延迟。</li>
<li>animation-iteration-count：规定动画应该播放的次数。</li>
<li>animation-direction ：规定是否应该轮流反向播放动画。</li>
<li>animation-fill-mode ：规定动画在播放之前或之后，其动画效果是否可见</li>
</ul>
</li>
<li><p>简写：</p>
<p>animation: name duration timing-function delay iteration-count direction fill-mode;</p>
</li>
<li><p>举例：</p>
<p>animation: wang 3s linear 1s infinite alternate forwards ;</p>
</li>
</ul>
<h4 id="10-3、keyframes"><a href="#10-3、keyframes" class="headerlink" title="10.3、keyframes"></a>10.3、keyframes</h4><ul>
<li><p>这个属性用来定义一系列关键帧。也就是在动画运行的全过程中的一个个中间点。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> zoomIn &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  60% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="11、居中布局"><a href="#11、居中布局" class="headerlink" title="11、居中布局"></a>11、居中布局</h3><ol>
<li><p>使用 Flex</p>
</li>
<li><p>使用绝对定位</p>
</li>
<li><p>inline-block</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.parent2&#123; text-align: center; &#125; .parent2 span&#123; display: inline-block;</span><br><span class="line">height:50% &#125; .parent2 .child&#123; display: inline-block; color: #fff; &#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>hello world-2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 table 和 table-cell</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent1</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent1</span> <span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子元素是单行文本</p>
<p>设置父元素的 text-align 和 line-height = height</p>
</li>
<li><p>利用 grid 布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-self</span>: center;</span><br><span class="line">  <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用绝对定位和 margin:auto</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 无需知道被居中元素的宽高 */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="12、等高布局"><a href="#12、等高布局" class="headerlink" title="12、等高布局"></a>12、等高布局</h3><ol>
<li><p>flex 布局</p>
</li>
<li><p>使用负 margin-bottom 和正 padding-bottom 对冲实现</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.Article</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span> -<span class="number">9999px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">9999px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模仿 table 布局</p>
<p>父：display: table; 子： display: table-cell;</p>
</li>
<li><p>grid 布局</p>
</li>
</ol>
<h3 id="13、三栏布局"><a href="#13、三栏布局" class="headerlink" title="13、三栏布局"></a>13、三栏布局</h3><h4 id="13-1、特点"><a href="#13-1、特点" class="headerlink" title="13.1、特点"></a>13.1、特点</h4><ul>
<li>两侧宽度固定，中间宽度自适应</li>
<li>中间部分在 DOM 结构上优先，以便先行渲染</li>
<li>都需要一个格外的 Div.container</li>
<li>允许任意列的高度最高</li>
</ul>
<h4 id="13-2、圣杯布局"><a href="#13-2、圣杯布局" class="headerlink" title="13.2、圣杯布局"></a>13.2、圣杯布局</h4><ul>
<li>特点 ：使用了相对定位</li>
<li>优势：在 DOM 结构上显得更加值观和自然</li>
</ul>
<p><strong>实现</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line">            padding: 0;</span><br><span class="line">            margin: 0;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span>&#123;</span></span><br><span class="line">            overflow: hidden;</span><br><span class="line">            padding: 0 100px 0 100px;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.middle</span>,<span class="selector-class">.left</span>,<span class="selector-class">.right</span>&#123;</span></span><br><span class="line">            position: relative;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: red;</span><br><span class="line">            margin-left: -100%;</span><br><span class="line">            left: -100px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: green;</span><br><span class="line">            margin-left: -100px;</span><br><span class="line">            right: -100px;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.middle</span>&#123;</span></span><br><span class="line">            background: blue;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="13-3、双飞翼布局"><a href="#13-3、双飞翼布局" class="headerlink" title="13.3、双飞翼布局"></a>13.3、双飞翼布局</h4><ul>
<li>特点：不需要定位，只用了浮动和负边距</li>
<li>优势<ul>
<li>不需要使用定位，所以更加简洁</li>
<li>允许的页面最小宽度通常比圣杯布局更小</li>
</ul>
</li>
</ul>
<p><strong>实现：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">       <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">           overflow: hidden;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="css">       <span class="selector-class">.middle</span>, <span class="selector-class">.left</span>, <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">           float: left;</span><br><span class="line">           height: 100px;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="css">       <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">           width: 100px;</span><br><span class="line">           background: red;</span><br><span class="line">           margin-left: -100%;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="css">       <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">           width: 100px;</span><br><span class="line">           background: blue;</span><br><span class="line">           margin-left: -100px;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="css">       <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line">           width: 100%;</span><br><span class="line">           background: aqua;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="css">       <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line">           margin: 0 100px;</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>middle<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="13-4、区别"><a href="#13-4、区别" class="headerlink" title="13.4、区别"></a>13.4、区别</h4><p>两者都是为了不让左右俩不遮住 middle，经典圣杯布局通过父亲 padding 给左右俩腾位置从而不会遮住 middle 内容，而双飞翼是 middle 设置 margin，限制内部内容区域，从而左右俩遮的地方不会影响到 middle 内容</p>
<p>对于三栏布局，modern solution 是 flex box/ grid 布局，这两者可以轻松实现 mobile-friendly 的方案，也可以控制顺序，middle 依然可以先渲染，2019 年兼容性不错了，如果 APP 无视 IE，这是优选</p>
<h3 id="14、多栏布局"><a href="#14、多栏布局" class="headerlink" title="14、多栏布局"></a>14、多栏布局</h3><h4 id="14-1、栅格系统（grid-systems）"><a href="#14-1、栅格系统（grid-systems）" class="headerlink" title="14.1、栅格系统（grid systems）"></a>14.1、栅格系统（grid systems）</h4><ul>
<li>特点 ：利用浮动实现的多栏布局</li>
<li>表现 ： Bootstrap</li>
</ul>
<h4 id="14-2、多列布局"><a href="#14-2、多列布局" class="headerlink" title="14.2、多列布局"></a>14.2、多列布局</h4><ul>
<li><p>特点：将内容按指定的列数排列</p>
</li>
<li><p>表现 ：报纸排版</p>
</li>
<li><p>使用方式： 通过 css3 的 column</p>
<ul>
<li>IE10 及以上和其它现代浏览器</li>
<li>但 -webkit- 以及 -moz- 前缀不能省略</li>
<li>比 flex 弹性布局更稳定、更兼容</li>
</ul>
</li>
<li><p>语法</p>
<ul>
<li><p>columns: &lt;’column-width’&gt; || &lt;’column-count’&gt;</p>
<p>设置对象的列数和每列的宽度。复合属性。</p>
</li>
<li><p>column-width ：设置对象的宽度</p>
</li>
<li><p>column-count ：用来定义对象中的列数，使用数字 1-10 表示</p>
</li>
<li><p>column-gap ：设置列与列之间的间距</p>
</li>
<li><p>column-rule：&lt;’ column-rule-width ‘&gt; || &lt;’ column-rule-style ‘&gt; || &lt;’ column-rule-color ‘&gt;</p>
<ul>
<li>设置对象的列与列之间的边框。复合属性</li>
<li>column-rule: 10px solid #090;</li>
</ul>
</li>
<li><p>column-fill：auto | balance</p>
<ul>
<li>设置对象所有列的高度是否统一</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="15、弹性布局（Flexbox）"><a href="#15、弹性布局（Flexbox）" class="headerlink" title="15、弹性布局（Flexbox）"></a>15、弹性布局（Flexbox）</h3><ul>
<li>CSS3 引入的新模式<ul>
<li>用来为盒装模型提供的最大的灵活性</li>
<li>目前已经得到了所有现代浏览器的支持</li>
</ul>
</li>
<li>优势<ul>
<li>轻松实现视图大小变化时对元素的相对位置的大小的保持</li>
<li>减少了对浮动布局的依赖以及重置元素的大小</li>
</ul>
</li>
<li>注意<ul>
<li>Webkit 内核的浏览器，必须加上 -webkit 前缀 display：-webkit-flex</li>
<li>子元素的 float、clear 和 vertical-align 属性失效</li>
</ul>
</li>
</ul>
<h3 id="16、流式布局"><a href="#16、流式布局" class="headerlink" title="16、流式布局"></a>16、流式布局</h3><ul>
<li>主要靠百分比进行排版</li>
<li>对应布局<ul>
<li>瀑布流布局<ul>
<li>表现 ：参差不齐的多栏布局</li>
<li>实现方式 ： 同样可以用 column 实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="17、响应式布局"><a href="#17、响应式布局" class="headerlink" title="17、响应式布局"></a>17、响应式布局</h3><ul>
<li>特点<ul>
<li>一个网站能够兼容多个终端</li>
<li>解决不用设备之间分辨率之间的兼容问题</li>
</ul>
</li>
<li>实现方式<ul>
<li>css3 的媒体查询</li>
<li>检测设备屏幕大小，通过 css 媒体查询来有针对性的更改页面的布局</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Offer</category>
        <category>字节跳动</category>
      </categories>
      <tags>
        <tag>面试全面总结</tag>
      </tags>
  </entry>
  <entry>
    <title>原型和原型链</title>
    <url>/2020/03/23/getOfferPrototypesandprototypechains/</url>
    <content><![CDATA[<h2 id="JavaScript-原型和原型链"><a href="#JavaScript-原型和原型链" class="headerlink" title="JavaScript 原型和原型链"></a>JavaScript 原型和原型链</h2><blockquote>
<p>拿到 字节跳动实习生 offer 总结</p>
<p>回馈分享一波自己的知识点总结</p>
</blockquote>
<blockquote>
<p>希望读者依此构建自己的知识树（思维导图）</p>
<p>偷懒一下：可参考我自己总结思维导图 : <a href="https://github.com/ZhChen7/Interview-mind-map">点这里</a></p>
<p>附带：高频面试题积累文档。 来自于（学长、牛客网等平台）</p>
<p>自己开发的博客地址：<a href="http://zxinc520.com/">zxinc520.com</a></p>
<p>github 地址: <a href="https://github.com/ZhChen7">点击</a></p>
</blockquote>
<blockquote>
<p>此篇 js - 【原型和原型链】 知识点： 全部弄懂了，面试很容易。</p>
</blockquote>
<h2 id="一、原型和原型定义"><a href="#一、原型和原型定义" class="headerlink" title="一、原型和原型定义"></a>一、原型和原型定义</h2><h3 id="1-1、背景"><a href="#1-1、背景" class="headerlink" title="1.1、背景"></a>1.1、背景</h3><p>JavaScript 中除了基础类型外的数据类型，都是对象（引用类型）。但是由于其没有 类（class，ES6 引入了 class，但其只是语法糖）的概念，如何将所有对象联系起来就成立一个问题，于是就有了原型和原型链的概念。</p>
<h3 id="1-2、原型是什么？"><a href="#1-2、原型是什么？" class="headerlink" title="1.2、原型是什么？"></a>1.2、原型是什么？</h3><blockquote>
<p>原型是一个 prototype 对象，用于表示对象之间的关系。</p>
</blockquote>
<h3 id="1-3、原型链"><a href="#1-3、原型链" class="headerlink" title="1.3、原型链"></a>1.3、原型链</h3><p>每个实例对象（ object ）都有一个私有属性（称之为 <strong>proto</strong> ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( <strong>proto</strong> ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。以上一整个原型与原型层层相链接的过程即为原型链</p>
<h3 id="1-4、公式"><a href="#1-4、公式" class="headerlink" title="1.4、公式"></a>1.4、公式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象 = <span class="keyword">new</span> 函数();</span><br><span class="line">对象.__proto__ === 对象的构造函数.prototype;</span><br></pre></td></tr></table></figure>

<h2 id="二、7-大继承写法"><a href="#二、7-大继承写法" class="headerlink" title="二、7 大继承写法"></a>二、7 大继承写法</h2><blockquote>
<p>常考点【熟练掌握】</p>
</blockquote>
<h3 id="2-1、原型链继承"><a href="#2-1、原型链继承" class="headerlink" title="2.1、原型链继承"></a>2.1、原型链继承</h3><ul>
<li><p>原型链继承的基本思想：是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<p>如 SubType.prototype = new SuperType();</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;Yvette&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br></pre></td></tr></table></figure>
</li>
<li><p>缺点</p>
<ol>
<li>通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享</li>
<li>在创建子类型的实例时，不能向超类型的构造函数中传递参数</li>
</ol>
</li>
</ul>
<h3 id="2-2、借用构造函数"><a href="#2-2、借用构造函数" class="headerlink" title="2.2、借用构造函数"></a>2.2、借用构造函数</h3><ul>
<li><p>其基本思想为:在子类型的构造函数中调用超类型构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点</p>
<ol>
<li>可以向超类传递参数</li>
<li>解决了原型中包含引用类型值被所有实例共享的问题</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>方法都在构造函数中定义，函数复用无从谈起</li>
<li>另外超类型原型中定义的方法对于子类型而言都是不可见的</li>
</ol>
</li>
</ul>
<h3 id="2-3、组合继承"><a href="#2-3、组合继承" class="headerlink" title="2.3、组合继承"></a>2.3、组合继承</h3><ul>
<li><p>组合继承指的是将原型链和借用构造函数技术组合到一块，从而发挥二者之长的一种继承模式。基本思路：使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;zc&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> SubType();</span><br><span class="line"></span><br><span class="line">a.colors.push(<span class="string">&quot;red&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.colors); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;red&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(b.colors); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>优点</p>
<ol>
<li>可以向超类传递参数</li>
<li>每个实例都有自己的属性</li>
<li>实现了函数复用</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</li>
</ol>
</li>
</ul>
<h3 id="2-4、原型式继承"><a href="#2-4、原型式继承" class="headerlink" title="2.4、原型式继承"></a>2.4、原型式继承</h3><ul>
<li><p>原型式继承继承的基本思想：在 object() 函数内部，先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例，从本质上讲，object() 对传入的对象执行了一次浅拷贝。</p>
<p>ECMAScript5 通过新增 Object.create()方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象(可以覆盖原型对象上的同名属性)，在传入一个参数的情况下，Object.create() 和 object() 方法的行为相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缺点</p>
<ol>
<li>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享</li>
</ol>
</li>
</ul>
<h3 id="2-5、寄生式继承"><a href="#2-5、寄生式继承" class="headerlink" title="2.5、寄生式继承"></a>2.5、寄生式继承</h3><ul>
<li><p>寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//以某种方式增强这个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点</p>
<ol>
<li>基于 person 返回了一个新对象 -—— person2，新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi() 方法。在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。</li>
<li>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。</li>
</ol>
</li>
</ul>
<h3 id="2-6、寄生组合式继承"><a href="#2-6、寄生组合式继承" class="headerlink" title="2.6、寄生组合式继承"></a>2.6、寄生组合式继承</h3><ul>
<li><p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，基本思路：</p>
<p>不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">  prototype.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">  subType.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuberType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SuberType, SuperType);</span><br></pre></td></tr></table></figure>
</li>
<li><p>步骤</p>
<p>第一步：创建超类型原型的一个副本</p>
<p>第二步：为创建的副本添加 constructor 属性</p>
<p>第三步：将新创建的对象赋值给子类型的原型</p>
</li>
<li><p>优点</p>
<ol>
<li>只调用了一次超类构造函数，效率更高。避免在 SuberType.prototype 上面创建不必要的、多余的属性，与其同时，原型链还能保持不变。因此寄生组合继承是引用类型最理性的继承范式。</li>
</ol>
</li>
</ul>
<h3 id="2-7、ES6-继承"><a href="#2-7、ES6-继承" class="headerlink" title="2.7、ES6 继承"></a>2.7、ES6 继承</h3><ul>
<li><p>Class 可以通过 extends 关键字实现继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age) &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age, name) &#123;</span><br><span class="line">    <span class="built_in">super</span>(age); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于 ES6 的 class 需要做以下几点说明</p>
<ol>
<li>class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。</li>
<li>class 声明内部会启用严格模式。</li>
<li>class 的所有方法（包括静态方法和实例方法）都是不可枚举的。</li>
<li>class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。</li>
<li>必须使用 new 调用 class</li>
<li>class 内部无法重写类名</li>
</ol>
</li>
</ul>
<h4 id="使用-extends-关键字实现继承，有几点需要特别说明"><a href="#使用-extends-关键字实现继承，有几点需要特别说明" class="headerlink" title="使用 extends 关键字实现继承，有几点需要特别说明"></a>使用 extends 关键字实现继承，有几点需要特别说明</h4><ul>
<li>子类必须在 constructor 中调用 super 方法，否则新建实例时会报错。如果没有子类没有定义 constructor 方法，那么这个方法会被默认添加。在子类的构造函数中，只有调用 super 之后，才能使用 this 关键字，否则报错。这是因为子类实例的构建，基于父类实例，只有 super 方法才能调用父类实例。</li>
<li>ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this</li>
</ul>
<h2 id="三、相关题目"><a href="#三、相关题目" class="headerlink" title="三、相关题目"></a>三、相关题目</h2><h3 id="3-1、写一个原型链继承的例子"><a href="#3-1、写一个原型链继承的例子" class="headerlink" title="3.1、写一个原型链继承的例子"></a>3.1、写一个原型链继承的例子</h3><ul>
<li>详细请观看上文。</li>
</ul>
<h3 id="3-2、描述-new-一个对象的过程"><a href="#3-2、描述-new-一个对象的过程" class="headerlink" title="3.2、描述 new 一个对象的过程"></a>3.2、描述 new 一个对象的过程</h3><h4 id="3-2-1、思路分析"><a href="#3-2-1、思路分析" class="headerlink" title="3.2.1、思路分析"></a>3.2.1、思路分析</h4><ol>
<li>创建一个新对象 obj</li>
<li>把 obj 的<strong>proto</strong>指向 构造函数.prototype 实现继承</li>
<li>执行构造函数，传递参数，改变 this 指向</li>
<li>最后把 obj 返回</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">伪代码：<span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>) = &#123;</span><br><span class="line">                <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">	obj.__proto__ = Person.prototype;</span><br><span class="line">	<span class="keyword">var</span> result = Person.call(obj,<span class="string">&quot;John&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> ? result : obj; <span class="comment">// 如果无返回值或者返回一个非对象值，则将obj返回作为新对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2、优秀的写法"><a href="#3-2-2、优秀的写法" class="headerlink" title="3.2.2、优秀的写法"></a>3.2.2、优秀的写法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">fn, ...arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">  <span class="keyword">const</span> ret = fn.apply(obj, arg);</span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>或</strong> 【个人倾向于后面一种】</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">fn, ...arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  obj.__proto__ = fn.prototype;</span><br><span class="line">  <span class="keyword">let</span> ret = fn.apply(obj, arg);</span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3、为什么-return-ret-instanceof-Object-ret-obj-需要存在这一步骤？"><a href="#3-2-3、为什么-return-ret-instanceof-Object-ret-obj-需要存在这一步骤？" class="headerlink" title="3.2.3、为什么 return ret instanceof Object ? ret : obj; 需要存在这一步骤？"></a>3.2.3、为什么 <code>return ret instanceof Object ? ret : obj;</code> 需要存在这一步骤？</h4><blockquote>
<p>这是因为 new 一个实例的时候，如果没有 return，</p>
<p>就会根据构造函数内部 this 绑定的值生成对象，如果有返回值，</p>
<p>就会根据返回值生成对象，为了模拟这一效果，就需要判断 apply 后是否有返回值。</p>
</blockquote>
<h4 id="3-2-4、总结-new-的过程中发生了什么"><a href="#3-2-4、总结-new-的过程中发生了什么" class="headerlink" title="3.2.4、总结 new 的过程中发生了什么"></a>3.2.4、总结 new 的过程中发生了什么</h4><ol>
<li><p>令 john 的<strong>proto</strong>属性指向 Person.prototype，确立了这条原型链， 导致 john 能通过原型链继承 Person.prototype 中的部分属性，可以简单地视 john 和 Person.prototype 是继承关系。</p>
</li>
<li><p>john 是 Person 构造函数 的实例 john instanceof Person; //true</p>
</li>
<li><p>我们再来了解一下 instanceof 的内部原理，以应证我们的图是正确的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> L = A.__proto__;</span><br><span class="line"><span class="keyword">var</span> R = B.prototype;</span><br><span class="line"><span class="keyword">if</span> (L === R) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
        <category>JS 三座大山</category>
        <category>Offer</category>
        <category>字节跳动</category>
      </categories>
      <tags>
        <tag>面试全面总结</tag>
        <tag>JS 三座大山</tag>
      </tags>
  </entry>
  <entry>
    <title>作用域和闭包</title>
    <url>/2020/03/23/getOfferScopeandclosure/</url>
    <content><![CDATA[<h2 id="专题总结：作用域和闭包"><a href="#专题总结：作用域和闭包" class="headerlink" title="专题总结：作用域和闭包"></a>专题总结：作用域和闭包</h2><blockquote>
<p>拿到 字节跳动实习生 offer 总结</p>
<p>回馈分享一波自己的知识点总结</p>
</blockquote>
<blockquote>
<p>希望读者依此构建自己的知识树（思维导图）</p>
<p>偷懒一下：可参考我自己总结思维导图 : <a href="https://github.com/ZhChen7/Interview-mind-map">点这里</a></p>
<p>附带：高频面试题积累文档。 来自于（学长、牛客网等平台）</p>
<p>自己开发的博客地址：<a href="http://zxinc520.com/">zxinc520.com</a></p>
<p>github 地址: <a href="https://github.com/ZhChen7">点击</a></p>
</blockquote>
<blockquote>
<p>此篇 js - 【作用域和闭包】 知识点： 全部弄懂了，面试很容易。</p>
</blockquote>
<h2 id="一、作用域和作用域链概念"><a href="#一、作用域和作用域链概念" class="headerlink" title="一、作用域和作用域链概念"></a>一、作用域和作用域链概念</h2><h3 id="1-1、作用域"><a href="#1-1、作用域" class="headerlink" title="1.1、作用域"></a>1.1、作用域</h3><h4 id="1-1-1、作用域是什么"><a href="#1-1-1、作用域是什么" class="headerlink" title="1.1.1、作用域是什么"></a>1.1.1、作用域是什么</h4><p>作用域本质就是程序源代码中定义变量的区域，它可以解释为一套规则，是关于 JS 引擎如何寻找变量以及会在何处找到变量的规则。</p>
<h4 id="1-1-2、作用域分为哪些"><a href="#1-1-2、作用域分为哪些" class="headerlink" title="1.1.2、作用域分为哪些"></a>1.1.2、作用域分为哪些</h4><ul>
<li>词法作用域（静态作用域）<ul>
<li>词法作用域是在写代码时就确定了作用域（不使用 eval 和 with 的前提下，这两个现在基本不使用，因此不讲了），即静态作用域</li>
</ul>
</li>
<li>动态作用域<ul>
<li>而动态作用域是在代码运行时动态确定的</li>
</ul>
</li>
</ul>
<h3 id="1-2、作用域链"><a href="#1-2、作用域链" class="headerlink" title="1.2、作用域链"></a>1.2、作用域链</h3><h4 id="1-2-1、作用域链是什么"><a href="#1-2-1、作用域链是什么" class="headerlink" title="1.2.1、作用域链是什么"></a>1.2.1、作用域链是什么</h4><p>作用域链实际上是指向变量对象的指针列表，它只引用但不实际包含变量对象，它的用途是保证对执行环境有权访问的所有变量和函数的有序访问。</p>
<p>简单来说：作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。</p>
<h5 id="两个重要概念："><a href="#两个重要概念：" class="headerlink" title="两个重要概念："></a>两个重要概念：</h5><ul>
<li><p>变量对象</p>
<p>每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中（变量对象其实就是作用域这个抽象概念的具体值），比如一个函数中包含的局部变量，它的参数，它里面声明的函数都存在变量对象中。（一个当前执行函数的变量对象最开始时就包含一个 arguments 对象，这个对象用来装函数括号内的参数，所以全局环境的变量对象没有这个）</p>
</li>
<li><p>执行环境</p>
<p>也可以叫执行上下文，这里定义了变量或函数有权访问的其他数据，当一个函数被执行时，他的执行环境会被推入环境栈，执行之后才会被弹出，把控制权返回给之前的执行环境。</p>
</li>
</ul>
<h2 id="二、闭包"><a href="#二、闭包" class="headerlink" title="二、闭包"></a>二、闭包</h2><h3 id="2-1、闭包是什么"><a href="#2-1、闭包是什么" class="headerlink" title="2.1、闭包是什么"></a>2.1、闭包是什么</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包最常用的方式就是在一个函数内部创建另一个函数。</p>
<h3 id="2-2、闭包的作用"><a href="#2-2、闭包的作用" class="headerlink" title="2.2、闭包的作用"></a>2.2、闭包的作用</h3><ol>
<li><p>能够访问函数定义时所在的词法作用域(阻止其被回收)。</p>
</li>
<li><p>私有化变量</p>
</li>
<li><p>模拟块级作用域</p>
</li>
<li><p>创建模块</p>
<ul>
<li>两个必备的条件(来自《你不知道的 JavaScript》)<ul>
<li>必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)</li>
<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;Yvette&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">20</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    sayName,</span><br><span class="line">    sayAge,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> info = coolModule();</span><br><span class="line">info.sayName(); <span class="comment">//&#x27;Yvette&#x27;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-3、闭包的缺点"><a href="#2-3、闭包的缺点" class="headerlink" title="2.3、闭包的缺点"></a>2.3、闭包的缺点</h3><p>闭包会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p>
<p>2.4、经典题目（闭包）</p>
<blockquote>
<p>函数自增</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(fn()); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(fn()); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(fn()); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(fn()); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
        <category>JS 三座大山</category>
        <category>Offer</category>
        <category>字节跳动</category>
      </categories>
      <tags>
        <tag>面试全面总结</tag>
        <tag>JS 三座大山</tag>
      </tags>
  </entry>
  <entry>
    <title>单线程和异步</title>
    <url>/2020/03/23/getOfferSinglethreadedandasynchronous/</url>
    <content><![CDATA[<h2 id="专题总结：单线程和异步"><a href="#专题总结：单线程和异步" class="headerlink" title="专题总结：单线程和异步"></a>专题总结：单线程和异步</h2><blockquote>
<p>拿到 字节跳动实习生 offer 总结</p>
<p>回馈分享一波自己的知识点总结</p>
</blockquote>
<blockquote>
<p>希望读者依此构建自己的知识树（思维导图）</p>
<p>偷懒一下：可参考我自己总结思维导图 : <a href="https://github.com/ZhChen7/Interview-mind-map">点这里</a></p>
<p>附带：高频面试题积累文档。 来自于（学长、牛客网等平台）</p>
<p>自己开发的博客地址：<a href="http://zxinc520.com/">zxinc520.com</a></p>
<p>github 地址: <a href="https://github.com/ZhChen7">点击</a></p>
</blockquote>
<blockquote>
<p>此篇 js - 【单线程和异步】 知识点： 全部弄懂了，面试很容易。</p>
</blockquote>
<h2 id="一、单线程和异步"><a href="#一、单线程和异步" class="headerlink" title="一、单线程和异步"></a>一、单线程和异步</h2><h3 id="1-1、同步-vs-异步"><a href="#1-1、同步-vs-异步" class="headerlink" title="1.1、同步 vs 异步"></a>1.1、同步 vs 异步</h3><ul>
<li>同步是什么？<ul>
<li>简单来说：一定要等任务执行完了，得到结果，才执行下一个任务。</li>
<li>指某段程序执行时会阻塞其它程序执行，其表现形式为程序的执行顺序依赖程序本身的书写顺序</li>
</ul>
</li>
<li>异步是什么？<ul>
<li>指某段程序执行时不会阻塞其它程序执行，其表现形式为程序的执行顺序不依赖程序本身的书写顺序</li>
<li>实现方式：event loop【事件轮询】</li>
</ul>
</li>
</ul>
<h3 id="1-2、异步和单线程"><a href="#1-2、异步和单线程" class="headerlink" title="1.2、异步和单线程"></a>1.2、异步和单线程</h3><ul>
<li><p>单线程</p>
<ul>
<li>是什么？单线程就是同时只做一件事，两段 JS 不能同时 执行</li>
<li>为什么是单线程？<ul>
<li>避免 DOM 渲染的冲突<ol>
<li>浏览器需要渲染 DOM</li>
<li>JS 可以修改 DOM 结构</li>
<li>JS 执行的时候，浏览器 DOM 渲染会暂停</li>
<li>两段 JS 也不能同时执行（都修改 DOM 就冲突了）</li>
<li>webworker 支持多线程，但是不能访问 DOM</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>单线程的解决方案 ？</p>
<ul>
<li>异步<ul>
<li>异步暴露出的问题<ol>
<li>没按照书写方式执行，可读性差</li>
<li>callback 中不容易模块化</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>event loop</p>
<ul>
<li>是什么？</li>
<li>事件轮询， JS 实现异步 的具体解决方案</li>
<li>具体<ul>
<li>同步代码，直接执行</li>
<li>异步函数先放在 异步队列 中</li>
<li>待同步函数执行完毕，轮询执行 异步队列 的函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-3、宏队列和微队列"><a href="#1-3、宏队列和微队列" class="headerlink" title="1.3、宏队列和微队列"></a>1.3、宏队列和微队列</h3><blockquote>
<p><code>macrotask</code>（宏任务） 和 <code>microtask</code>（微任务）</p>
<p>面试常考题【promise 回调函数和定时器任务的顺序问题】</p>
</blockquote>
<ul>
<li><p>宏任务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">script(整体代码)</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line"><span class="built_in">setInterval</span></span><br><span class="line">I/O</span><br><span class="line">UI交互事件</span><br><span class="line">postMessage</span><br><span class="line">MessageChannel</span><br><span class="line">setImmediate(Node.js 环境)</span><br></pre></td></tr></table></figure>
</li>
<li><p>微任务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.then</span><br><span class="line"><span class="built_in">Object</span>.observe</span><br><span class="line">MutaionObserver</span><br><span class="line">process.nextTick(Node.js 环境)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>执行机制：</p>
<ol>
<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>
<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>
<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>
<li>当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染</li>
<li>渲染完毕后，JS 引擎线程继续，开始下一个宏任务（从宏任务队列中获取）</li>
</ol>
<h4 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1 end&quot;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;settimeout&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"><span class="comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4、前端异步的场景"><a href="#1-4、前端异步的场景" class="headerlink" title="1.4、前端异步的场景"></a>1.4、前端异步的场景</h3><ul>
<li>简单来说：所有的 “ 等待情况” 都需要异步</li>
<li>定时任务：setTimeout，setInterval</li>
<li>网络请求：ajax 请求，动态 &lt;_img_ &gt; 加载</li>
<li>事件绑定</li>
</ul>
<h3 id="1-5、Web-Worker"><a href="#1-5、Web-Worker" class="headerlink" title="1.5、Web Worker"></a>1.5、Web Worker</h3><blockquote>
<p>就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p>
</blockquote>
<h3 id="1-6、模块化发展历程"><a href="#1-6、模块化发展历程" class="headerlink" title="1.6、模块化发展历程"></a>1.6、模块化发展历程</h3><blockquote>
<p>可从 IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module、&lt;_script type=”module”_ &gt; 这几个角度考虑。</p>
<p><strong>作用</strong> ：模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。</p>
</blockquote>
<ol>
<li><p>IIFE</p>
<ul>
<li><p>使用自执行函数来编写模块化</p>
</li>
<li><p>特点：</p>
<p>在一个单独的函数作用域中执行代码，避免变量冲突。</p>
</li>
</ul>
</li>
<li><p>AMD</p>
<ul>
<li><p>使用 requireJS 来编写模块化</p>
</li>
<li><p>特点：依赖必须提前声明好</p>
</li>
<li><p>简单实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="string">&quot;./index.js&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// code 就是index.js 返回的内容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>CMD</p>
<ul>
<li><p>使用 seaJS 来编写模块化</p>
</li>
<li><p>特点：支持动态引入依赖文件</p>
</li>
<li><p>简单实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> indexCode = <span class="built_in">require</span>(<span class="string">&quot;./index.js&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>CommonJS</p>
<ul>
<li>nodejs 中自带的模块化</li>
<li>var fs = require(‘fs’);</li>
</ul>
</li>
<li><p>UMD</p>
<ul>
<li>兼容 AMD，CommonJS 模块化语法</li>
</ul>
</li>
<li><p>webpack(require.ensure)</p>
<ul>
<li>webpack 2.x 版本中的代码分割</li>
</ul>
</li>
<li><p>ES Modules</p>
<ul>
<li>ES6 引入的模块化，支持 import 来引入另一个 js</li>
<li>import a from ‘a’;</li>
</ul>
</li>
</ol>
<h4 id="1-6-1、AMD-与-CMD-的比较"><a href="#1-6-1、AMD-与-CMD-的比较" class="headerlink" title="1.6.1、AMD 与 CMD 的比较"></a>1.6.1、AMD 与 CMD 的比较</h4><ul>
<li><p>定义</p>
<p>AMD 和 CMD 都是用于浏览器端的模块规范</p>
</li>
<li><p>AMD</p>
<ul>
<li>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出</li>
<li>其主要内容就是定义了 define 函数该如何书写，只要你按照这个规范书写模块和依赖，require.js 就能正确的进行解析。</li>
</ul>
</li>
<li><p>CMD</p>
<ul>
<li>CMD 其实就是 SeaJS 在推广过程中对模块定义的规范化产出</li>
<li>主要内容就是描述该如何定义模块，如何引入模块，如何导出模块，只要你按照这个规范书写代码，sea.js 就能正确的进行解析</li>
</ul>
</li>
<li><p>AMD 与 CMD 的区别</p>
<ol>
<li>AMD 推崇依赖前置，CMD 推崇依赖就近</li>
<li>AMD 是提前执行，CMD 是延迟执行。</li>
</ol>
</li>
</ul>
<h4 id="1-6-2、CommonJS-与-AMD-的比较"><a href="#1-6-2、CommonJS-与-AMD-的比较" class="headerlink" title="1.6.2、CommonJS 与 AMD 的比较"></a>1.6.2、CommonJS 与 AMD 的比较</h4><blockquote>
<p>在服务器端比如 node，采用的则是 CommonJS 规范。</p>
<p>AMD 和 CMD 都是用于浏览器端的模块规范</p>
</blockquote>
<ol>
<li><p>CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。</p>
</li>
<li><p>AMD 规范则是非同步加载模块，允许指定回调函数。</p>
<p>由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。</p>
</li>
<li><p>但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。</p>
</li>
</ol>
<h4 id="16-3、ES6-与-CommonJS-的比较"><a href="#16-3、ES6-与-CommonJS-的比较" class="headerlink" title="16.3、ES6 与 CommonJS 的比较"></a>16.3、ES6 与 CommonJS 的比较</h4><blockquote>
<p>注意！浏览器加载 ES6 模块，也使用 &lt;_script_ &gt; 标签，但是要加入 type=”module” 属性。</p>
</blockquote>
<ol>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</li>
</ol>
<h3 id="1-7、async-和-defer"><a href="#1-7、async-和-defer" class="headerlink" title="1.7、async 和 defer"></a>1.7、async 和 defer</h3><ul>
<li><p>共同点</p>
<p>两者都会并行下载，不会影响页面的解析。</p>
</li>
<li><p>defer：defer 会按照顺序在 DOMContentLoaded 前按照页面出现顺序依次执行。</p>
</li>
<li><p>async ：async 则是下载完立即执行</p>
</li>
<li><p>具体解析【剖析】</p>
<ul>
<li><p>先来看一个普通的 script 标签。&lt;_script src=”a.js”&gt;</script_ ></p>
<ul>
<li><p>浏览器会做如下处理：</p>
<p>1、停止解析 document.</p>
<p>2、请求 a.js</p>
<p>3、执行 a.js 中的脚本</p>
<p>4、继续解析 document</p>
</li>
</ul>
</li>
<li><pre><code class="js">&lt;script src=&quot;d.js&quot; defer&gt;&lt;/script&gt;
&lt;script src=&quot;e.js&quot; defer&gt;&lt;/script&gt;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  不阻止解析 document， 并行下载 d.js, e.js</span><br><span class="line"></span><br><span class="line">  即使下载完 d.js, e.js 仍继续解析 document</span><br><span class="line"></span><br><span class="line">  按照页面中出现的顺序，在其他同步脚本执行后，DOMContentLoaded 事件前 依次执行 d.js, e.js。</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;js</span><br><span class="line">  &lt;script src&#x3D;&quot;b.js&quot; async&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;c.js&quot; async&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

不阻止解析 document, 并行下载 b.js, c.js

当脚本下载完后立即执行。（两者执行顺序不确定，执行阶段不确定，可能在 DOMContentLoaded 事件前或者后 ）
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="async-和-defer-总结"><a href="#async-和-defer-总结" class="headerlink" title="async 和 defer 总结"></a>async 和 defer 总结</h4><ul>
<li><p>两者都不会阻止 document 的解析</p>
</li>
<li><p>defer 会在 DOMContentLoaded 前依次执行 （可以利用这两点哦！）</p>
</li>
<li><p>async 则是下载完立即执行，不一定是在 DOMContentLoaded 前</p>
</li>
<li><p>async 因为顺序无关，所以很适合像 Google Analytics 这样的无依赖脚本</p>
</li>
</ul>
<h3 id="1-8、异步编程-6-种解决方案"><a href="#1-8、异步编程-6-种解决方案" class="headerlink" title="1.8、异步编程 6 种解决方案"></a>1.8、异步编程 6 种解决方案</h3><ol>
<li><p>回调函数（Callback）</p>
<ul>
<li><p>回调函数是异步操作最基本的方法</p>
</li>
<li><p>ajax(url, () =&gt; {</p>
<p>​ // 处理逻辑</p>
<p>})</p>
</li>
<li><p>缺点</p>
<ul>
<li>容易写出回调地狱（Callback hell）</li>
<li>不能使用 try catch 捕获错误，不能直接 return</li>
</ul>
</li>
</ul>
</li>
<li><p>事件监听</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1.on(<span class="string">&quot;done&quot;</span>, f2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布订阅</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery.subscribe(<span class="string">&quot;done&quot;</span>, f2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise</p>
<ul>
<li><p>是什么？</p>
<ul>
<li>promise 是目前 JS 异步编程的主流解决方案，遵循 Promises/A+ 方案。Promise 用于异步操作，表示一个还未完成但是预期会完成的操作。</li>
<li>Promise 是 ES6 引入的一个新的对象，他的主要作用是用来解决 JS 异步机制里，回调机制产生的“回调地狱”。它并不是什么突破性的 API，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用。</li>
</ul>
</li>
<li><p>剖析</p>
<ul>
<li><p>promise 本身相当于一个状态机，拥有三种状态</p>
<ul>
<li>pending</li>
<li>fulfilled</li>
<li>rejected</li>
</ul>
<p>一个 promise 对象初始化时的状态是 pending，调用了 resolve 后会将 promise 的状态扭转为 fulfilled，调用 reject 后会将 promise 的状态扭转为 rejected，这两种扭转一旦发生便不能再扭转该 promise 到其他状态。</p>
</li>
</ul>
</li>
<li><p>Promise 如何使用</p>
<p>构造一个 promise 对象，并将要执行的异步函数传入到 promise 的参数中执行，并且在异步执行结束后调用 resolve( ) 函数，就可以在 promise 的 then 方法中获取到异步函数的执行结果</p>
</li>
<li><p>Promise 原型上的方法</p>
<ol>
<li>Promise.prototype.then(onFulfilled, onRejected)</li>
<li>Promise.prototype.catch(onRejected)</li>
<li>Promise.prototype.finally(onFinally)</li>
</ol>
</li>
<li><p>Promise 静态方法</p>
<ol>
<li><p>Promise.all()</p>
<p>Promise.all 接收一个 promise 对象数组作为参数，只有全部的 promise 都已经变为 fulfilled 状态后才会继续后面的处理</p>
</li>
<li><p>Promise.race()</p>
<p>这个函数会在 promises 中第一个 promise 的状态扭转后就开始后面的处理（fulfilled、rejected 均可）</p>
</li>
<li><p>Promise.resolve()</p>
</li>
<li><p>Promise.reject()</p>
</li>
</ol>
</li>
<li><p>优点</p>
<p>将异步操作以同步操作的流程表达出来，promise 链式调用，更好地解决了层层嵌套的回调地狱</p>
</li>
<li><p>缺点</p>
<ol>
<li>不能取消执行。</li>
<li>无法获取当前执行的进度信息（比如，要在用户界面展示进度条）。</li>
<li>外部无法捕捉 Promise 内部抛出的错误</li>
</ol>
</li>
</ul>
</li>
<li><p>generator 函数</p>
<ul>
<li><p>是什么</p>
<ul>
<li>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</li>
<li>如果说 JavaScript 是 ECMAScript 标准的一种具体实现、Iterator 遍历器是 Iterator 的具体实现，那么 Generator 函数可以说是 Iterator 接口的具体实现方式。</li>
<li>Generator 函数可以通过配合 Thunk 函数更轻松更优雅的实现异步编程和控制流管理</li>
</ul>
</li>
<li><p>描述</p>
<ul>
<li>执行 Generator 函数会返回一个遍历器对象，每一次 Generator 函数里面的 yield 都相当一次遍历器对象的 next()方法，并且可以通过 next(value)方法传入自定义的 value,来改变 Generator 函数的行为。</li>
</ul>
</li>
<li><p>能封装异步任务的根本原因</p>
<ul>
<li>最大特点就是可以交出函数的执行权（即暂停执行）。Generator 函数可以暂停执行和恢复执行</li>
</ul>
</li>
<li><p>两个特征</p>
<ul>
<li>function 关键字与函数名之间有一个星号</li>
<li>函数体内部使用 yield 表达式，定义不同的内部状态（yield 在英语里的意思就是“产出”）。</li>
</ul>
</li>
<li><p>过程</p>
<p>Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）</p>
</li>
<li><p>Generator 及其异步方面的应用</p>
<ul>
<li>Generator 函数将 JavaScript 异步编程带入了一个全新的阶段</li>
</ul>
</li>
<li><p>总结</p>
<p>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值；done 属性是一个布尔值，表示是否遍历结束。</p>
</li>
<li><p>demo</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&quot;node-fetch&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">&quot;https://api.github.com/users/github&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>async 和 await</p>
<ul>
<li><p>含义</p>
<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>
</li>
<li><p>是什么？</p>
<ul>
<li>一句话，它就是 Generator 函数的语法糖。</li>
<li>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。</li>
<li>async 函数可以理解为内置自动执行器的 Generator 函数语法糖，它配合 ES6 的 Promise 近乎完美的实现了异步编程解决方案。</li>
</ul>
</li>
<li><p>相对于 Promise，优势体现在</p>
<ol>
<li>处理 then 的调用链，能够更清晰准确的写出代码</li>
<li>并且也能优雅地解决回调地狱问题</li>
</ol>
</li>
<li><p>相对 Generator 函数，体现在以下 4 点</p>
<ol>
<li>内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行</li>
<li>更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果</li>
<li>更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）</li>
<li>返回值是 Promise。async 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用 then 方法指定下一步的操作。</li>
</ol>
</li>
<li><p>缺点</p>
<p>当然 async/await 函数也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise.all 的方式。</p>
</li>
</ul>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>JS 异步编程进化史：callback -&gt; promise -&gt; generator -&gt; async + await</li>
<li>async/await 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里</li>
<li>async/await 可以说是异步终极解决方案了</li>
</ol>
<h2 id="二、相关面试问题"><a href="#二、相关面试问题" class="headerlink" title="二、相关面试问题"></a>二、相关面试问题</h2><ol>
<li><p>什么是单线程，和异步有什么关系？</p>
<ul>
<li>单线程就是同时只做一件事，两段 JS 不能同时 执行</li>
<li>原因就是 为了避免 DOM 渲染的冲突</li>
<li>异步是一种 “无奈” 的解决方案，虽然有很多问题</li>
</ul>
</li>
<li><p>是否用过 jQuery 的 Deferred</p>
<ul>
<li><p>步骤</p>
<p>可以 jQuery 1.5 对 ajax 的改变举例</p>
<p>说明如何简单的封装，使用 Deferred</p>
<p>说明 ES6 promise 和 Deferred 的区别</p>
</li>
<li><p>jQuery 1.5 的变化</p>
<ul>
<li><p>无法改变 JS 异步和单线程的本质</p>
</li>
<li><p>只能从写法上杜绝 callback 这种形式</p>
</li>
<li><p>它是一种语法糖形式，但是解耦了代码</p>
</li>
<li><p>很好的体现：开放封闭原则</p>
</li>
<li><p>ajax 为例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = $.ajax(<span class="string">&quot;data.json&quot;</span>);</span><br><span class="line">ajax</span><br><span class="line">  .done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success 1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .fail(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success 2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ajax); <span class="comment">//返回一个 deferred 对象</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使用 jQuery Deferred</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitHandle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dtd = $.Deferred(); <span class="comment">//创建一个 Deferred 对象</span></span><br><span class="line">  <span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span> (<span class="params">dtd</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//要求传入一个 Deferred 对象</span></span><br><span class="line">    <span class="keyword">var</span> task = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;执行完成&quot;</span>);</span><br><span class="line">      dtd.resolve(); <span class="comment">//表示异步任务已经完成</span></span><br><span class="line">      <span class="comment">// dtd.reject()  //表示异步任务失败或出错</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">setTimeout</span>(task, <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> dtd; <span class="comment">// 要求返回 Deferred 对象</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 注意，这里一定要有返回值</span></span><br><span class="line">  <span class="keyword">return</span> wait(dtd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
        <category>JS 三座大山</category>
        <category>Offer</category>
        <category>字节跳动</category>
      </categories>
      <tags>
        <tag>面试全面总结</tag>
        <tag>JS 三座大山</tag>
      </tags>
  </entry>
  <entry>
    <title>html 面试考点全面总结下篇</title>
    <url>/2020/03/23/getOfferhtml2/</url>
    <content><![CDATA[<h2 id="html-面试考点全面总结下篇"><a href="#html-面试考点全面总结下篇" class="headerlink" title="html 面试考点全面总结下篇"></a>html 面试考点全面总结下篇</h2><blockquote>
<p>拿到 字节跳动实习生 offer 总结</p>
<p>回馈分享一波自己的知识点总结</p>
</blockquote>
<blockquote>
<p>希望读者依此构建自己的知识树（思维导图）</p>
<p>偷懒一下：可参考我自己总结思维导图 : <a href="https://github.com/ZhChen7/Interview-mind-map">点这里</a></p>
<p>附带：高频面试题积累文档。 来自于（学长、牛客网等平台）</p>
<p>自己开发的博客地址：<a href="http://zxinc520.com/">zxinc520.com</a></p>
<p>github 地址: <a href="https://github.com/ZhChen7">点击</a></p>
</blockquote>
<blockquote>
<p>此篇 html 共总结 22 大知识点： 全部弄懂了，面试很容易。</p>
</blockquote>
<h3 id="11、label-标签"><a href="#11、label-标签" class="headerlink" title="11、label 标签"></a>11、label 标签</h3><blockquote>
<p>作用：用于定义表单控件的关系，点击时自动将焦点移至相关联的控件。</p>
</blockquote>
<h4 id="两个有用属性"><a href="#两个有用属性" class="headerlink" title="两个有用属性"></a>两个有用属性</h4><ul>
<li>for<ul>
<li>关联相关控件</li>
<li>通过控件 id 关联</li>
</ul>
</li>
<li>accessKey ：设置访问快捷键 例如：accesskey=”h”</li>
</ul>
<blockquote>
<p><strong>注意</strong> ：该标签不能为 a 和 button 标签的后代</p>
</blockquote>
<h3 id="12、link-与-import"><a href="#12、link-与-import" class="headerlink" title="12、link 与 @import"></a>12、link 与 @import</h3><blockquote>
<p>link ：建议使用</p>
<p>@import ：慎用 【会造成 “无样式内容闪烁”】</p>
</blockquote>
<h4 id="link-与-import-区别"><a href="#link-与-import-区别" class="headerlink" title="link 与 @import 区别"></a>link 与 @import 区别</h4><ol>
<li>从属和作用<ul>
<li>link 是 HTML 提供的标签<ul>
<li>可以加载 css</li>
<li>可以定义 rel 等属性（rel 属性规定当前文档与被链接文档之间的关系。） 【技巧：这里引申到 预加载知识：可以关注 Resource Hint 标准 — <strong>页面加载性能利器</strong>】</li>
</ul>
</li>
<li>@import 是 css 提供的语法<ul>
<li>只有导入样式表的作用</li>
</ul>
</li>
</ul>
</li>
<li>加载顺序<ul>
<li>link 在页面加载时 css 同时被加载</li>
<li>@import 引入的 css 需要等页面加载后再加载</li>
</ul>
</li>
<li>兼容性问题<ul>
<li>link 是 HTML 提供的语法，没有兼容性问题</li>
<li>@import 是 css2.1 提供的语法，ie5 以上才兼容</li>
</ul>
</li>
<li>DOM 可控性<ul>
<li>js 可以通过插入 link 标签来改变样式</li>
<li>js 不可以通过 @import 去引入新的 css 文件来改变样式</li>
</ul>
</li>
</ol>
<h3 id="13、target"><a href="#13、target" class="headerlink" title="13、target"></a>13、target</h3><blockquote>
<p>属性作用：指定所连接的页面在浏览器窗口中的打开方式</p>
</blockquote>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul>
<li>_self（默认值）：在当前窗口打开</li>
<li>_blank： 在新窗口中打开</li>
<li>_parent ： 在父级窗口打开</li>
<li>_top ： 在顶级窗口打开</li>
</ul>
<h3 id="14、部分标签-属性区别"><a href="#14、部分标签-属性区别" class="headerlink" title="14、部分标签/属性区别"></a>14、部分标签/属性区别</h3><h4 id="标签区别"><a href="#标签区别" class="headerlink" title="标签区别"></a>标签区别</h4><ul>
<li>title 和 h1<ul>
<li>title ：只表示是个标题</li>
<li>h1-h7<ul>
<li>表示层次明确的标题</li>
<li>对页面信息的抓取有帮助</li>
</ul>
</li>
</ul>
</li>
<li>b 与 strong<ul>
<li>b：展示为粗体</li>
<li>strong<ul>
<li>标明重点内容，有语气加强的含义 u</li>
<li>使用阅读设备时，会重读</li>
</ul>
</li>
</ul>
</li>
<li>i 与 em<ul>
<li>i：展示为斜体</li>
<li>em：表示强调的文本</li>
</ul>
</li>
</ul>
<h4 id="属性区别"><a href="#属性区别" class="headerlink" title="属性区别"></a>属性区别</h4><ul>
<li>src 与 href<ul>
<li>src：引入 ; 将指定资源应用到文档内.</li>
<li>href：引用 ; 建立与当前文档之间的链接.</li>
</ul>
</li>
<li>【img】title 和 alt<ul>
<li>title<ul>
<li>全局属性</li>
<li>提供关于元素的额外信息</li>
<li>鼠标移至显示</li>
</ul>
</li>
<li>alt<ul>
<li>用于图片无法加载时显示</li>
<li>web Quality（无障碍）易访问的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="15、Shadow-DOM（影子-DOM）"><a href="#15、Shadow-DOM（影子-DOM）" class="headerlink" title="15、Shadow DOM（影子 DOM）"></a>15、Shadow DOM（影子 DOM）</h3><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><blockquote>
<p>浏览器的一种能力 ：渲染时插入独立的 DOM 树</p>
</blockquote>
<h4 id="特点？"><a href="#特点？" class="headerlink" title="特点？"></a>特点？</h4><ul>
<li>与原始 DOM 完全隔离</li>
<li>具有自己的元素和样式</li>
</ul>
<h4 id="作用？"><a href="#作用？" class="headerlink" title="作用？"></a>作用？</h4><ul>
<li>封装需要隔离外部的文档细节/组件</li>
<li>防止开发人员随意修改样式</li>
</ul>
<h4 id="使用方式？"><a href="#使用方式？" class="headerlink" title="使用方式？"></a>使用方式？</h4><ul>
<li>Node1.attachShadow(Node2)</li>
<li>Node2.innerHTML = ….</li>
</ul>
<h3 id="16、浏览器的数据存储方式有哪些"><a href="#16、浏览器的数据存储方式有哪些" class="headerlink" title="16、浏览器的数据存储方式有哪些"></a>16、浏览器的数据存储方式有哪些</h3><blockquote>
<p>分为三类来讲：</p>
<p>cookie 、localStorage 和 sessionStorage 、userData。</p>
</blockquote>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><blockquote>
<p>h5 之前，存储主要用 cookies，缺点是在请求头上带着数据，导致流量增加。大小限制 4k</p>
</blockquote>
<h5 id="创建目的"><a href="#创建目的" class="headerlink" title="创建目的"></a>创建目的</h5><ul>
<li>为了保持 HTTP 的状态</li>
<li>为了识别用户信息而储存在本地上的数据</li>
</ul>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>可储存大小为 4k</li>
<li>储存个数有限制（各浏览器不同）</li>
<li>有效时间在设置的 cookie 过期时间之前一直有效</li>
</ol>
<h4 id="localStorage-和-sessionStorage"><a href="#localStorage-和-sessionStorage" class="headerlink" title="localStorage 和 sessionStorage"></a>localStorage 和 sessionStorage</h4><blockquote>
<p>创建目的：便于客户端储存数据</p>
</blockquote>
<h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h5><ul>
<li>都由 HTML5 Web Storage API 提供</li>
<li>在本地保存</li>
<li>可储存大小 5M 以上</li>
</ul>
<h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5><ul>
<li>有效时间不同<ul>
<li>localStorage（以键值对(Key-Value)的方式存储）<ul>
<li>储存持久数据</li>
<li>浏览器关闭后数据不丢失除非主动清除数据</li>
</ul>
</li>
<li>sessionStorage<ul>
<li>数据在当前浏览器关闭后自动删除</li>
</ul>
</li>
</ul>
</li>
<li>作用域不同<ul>
<li>localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。</li>
<li>sessionStorage 不在不同的浏览器页面中共享，即使是同一个页面</li>
</ul>
</li>
</ul>
<blockquote>
<p>安全性：需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的，因为它们保存在本地容易被篡改，使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。所以千万不要用它们存储你系统中的敏感数据。</p>
</blockquote>
<h4 id="userData"><a href="#userData" class="headerlink" title="userData"></a>userData</h4><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul>
<li>IE 专属 ：早期 IE 浏览器用来本地储存数据用的</li>
<li>以文件的形式保存在磁盘上 ：持久化储存方式</li>
<li>可以设置失效日期</li>
<li>可储存大小 1MB 左右</li>
</ul>
<blockquote>
<p>注意：使用 IE 条件注释来避免其它浏览器载入上述代码 &lt;_!–[if IE]&gt;&lt;[end If]–_ &gt;</p>
</blockquote>
<h3 id="17、如何实现标签页面的通信"><a href="#17、如何实现标签页面的通信" class="headerlink" title="17、如何实现标签页面的通信"></a>17、如何实现标签页面的通信</h3><ol>
<li><p>方法一 ：使用 localStorage</p>
<ul>
<li><p>使用 localStorage.setItem(key,value) 添加内容</p>
</li>
<li><p>使用 Storage 事件监听添加、修改、删除的动作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onstorage = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(e)&#125;</span><br><span class="line"><span class="comment">// 或者这样</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;storage&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(e)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>方法二：使用 cookie+setInterval</p>
<ul>
<li>将要传递的信息储存在 cookie 中</li>
<li>每隔一定时间读取 cookie 信息，获取要传递的信息</li>
<li><strong>具体描述</strong> ：1、在页面 A 设置一个使用 setInterval 定时器不断刷新，检查 Cookies 的值是否发生变化，如果变化就进行刷新的操作。 2、由于 Cookies 是在同域可读的，所以在页面 B 审核的时候改变 Cookies 的值，页面 A 自然是可以拿到的。这样做确实可以实现我想要的功能，但是这样的方法相当浪费资源。虽然在这个性能过盛的时代，浪费不浪费也感觉不出来，但是这种实现方案，确实不够优雅。</li>
</ul>
</li>
<li><p>方法三 ：websocket 通讯（HTML5）</p>
<ul>
<li>定义：WebSocket 是 HTML5 新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。</li>
<li>WebSocket 连接必须由浏览器发起，特点<ul>
<li>建立在 TCP 协议之上，服务器端的实现比较容易。</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
<li>数据格式比较轻量，性能开销小，通信高效。</li>
<li>可以发送文本，也可以发送二进制数据。</li>
<li>没有同源限制，客户端可以与任意服务器通信。</li>
<li>协议标识符是 ws（如果加密，则为 wss），服务器网址就是</li>
</ul>
</li>
</ul>
</li>
<li><p>SharedWorker（html5 浏览器的新特性 SharedWorker）</p>
<ul>
<li>本质还是单线程，只是利用了浏览器不同 JS 引擎</li>
<li>必须在服务器上才跑得动</li>
<li>IE 未兼容</li>
</ul>
</li>
</ol>
<h3 id="18、谈谈-cookie-和-session-的区别"><a href="#18、谈谈-cookie-和-session-的区别" class="headerlink" title="18、谈谈 cookie 和 session 的区别"></a>18、谈谈 cookie 和 session 的区别</h3><blockquote>
<p>共同点：记录用户状态</p>
</blockquote>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><h5 id="cookie-1"><a href="#cookie-1" class="headerlink" title="cookie"></a>cookie</h5><ul>
<li><p>什么是 Cookie？</p>
<p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
</li>
<li><p>采用的是在客户端保持状态的方案 ： 即运行在客户端</p>
</li>
<li><p>有大小限制，存储个数有限</p>
</li>
<li><p>有安全隐患 ：通过某些手法可以篡改本地储存的信息来欺骗客户端</p>
</li>
<li><p>支持跨域名访问</p>
</li>
</ul>
<h5 id="session"><a href="#session" class="headerlink" title="session"></a>session</h5><ul>
<li><p>什么是 Session？</p>
<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
</li>
<li><p>采用的是在服务端保持状态的方案： 即运行在服务端</p>
</li>
<li><p>没有大小限制和服务器内存大小有关</p>
</li>
<li><p>过多会增加服务器压力</p>
</li>
<li><p>仅在他所在的域名内有效</p>
</li>
</ul>
<h4 id="cookie-和-session-流程介绍"><a href="#cookie-和-session-流程介绍" class="headerlink" title="cookie 和 session 流程介绍"></a>cookie 和 session 流程介绍</h4><blockquote>
<p>1、用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>
<p>2、当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>
<p>3、根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p>
</blockquote>
<h4 id="18-1、既然服务端是根据-Cookie-中的信息判断用户是否登录，那么如果浏览器中禁止了-Cookie，如何保障整个机制的正常运转"><a href="#18-1、既然服务端是根据-Cookie-中的信息判断用户是否登录，那么如果浏览器中禁止了-Cookie，如何保障整个机制的正常运转" class="headerlink" title="18.1、既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转"></a>18.1、既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转</h4><ul>
<li><p>第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 xxx?SessionID=123456…。</p>
</li>
<li><p>第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。</p>
<p>Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。</p>
<p>当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。</p>
</li>
</ul>
<h4 id="18-2、如何考虑分布式-Session-问题？"><a href="#18-2、如何考虑分布式-Session-问题？" class="headerlink" title="18.2、如何考虑分布式 Session 问题？"></a>18.2、如何考虑分布式 Session 问题？</h4><ul>
<li>在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。</li>
<li>分布式 Session 一般会有以下几种解决方案<ul>
<li>Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</li>
<li>Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</li>
<li>共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。</li>
</ul>
</li>
</ul>
<h4 id="18-3、cookie-和-session-各自优势"><a href="#18-3、cookie-和-session-各自优势" class="headerlink" title="18.3、cookie 和 session 各自优势"></a>18.3、cookie 和 session 各自优势</h4><h5 id="cookie-2"><a href="#cookie-2" class="headerlink" title="cookie"></a>cookie</h5><ul>
<li>极高的扩展性和可用性</li>
<li>不需要使用大量服务器资源</li>
<li>简单性 Cookie 是一种基于文本的轻量结构，包含简单的键值对，结构简单。</li>
</ul>
<h5 id="session-1"><a href="#session-1" class="headerlink" title="session"></a>session</h5><ul>
<li>易于读写</li>
<li>易于站点的用户化</li>
</ul>
<h4 id="18-4：cookie-和-session-常见攻击方式及解决方案"><a href="#18-4：cookie-和-session-常见攻击方式及解决方案" class="headerlink" title="18.4：cookie 和 session 常见攻击方式及解决方案"></a>18.4：cookie 和 session 常见攻击方式及解决方案</h4><h5 id="cookie-3"><a href="#cookie-3" class="headerlink" title="cookie"></a>cookie</h5><ul>
<li>具体<ul>
<li>直接访问 Cookie 文件查找想要的机密文件</li>
<li>进行 Cookie 信息传递时被截取</li>
<li>攻击者伪造 Cookie 信息，客户端获取后进行操作</li>
</ul>
</li>
<li>解决方案<ul>
<li>不要早 Cookie 中保存敏感信息</li>
<li>不要早 Cookie 中保存没有经过加密的或者容易被解密的敏感信息</li>
<li>对从客户端获取得的 Cookie 信息进行严格校验</li>
</ul>
</li>
</ul>
<h5 id="session-2"><a href="#session-2" class="headerlink" title="session"></a>session</h5><ul>
<li>具体<ul>
<li>会话劫持（通过获取用户 Session ID 后，使用该 Session ID 登录目标账号）</li>
<li>会话固定（诱骗受害者使用攻击者指定的会话标识 Session ID 的攻击手段）</li>
</ul>
</li>
<li>解决方案<ul>
<li>使用 User-Agent 检测请求的一致性，设置 HttpOnly，可以防止客户端脚本访问这个 Cookie，从而有效的防止 XSS 攻击；关闭透明化 Session ID；更改 Session 名称</li>
<li>用户登录时生成新的 Session ID</li>
</ul>
</li>
</ul>
<h3 id="19、谈谈对-WebSocket-的认识"><a href="#19、谈谈对-WebSocket-的认识" class="headerlink" title="19、谈谈对 WebSocket 的认识"></a>19、谈谈对 WebSocket 的认识</h3><blockquote>
<p>创建原因：HTTP 协议只能由客户端发起 单向连接</p>
</blockquote>
<h4 id="19-1、是什么？"><a href="#19-1、是什么？" class="headerlink" title="19.1、是什么？"></a>19.1、是什么？</h4><ul>
<li>HTML5 中的协议，支持持久连接</li>
<li>WebSocket 是基于 HTTP 协议的 ： 借用了 Http 协议来完成一部分握手</li>
<li>是真正意义上的双向绑定</li>
</ul>
<h4 id="19-2、WebSocket-区别-http-协议"><a href="#19-2、WebSocket-区别-http-协议" class="headerlink" title="19.2、WebSocket 区别 http 协议"></a>19.2、WebSocket 区别 http 协议</h4><ul>
<li>http 协议 不支持持久性连接</li>
<li>HTTP1.1 中出现 keep-alive，合并多个 http 请求</li>
<li>HTTP 的生命周期通过 Request 来界定 ： 一个 Request 对应一个 Response</li>
<li>Response 是被动的，不能主动发起</li>
</ul>
<h4 id="19-3、如何模拟双向通信"><a href="#19-3、如何模拟双向通信" class="headerlink" title="19.3、如何模拟双向通信"></a>19.3、如何模拟双向通信</h4><ul>
<li>短轮询<ul>
<li>客户端定时向服务器发送 Ajax 请求，服务器接到请求后马上返回响应信息并关闭连接。</li>
<li>优点 ： 后端编写容易</li>
<li>缺点 ： 请求中大半是无用，浪费宽带和服务器资源</li>
<li>适用 ： 小型应用</li>
</ul>
</li>
<li>长轮询<ul>
<li>客户端向服务器发送 Ajax 请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。</li>
<li>优点 ：在无消息的情况下不会频繁的请求，耗费资源小</li>
<li>缺点<ul>
<li>服务器 hold 连接会消耗资源</li>
<li>返回数据顺序无保证，难于管理维护</li>
</ul>
</li>
</ul>
</li>
<li>长连接<ul>
<li>在页面嵌入一个隐藏 iframe，将这个隐藏 iframe 的 src 属性设为对一个长连接的请求或是采用 xhr 请求，服务器端就能源源不断的往客户端输入数据</li>
<li>优点<ul>
<li>消息及时到达，不发无用请求</li>
<li>管理起来也相对方便</li>
</ul>
</li>
<li>缺点：服务器维护一个长连接会增加开销</li>
</ul>
</li>
</ul>
<h3 id="20、渲染-了解网页渲染流程与优化技巧"><a href="#20、渲染-了解网页渲染流程与优化技巧" class="headerlink" title="20、渲染 | 了解网页渲染流程与优化技巧"></a>20、渲染 | 了解网页渲染流程与优化技巧</h3><h4 id="20-1、生成网页步骤"><a href="#20-1、生成网页步骤" class="headerlink" title="20.1、生成网页步骤"></a>20.1、生成网页步骤</h4><ul>
<li>HTML 代码转成 DOM（Document Object Model）： 解析 HTML 生成</li>
<li>CSS 代码转化成 CSSOM（CSS Object Model）： 解析 CSS 生成</li>
<li>结合 DOM 和 CSSOM 生成一颗渲染树： 包含每个节点的视觉信息</li>
<li>生成布局（layout）： 将所有渲染树的所有节点进行平面合成</li>
<li>将布局绘制（paint）在屏幕上</li>
</ul>
<h4 id="20-2、重新渲染-（重排【回流】和重绘）"><a href="#20-2、重新渲染-（重排【回流】和重绘）" class="headerlink" title="20.2、重新渲染 （重排【回流】和重绘）"></a>20.2、重新渲染 （重排【回流】和重绘）</h4><h5 id="重排（回流）"><a href="#重排（回流）" class="headerlink" title="重排（回流）"></a>重排（回流）</h5><blockquote>
<p>重新生成布局</p>
</blockquote>
<h5 id="布局改了就一定会重排"><a href="#布局改了就一定会重排" class="headerlink" title="布局改了就一定会重排"></a>布局改了就一定会重排</h5><ol>
<li>添加或删除可见的 DOM 元素</li>
<li>元素位置改变</li>
<li>元素尺寸改变——边距、填充、边框、宽度和高度</li>
<li>内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；</li>
<li>页面渲染器初始化</li>
<li>浏览器窗口尺寸改变——resize 事件发生时；</li>
</ol>
<blockquote>
<p>重排一定需要重绘</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">var s = document.body.style;</span><br><span class="line">s.padding = &quot;2px&quot;; // 回流+重绘</span><br><span class="line">s.border = &quot;1px solid red&quot;; // 再一次 回流+重绘</span><br><span class="line">s.color = &quot;blue&quot;; // 重绘</span><br><span class="line">s.backgroundColor = &quot;#ccc&quot;; // 重绘</span><br><span class="line">s.fontSize = &quot;14px&quot;; // 再一次 回流+重绘</span><br><span class="line">document.body.appendChild(document.createTextNode(&#x27;abc!&#x27;));// 添加node，再一次 回流+重绘</span><br></pre></td></tr></table></figure>

<h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><blockquote>
<p>只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫称为重绘。</p>
</blockquote>
<h4 id="重新渲染出现情况"><a href="#重新渲染出现情况" class="headerlink" title="重新渲染出现情况"></a>重新渲染出现情况</h4><ul>
<li>修改 DOM</li>
<li>修改样式表</li>
<li>用户事件<ul>
<li>鼠标悬停</li>
<li>页面滚动</li>
<li>输入框输入文字</li>
<li>改变窗口等</li>
</ul>
</li>
</ul>
<h3 id="21、性能优化技巧"><a href="#21、性能优化技巧" class="headerlink" title="21、性能优化技巧"></a>21、性能优化技巧</h3><blockquote>
<p>回答性能优化问题时：分两层阐述：</p>
<p>1、底层：重排【回流】和重绘层级 — 下面针对此层</p>
<p>2、应用层（雅虎军规 35 条）— 在性能优化专题会仔细分析。</p>
</blockquote>
<h4 id="21-1、减少重新渲染频率"><a href="#21-1、减少重新渲染频率" class="headerlink" title="21.1、减少重新渲染频率"></a>21.1、减少重新渲染频率</h4><ol>
<li><p>DOM 的多个读/写操作应该放在一起。</p>
<ul>
<li>不要两个读操作之间，加入一个写操作</li>
</ul>
</li>
<li><p>如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候又要重排</p>
</li>
<li><p>不要一条条地改变样式</p>
<ul>
<li>通过改变 class，csstext，一次改变样式</li>
</ul>
</li>
<li><p>尽量使用离线 DOM，而不是真实的网页 DOM，来改变元素样式</p>
<ul>
<li><p>例如</p>
<ul>
<li><p>操作 Document Fragment 对象</p>
</li>
<li><p>cloneNode 克隆节点操作后替换</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用虚拟 DOM 的脚本库，比如 React，vue 等</p>
</li>
<li><p>很新颖（嘻嘻）</p>
</li>
</ol>
<ul>
<li>设为 dispaly：none（需要一次重排和重绘）后进行 n 次操作，最后再恢复显示（需要一次重排和重绘）</li>
<li>用两次重新渲染，取代了可能 n（可能是个大树）次的重新渲染</li>
<li>只有在必要的时候，才将元素的 display 属性为可见</li>
<li>visibility:hidden 的元素只对重绘有影响，不影响重排</li>
<li>隐藏后不可见的元素读写不影响重排和重绘</li>
</ul>
<ol start="7">
<li><p>使用调整重新渲染的方法 ： 可以大幅度提高网页性能</p>
<ul>
<li>使用 window.requestAnimationFrame()方法<ul>
<li>作用：将某些代码放到下一次重新渲染时执行</li>
<li>适用<ul>
<li>页面滚动事件的监听函数</li>
<li>网页动画</li>
</ul>
</li>
</ul>
</li>
<li>使用 window.requestdleCallback()方法<ul>
<li>暂时就 Chrome 支持</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="21-2、减少渲染成本"><a href="#21-2、减少渲染成本" class="headerlink" title="21.2、减少渲染成本"></a>21.2、减少渲染成本</h4><ul>
<li><p>position 属性为 absolute 或 fixed 的元素，重排的开销会比较小</p>
<p>因为它们脱离文档，不用考虑他们对其他元素的影响，所以用 absolute，而少用 float</p>
</li>
</ul>
<h3 id="22、HTML5-概括"><a href="#22、HTML5-概括" class="headerlink" title="22、HTML5 概括"></a>22、HTML5 概括</h3><blockquote>
<p>HTML（超文本标记语言 HyperText Markup Language）的最新本版本</p>
</blockquote>
<h4 id="新增特性"><a href="#新增特性" class="headerlink" title="新增特性"></a>新增特性</h4><ol>
<li><p>语义化元素 推荐使用</p>
</li>
<li><p>新的通讯方式</p>
<ul>
<li>WebSockets</li>
<li>重新绘制界面 布局没改，样式改了，需要重绘，不一定重排</li>
</ul>
</li>
<li><p>缓存</p>
<ul>
<li>应用程序缓存<ul>
<li>使用方式<ul>
<li>&lt;_html manifest=”demo.appcache”_ &gt;</li>
<li>manifest 文件的建议的文件扩展名是：”.appcache”</li>
</ul>
</li>
<li>优点<ul>
<li>离线浏览 - 用户可在应用离线时使用它们</li>
<li>更快速度 - 已缓存资源加载得更快</li>
<li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li>
</ul>
</li>
</ul>
</li>
<li>浏览器缓存<ul>
<li>Web Storage<ul>
<li>localStorage</li>
<li>sessionStorage</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>多媒体</p>
<ul>
<li>audio</li>
<li>video</li>
</ul>
</li>
<li><p>3D &amp; 图像</p>
<ul>
<li>canvas</li>
<li>WebGL：用 canvas 元素中的 API 实现 3D 图像功能</li>
<li>svg ：基于 XML 直接嵌入到 HTML 中的矢量图形格式</li>
</ul>
</li>
<li><p>性能 &amp; 集成</p>
<ul>
<li><p>Web workers</p>
<p>Web Worker 是为了解决 JavaScript 在浏览器环境中没有多线程的问题。正常形况下，浏览器执行某段程序的时候会阻塞直到运行结束后在恢复到正常状态，而 HTML5 的 Web Worker 就是为了解决这个问题，提升程序的执行效率。 所以 Web Worker 的最佳使用场景是执行一些开销较大的数据处理或计算任务。</p>
</li>
<li><p>web worker 的创建</p>
<ul>
<li>worker 是一个对象，通过构造函数 Worker 创建，参数就是一个 js 文件的路径；文件中的 js 代码将运行在主线程之外的 worker 线程；</li>
<li>例如：var myWorker = new Worker(‘worker.js’);</li>
</ul>
</li>
<li><p>History API ：允许对浏览器历史记录进行操作</p>
</li>
<li><p>XMLHttpRequest Level 2(（XHR）对象可以与服务器交互。)</p>
<p>新版本功能：</p>
<ul>
<li>可以设置 HTTP 请求的时限</li>
<li>可以使用 FormData 对象管理表单数据。</li>
<li>可以上传文件。</li>
<li>可以请求不同域名下的数据（跨域请求）</li>
<li>可以获取服务器端的二进制数据</li>
<li>可以获得数据传输的进度信息</li>
</ul>
<p>老版本的缺点：</p>
<ul>
<li>只支持文本数据的传送，无法用来读取和上传二进制文件。</li>
<li>传送和接收数据时，没有进度信息，只能提示有没有完成。</li>
<li>受到”同域限制”（Same Origin Policy），只能向同一域名的服务器请求数据。</li>
</ul>
</li>
<li><p>contentEditable</p>
<ul>
<li>让元素的区域可编辑</li>
<li>已标准化</li>
</ul>
</li>
<li><p>requestAnimationFrame ： 允许控制动画渲染以获得更优性能</p>
</li>
<li><p>拖放 API draggable 属性、拖放事件(dragstart、drag、dragenter、dragleave、dragover、drap、dragend)、dataTransfer 对象</p>
</li>
<li><p>全屏 API</p>
</li>
<li><p>在线和离线事件</p>
</li>
</ul>
</li>
<li><p>设备访问</p>
<ul>
<li>carnera ：能够操作计算机的摄像头</li>
<li>地理位置定位 Geolocation</li>
<li>触控事件</li>
<li>检测设备方向 ：横向还是竖向</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Offer</category>
        <category>字节跳动</category>
      </categories>
      <tags>
        <tag>面试全面总结</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>html 面试考点全面总结上篇</title>
    <url>/2020/03/23/getOfferhtml1/</url>
    <content><![CDATA[<h2 id="html-面试考点全面总结上篇"><a href="#html-面试考点全面总结上篇" class="headerlink" title="html 面试考点全面总结上篇"></a>html 面试考点全面总结上篇</h2><blockquote>
<p>拿到 字节跳动实习生 offer 总结</p>
<p>回馈分享一波自己的知识点总结</p>
</blockquote>
<blockquote>
<p>希望读者依此构建自己的知识树（思维导图）</p>
<p>偷懒一下：可参考我自己总结思维导图 : <a href="https://github.com/ZhChen7/Interview-mind-map">点这里</a></p>
<p>附带：高频面试题积累文档。 来自于（学长、牛客网等平台）</p>
<p>自己开发的博客地址：<a href="http://zxinc520.com/">zxinc520.com</a></p>
<p>github 地址: <a href="https://github.com/ZhChen7">点击</a></p>
</blockquote>
<blockquote>
<p>此篇 html 共总结 22 大知识点： 全部弄懂了，面试很容易。</p>
</blockquote>
<h3 id="1、浏览器页面由哪三层构成"><a href="#1、浏览器页面由哪三层构成" class="headerlink" title="1、浏览器页面由哪三层构成"></a>1、浏览器页面由哪三层构成</h3><ul>
<li>结构层<ul>
<li>HTML</li>
<li>构建文件结构</li>
</ul>
</li>
<li>表示层<ul>
<li>css</li>
<li>设置文档呈现效果</li>
</ul>
</li>
<li>行为层<ul>
<li>JS 和 DOM 脚本</li>
<li>实现文档的行为</li>
</ul>
</li>
</ul>
<h3 id="2、语义化-谈谈-html5-语义化"><a href="#2、语义化-谈谈-html5-语义化" class="headerlink" title="2、语义化 | 谈谈 html5 语义化"></a>2、语义化 | 谈谈 html5 语义化</h3><h4 id="2-1、什么是语义化？"><a href="#2-1、什么是语义化？" class="headerlink" title="2.1、什么是语义化？"></a>2.1、什么是语义化？</h4><p>HTML5 的语义化指的是合理使用语义化的标签来创建页面结构，如 header,footer,nav，从标签上即可以直观的知道这个标签的作用，而不是滥用 div。</p>
<h4 id="2-2、语义化的优点有"><a href="#2-2、语义化的优点有" class="headerlink" title="2.2、语义化的优点有"></a>2.2、语义化的优点有</h4><ol>
<li>代码结构清晰，易于阅读，利于开发和维护</li>
<li>提高用户体验，在样式加载失败时，页面结构清晰</li>
<li>方便其他设备解析（如屏幕阅读器）根据语义渲染网页。</li>
<li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</li>
</ol>
<h4 id="2-3、常用语义化标签有哪些"><a href="#2-3、常用语义化标签有哪些" class="headerlink" title="2.3、常用语义化标签有哪些"></a>2.3、常用语义化标签有哪些</h4><blockquote>
<p>article | aside | nav | section | header | footer</p>
</blockquote>
<h3 id="3、HTML5-元素分类"><a href="#3、HTML5-元素分类" class="headerlink" title="3、HTML5 元素分类"></a>3、HTML5 元素分类</h3><ol>
<li>结构性元素<ul>
<li>section：在 web 页面应用中，该元素也可以用于区域章节表述；</li>
<li>header：页面主题上的头部，注意区别于 head 元素；</li>
<li>footer：页面的底部（页脚）；</li>
<li>nav：是专门用于菜单导航、链接导航的元素，是 navigator 的缩写；</li>
<li>article：用于表示一篇文章的主题部分，一般为文字集中显示的区域；</li>
</ul>
</li>
<li>级块性元素<ul>
<li>aside：用以表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容；</li>
<li>figure：是对多个元素进行组合并展示的元素，通常与 figcaption 联合使用；</li>
<li>code：表示一段代码块；</li>
<li>dialog：用于表达人与人之间的对话，该元素还包括 dt 和 dd 这两个组合元素，他们常常同时使用。dt 用于表示说话者，而 dd 用来表示说话者的内容。</li>
</ul>
</li>
<li>行内语义性元素<ul>
<li>meter：表示特定范围内的数值，可用于工资、数量、百分比等；</li>
<li>time：表示时间值；</li>
<li>progress：用来表示进度条，可通过对其 max、min、step 等属性进行控制，完成对进度的表示和监视；</li>
<li>video：视频元素，用于支持和实现视频（含视频流）文件的直接播放，支持缓冲预载和多种视频媒体格式；</li>
<li>audio：音频元素，用于支持和实现音频（音频流）文件的直接播放，支持缓冲预载和多种音频媒体格式；</li>
</ul>
</li>
<li>交互性元素<ul>
<li>details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来；</li>
<li>datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新；</li>
<li>menu：主要用于交互菜单；</li>
<li>command：用来处理命令按钮。</li>
</ul>
</li>
</ol>
<h3 id="4、常见空元素"><a href="#4、常见空元素" class="headerlink" title="4、常见空元素"></a>4、常见空元素</h3><p><strong>含义</strong> ：没有元素内容标记的内容【也称自闭合元素】</p>
<p>常用的空元素：</p>
<meta> <br> <hr> <input> <img> <link>

<h3 id="5、表单增强-新增的-input-类型及属性"><a href="#5、表单增强-新增的-input-类型及属性" class="headerlink" title="5、表单增强 | 新增的 input 类型及属性"></a>5、表单增强 | 新增的 input 类型及属性</h3><h4 id="5-1、新类型"><a href="#5-1、新类型" class="headerlink" title="5.1、新类型"></a>5.1、新类型</h4><ul>
<li>color ：用于指定颜色的控件</li>
<li>number：用于输入浮点数的控件</li>
<li>tel：用于输入电话号码的控件；换行会被自动从输入的值中移除 A，但不会执行其他语法。可以使用属性，比如 pattern 和 maxlength 来约束控件输入的值。恰当的时候，可以应用 :valid 和 :invalid CSS 伪类。</li>
<li>email：用于编辑 e-mail 的字段。 合适的时候可以使用 :valid 和 :invalid CSS 伪类。</li>
<li>url ：用于编辑 URL 的字段</li>
<li>range ：用于输入不精确值控件</li>
<li>search ：用于输入搜索字符串的单行文本字段。换行会被从输入的值中自动移除。</li>
<li>与时间相关<ul>
<li>date ： 用于输入日期的控件（年，月，日，不包括时间）</li>
<li>time ： 用于输入不含时区的时间控件</li>
<li>datatime 【已弃用】 ： 用于输入日期和时间的控件（小时，分钟， 秒，基于 UTC 时区的一小部分。 此功能已从 WHATWG HTML 中删除。</li>
<li>datetime-local ： 用于输入日期时间控件，不包含时区</li>
<li>month ： 用于输入年月的控件，不带时区</li>
<li>week ： 用于输入一个由星期-年组成的日期，日期不包括时</li>
</ul>
</li>
</ul>
<h4 id="5-2、新属性"><a href="#5-2、新属性" class="headerlink" title="5.2、新属性"></a>5.2、新属性</h4><ul>
<li><p>placeholder</p>
</li>
<li><p>required 必填项</p>
</li>
<li><p>list 属性规定输入域的 datalist。datalist 是输入域的选项列表</p>
</li>
<li><p>pattern 定义正则</p>
</li>
<li><p>autofocus 属性规定在页面加载时，域自动地获得焦点。</p>
</li>
<li><p>readonly 该字段只读，不能修改</p>
</li>
<li><p>autocomplete 属性规定 form 或 input 域应该拥有自动完成功能。</p>
</li>
<li><p>min/max / step</p>
<ul>
<li><p>min、max 和 step 属性用于为包含数字或日期的 input 类型规定限定（约束）。</p>
<p>max 属性规定输入域所允许的最大值。</p>
<p>min 属性规定输入域所允许的最小值。</p>
<p>step 属性为输入域规定合法的数字间隔（如果 step=”3”，则合法的数是 -3,0,3,6 等）。</p>
</li>
</ul>
</li>
</ul>
<h3 id="6、认识-SVG"><a href="#6、认识-SVG" class="headerlink" title="6、认识 SVG"></a>6、认识 SVG</h3><p><strong>含义</strong> ：可缩放矢量图形（Scalable Vector Graphics，SVG），是一种用于描述基于二维的矢量图形的，基于 XML 的标记语言。</p>
<p><strong>关键词</strong>：【基于 XML】【矢量】 【图像格式】</p>
<p><strong>特点</strong>：</p>
<ul>
<li>矢量<ul>
<li>可以任意缩放</li>
<li>不会破坏图像的清晰度和细节</li>
<li>边缘清晰，适用任何分辨率</li>
</ul>
</li>
<li>文本独立 文字独立于图像</li>
<li>文件小 下载快</li>
<li>颜色控制</li>
</ul>
<h4 id="6-1、SVG-与-HTML5-的-canvas-各有什么优点，哪个更有前途？"><a href="#6-1、SVG-与-HTML5-的-canvas-各有什么优点，哪个更有前途？" class="headerlink" title="6.1、SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途？"></a>6.1、SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途？</h4><blockquote>
<p>Canvas 是使用 JavaScript 程序绘图(动态生成)，SVG 是使用 XML 文档描述来绘图。<br>从这点来看：SVG 更适合用来做动态交互，而且 SVG 绘图很容易编辑，只需要增加或移除相应的元素就可以了。<br>同时 SVG 是基于矢量的，所有它能够很好的处理图形大小的改变。Canvas 是基于位图的图像，它不能够改变大小，只能缩放显示；所以说 Canvas 更适合用来实现类似于 Flash 能做的事情(当然现在 Canvas 与 Flash 相比还有一些不够完善的地方)。<br>关于最后一点二者谁更有前途：从上面我们可以知道二者是有不同用途的，作为一个开发者，你应该做的是理解应用程序的具体需求并选择正确的技术来实现它。</p>
</blockquote>
<h3 id="7、浏览器内核"><a href="#7、浏览器内核" class="headerlink" title="7、浏览器内核"></a>7、浏览器内核</h3><h4 id="7-1、认识内核"><a href="#7-1、认识内核" class="headerlink" title="7.1、认识内核"></a>7.1、认识内核</h4><ul>
<li>渲染引擎 ：渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息</li>
<li>JS 引擎<ul>
<li>解析和执行 JavaScript 来实现网页的动态效果</li>
<li>引擎越来越独立，内核就倾向于只指渲染引擎</li>
</ul>
</li>
</ul>
<h4 id="7-2、主流浏览器所用的内核"><a href="#7-2、主流浏览器所用的内核" class="headerlink" title="7.2、主流浏览器所用的内核"></a>7.2、主流浏览器所用的内核</h4><ul>
<li>IE 浏览器 Trident 内核</li>
<li>谷歌浏览器（chrome）<ul>
<li>Webkit（之前使用）</li>
<li>blink 内核</li>
</ul>
</li>
<li>Opera 浏览器<ul>
<li>blink 内核</li>
<li>Presto 内核（之前使用）<ul>
<li>渲染速度的优化达到了极致</li>
<li>牺牲了兼容性</li>
</ul>
</li>
</ul>
</li>
<li>火狐浏览器（Firefox）<ul>
<li>Gecko 内核 ： 代码完全公开，可开发程度很高</li>
</ul>
</li>
<li>Safari 浏览器 ：苹果公司 webkit 内核</li>
<li>国产浏览器<ul>
<li>双内核（一个负责兼容，一个负责速度）</li>
<li>常用<ul>
<li>Trident + webkit</li>
<li>Trident + blink</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8、WEB-标准以及-W3C"><a href="#8、WEB-标准以及-W3C" class="headerlink" title="8、WEB 标准以及 W3C"></a>8、WEB 标准以及 W3C</h3><h4 id="8-1、web-标准"><a href="#8-1、web-标准" class="headerlink" title="8.1、web 标准"></a>8.1、web 标准</h4><blockquote>
<p>分为结构、表现、行为</p>
</blockquote>
<h5 id="web-标准是什么？"><a href="#web-标准是什么？" class="headerlink" title="web 标准是什么？"></a>web 标准是什么？</h5><blockquote>
<p>一系列标准的集合：</p>
</blockquote>
<ul>
<li>结构化标准语言</li>
<li>表现标准语言</li>
<li>行为标准语言</li>
</ul>
<h5 id="web-标准诞生原因？"><a href="#web-标准诞生原因？" class="headerlink" title="web 标准诞生原因？"></a>web 标准诞生原因？</h5><blockquote>
<p>为了解决因浏览器版本不同、软硬件设备不同导致的需多版本开发的问题。</p>
</blockquote>
<h4 id="8-2、W3C"><a href="#8-2、W3C" class="headerlink" title="8.2、W3C"></a>8.2、W3C</h4><blockquote>
<p>W3C 对 web 标准提出规范化要求</p>
</blockquote>
<h5 id="一：结构要求："><a href="#一：结构要求：" class="headerlink" title="一：结构要求："></a>一：结构要求：</h5><ul>
<li>遵循的好处<ul>
<li>提升搜索引擎对页面的抓取效率</li>
<li>对 SEO 很有帮助</li>
</ul>
</li>
<li>具体<ul>
<li>标签字母要小写</li>
<li>标签要闭合</li>
<li>标签不允许随便嵌套</li>
</ul>
</li>
</ul>
<h5 id="二：表现与行为要求："><a href="#二：表现与行为要求：" class="headerlink" title="二：表现与行为要求："></a>二：表现与行为要求：</h5><ul>
<li>遵循的好处<ul>
<li>使用户浏览者更方便的阅读</li>
<li>使网页开发者之间更好的交流</li>
</ul>
</li>
<li>具体<ul>
<li>尽量使用外链 css 样式表和 js 脚本：提高页面渲染速度</li>
<li>页面尽量少用行间样式表 ： 使结构和表现分离</li>
<li>标签 id 和 class 等属性名要见文知义</li>
</ul>
</li>
</ul>
<h3 id="9、Doctype（DTD）"><a href="#9、Doctype（DTD）" class="headerlink" title="9、Doctype（DTD）"></a>9、Doctype（DTD）</h3><blockquote>
<p>作用 ： 声明文档的类型风格</p>
<p>告诉浏览器采用何种渲染模式解析页面</p>
</blockquote>
<h4 id="9-1、渲染模式"><a href="#9-1、渲染模式" class="headerlink" title="9.1、渲染模式"></a>9.1、渲染模式</h4><ul>
<li>怪异模式（兼容模式、混杂模式）<ul>
<li>服务于旧式规则</li>
<li>页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</li>
</ul>
</li>
<li>标准模式（严格模式）<ul>
<li>服务于标准规则</li>
<li>标准模式的排版 和 JS 运作模式都是以该浏览器支持的最高标准运行</li>
</ul>
</li>
<li>近似标准模式<ul>
<li>基本是标准模型</li>
<li>有一些是自己的调整</li>
</ul>
</li>
</ul>
<p><strong>意义</strong>：严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。</p>
<h4 id="9-2、标准模式和混杂模式的区别？"><a href="#9-2、标准模式和混杂模式的区别？" class="headerlink" title="9.2、标准模式和混杂模式的区别？"></a>9.2、标准模式和混杂模式的区别？</h4><ul>
<li><p><strong>盒模型的处理差异：</strong>标准 CSS 盒模型的宽度和高度等于内容区的高度和宽度，不包含内边距和边框，而 IE6 之前的浏览器实现的盒模型的宽高计算方式是包含内边距和边框的。因此，对于 IE，怪异模式和标准模式下的盒模型宽高计算方式是不一样的；</p>
</li>
<li><p><strong>行内元素的垂直对齐：</strong>很多早期的浏览器对齐图片至包含它们的盒子的下边框，虽然 CSS 的规范要求它们被对齐至盒内文本的基线。标准模式下，基于 Gecko 的浏览器将会对齐至基线，而在 quirks 模式下它们会对齐至底部。最直接的例子就是图片的显示。在标准模式下，图片并不是与父元素的下边框对齐的，如果仔细观察，你会发现图片与父元素下边框之间存在一点小空隙。那是因为标准模式下，图片是基线对齐的。而怪异模式下，则不存在这个问题。具体请看这篇文章 <a href="https://link.jianshu.com/?t=http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/">CSS 深入理解 vertical-align 和 line-height 的基友关系</a>。</p>
</li>
</ul>
<h4 id="9-3、标准模式和严格模式的区别？"><a href="#9-3、标准模式和严格模式的区别？" class="headerlink" title="9.3、标准模式和严格模式的区别？"></a>9.3、标准模式和严格模式的区别？</h4><p>严格模式主要有以下限制：</p>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用 with 语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀 0 表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量 delete prop，会报错，只能删除属性 delete global[prop]</li>
<li>eval 不会在它的外层作用域引入变量</li>
<li>eval 和 arguments 不能被重新赋值</li>
<li>arguments 不会自动反映函数参数的变化</li>
<li>不能使用 arguments.callee</li>
<li>不能使用 arguments.caller</li>
<li>禁止 this 指向全局对象</li>
<li>不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈</li>
</ul>
<h3 id="10、meta-标签"><a href="#10、meta-标签" class="headerlink" title="10、meta 标签"></a>10、meta 标签</h3><blockquote>
<p>&lt;_meta_ &gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。</p>
</blockquote>
<h4 id="10-1、四个属性"><a href="#10-1、四个属性" class="headerlink" title="10.1、四个属性"></a>10.1、四个属性</h4><ul>
<li>http-equiv 【重要关键词】<ul>
<li>content-type<ul>
<li>定义字符编码</li>
<li>不推荐使用 改用 charset 属性</li>
</ul>
</li>
<li>refresh：指定以秒为单位，执行重载和重定向</li>
</ul>
</li>
<li>name 【 重要关键词】<ul>
<li>application-name：应用程序名称</li>
<li>keywords ： keywords 用来告诉搜索引擎你网页的关键字是什么</li>
<li>author ： 当前页的作者名</li>
<li>viewport<ul>
<li>设置浏览器视口</li>
<li>重要关键字<ul>
<li>width ： 视口宽度</li>
<li>*-scale （initial-scale）： 缩放相关</li>
<li>user-scalable ： 是否可以手动缩放</li>
<li>例如：&lt;_meta name=”viewport” content=”width=device-width, initial-scale=1, maximum-scale=1”_ &gt;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>description description 用来告诉搜索引擎你的网站主要内容</li>
<li>content ：具体描述 、不能单独存在</li>
<li>charset（HTML5）：推荐使用 utf-8 简化了不同脚本对文件中字符的处理</li>
</ul>
<h4 id="10-2、meta-标签的作用"><a href="#10-2、meta-标签的作用" class="headerlink" title="10.2、meta 标签的作用"></a>10.2、meta 标签的作用</h4><ol>
<li><p>搜索引擎优化（SEO）</p>
</li>
<li><p>定义页面使用语言</p>
</li>
<li><p>自动刷新并指向新的页面</p>
</li>
<li><p>实现网页转换时的动态效果</p>
</li>
<li><p>控制页面缓冲</p>
</li>
<li><p>网页定级评价</p>
</li>
<li><p>控制网页显示的窗口</p>
</li>
</ol>
<p>######</p>
<p>######</p>
]]></content>
      <categories>
        <category>Offer</category>
        <category>字节跳动</category>
      </categories>
      <tags>
        <tag>面试全面总结</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2019/10/10/regular_expression/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><blockquote>
<p>正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象。这些模式被用于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp"><code>RegExp</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>exec</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"><code>test</code></a> 方法, 以及 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String"><code>String</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code>match</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll"><code>matchAll</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><code>replace</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search"><code>search</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split"><code>split</code></a> 方法。本章介绍 JavaScript <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式</a>。</p>
</blockquote>
<p>辅助正则可视化网站：<a href="https://regexper.com/">https://regexper.com/</a></p>
<p><strong>使用正则表达式的方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>exec</code></a></td>
<td>一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组（未匹配到则返回 null）。</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"><code>test</code></a></td>
<td>一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或 false。</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code>match</code></a></td>
<td>一个在字符串中执行查找匹配的 String 方法，它返回一个数组，在未匹配到时会返回 null。</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll"><code>matchAll</code></a></td>
<td>一个在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器（iterator）。</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search"><code>search</code></a></td>
<td>一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回-1。</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><code>replace</code></a></td>
<td>一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串。</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split"><code>split</code></a></td>
<td>一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 <code>String</code> 方法。</td>
</tr>
</tbody></table>
<h2 id="REGEXP-对象"><a href="#REGEXP-对象" class="headerlink" title="REGEXP 对象"></a>REGEXP 对象</h2><ul>
<li>JavaScript 通过内置函数对象 RegExp 支持正则表达式</li>
<li>有两种方法实例化 RegExp 对象<ul>
<li>字面量</li>
<li>构造函数</li>
</ul>
</li>
</ul>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\bis\b/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;he is dog ,he love she how are you is&quot;</span>.replace(reg, <span class="string">&quot;IS&quot;</span>));</span><br><span class="line"><span class="comment">// he IS dog ,he love she how are you IS</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;\\bis\\b&quot;</span>, <span class="string">&quot;g&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;he is dog ,he love she how are you is&quot;</span>.replace(reg, <span class="string">&quot;IS&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// he IS dog ,he love she how are you IS</span></span><br></pre></td></tr></table></figure>

<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>在 JavaScript 中，<strong>正则表达式标志</strong>：</p>
<ul>
<li><p><code>i</code></p>
<p>不区分大小写搜索。</p>
</li>
<li><p><code>g</code></p>
<p>全局搜索。</p>
</li>
<li><p><code>m</code></p>
<p>多行搜索。</p>
</li>
<li><p><code>u</code></p>
<p>使用 unicode 码的模式进行匹配。</p>
</li>
<li><p><code>y</code></p>
<p>执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用 y 标志。</p>
</li>
<li><p><code>s</code></p>
<p>允许 <code>.</code> 匹配换行符。</p>
</li>
</ul>
<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><ul>
<li>正则表达式由两种基本字符类型组成：<ul>
<li>原义文本字符</li>
<li>元字符</li>
</ul>
</li>
<li>元字符是在正则表达式中有特殊含义的非字母字符</li>
</ul>
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>将下一个字符标记为特殊字符或字面值。例如，n 匹配字符 _n_，而 \n 匹配换行符。序列 \ 匹配 \，而 ( 匹配 (。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入的开始部分。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入的结束部分。</td>
</tr>
<tr>
<td>*</td>
<td>零次或更多次匹配前面的字符。例如，zo* 匹配 <em>z</em> 或 <em>zoo\</em>。</td>
</tr>
<tr>
<td>+</td>
<td>一次或更多次匹配前面的字符。例如，zo+ 匹配 _zoo_，但是不匹配 _z_。</td>
</tr>
<tr>
<td>?</td>
<td>零次或一次匹配前面的字符。例如，a?ve? 匹配 <em>never</em> 中的 _ve_。</td>
</tr>
<tr>
<td>.</td>
<td>匹配任何单个字符，但换行符除外。</td>
</tr>
<tr>
<td>(pattern)</td>
<td>匹配模式并记住匹配项。通过使用以下代码，匹配的子串可以检索自生成的匹配项集合：Item [0]…[n]。要匹配圆括号字符 ( )，请使用 ( 或 )。</td>
</tr>
<tr>
<td>x|y</td>
<td>匹配 x 或 y。 例如，z|wood 匹配 <em>z</em> 或 <em>wood_。(z|w)oo 匹配 _zoo</em> 或 _wood_。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。精确匹配 n 次。例如，o{2} 不匹配 <em>Bob</em> 中的 <em>o_，但是匹配 _foooood</em> 中的前两个 _o_。</td>
</tr>
<tr>
<td>{n,}</td>
<td>在此表达式中，n 是一个非负整数。至少 n 次匹配前面的字符。例如，o{2,} 不匹配 <em>Bob</em> 中的 <em>o_，但是匹配 _foooood</em> 中的所有 _o_。o{1,} 表达式等效于 o+，o{0,} 等效于 o*。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 变量是非负整数。至少 n 次且至多 m 次匹配前面的字符。例如，o{1,3} 匹配 <em>fooooood</em> 中的前三个 _o_。o{0,1} 表达式等效于 o?。</td>
</tr>
<tr>
<td>[xyz]</td>
<td>一个字符集。匹配任意一个包含的字符。例如，[abc] 匹配 <em>plain</em> 中的 _a_。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>一个否定字符集。匹配任何未包含的字符。例如，[^abc] 匹配 <em>plain</em> 中的 _p_。</td>
</tr>
<tr>
<td>[a-z]</td>
<td>字符范围。匹配指定范围中的任何字符。例如，[a-z] 匹配英语字母中的任何小写的字母字符。</td>
</tr>
<tr>
<td>[^m-z]</td>
<td>一个否定字符范围。匹配未在指定范围中的任何字符。例如，[m-z] 匹配未在范围 <em>m</em> 到 <em>z</em> 之间的任何字符。</td>
</tr>
<tr>
<td>\A</td>
<td>仅匹配字符串的开头。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配某个单词边界，即，某个单词和空格之间的位置。例如，er\b 匹配 <em>never</em> 中的 <em>er_，但是不匹配 _verb</em> 中的 _er_。</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界。ea*r\B 表达式匹配 <em>never early</em> 中的 <em>ear\</em>。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字字符。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字字符。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配换页字符。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配换行符。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配回车字符。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空格，包括空白、制表符、换页字符等等。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空格字符。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配跳进字符。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配垂直跳进字符。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配任何单词字符，包括下划线。此表达式等效于 [A-Za-z0-9_]。</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任何非单词字符。此表达式等效于 [^a-za-z0-9__]。</td>
</tr>
<tr>
<td>\z</td>
<td>仅匹配字符串的结尾。</td>
</tr>
<tr>
<td>\Z</td>
<td>仅匹配字符串的结尾，或者结尾的换行符之前。</td>
</tr>
</tbody></table>
<p><strong>字符类：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;a1b2c3d4&quot;</span>.replace(<span class="regexp">/[abc]/g</span>, <span class="string">&quot;X&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;X1X2X3d4&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;a1b2c3d4&quot;</span>.replace(<span class="regexp">/[^abc]/g</span>, <span class="string">&quot;X&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;aXbXcXXX&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>范围类：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;a1b2c3d4zcczx&quot;</span>.replace(<span class="regexp">/[a-z]/g</span>, <span class="string">&quot;Q&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;Q1Q2Q3Q4QQQQQ&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;a1b2c3d4zcczxAAAAAAA&quot;</span>.replace(<span class="regexp">/[a-zA-Z]/g</span>, <span class="string">&quot;Q&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;Q1Q2Q3Q4QQQQQQQQQQQQ&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;2016-09-12&quot;</span>.replace(<span class="regexp">/[0-9]/g</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;AAAA-AA-AA&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;2016-09-12&quot;</span>.replace(<span class="regexp">/[0-9-]/g</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;AAAAAAAAAA&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>预定义类：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20191009/FsMlDwV4Kfrh.png?imageslim" alt="mark"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配一个 ab + 数字 + 任意字符 的字符串</span></span><br><span class="line">ab\d.</span><br></pre></td></tr></table></figure>

<p><strong>边界：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20191009/UQyV6XeWDuqI.png?imageslim" alt="mark"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;this is a boy&quot;</span>.replace(<span class="regexp">/\bis\b/g</span>, <span class="string">&quot;IS&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;this IS a boy&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;@13@12331&quot;</span>.replace(<span class="regexp">/@./g</span>, <span class="string">&quot;Q&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;Q3Q2331&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;@13@12331&quot;</span>.replace(<span class="regexp">/^@./g</span>, <span class="string">&quot;Q&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;Q3@12331&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;@13@12331@&quot;</span>.replace(<span class="regexp">/.@$/g</span>, <span class="string">&quot;Q&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;@13@1233Q&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>量词：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20191009/KsjXw8IGYwJD.png?imageslim" alt="mark"></p>
<p><strong>贪婪模式：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;12345678&quot;</span>.replace(<span class="regexp">/\d&#123;3,6&#125;/g</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;a78&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>非贪婪模式：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;12345678&quot;</span>.replace(<span class="regexp">/\d&#123;3,6&#125;?/g</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;aa78&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>分组：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;a1b2c3d4&quot;</span>.replace(<span class="regexp">/([a-zA-z]\d)&#123;3&#125;/g</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;Ad4&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>或：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;123456789122312&quot;</span>.replace(<span class="regexp">/(123|456)/g</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;AA789122312&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>反向引用：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;2019-10-09&quot;</span>.replace(<span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g</span>, <span class="string">&quot;$3/$2/$1&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;09/10/2019&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>前瞻：</strong></p>
<ul>
<li>正则表达式从文本头部向尾部开始解析，文本尾部方向，称为“前”</li>
<li><strong>前瞻</strong> 就是正则表达式匹配到规则的时候，向前检查是否符合断言，后顾/后瞻 方向相反</li>
<li>JavaScript 不支持 后顾</li>
<li>符合和不符合特定断言称为 <strong>肯定/正向</strong> 匹配 和 <strong>否定/负向</strong> 匹配</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20191009/VS8ezfIwVH95.png?imageslim" alt="mark"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;a2*3&quot;</span>.replace(<span class="regexp">/\w(?=\d)/g</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;A2*3&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h3><ul>
<li>global：是否全文搜索，默认 false</li>
<li>ignore case：是否大小写敏感，默认是 false</li>
<li>multiline：多行搜索，默认值是 false</li>
<li>lastIndex: 是当前表达式匹配内容的最后一个字符的下一个位置</li>
<li>source：正则表达式的文本字符串</li>
</ul>
<h2 id="RegExp-prototype-test"><a href="#RegExp-prototype-test" class="headerlink" title="RegExp.prototype.test()"></a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test">RegExp.prototype.test()</a></h2><blockquote>
<p><code>test()</code> 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 <code>true</code> 或 <code>false</code>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/\w/</span>;</span><br><span class="line">reg1.test(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>注意：/g（全局匹配 ） 使用 test 方法，结果不稳定！</p>
<h2 id="RegExp-prototype-exec"><a href="#RegExp-prototype-exec" class="headerlink" title="RegExp.prototype.exec()"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec">RegExp.prototype.exec()</a></h2><blockquote>
<p><code>exec() </code>方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a>。</p>
<p>如果你只是为了判断是否匹配（true 或 false），可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"><code>RegExp.test()</code></a> 方法，或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search"><code>String.search()</code></a> 方法。</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟DOM</title>
    <url>/2019/09/20/virtualDOM/</url>
    <content><![CDATA[<h1 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h1><blockquote>
<p>本章分析了<strong>虚拟 DOM</strong> 的使用场景、<strong>常用 API</strong>、以及 <strong>diff 算法</strong> 的代码框架。通过学习和了解虚拟 DOM ，为后面的 vue 和 React 学习打好基础。</p>
<p><strong>知识点</strong></p>
<p>5-1 什么是 vdom，为何使用 vdom？</p>
<p>5-2 vdom 的如何应用，核心 API 是什么？</p>
<p>5-3 介绍 一下 diff 算法</p>
<p>Ignorance is the curse of God, knowledge the wing wherewith we fly to heaven.——William Shakespeare</p>
<p>无知乃是罪恶，知识乃是我们借以飞向天堂的翅膀。——莎士比亚</p>
</blockquote>
<h3 id="virtual-dom"><a href="#virtual-dom" class="headerlink" title="virtual dom"></a>virtual dom</h3><ul>
<li>vdom 是 vue 和 React 的核心，先讲哪个都绕不开它</li>
<li>vdom 比较独立，使用也比较简单</li>
<li>如果面试问到 vue 和 React 的实现，免不了问 vdom</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>vdom 是什么？为何会存在 vdom？</li>
<li>vdom 的如何应用，核心 API 是什么？</li>
<li>介绍一下 diff 算法</li>
</ul>
<h2 id="5-1-什么是-vdom，为何使用-vdom？"><a href="#5-1-什么是-vdom，为何使用-vdom？" class="headerlink" title="5-1 什么是 vdom，为何使用 vdom？"></a>5-1 什么是 vdom，为何使用 vdom？</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>什么是 vdom？</li>
<li>设计一个需求场景</li>
<li>用 jQuery 实现</li>
<li>遇到的问题</li>
</ul>
<h4 id="什么是-vdom？"><a href="#什么是-vdom？" class="headerlink" title="什么是 vdom？"></a>什么是 vdom？</h4><ul>
<li>virtual dom，虚拟 DOM</li>
<li>用 JS 模拟 DOM 结构</li>
<li>DOM 变化的对比，放在 JS 层来做 （ 图灵完备语言 ）</li>
<li>提高重绘性能</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">  &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item&quot;</span>&gt;Item <span class="number">1</span>&lt;/li&gt;</span><br><span class="line">  &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item&quot;</span>&gt;Item <span class="number">2</span>&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p><strong>用 JS 模拟 DOM</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vdom</span></span><br><span class="line">&#123;</span><br><span class="line">    tag:<span class="string">&#x27;ul&#x27;</span>,</span><br><span class="line">    attrs:&#123;</span><br><span class="line">        id:<span class="string">&#x27;list&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    children:[</span><br><span class="line">        &#123;</span><br><span class="line">            tag:<span class="string">&#x27;li&#x27;</span>,</span><br><span class="line">            attrs:&#123;<span class="attr">className</span>:<span class="string">&#x27;item&#x27;</span>&#125;,</span><br><span class="line">            children:[<span class="string">&#x27;Item 1&#x27;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            tag:<span class="string">&#x27;li&#x27;</span>,</span><br><span class="line">            attrs:&#123;<span class="attr">className</span>:<span class="string">&#x27;item&#x27;</span>&#125;,</span><br><span class="line">            children:[<span class="string">&#x27;Item 2&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="设计一个需求场景"><a href="#设计一个需求场景" class="headerlink" title="设计一个需求场景"></a>设计一个需求场景</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.将该数据展示成一个表格</span></span><br><span class="line"><span class="comment"> * 2.随便修改一个信息，表格也跟着修改</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    age: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">    address: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">    age: <span class="string">&quot;21&quot;</span>,</span><br><span class="line">    address: <span class="string">&quot;上海&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;王五&quot;</span>,</span><br><span class="line">    age: <span class="string">&quot;22&quot;</span>,</span><br><span class="line">    address: <span class="string">&quot;广州&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p><em>jQuery 实现</em> ：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn-change&quot;</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> data = [</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line"><span class="javascript">          age: <span class="string">&quot;20&quot;</span>,</span></span><br><span class="line"><span class="javascript">          address: <span class="string">&quot;北京&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;李四&quot;</span>,</span></span><br><span class="line"><span class="javascript">          age: <span class="string">&quot;21&quot;</span>,</span></span><br><span class="line"><span class="javascript">          address: <span class="string">&quot;上海&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;王五&quot;</span>,</span></span><br><span class="line"><span class="javascript">          age: <span class="string">&quot;22&quot;</span>,</span></span><br><span class="line"><span class="javascript">          address: <span class="string">&quot;广州&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">      ];</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//渲染函数</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> $container = $(<span class="string">&quot;#container&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//清空容器</span></span></span><br><span class="line"><span class="javascript">        $container.html(<span class="string">&quot;&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//拼接  table</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> $table = $(<span class="string">&quot;&lt;table&gt;&quot;</span>);</span></span><br><span class="line"><span class="handlebars"><span class="xml">        $table.append($(&quot;<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>name<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>age<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>address<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span>&quot;));</span></span></span><br><span class="line"><span class="javascript">        data.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span></span><br><span class="line">          $table.append(</span><br><span class="line"><span class="javascript">            $(</span></span><br><span class="line"><span class="handlebars"><span class="xml">              &quot;<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>&quot; +</span></span></span><br><span class="line">                item.name +</span><br><span class="line"><span class="handlebars"><span class="xml">                &quot;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>&quot; +</span></span></span><br><span class="line">                item.age +</span><br><span class="line"><span class="handlebars"><span class="xml">                &quot;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>&quot; +</span></span></span><br><span class="line">                item.address +</span><br><span class="line"><span class="handlebars"><span class="xml">                &quot;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span>&quot;</span></span></span><br><span class="line">            )</span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//渲染 到页面   jQuery放在这里：只有 一次DOM渲染，性能更好，但是 并不符合理想情况</span></span></span><br><span class="line">        $container.append($table);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      $(<span class="string">&quot;#btn-change&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        data[1].age = 30;</span><br><span class="line"><span class="javascript">        data[<span class="number">2</span>].address = <span class="string">&quot;深圳&quot;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//  re-render 再次渲染</span></span></span><br><span class="line">        render(data);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//页面加载完，立即执行</span></span></span><br><span class="line">      render(data);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190826/fnRWrTN8GFST.gif" alt="mark"></p>
<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ul>
<li>DOM 操作是 “昂贵”的，js <strong>运行效率高</strong></li>
<li>尽量减少 DOM 操作 ，而不是 “推倒重来”</li>
<li>项目越复杂 ，影响就越严重</li>
<li>vdom 即可解决这个问题</li>
</ul>
<h4 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h4><ul>
<li><p>vdom 是什么？为何会存在 vdom？</p>
<ul>
<li>virtual dom，虚拟 DOM</li>
<li>用 JS 模拟 DOM 结构</li>
<li>DOM 操作非常 “昂贵”</li>
<li>将 DOM 对比操作放在 JS 层，提高效率</li>
</ul>
</li>
<li><p>vdom 的如何应用，核心 API 是什么？</p>
<ul>
<li>介绍 <a href="https://github.com/snabbdom/snabbdom">snabbdom</a></li>
<li>重做 之前的 demo</li>
<li>核心 API</li>
</ul>
</li>
</ul>
<h2 id="5-2-vdom-的如何应用，核心-API-是什么？"><a href="#5-2-vdom-的如何应用，核心-API-是什么？" class="headerlink" title="5-2 vdom 的如何应用，核心 API 是什么？"></a>5-2 vdom 的如何应用，核心 API 是什么？</h2><blockquote>
<p>介绍 snabbdom ：一个 vdom 实现库。</p>
</blockquote>
<h3 id="介绍-snabbdom"><a href="#介绍-snabbdom" class="headerlink" title="介绍 snabbdom"></a>介绍 snabbdom</h3><blockquote>
<p>虚拟 DOM 非常棒。它允许我们将应用程序的视图表示为其状态的函数。但现有的解决方案太过臃肿，太慢，缺乏功能，API 偏向于 OOP 和/或缺少我需要的功能。</p>
<p><a href="https://github.com/snabbdom/snabbdom">Snabbdom</a> 由一个非常简单，高性能和可扩展的核心组成，只有 ≈200SLOC。它提供了模块化架构，具有丰富的功能，可通过自定义模块进 为了保持核心简单，所有非必要功能都委托给模块。</p>
<p>你可以将 Snabbdom 塑造成你想要的任何东西！选择，选择和自定义所需的功能。或者，您可以使用默认扩展并获得具有高性能，小尺寸和下面列出的所有功能的虚拟 DOM 库。</p>
</blockquote>
<h4 id="介绍-snabbdom-h-函数"><a href="#介绍-snabbdom-h-函数" class="headerlink" title="介绍 snabbdom - h 函数"></a>介绍 snabbdom - h 函数</h4><p><img src="http://static.zxinc520.com/blog/20190826/DY84t1uJz1C3.png?imageslim" alt="mark"></p>
<h4 id="介绍-snabbdom-patch-函数"><a href="#介绍-snabbdom-patch-函数" class="headerlink" title="介绍 snabbdom -patch 函数"></a>介绍 snabbdom -patch 函数</h4><p><img src="http://static.zxinc520.com/blog/20190826/dbhW2mzgt6n3.png?imageslim" alt="mark"></p>
<h3 id="使用-snabbdom"><a href="#使用-snabbdom" class="headerlink" title="使用 snabbdom"></a>使用 snabbdom</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-class.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-props.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-style.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-eventlisteners.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/h.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> snabbdom = <span class="built_in">window</span>.snabbdom;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//定义 patch</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> patch = snabbdom.init([</span></span><br><span class="line">        snabbdom_class,</span><br><span class="line">        snabbdom_props,</span><br><span class="line">        snabbdom_style,</span><br><span class="line">        snabbdom_eventlisteners,</span><br><span class="line">      ]);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 定义 h</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> h = snabbdom.h;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//生成 vnode</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> vnode = h(<span class="string">&quot;ul#list&quot;</span>, &#123;&#125;, [</span></span><br><span class="line"><span class="javascript">        h(<span class="string">&quot;li.item&quot;</span>, &#123;&#125;, <span class="string">&quot;Item 1&quot;</span>),</span></span><br><span class="line"><span class="javascript">        h(<span class="string">&quot;li.item&quot;</span>, &#123;&#125;, <span class="string">&quot;Item 2&quot;</span>),</span></span><br><span class="line">      ]);</span><br><span class="line"></span><br><span class="line">      patch(container, vnode);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span></span></span><br><span class="line"><span class="javascript">        .getElementById(<span class="string">&quot;btn-change&quot;</span>)</span></span><br><span class="line"><span class="javascript">        .addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">//生成 newVnode</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> newVnode = h(<span class="string">&quot;ul#list&quot;</span>, &#123;&#125;, [</span></span><br><span class="line"><span class="javascript">            h(<span class="string">&quot;li.item&quot;</span>, &#123;&#125;, <span class="string">&quot;Item 1&quot;</span>),</span></span><br><span class="line"><span class="javascript">            h(<span class="string">&quot;li.item&quot;</span>, &#123;&#125;, <span class="string">&quot;Item B&quot;</span>),</span></span><br><span class="line"><span class="javascript">            h(<span class="string">&quot;li.item&quot;</span>, &#123;&#125;, <span class="string">&quot;Item 3&quot;</span>),</span></span><br><span class="line">          ]);</span><br><span class="line">          patch(vnode, newVnode);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190826/o5jyCvk0PiHc.gif" alt="mark"></p>
<h3 id="重做-之前的-demo"><a href="#重做-之前的-demo" class="headerlink" title="重做 之前的 demo"></a>重做 之前的 demo</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn-change&quot;</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-class.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-props.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-style.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-eventlisteners.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/h.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> snabbdom = <span class="built_in">window</span>.snabbdom;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//定义 patch</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> patch = snabbdom.init([</span></span><br><span class="line">        snabbdom_class,</span><br><span class="line">        snabbdom_props,</span><br><span class="line">        snabbdom_style,</span><br><span class="line">        snabbdom_eventlisteners,</span><br><span class="line">      ]);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 定义 h</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> h = snabbdom.h;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//原始数据</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> data = [</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line"><span class="javascript">          age: <span class="string">&quot;20&quot;</span>,</span></span><br><span class="line"><span class="javascript">          address: <span class="string">&quot;北京&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;李四&quot;</span>,</span></span><br><span class="line"><span class="javascript">          age: <span class="string">&quot;21&quot;</span>,</span></span><br><span class="line"><span class="javascript">          address: <span class="string">&quot;上海&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;王五&quot;</span>,</span></span><br><span class="line"><span class="javascript">          age: <span class="string">&quot;22&quot;</span>,</span></span><br><span class="line"><span class="javascript">          address: <span class="string">&quot;广州&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">      ];</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//把表也放在 data 中</span></span></span><br><span class="line">      data.unshift(&#123;</span><br><span class="line"><span class="javascript">        name: <span class="string">&quot;姓名&quot;</span>,</span></span><br><span class="line"><span class="javascript">        age: <span class="string">&quot;年龄&quot;</span>,</span></span><br><span class="line"><span class="javascript">        address: <span class="string">&quot;地址&quot;</span>,</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//渲染函数</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> vnode;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> newVnode = h(</span></span><br><span class="line"><span class="javascript">          <span class="string">&quot;table&quot;</span>,</span></span><br><span class="line">          &#123;&#125;,</span><br><span class="line"><span class="javascript">          data.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> tds = [];</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> i;</span></span><br><span class="line">            for (i in item) &#123;</span><br><span class="line">              if (item.hasOwnProperty(i)) &#123;</span><br><span class="line"><span class="javascript">                tds.push(h(<span class="string">&quot;td&quot;</span>, &#123;&#125;, item[i] + <span class="string">&quot;&quot;</span>));</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> h(<span class="string">&quot;tr&quot;</span>, &#123;&#125;, tds);</span></span><br><span class="line">          &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        if (vnode) &#123;</span><br><span class="line"><span class="javascript">          <span class="comment">// 再次渲染</span></span></span><br><span class="line">          patch(vnode, newVnode);</span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 初次渲染</span></span></span><br><span class="line">          patch(container, newVnode);</span><br><span class="line">        &#125;</span><br><span class="line">        vnode = newVnode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 初次渲染</span></span></span><br><span class="line">      render(data);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> btnChange = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn-change&quot;</span>);</span></span><br><span class="line"><span class="javascript">      btnChange.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        data[1].age = 30;</span><br><span class="line"><span class="javascript">        data[<span class="number">2</span>].address = <span class="string">&quot;深圳&quot;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//re-render</span></span></span><br><span class="line">        render(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190826/c9oXjl7n0ScN.gif" alt="mark"></p>
<h3 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h3><ul>
<li>h（’&lt;标签名&gt;’，{ … 属性 … }，[… 子元素 …]）</li>
<li>h（’&lt;标签名&gt;’，{ … 属性 … }，[ ‘….’]）</li>
<li>patch（container，vnode）</li>
<li>patch（vnode，newVnode）</li>
</ul>
<h3 id="问题解答-1"><a href="#问题解答-1" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>vdom 的如何应用，核心 API 是什么？<ul>
<li>如何使用？ 可用 snabbdom 的 用法 来 举例</li>
<li>核心 函数 ：h 函数，patch 函数</li>
</ul>
</li>
</ul>
<h2 id="5-3-介绍-一下-diff-算法"><a href="#5-3-介绍-一下-diff-算法" class="headerlink" title="5-3 介绍 一下 diff 算法"></a>5-3 介绍 一下 diff 算法</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul>
<li>什么是 diff 算法？</li>
<li>去繁就简</li>
<li>vdom 为何用 diff 算法 ？</li>
<li>diff 算法 的 实现流程</li>
</ul>
<h4 id="什么是-diff-算法"><a href="#什么是-diff-算法" class="headerlink" title="什么是 diff 算法"></a>什么是 diff 算法</h4><blockquote>
<p>diff 算法 一直在我们身边</p>
<p><u>并不是 Vue 和 React 创造出来的概念</u></p>
</blockquote>
<p><em>diff 算法命令演示</em> ：</p>
<ul>
<li>linux 系统下： <code>diff log1.txt log2.txt</code> ：比较 2 个文件的不同</li>
<li><code>git diff xxxx</code> 的示例 ： git 里面比较不同版本间的代码差异</li>
</ul>
<h4 id="去繁就简"><a href="#去繁就简" class="headerlink" title="去繁就简"></a>去繁就简</h4><ul>
<li>diff 算法非常复杂，实现难度很大，源码量很大</li>
<li>去繁就简，讲明白核心流程 ，不关心细节</li>
<li>面试官也大部分都不清楚细节，但是很关心核心流程</li>
<li>去繁就简之后，依然 具有很大挑战性，并不简单</li>
</ul>
<h4 id="vdom-为何用-diff-算法"><a href="#vdom-为何用-diff-算法" class="headerlink" title="vdom 为何用 diff 算法"></a>vdom 为何用 diff 算法</h4><ul>
<li>DOM 操作是 “昂贵”的，因此尽量减少 DOM 操作</li>
<li>找出本次 DOM 必须更新的节点来更新，其它的 不更新</li>
<li>这个 “ 找出 ” 的过程，就需要 diff 算法</li>
</ul>
<h3 id="diff-实现过程"><a href="#diff-实现过程" class="headerlink" title="diff 实现过程"></a>diff 实现过程</h3><ul>
<li>patch （container，vnode）</li>
<li>patch （vnode，newVnode）</li>
</ul>
<h4 id="patch-（container，vnode）"><a href="#patch-（container，vnode）" class="headerlink" title="patch （container，vnode）"></a>patch （container，vnode）</h4><p><img src="http://static.zxinc520.com/blog/20190826/EQNow2OMou5G.png?imageslim" alt="mark"></p>
<p><strong>核心：如何使用 左边的 JS 节点 生成 右侧 Dom 节点？</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190826/xcTxunRSOhnV.png?imageslim" alt="mark"></p>
<h4 id="patch-（vnode，newVnode）"><a href="#patch-（vnode，newVnode）" class="headerlink" title="patch （vnode，newVnode）"></a>patch （vnode，newVnode）</h4><blockquote>
<p>核心：**对比 **</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190826/3a4N2wzMJLaA.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190826/k1hdRameLCv5.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190826/hycgLD8H9RuC.png?imageslim" alt="mark"></p>
<h4 id="diff-实现过程-1"><a href="#diff-实现过程-1" class="headerlink" title="diff 实现过程"></a>diff 实现过程</h4><ul>
<li>patch （container，vnode）和 patch （vnode，newVnode）</li>
<li>createElment</li>
<li>updataChildren</li>
</ul>
<h3 id="问题解答-2"><a href="#问题解答-2" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>介绍一下 diff 算法？<ul>
<li>知道什么是 diff 算法，是 linux 的基础命令</li>
<li>vdom 中 应用 diff 算法目的： 是为了 找出需要更新的节点</li>
<li>diff 实现：patch （container，vnode）和 patch （vnode，newVnode）</li>
<li>核心 逻辑 ， createElment 和 updataChildren</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
        <category>虚拟DOM</category>
      </categories>
      <tags>
        <tag>虚拟DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试每日三加一</title>
    <url>/2019/09/20/three-plus-one-a-day/</url>
    <content><![CDATA[<h2 id="前端面试每日三加一"><a href="#前端面试每日三加一" class="headerlink" title="前端面试每日三加一"></a>前端面试每日三加一</h2><blockquote>
<p>待更新状态</p>
<p>今天 2019/12/24 ~ ✌</p>
<p><a href="https://www.kancloud.cn/aya001001/fe-interview/1054361">网页版标签分类</a></p>
</blockquote>
<h3 id="第-1-天-2019-09-19）"><a href="#第-1-天-2019-09-19）" class="headerlink" title="第 1 天 (2019.09.19）"></a>第 1 天 (2019.09.19）</h3><p><strong>总览</strong>：</p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/1">页面导入样式时，使用 link 和@import 有什么区别？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/2">圣杯布局和双飞翼布局的理解和区别，并用代码实现</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/3">用递归算法实现，数组长度为 5 且元素的随机数在 2-32 间不重复的值</a></li>
</ul>
<p>1、【html】：页面导入样式时，使用 link 和@import 有什么区别？</p>
<p><strong>解析</strong>：</p>
<p>区别：</p>
<ol>
<li>link 是 HTML 标签，<a href="https://github.com/import">@import</a>是 css 提供的。</li>
<li>link 引入的样式页面加载时同时加载，<a href="https://github.com/import">@import</a>引入的样式需等页面加载完成后再加载。</li>
<li>link 没有兼容性问题，<a href="https://github.com/import">@import</a>不兼容 ie5 以下。</li>
<li>link 可以通过 js 操作 DOM 动态引入样式表改变样式，而<a href="https://github.com/import">@import</a>不可以。</li>
</ol>
<p>2、【css】：圣杯布局和双飞翼布局的理解和区别，并用代码实现</p>
<p><strong>解析：</strong></p>
<p><strong>作用</strong>：圣杯布局和双飞翼布局解决的问题是一样的，就是两边顶宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。</p>
<p><strong>区别</strong>：两者都是为了不让左右俩不遮住 middle，经典圣杯布局通过父亲 padding 给左右俩腾位置从而不会遮住 middle 内容，而双飞翼是 middle 设置 margin，限制内部内容区域，从而左右俩遮的地方不会影响到 middle 内容</p>
<p>对于三栏布局，modern solution 是 flex box/ grid 布局，这两者可以轻松实现 mobile-friendly 的方案，也可以控制顺序，middle 依然可以先渲染，9012 年兼容性不错了，如果 APP 无视 IE，这是优选</p>
<p>3、【js】：用递归算法实现，数组长度为 5 且元素的随机数在 2-32 间不重复的值</p>
<p>这一题是起源题</p>
<p>描述：</p>
<p>这是一道大题目，把考点拆成了 4 个小项；需要侯选人用递归算法实现（限制 15 行代码以内实现；限制时间 10 分钟内完成）：</p>
<ol>
<li>生成一个长度为 5 的空数组 arr。</li>
<li>生成一个（2－32）之间的随机整数 rand。</li>
<li>把随机数 rand 插入到数组 arr 内，如果数组 arr 内已存在与 rand 相同的数字，则重新生成随机数 rand 并插入到 arr 内[需要使用递归实现，不能使用 for/while 等循环]</li>
<li>最终输出一个长度为 5，且内容不重复的数组 arr。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">AddRandom(arr, creatrandomnum());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AddRandom</span>(<span class="params">arr, randomnum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.indexOf(randomnum) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    arr[i] = randomnum;</span><br><span class="line">    i++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    randomnum = creatrandomnum();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    AddRandom(arr, randomnum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatrandomnum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (<span class="number">32</span> - <span class="number">2</span>) + <span class="number">2</span>); <span class="comment">//不含最大值，含最小值 [2-33)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点评：<br>知识点：递归、随机数<br>难点：1 颗星<br>这道题主要是想考递归的用法，同时顺带考了生成指定范围的随机数方法。</p>
<h3 id="第-2-天-2019-09-20"><a href="#第-2-天-2019-09-20" class="headerlink" title="第 2 天 (2019.09.20)"></a>第 2 天 (2019.09.20)</h3><p><strong>总览</strong> ：</p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/4">html 的元素有哪些（包含 H5）？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/5">CSS3 有哪些新增的特性？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/6">写一个方法去掉字符串中的空格</a></li>
</ul>
<p>1、【html】 html 的元素有哪些（包含 H5）？</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">行内元素：</span><br><span class="line">- a</span><br><span class="line">- b</span><br><span class="line">- span</span><br><span class="line">- strong</span><br><span class="line">- i</span><br><span class="line">- em</span><br><span class="line">- button</span><br><span class="line">- input</span><br><span class="line">- label</span><br><span class="line">- br</span><br><span class="line">- textarea</span><br><span class="line">- select</span><br><span class="line"></span><br><span class="line">块元素 ：</span><br><span class="line">- div</span><br><span class="line">- p</span><br><span class="line">- h1-h6</span><br><span class="line">- ol</span><br><span class="line">- ul</span><br><span class="line">- li</span><br><span class="line">- table</span><br><span class="line">- tbody</span><br><span class="line">- td</span><br><span class="line">- tr</span><br><span class="line">- thead</span><br><span class="line">- dl</span><br><span class="line">- dt</span><br><span class="line">- dd</span><br><span class="line"></span><br><span class="line">H5新增元素：</span><br><span class="line">- section</span><br><span class="line">- article</span><br><span class="line">- audio</span><br><span class="line">- video</span><br><span class="line">- hearder</span><br><span class="line">- footer</span><br><span class="line">- small</span><br></pre></td></tr></table></figure>

<p>2、【css】 CSS3 有哪些新增的特性？</p>
<blockquote>
<p><a href="https://juejin.im/entry/595f1e3c5188250d914dd53c">前端面试之 CSS3 新特性</a></p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">边框(<span class="selector-tag">borders</span>):</span><br><span class="line">    <span class="selector-tag">border-radius</span> 圆角</span><br><span class="line">    <span class="selector-tag">box-shadow</span> 盒阴影</span><br><span class="line">    <span class="selector-tag">border-image</span> 边框图像</span><br><span class="line">背景:</span><br><span class="line">    <span class="selector-tag">background-size</span> 背景图片的尺寸</span><br><span class="line">    <span class="selector-tag">background_origin</span> 背景图片的定位区域</span><br><span class="line">    <span class="selector-tag">background-clip</span> 背景图片的绘制区域</span><br><span class="line">渐变：</span><br><span class="line">    <span class="selector-tag">linear-gradient</span> 线性渐变</span><br><span class="line">    <span class="selector-tag">radial-gradient</span> 径向渐变</span><br><span class="line">文本效果;</span><br><span class="line">    <span class="selector-tag">word-break</span></span><br><span class="line">    <span class="selector-tag">word-wrap</span></span><br><span class="line">    <span class="selector-tag">text-overflow</span></span><br><span class="line">    <span class="selector-tag">text-shadow</span></span><br><span class="line">    <span class="selector-tag">text-wrap</span></span><br><span class="line">    <span class="selector-tag">text-outline</span></span><br><span class="line">    <span class="selector-tag">text-justify</span></span><br><span class="line">转换：</span><br><span class="line">2<span class="selector-tag">D</span>转换属性</span><br><span class="line">    <span class="selector-tag">transform</span></span><br><span class="line">    <span class="selector-tag">transform-origin</span></span><br><span class="line">2<span class="selector-tag">D</span>转换方法</span><br><span class="line">    <span class="selector-tag">translate</span>(<span class="selector-tag">x</span>,<span class="selector-tag">y</span>)</span><br><span class="line">    <span class="selector-tag">translateX</span>(<span class="selector-tag">n</span>)</span><br><span class="line">    <span class="selector-tag">translateY</span>(<span class="selector-tag">n</span>)</span><br><span class="line">    <span class="selector-tag">rotate</span>(<span class="selector-tag">angle</span>)</span><br><span class="line">    <span class="selector-tag">scale</span>(<span class="selector-tag">n</span>)</span><br><span class="line">    <span class="selector-tag">scaleX</span>(<span class="selector-tag">n</span>)</span><br><span class="line">    <span class="selector-tag">scaleY</span>(<span class="selector-tag">n</span>)</span><br><span class="line">    <span class="selector-tag">rotate</span>(<span class="selector-tag">angle</span>)</span><br><span class="line">    <span class="selector-tag">matrix</span>(<span class="selector-tag">n</span>,<span class="selector-tag">n</span>,<span class="selector-tag">n</span>,<span class="selector-tag">n</span>,<span class="selector-tag">n</span>,<span class="selector-tag">n</span>)</span><br><span class="line">3<span class="selector-tag">D</span>转换：</span><br><span class="line">*3<span class="selector-tag">D</span>转换属性：</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">transform</span></span><br><span class="line">    <span class="selector-tag">transform-origin</span></span><br><span class="line">    <span class="selector-tag">transform-style</span></span><br><span class="line">3<span class="selector-tag">D</span>转换方法</span><br><span class="line">    <span class="selector-tag">translate3d</span>(<span class="selector-tag">x</span>,<span class="selector-tag">y</span>,<span class="selector-tag">z</span>)</span><br><span class="line">    <span class="selector-tag">translateX</span>(<span class="selector-tag">x</span>)</span><br><span class="line">    <span class="selector-tag">translateY</span>(<span class="selector-tag">y</span>)</span><br><span class="line">    <span class="selector-tag">translateZ</span>(<span class="selector-tag">z</span>)</span><br><span class="line">    <span class="selector-tag">scale3d</span>(<span class="selector-tag">x</span>,<span class="selector-tag">y</span>,<span class="selector-tag">z</span>)</span><br><span class="line">    <span class="selector-tag">scaleX</span>(<span class="selector-tag">x</span>)</span><br><span class="line">    <span class="selector-tag">scaleY</span>(<span class="selector-tag">y</span>)</span><br><span class="line">    <span class="selector-tag">scaleZ</span>(<span class="selector-tag">z</span>)</span><br><span class="line">    <span class="selector-tag">rotate3d</span>(<span class="selector-tag">x</span>,<span class="selector-tag">y</span>,<span class="selector-tag">z</span>,<span class="selector-tag">angle</span>)</span><br><span class="line">    <span class="selector-tag">rotateX</span>(<span class="selector-tag">x</span>)</span><br><span class="line">    <span class="selector-tag">rotateY</span>(<span class="selector-tag">y</span>)</span><br><span class="line">    <span class="selector-tag">rotateZ</span>(<span class="selector-tag">z</span>)</span><br><span class="line">    <span class="selector-tag">perspective</span>(<span class="selector-tag">n</span>)</span><br><span class="line">过渡</span><br><span class="line">	<span class="selector-tag">transition</span></span><br><span class="line">动画</span><br><span class="line">	<span class="keyword">@Keyframes</span>规则</span><br><span class="line">	animation</span><br><span class="line">弹性盒子(flexbox)</span><br><span class="line">多媒体查询@media</span><br></pre></td></tr></table></figure>

<p>3、【js】 写一个方法去掉字符串中的空格</p>
<blockquote>
<p>写一个方法去掉字符串中的空格，要求传入不同的类型分别能去掉前、后、前后、中间的空格</p>
<p>知识点：正则表达式、数组的 API</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;  abc d e f  g &quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="regexp">/\s+/g</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> trimStr = str.replace(reg, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(trimStr);</span><br><span class="line">&#125;</span><br><span class="line">trim(str);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> trim = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/\s*/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">str.replace(<span class="regexp">/\s*/g</span>, <span class="string">&quot;&quot;</span>); <span class="comment">//去除字符串内所有的空格</span></span><br><span class="line">str.replace(<span class="regexp">/^\s*|\s*$/g</span>, <span class="string">&quot;&quot;</span>); <span class="comment">//去除字符串内两头的空格</span></span><br><span class="line">str.replace(<span class="regexp">/^\s*/</span>, <span class="string">&quot;&quot;</span>); <span class="comment">//去除字符串内左侧的空格</span></span><br><span class="line">str.replace(<span class="regexp">/(\s*$)/g</span>, <span class="string">&quot;&quot;</span>); <span class="comment">//去除字符串内右侧的空格</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;  abc d e f  g &quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.split(<span class="string">&quot; &quot;</span>).join(<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="第-3-天-2019-09-21"><a href="#第-3-天-2019-09-21" class="headerlink" title="第 3 天 (2019.09.21)"></a>第 3 天 (2019.09.21)</h3><p><strong>总览</strong> ：</p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/7">HTML 全局属性(global attribute)有哪些（包含 H5）？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/8">在页面上隐藏元素的方法有哪些？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/9">去除字符串中最后一个指定的字符</a></li>
</ul>
<p>1、【html 】HTML 全局属性(global attribute)有哪些（包含 H5）？</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">全局属性：用于任何HTML5元素的属性</span><br><span class="line"></span><br><span class="line">    accesskey ：规定激活元素的快捷键；</span><br><span class="line">    class ：规定元素的一个或多个类名（引用样式表中的类）；</span><br><span class="line">    contenteditable ：规定元素内容是否可编辑；</span><br><span class="line">    contextmenu ：规定元素的上下文菜单。上下文菜单在用户点击元素时显示。</span><br><span class="line">    data-* ：用于存储页面或应用程序的私有定制数据。</span><br><span class="line">    dir ：规定元素中内容的文本方向。</span><br><span class="line">    draggable ：规定元素是否可拖动。</span><br><span class="line">    dropzone： 规定在拖动被拖动数据时是否进行复制、移动或链接。</span><br><span class="line">    hidden ： 样式上会导致元素不显示，但是不能用这个属性实现样式。</span><br><span class="line">    id 规定元素的唯一： id。</span><br><span class="line">    lang ：规定元素内容的语言。</span><br><span class="line">    spellcheck： 规定是否对元素进行拼写和语法检查。</span><br><span class="line">    style ：规定元素的CSS行内元素。</span><br><span class="line">    tabindex ：规定元素的tab键次序。</span><br><span class="line">    title： 规定有关元素的额外信息。</span><br><span class="line">    translate ：规定是否应该翻译元素内容。</span><br></pre></td></tr></table></figure>

<p>2、【css】： 在页面上隐藏元素的方法有哪些？</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">占位:</span><br><span class="line">    -visibility: hidden;</span><br><span class="line">    -margin-left: -100%;</span><br><span class="line">    -opacity: 0;</span><br><span class="line">    -transform: scale(0);</span><br><span class="line"></span><br><span class="line">不占位:</span><br><span class="line">    -display: none;</span><br><span class="line">    -width: 0; height: 0; overflow: hidden;</span><br><span class="line"></span><br><span class="line">仅对块内文本元素:</span><br><span class="line">    -text-indent: -9999px;</span><br><span class="line">    -font-size: 0;</span><br><span class="line"></span><br><span class="line"> 利用 position （absolute 的情况下）</span><br><span class="line">    left/right/top/bottom: 9999px/-9999px 让元素在视区外</span><br><span class="line">    z-index: -9999 放到最底层，同一位置可以让其他元素把这个给遮掉</span><br></pre></td></tr></table></figure>

<p>3、【js】去除字符串中最后一个指定的字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetLaststr</span>(<span class="params">s, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> s != <span class="string">&quot;string&quot;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> index = s.lastIndexOf(target);</span><br><span class="line">  <span class="keyword">return</span> s.substring(<span class="number">0</span>, index) + s.substring(index + <span class="number">1</span>, s.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delLast</span>(<span class="params">str, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">    .split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .reverse()</span><br><span class="line">    .join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .replace(target, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    .split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .reverse()</span><br><span class="line">    .join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-4-天-2019-09-22"><a href="#第-4-天-2019-09-22" class="headerlink" title="第 4 天 (2019.09.22)"></a>第 4 天 (2019.09.22)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/10">HTML5 的文件离线储存怎么使用，工作原理是什么？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/11">CSS 选择器有哪些？哪些属性可以继承？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/12">写一个方法把下划线命名转成大驼峰命名</a></li>
</ul>
<p>1、【html】 HTML5 的文件离线储存怎么使用，工作原理是什么？</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000000732617">有趣的 HTML5：离线存储</a></p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">优点:</span><br><span class="line">没有网络时可以浏览,加快资源的加载速度,减少服务器负载</span><br><span class="line"></span><br><span class="line">使用:</span><br><span class="line">只需要在页面头部加入,然后创建manifest.appcache文件</span><br><span class="line"></span><br><span class="line">浏览器如何解析manifest</span><br><span class="line">    1.在线情况:浏览器发现html头部有manifest属性,他会请求manifest文件,如果是第一次访问,那么浏览器会根据manifest文件的内容下载相应的资源并且进行离线存储.如果已经访问过并存储,那么浏览器使用 离线的资源价值,然后对比新的文件,如果没有发生改变就不做任何操作,如果文件改变了,那么就会重新下载文件中的资源并进行离线存储</span><br><span class="line">    2.离线情况:浏览器就直接使用离线存储资源</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】CSS 选择器有哪些？哪些属性可以继承？</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器:</span><br><span class="line">    通配符,<span class="selector-tag">id</span>,<span class="selector-tag">class</span>,标签,后代选择器,子选择器,兄弟选择器,属性选择器,伪类选择器,伪元素选择器</span><br><span class="line"></span><br><span class="line">可继承的属性:</span><br><span class="line">    字体属性<span class="selector-pseudo">:font-size</span>,<span class="selector-tag">font-weight</span>,<span class="selector-tag">font-style</span>,<span class="selector-tag">font-family</span></span><br><span class="line">    文本属性<span class="selector-pseudo">:text-indent</span>,<span class="selector-tag">text-align</span>,<span class="selector-tag">line-height</span>,<span class="selector-tag">word-spacing</span>,<span class="selector-tag">letter-spacing</span>,<span class="selector-tag">color</span>,<span class="selector-tag">direction</span>,<span class="selector-tag">text-transform</span></span><br><span class="line">    元素可见性<span class="selector-pseudo">:visibility</span>,<span class="selector-tag">opacity</span></span><br><span class="line">    光标属性<span class="selector-pseudo">:cursor</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】 写一个方法把下划线命名转成大驼峰命名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeStr</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str.split(<span class="string">&quot;_&quot;</span>).length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  str.split(<span class="string">&quot;_&quot;</span>).reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b.substr(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + b.substr(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-5-天-2019-09-23"><a href="#第-5-天-2019-09-23" class="headerlink" title="第 5 天 (2019.09.23)"></a>第 5 天 (2019.09.23)</h3><p><strong>总览</strong> ：</p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/13">简述超链接 target 属性的取值和作用</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/14">CSS3 新增伪类有哪些并简要描述</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/15">写一个把字符串大小写切换的方法</a></li>
</ul>
<p>1、【html】 简述超链接 target 属性的取值和作用</p>
<p><code>a</code> 标签的 <code>target</code> 属性一共有四个值。</p>
<ul>
<li><p><code>_self</code></p>
<p>默认属性。在当前窗口或者框架中加载目标文档。</p>
</li>
<li><p><code>_blank</code></p>
<p>打开新的窗口或者新的标签页。在使用这个属性时，最好添加 <code>rel=&quot;noopener norefferrer&quot;</code> 属性，防止打开的新窗口对原窗口进行篡改。防止 <code>window.opener</code> API 的恶意行为。</p>
</li>
<li><p><code>_parent</code></p>
<p>在 <code>frame</code> 或者 <code>iframe</code> 中使用较多。在父级框架中载入目标文档，当 <code>a</code> 标签本身在顶层时，与 <code>_self</code> 相同。</p>
</li>
<li><p><code>_top</code></p>
<p>在 <code>frame</code> 或者 <code>iframe</code> 中使用较多。直接在顶层的框架中载入目标文档，加载整个窗口。</p>
</li>
</ul>
<p>2、【css】CSS3 新增伪类有哪些并简要描述</p>
<p>CSS3 中规定伪类使用一个 <code>:</code> 来表示；伪元素则使用 <code>::</code> 来表示。</p>
<p>CSS3 中新增的伪元素有以下这些:</p>
<ul>
<li><code>:first-child / :last-child</code> 表示子元素结构关系的</li>
<li><code>:nth-child() / nth-last-child()</code> 用来控制奇数、偶数行的（控制表单奇数、偶数行的样式）</li>
<li><code>:first-of-type / :last-of-type</code> 表示一组兄弟元素中其类型的第一个元素 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-of-type">MDN</a></li>
<li><code>:nth-of-type() / :nth-last-of-type()</code> 这个选择器匹配那些在相同兄弟节点中的位置与模式 an+b 匹配的相同元素` <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-of-type">MDN</a></li>
<li><code>:root</code> html 根元素</li>
<li><code>:not()</code> 否定选择器，用的比较多</li>
<li><code>:only-child</code> 只有一个子元素时才会生效</li>
<li><code>:empty</code> 选择连空格都没有的元素</li>
</ul>
<p>3、【js】写一个把字符串大小写切换的方法</p>
<p>正则表达式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">caseConvert</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/([a-z]*)([A-Z]*)/g</span>, <span class="function">(<span class="params">m, s1, s2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;s1.toUpperCase()&#125;</span><span class="subst">$&#123;s2.toLowerCase()&#125;</span>`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 toUpperCase() ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aBcDeFgH&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === item.toUpperCase()) &#123;</span><br><span class="line">    item = item.toLowerCase();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    item = item.toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">  arr.push(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newStr = arr.join(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="第-6-天-2019-09-24"><a href="#第-6-天-2019-09-24" class="headerlink" title="第 6 天 (2019.09.24)"></a>第 6 天 (2019.09.24)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/16">label 都有哪些作用？并举相应的例子说明</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/17">用 css 创建一个三角形，并简述原理</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/18">写一个去除制表符和换行符的方法</a></li>
</ul>
<p>1、【html】label 都有哪些作用？并举相应的例子说明</p>
<p><strong>解析</strong>:</p>
<ol>
<li>互相关联的机制</li>
</ol>
<p>表示用户界面中某个元素的说明<br>增加命中区域，屏幕阅读器可以读出标签。使使用辅助技术的用户更容易理解输入 哪些数据</p>
<ol start="2">
<li>利用<code>label</code>“模拟”<code>button</code>来解决不同浏览器原生<code>button</code>样式不同的问题</li>
<li>结合<code>checkbox</code>、<code>radio</code>表单元素实现纯 CSS 状态切换，这样的实例就太多了。比如控制 CSS 动画播放和停止。下面是一部分代码。<a href="https://codepen.io/mts123/pen/EzqdbM">详细实例地址</a>*</li>
<li><code>input</code>的<code>focus</code>事件会触发锚点定位，我们可以利用<code>label</code>当触发器实现选项卡切换效果。下面代码选自张鑫旭《CSS 世界》</li>
</ol>
<p>2、【css】用 css 创建一个三角形，并简述原理</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、【js】写一个去除制表符和换行符的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = str.replace(<span class="regexp">/\t\n\v\r\f+/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-7-天-2019-09-25"><a href="#第-7-天-2019-09-25" class="headerlink" title="第 7 天 (2019.09.25)"></a>第 7 天 (2019.09.25)</h3><p><strong>总览</strong> ：</p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/19">iframe 框架都有哪些优缺点？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/20">简述你对 BFC 规范的理解</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/21">统计某一字符或字符串在另一个字符串中出现的次数</a></li>
</ul>
<p>1、【html】iframe 框架都有哪些优缺点？</p>
<p>iframe 是一种框架，也是一种很常见的网页嵌入方式</p>
<p><strong>iframe 的优点：</strong></p>
<p>1.iframe 能够原封不动的把嵌入的网页展现出来。</p>
<p>2.如果有多个网页引用 iframe，那么你只需要修改 iframe 的内容，就可以实现调用的每一个页面内容的更改，方便快捷。</p>
<p>3.网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用 iframe 来嵌套，可以增加代码的可重用。</p>
<p>4.如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由 iframe 来解决。</p>
<p><strong>iframe 的缺点</strong> ：</p>
<p>1.会产生很多页面，不容易管理。</p>
<p>2.iframe 框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。</p>
<p>3.代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理 iframe 中的内容，所以使用 iframe 会不利于搜索引擎优化。</p>
<p>4.很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。</p>
<p>5.iframe 框架页面会增加服务器的 http 请求，对于大型网站是不可取的。</p>
<p>分析了这么多，现在基本上都是用 Ajax 来代替 iframe，所以 iframe 已经渐渐的退出了前端开发</p>
<p>2.【css】简述你对 BFC 规范的理解</p>
<blockquote>
<p><a href="https://juejin.im/post/5909db2fda2f60005d2093db">[布局概念] 关于 CSS-BFC 深入理解</a></p>
</blockquote>
<p><strong>块格式化上下文（Block Formatting Context，BFC）</strong> 是 Web 页面的可视化 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">BFC：是CSS中的一个渲染机制，BFC就相当于一个盒子，内部的元素与外界的元素互不干扰。它不会影响外部的布局，外部的布局也不会影响到它。</span><br><span class="line"></span><br><span class="line">形成条件（任意一条）</span><br><span class="line">    float的值不是none</span><br><span class="line">    position 的值不是static或者relative</span><br><span class="line">    display的值是inline-block,table-cell,flex,table-caption或者inline-flex</span><br><span class="line">    overflow的值不是visible</span><br><span class="line"></span><br><span class="line">特性</span><br><span class="line">    内部的盒子会在垂直方向上一个接一个的放置</span><br><span class="line">    对于同一个BFC的俩个相邻的盒子的margin会发生重叠，与方向无关。</span><br><span class="line">    每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此</span><br><span class="line">    BFC的区域不会与float的元素区域重叠</span><br><span class="line">    计算BFC的高度时，浮动子元素也参与计算</span><br><span class="line">    BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】 统计某一字符或字符串在另一个字符串中出现的次数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strCount</span>(<span class="params">str, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (!target) <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">while</span>(str.match(target)) &#123;</span><br><span class="line">        str = str.replace(target, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-8-天-2019-09-26"><a href="#第-8-天-2019-09-26" class="headerlink" title="第 8 天 (2019.09.26)"></a>第 8 天 (2019.09.26)</h3><p>总览：</p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/22">简述下 html5 的离线储存原理，同时说明如何使用？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/23">清除浮动的方式有哪些及优缺点？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/24">写一个加密字符串的方法</a></li>
</ul>
<p>1、【html】 简述下 html5 的离线储存原理，同时说明如何使用？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">原理：</span><br><span class="line">HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</span><br><span class="line">如何使用： ①　页面头部像下面一样加入一个manifest的属性。</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">&quot;cache.manifest&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">在cache.manifest文件的编写离线存储的资源。 CACHE MANIFEST #v0.1 CACHE:</span><br><span class="line">js/index.js css/index.css NETWORK: images/logo.png FALLBACK: *.html /404.html /*</span><br><span class="line">/ /404.html 或 /html/ /404.html 也可*/</span><br><span class="line">以#号开头的是注释，一般会在第二行写个版本号，用来在缓存的文件更新时，更新manifest以实现浏览器重新下载新的文件，可以是版本号，时间戳或md5码等。</span><br><span class="line">离线存储的 manifest一般由三个部分组成：</span><br><span class="line">①　CACHE：必选，表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</span><br><span class="line">②　NETWORK：可选，可以使用通配符，表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。</span><br><span class="line">③　FALLBACK：可选，表示如果访问第一个资源失败，那么就使用第二个资源来替换他，如/html/</span><br><span class="line">/404.html表示用 “404.html” 替代 /html/ 目录中的所有文件，/ /404.html表示用</span><br><span class="line">“404.html” 替代当前目录中的所有文件，*.html /404.html表示用 “404.html” 替代</span><br><span class="line">所有html文件。</span><br></pre></td></tr></table></figure>

<p>2、【css】清除浮动的方式有哪些及优缺点？</p>
<p>唠叨：</p>
<ul>
<li>在现在的实际工作当中我已经很少用浮动来布局了，真的很少，刚开始学习的时候用的还蛮多，现在 Flex 布局，标准文档流以及 定位 已经可以满足大部分的布局需求了。</li>
<li>浮动带来的问题是盒子塌陷问题，所以我们就来解决这个问题吧</li>
</ul>
<p><strong>解决方案</strong></p>
<ol>
<li>给外部盒子也添加浮动</li>
</ol>
<p>把外部盒子也从标准文档流中抽离，让它和孩子们见面。<br><strong>缺点</strong> ：可读性差，不易于维护（别人很难理解为什么要给父元素也添上 float），而且可能需要调整整个页面布局。</p>
<ol start="2">
<li>在外部盒子内最下方添上带 clear 属性的空盒子</li>
</ol>
<p>可以是 div 也可以是其它块级元素，把 <code>&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</code>放在盒内底部，用最下面的空盒子清除浮动，把盒子重新撑起来。<br><strong>缺点</strong>：引入了冗余元素</p>
<ol start="3">
<li>用 overflow:hidden 清除浮动 ，外层父元素使用 <code>overflow:hidden;</code> 属性触发 BFC，让内层的 <code>float</code> 不会影响外层的布局</li>
</ol>
<p>给外部盒子添上这个属性就好了，非常简单。<br><strong>缺点</strong> ：有可能造成溢出元素不可见，影响展示效果。</p>
<ol start="4">
<li>用 after 伪元素清除浮动 ( 比较常用的方式 )</li>
</ol>
<p>给外部盒子的 after 伪元素设置 clear 属性，再隐藏它<br>这其实是对空盒子方案的改进，一种纯 CSS 的解决方案，不用引入冗余元素。</p>
<p>3、【js】 简要描述下什么是回调函数并写一个例子出来</p>
<blockquote>
<p>回调是把一个函数作为参数传递给另一个函数，当该函数满足某个条件时触发该参数函数。<br>主要用于异步操作 例如网络请求 防止页面同步代码阻塞导致渲染线程停止</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longTask</span>(<span class="params">callback, timeout</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(callback, timeout);</span><br><span class="line">&#125;</span><br><span class="line">longTask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;回调任务被执行了&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;我是同步代码 不会阻塞我&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="第-9-天-2019-09-27"><a href="#第-9-天-2019-09-27" class="headerlink" title="第 9 天 (2019.09.27)"></a>第 9 天 (2019.09.27)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/25">浏览器内多个标签页之间的通信方式有哪些？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/26">简述下你理解的优雅降级和渐进增强</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/27">写一个判断数据类型的方法</a></li>
</ul>
<p>1、【html】浏览器内多个标签页之间的通信方式有哪些？</p>
<blockquote>
<p><a href="https://juejin.im/post/5acdba01f265da23826e5633">实现多个标签页之间通信的几种方法</a></p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">完全答案：</span><br><span class="line">    WebSocket （可跨域）</span><br><span class="line">    postMessage（可跨域）</span><br><span class="line">    Worker之SharedWorker</span><br><span class="line">    Server-Sent Events</span><br><span class="line">    localStorage</span><br><span class="line">    BroadcastChannel</span><br><span class="line">    Cookies</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】 简述下你理解的优雅降级和渐进增强</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000013818745">前端面试题-渐进增强和优雅降级</a></p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">简介：渐进增强和优雅降级这两个概念是在 CSS3 出现之后火起来的。由于低级浏览器不支持 CSS3，但是 CSS3 特效太优秀不忍放弃，所以在高级浏览器中使用 CSS3，而在低级浏览器只保证最基本的功能。</span><br><span class="line"></span><br><span class="line">优雅降级：</span><br><span class="line">	先不考虑兼容，优先最新版本浏览器效果，之后再逐渐兼容低版本浏览器。</span><br><span class="line"></span><br><span class="line">渐进增强：</span><br><span class="line">    考虑兼容，以较低（多）浏览器效果为主，之后再逐渐增加对新版本浏览器的支持，以内容为主。也是多数公司所采用的方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】 写一个判断数据类型的方法</p>
<blockquote>
<p>考点：Object.prototype.toString 方法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> typeCheck = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> typeStr = <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line">  <span class="built_in">console</span>.log(typeStr);</span><br><span class="line">  <span class="keyword">return</span> typeStr.toLowerCase().slice(<span class="number">8</span>, typeStr.length - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第-10-天-2019-09-28"><a href="#第-10-天-2019-09-28" class="headerlink" title="第 10 天 (2019.09.28)"></a>第 10 天 (2019.09.28)</h3><p><strong>总览</strong> ：</p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/28">viewport 常见设置都有哪些？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/29">对比下 px、em、rem 有什么不同？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/30">简要描述下什么是回调函数并写一个例子出来</a></li>
</ul>
<p>1、【html】 viewport 常见设置都有哪些？</p>
<p><strong>解析</strong> ：</p>
<p>在移动端做开发时，必须要搞清楚 <code>viewport</code> 这一设置。</p>
<p><code>viewport</code> 就是视区窗口，也就是浏览器中显示网页的部分。PC 端上基本等于设备显示区域，但在移动端上 <code>viewport</code> 会超出设备的显示区域（即会有横向滚动条出现）。<br>设备默认的 <code>viewport</code> 在 980 - 1024 之间。</p>
<p>为了让移动端可以很好地显示页面，因此需要对 <code>viewport</code> 进行设置。相关的设置值如下：</p>
<p><img src="http://static.zxinc520.com/blog/20190928/QQxtaIhl4ArA.png?imageslim" alt="mark"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// width=device-width, initial-scale=1.0 是为了兼容不同浏览器</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、【css】 对比下 px、em、rem 有什么不同？</p>
<ul>
<li>px: 绝对固定的值，无论页面放大或者缩小都不会改变。</li>
<li>em: 相对父元素字体大小的倍数。如果父元素的字体为 <code>12px</code>，那么子元素 <code>1em</code> 就是 <code>24px</code>。由于是相对父级的倍数，所以多层嵌套时，倍数关系的计算会很头痛。</li>
<li>rem: 相对根元素字体大小的倍数。相对于 <code>html</code> 的字体大小，如果不做任何修改，浏览器默认字体大小为 <code>16px</code>。</li>
</ul>
<blockquote>
<p><strong>小技巧</strong></p>
</blockquote>
<p>如果为了方便计算 <code>rem</code>，可以设置 <code>font-size= 62.5%</code> 这样一来默认的字体就变成 <code>10px</code> 了。之后的 <code>rem</code> 就是以 <code>10</code> 为基准了。</p>
<p>3、【js】 简要描述下什么是回调函数并写一个例子出来</p>
<p>回调函数首先作为一个函数的参数传入，当这个函数执行后再执行的函数，往往会依赖前一个函数执行的结果。<br>在 <code>javascript</code> 中，对于 I/O、HTTP 请求等异步操作，为了控制执行的顺序就需要使用回调的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三个参数就是回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">param1, param2, ..., callback</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// To do some action</span></span><br><span class="line">  <span class="comment">// 往往会在最后调用 callback 并且传入操作过的参数</span></span><br><span class="line">  callback(cbParam1, cbParam2, ...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际调用的时候</span></span><br><span class="line">func1(param1, param2, ..., <span class="function">(<span class="params">cbParam1, cbParam2, ...</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// To do some action</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当有过个任务需要顺序执行时，如果采用回调函数的形式就会出现我们熟悉的“回调地狱”的情况。为了解决这个问题，在 ES6 中就有了 <code>Promise</code> 和 <code>async/await</code> 方法。<br>目前看来 <code>async/await</code> 在异步写法上较为优雅。</p>
<h3 id="第-11-天-2019-09-29"><a href="#第-11-天-2019-09-29" class="headerlink" title="第 11 天 (2019.09.29)"></a>第 11 天 (2019.09.29)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/31">你对标签语义化的理解是什么？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/32">css 常用的布局方式有哪些？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/33">简要描述下 JS 有哪些内置的对象</a></li>
</ul>
<p>1、【html】 你对标签语义化的理解是什么？</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">①去掉或者丢失样式的时候能够让页面呈现出清晰的结构；</span><br><span class="line"></span><br><span class="line">②有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</span><br><span class="line"></span><br><span class="line">③方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</span><br><span class="line"></span><br><span class="line">④便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】css 常用的布局方式有哪些？</p>
<ul>
<li><p>流式布局: 最基本的布局，就是顺着 html 像流水一样流下来</p>
</li>
<li><p>绝对定位: 利用 <code>position: absolute</code> 进行绝对定位的布局</p>
</li>
<li><p>float 布局: 最初用来解决多栏布局的问题。比如圣杯、双飞燕的布局都可以用 <code>float</code> 来实现</p>
</li>
<li><p>珊格布局: bootstrap 用的布局，把页面分为 24 分，通过 row 和 col 进行布局</p>
</li>
<li><p>flex 布局: css3 的布局可以非常灵活地进行布局和排版</p>
</li>
<li><p>grid 布局: 网格布局</p>
<p>3.【js】简要描述下 JS 有哪些内置的对象？</p>
</li>
</ul>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000011467723">JS 所有内置对象属性和方法汇总</a></p>
</blockquote>
<p><strong>JavaScript 有 3 大对象，分别是本地对象、内置对象和宿主对象。</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">本地对象：这些引用类型在运行过程中需要通过new来创建所需的实例对象。</span><br><span class="line">包含：Object、Array、Date、RegExp、Function、Boolean、Number、String等。</span><br><span class="line"></span><br><span class="line">内置对象：内置对象是本地对象的子集。</span><br><span class="line">包含：Global和Math。</span><br><span class="line">ECMAScript5中增添了JSON这个存在于全局的内置对象。</span><br><span class="line"></span><br><span class="line">宿主对象：对于嵌入到网页中的JS来说，其宿主对象就是浏览器提供的对象，浏览器对象有很多，如Window和Document等。</span><br><span class="line">所有的DOM和BOM对象都属于宿主对象。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-12-天-2019-09-30"><a href="#第-12-天-2019-09-30" class="headerlink" title="第 12 天 (2019.09.30)"></a>第 12 天 (2019.09.30)</h3><p><strong>总览</strong> ：</p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/34">常见的浏览器内核都有哪些？并介绍下你对内核的理解</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/35">说说你对 css 盒子模型的理解</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/36">写一个获取当前 url 查询字符串中的参数的方法</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/37">网页应用从服务器主动推送到客户端有那些方式？</a></li>
</ul>
<p>1、【html】常见的浏览器内核都有哪些？并介绍下你对内核的理解</p>
<p><strong>常见的浏览器内核：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Trident内核：IE，360，搜过浏览器；</span><br><span class="line">Gecko内核：Netscape6及以上版本，</span><br><span class="line">Presto内核：Opera</span><br><span class="line">Blink内核：Opera；</span><br><span class="line">Webkit内核：Safari，Chrome</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>介绍一下对浏览器内核的理解</strong></p>
<blockquote>
<p>主要分成两个部分：渲染引擎(Render Engine)和 JS 引擎。</p>
</blockquote>
<p><strong>渲染引擎</strong>：负责取得网页的内容(html,xml 和图像等)，整理讯息(例如假如 css)，以及计算网页的显示方式，然后输出到显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不同。所有网页浏览器、电子邮件客户端以及它需要编辑、显示网络内容的应用程序都需要内核。</p>
<p><strong>JS 引擎</strong>：解析和执行 JavaScript 来实现网页的动态效果。</p>
<p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向与只指渲染引擎。</p>
<p>2.【css】说说你对 css 盒子模型的理解？</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000015235886">面试官：谈谈你对 CSS 盒模型的认识?（你确定会？）</a></p>
</blockquote>
<p>涉及知识点(层层递进):</p>
<blockquote>
<ol>
<li>基本概念：标准模型+ IE 模型(区别)</li>
<li>CSS 如何设置这两种模型</li>
<li>JS 如何设置获取盒子模型对应的宽和高</li>
<li>实例题(根据盒模型解释边距重叠)</li>
<li>BFC(边距重叠解决方案)</li>
</ol>
</blockquote>
<p><strong>1.基本概念：标准模型+IE 模型</strong></p>
<p>标准盒子模型：包括 margin,border,padding,content,<u>并且 content 部分不包括其他部分</u><br>IE 盒子模型：包括 margin,border,padding,content，<u>content 包含了 border 和 padding</u></p>
<p><strong>2.css 如何设置这两种模式</strong></p>
<p>标准盒模型：box-sizing:content-box<br>IE 盒模型：box-sizing:border-box</p>
<p><strong>3.js 如何设置获取盒子模型对应的宽和高</strong></p>
<ol>
<li>dom.style.width:</li>
</ol>
<blockquote>
<p>只能获取内联样式，因此是不准确的</p>
</blockquote>
<ol start="2">
<li>dom.currentStyle.width</li>
</ol>
<blockquote>
<p>与 window.getComputedStyle 方法功能相同，实现在旧版本的 IE 浏览器中<br>3）window.getComputedStyle(dom).width:<br>方法返回一个对象，该对象在应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有 CSS 属性值。因此输出是准确的<br>4）dom.getBoundingClientRect().width<br>返回一个 DOMRect 对象，这个对象是由该元素的 getClientRects()方法返回的一组矩形的集合。<br>DOMRect 对象包含了一组用于描述边框的只读属性–left,top,right,bottom,单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的。</p>
</blockquote>
<p>3、【js】 写一个获取当前 url 查询字符串中的参数的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	例如网址：http://zxinc520.com/?a=hello&amp;b=world</span></span><br><span class="line"><span class="comment">	window.location.search = &quot; ?a=hello&amp;b=world &quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">params</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> search = <span class="built_in">window</span>.location.search;</span><br><span class="line">  search = search.substr(<span class="number">1</span>, search.length);</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (!search) <span class="keyword">return</span> res;</span><br><span class="line">  search.split(<span class="string">&quot;&amp;&quot;</span>).map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [key, value] = item.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">    res[key] = <span class="built_in">decodeURIComponent</span>(value);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、【软技能】 网页应用从服务器主动推送到客户端有那些方式？</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1. html5 websocket</span><br><span class="line">2. WebSocket 通过 Flash</span><br><span class="line">3. XHR长时间连接</span><br><span class="line">4. XHR Multipart Streaming</span><br><span class="line">5. 不可见的Iframe</span><br><span class="line">6. &lt;script&gt;标签的长时间连接(可跨域)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-13-天-2019-10-08"><a href="#第-13-天-2019-10-08" class="headerlink" title="第 13 天 (2019.10.08)"></a>第 13 天 (2019.10.08)</h3><p>总览：</p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/38">html5 中的 form 怎么关闭自动完成？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/39">::before 和:after 中单冒号和双冒号的区别是什么，这两个伪元素有什么作用？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/40">说说你对 javascript 的作用域的理解</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/41">http 都有哪些状态码？</a></li>
</ul>
<p>1、【html】 html5 中的 form 怎么关闭自动完成？</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">h5新增的补全功能，菜鸟教程上写的比较含糊比较难懂；</span><br><span class="line">解释： 在部分浏览器上，foucs输入框可以把之前输入过的值自动填入，如果不想自动填入，可以关掉它；</span><br><span class="line">autocomplete=&quot;off&quot;</span><br><span class="line">默认是&quot;on&quot; 开启状态</span><br><span class="line"></span><br><span class="line">一般业务下不会调整这个自动完成，因为对产品来说简化用户操作，建议打开</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】::before 和:after 中单冒号和双冒号的区别是什么，这两个伪元素有什么作用？</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">:表示伪类，是一种样式，比如:hover, :active等</span><br><span class="line">::表示伪元素，是具体的内容，比如::before是在元素前面插入内容，::after则是在元素后面插入内容，不过需要content配合，并且插入的内容是inline的。</span><br><span class="line">:before和:after其实还是表示伪元素，在css3中已经修订为::before和::after了，只是为了能兼容IE浏览器，所以也可以表示成:before和:after</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">:: 和 : 是 CSS3 中为了区别伪类和伪元素所用的不同的写法。:: 表示伪元素，目前两种写法都被兼容。</span><br><span class="line">::before,::after 可以在一个 DOM 元素的前面和后面增加一个伪元素。可以用来清除浮动、为元素增加特殊效果（如前面有特殊符号等）。</span><br><span class="line">::before 和 ::after 默认添加的是 inlne 元素，通过 content 属性来设置展示的内容，并且必须要设置 content 属性。content 属性可以利用 attr 与元素的相关内容做联动。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】说说你对 javascript 的作用域的理解？</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1、全局作用域。这个没啥说的，就是在顶层环境中申明的变量都是全局作用域，他们的属性其实都在window对象下面。</span><br><span class="line"></span><br><span class="line">2、函数作用域。在函数内部定义的变量都是函数作用域，只能在函数中访问到，当然也可以通过闭包来访问。除此之外，在其他地方是没法访问函数内部的变量的。</span><br><span class="line">局部作用域。es6中新增的特性，弥补了以前只能使用匿名及时运行函数来创建局部变量的缺陷。使用很简单，直接用let来申明变量就行。也可以使用const来申明变量，表明这是常数。</span><br><span class="line"></span><br><span class="line">3、作用域链。要说清这个，需要首先明白javascript的代码运行过程。假设现在有个函数funcA，在该函数内部申明了一个局部变量a，在函数内部又定义了一个函数funcB，在函数B中申明了变量b。如下：</span><br><span class="line">    function funcA () &#123;</span><br><span class="line">    let a;</span><br><span class="line">    function funcB () &#123;</span><br><span class="line">    let b;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">当进入funcA时，这时候会把变量a压入当前的作用域A中，并且将作用域A入栈，当进入funcB时，则会把变量b压入当前的作用域B中，并且将作用域B入栈，那么这时候栈中就有了作用域A和作用域B，当在funcB中查找某个变量时，会先从当前的作用域B中查找，如果没有的话，那么就根据栈中的作用域依次往上查找，这就是作用域链。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4、【软技能】http 都有哪些状态码？</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">200 成功</span><br><span class="line">301 重定向</span><br><span class="line">304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</span><br><span class="line">400 (错误请求) 服务器不理解请求的语法。</span><br><span class="line">403 (禁止) 服务器拒绝请求。</span><br><span class="line">404 (未找到) 服务器找不到请求的网页。</span><br><span class="line">500 (服务器内部错误) 服务器遇到错误，无法完成请求。</span><br><span class="line">501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</span><br><span class="line">502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。</span><br><span class="line">503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。</span><br><span class="line">504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</span><br><span class="line">505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。</span><br><span class="line"></span><br><span class="line">常见状态码：</span><br><span class="line">    2xx 成功</span><br><span class="line">    3xx 重定向</span><br><span class="line">    4xx 未找到资源</span><br><span class="line">    5xx 服务器异常</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-14-天-2019-10-09"><a href="#第-14-天-2019-10-09" class="headerlink" title="第 14 天 (2019.10.09)"></a>第 14 天 (2019.10.09)</h3><p><strong>总览</strong> ：</p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/42">为什么 HTML5 只需要写&lt;_!DOCTYPE HTML_ &gt;就可以？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/43">position:fixed;在 ios 下无效该怎么办？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/44">什么是闭包？优缺点分别是什么？</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/45">你最喜欢用哪些编辑器？喜欢它的理由是什么？</a></li>
</ul>
<p>1、【html】为什么 HTML5 只需要写&lt;_!DOCTYPE HTML_ &gt;就可以？</p>
<p><strong>解析</strong>：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE&gt;只是一个说明，用来告诉浏览器当前的html页面是用什么版本的html写的。</span><br><span class="line">html4.01的&lt;!DOCTYPE&gt;引用了DTD（document type define），因为html4.01是基于SGML的，而它引用的DTD指明了html的规则，从而浏览器能正确的渲染页面。而html5不是基于SGML所以不需要引用DTD。</span><br><span class="line"></span><br><span class="line">翻译一下：SGML，即一般标准标记语言，是一个用于定义文档标记语言标准的集合。</span><br><span class="line">总结一下：因为html4是基于SGML这个标记语言的集合，既然是集合说明里面有各种的标准，那么DTD就是指出了当前html文件是用的是哪个SGML规则。</span><br><span class="line">html5不存在这个问题，所以只需要简单的声明浏览器就可以正确渲染页面啦</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】 position:fixed;在 ios 下无效该怎么办？</p>
<p>当采用 <code>fixed</code> 做吸底、吸顶布局时，如果触发键盘弹出事件则 <code>fixed</code> 属性会失效，布局就会被扰乱。其原因解释如下：</p>
<blockquote>
<p>软键盘唤起后，页面的 fixed 元素将失效（即无法浮动，也可以理解为变成了 absolute 定位），所以当页面超过一屏且滚动时，失效的 fixed 元素就会跟随滚动了。</p>
</blockquote>
<p>第三方库 <code>isScroll.js</code> 可以解决此问题。</p>
<p>3、【js】 什么是闭包？优缺点分别是什么？</p>
<p><strong>解析</strong> ：</p>
<p>闭包是可以访问另一个函数作用域的函数。由于 <code>javascript</code> 的特性，外层的函数无法访问内部函数的变量；而内部函数可以访问外部函数的变量（即作用域链）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 这个函数就是个闭包，可以访问外层 a 函数的变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> b + c + d;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = a();</span><br><span class="line"><span class="built_in">console</span>.log(e());</span><br></pre></td></tr></table></figure>

<p>因此，使用闭包可以隐藏变量以及防止变量被篡改和作用域的污染，从而实现封装。<br>而缺点就是由于保留了作用域链，会增加内存的开销。因此需要注意内存的使用，并且防止内存泄露的问题。</p>
<p>4、【软技能】 你最喜欢用哪些编辑器？喜欢它的理由是什么？</p>
<p>解析：</p>
<p>webstorm ： 喜欢它不需要理由！</p>
<h3 id="第-15-天-2019-10-10"><a href="#第-15-天-2019-10-10" class="headerlink" title="第 15 天 (2019.10.10)"></a>第 15 天 (2019.10.10)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/46">title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/47">style 标签写在 body 前和 body 后的区别是什么？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/48">写一个数组去重的方法（支持多维数组）</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/49">对于加班你是怎么看的？</a></li>
</ul>
<p>1、【html】title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">关于 title 和 h1，title 是网页的标题。主要面向的对象是搜索引擎和通过搜索结果过来的人（面向外人，可以理解为报纸首页的标题）。而 h1 是网页内部的标题，是给已经进到页面的人看的（可以理解为报纸某个版面的大标题）。从人类的语境上来理解，两者并没有差别。</span><br><span class="line"></span><br><span class="line">b 与 strong 的效果人眼上是无法区分的。在语义上，b 仅表示加粗既装饰用，我们应该使用 CSS 而不应该使用 b；而 strong 则表示被包围的内容很重要，是语气上的感觉。对于搜索引擎来说，会把 b 和 strong 视为同一含义。因此我们在使用上需要注意。</span><br><span class="line"></span><br><span class="line">i 与 em 的区别类似 b 和 strong 的区别。i 用于斜体展示，我们应该使用 CSS 而不应该使用 i；而 em 则是对内容的强调，但程度没有 strong 那么高。同样，对搜索引擎来说，两者是没有区别的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】style 标签写在 body 前和 body 后的区别是什么？</p>
<blockquote>
<p>参考文章：<br><a href="https://softwareengineering.stackexchange.com/questions/224422/will-it-be-a-wrong-idea-to-have-style-in-body">Will it be a wrong idea to have in &lt;_body_ &gt;?</a> &gt; <a href="https://www.w3.org/TR/html52/document-metadata.html#the-style-element">W3C The style element</a> &gt; <a href="https://www.cnblogs.com/xianyulaodi/p/5198603.html">什么是 FOUC？如何避免 FOUC？</a> &gt; <a href="https://bitsofco.de/understanding-the-critical-rendering-path/">Understanding the Critical Rendering Path</a></p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">在 HTML4 的时候，不应该把 style 放到 body 中间。</span><br><span class="line"></span><br><span class="line">浏览器在渲染页面时 DOM 和 CSSOM 是并行的，然后两者结合形成 Render Tree 显示页面。从直觉上来说，style 写在 body 前不会对 DOM 的渲染进行阻塞；而写在 body 内会对 DOM 渲染进行阻塞。会产生 FOUC（Flash of Unstyled Content) 的现象，既一瞬间的白屏或者样式的突然变化（原因是 Render Tree 重新生成了）。</span><br><span class="line"></span><br><span class="line">不过 W3C 在 HTML5.2 的定义中对于 style 标签的使用的定义中是允许将 style 放到 body 中的。</span><br><span class="line"></span><br><span class="line">Contexts in which this element can be used:</span><br><span class="line">Where metadata content is expected.</span><br><span class="line">In a noscript element that is a child of a head element.</span><br><span class="line">In the body, where flow content is expected.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】写一个数组去重的方法（支持多维数组）</p>
<blockquote>
<p><a href="https://juejin.im/post/5adc8e396fb9a07aa0479725">5 种方法实现数组扁平化</a></p>
<p><a href="https://juejin.im/post/5aed6110518825671b026bed">7 种方法实现数组去重</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.toString().split(<span class="string">&quot;,&quot;</span>).map(<span class="built_in">Number</span>))));</span><br><span class="line"><span class="comment">// [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</span></span><br></pre></td></tr></table></figure>

<p>4、【软技能】对于加班你是怎么看的？</p>
<ol>
<li>首先，始终要以工作效率为首要目标，不能出现为了加班而故意降低白天的工作效率。</li>
<li>其次，在保证了白天的工作效率以后，如果确实需要加班，则可以适度的加班，但不能超过 10 点，不然肯定影响第二天的效率。</li>
</ol>
<h3 id="第-16-天-2019-10-11"><a href="#第-16-天-2019-10-11" class="headerlink" title="第 16 天 (2019.10.11)"></a>第 16 天 (2019.10.11)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/50">元素的 alt 和 title 有什么区别？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/51">请描述 margin 边界叠加是什么及解决方案</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/52">返回到顶部的方法有哪些？把其中一个方法出来</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/53">你在的公司有没有做代码审查（CodeReview）？如果有是怎么做的？如果没有你觉得应该怎么做才更好？</a></li>
</ul>
<p>1、【html】元素的 alt 和 title 有什么区别？</p>
<p><strong>ALT 属性：</strong></p>
<p>最常见用在 <code>&lt;img&gt;</code> 标签上，那我们先来看下 <code>&lt;img&gt;</code> 标签的 <code>alt</code> 属性。</p>
<p><code>alt</code> 属性是一个必需的属性，它规定在图像无法显示时的替代文本。</p>
<p>假设由于下列原因用户无法查看图像，<code>alt</code> 属性可以为图像提供替代的信息：</p>
<ul>
<li>网速太慢</li>
<li><code>src</code> 属性中的错误</li>
<li>浏览器禁用图像</li>
<li>用户使用的是屏幕阅读器</li>
</ul>
<p>&lt;_img_ &gt;  标签的  alt  属性指定了替代文本，用于在图像无法显示或者用户禁用图像显示时，代替图像显示在浏览器中的内容</p>
<p>**TITLE 属性： **</p>
<p><code>title</code> 属性规定关于元素的额外信息。</p>
<p>这些信息通常会在鼠标移到元素上时显示一段工具提示文本（tooltip text）。</p>
<p>提示：<code>title</code> 属性常与 <code>form</code> 以及 <code>a</code> 元素一同使用，以提供关于输入格式和链接目标的信息。同时它也是 <code>abbr</code> 和 <code>acronym</code> 元素的必需属性。当然 <code>title</code> 属性是比较广泛使用的，可以用在除了<code>base</code>，<code>basefont</code>，<code>head</code>，<code>html</code>，<code>meta</code>，<code>param</code>，<code>script</code> 和 <code>title</code> 之外的所有标签。但是并不是必须的。</p>
<p><code>title</code> 属性有一个很好的用途，即为链接添加描述性文字，特别是当连接本身并不是十分清楚的表达了链接的目的。这样就使得访问者知道那些链接将会带他们到什么地方，他们就不会加载一个可能完全不感兴趣的页面。另外一个潜在的应用就是为图像提供额外的说明信息，比如日期或者其他非本质的信息。</p>
<p>2、【css】请描述 margin 边界叠加是什么及解决方案</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1，使用padding代替，但是父盒子要减去相应的高度</span><br><span class="line">2，使用boder（透明）代替（不推荐，不符合书写规范，如果父盒子子盒子时有颜色的不好处理）</span><br><span class="line">3，给父盒子设置overflow：hidden(如果有移除元素无法使用)</span><br><span class="line">4，给父盒子设置1px的padding</span><br><span class="line">5，给父盒子设置1px的透明border，高度减1px</span><br><span class="line">6，子盒子使用定位position</span><br><span class="line">7，子盒子浮动, 但是居中比较难以控制</span><br><span class="line">8，给子盒子设置display: inline-block;</span><br><span class="line">9，子盒子上面放一个table标签</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】 返回到顶部的方法有哪些？把其中一个方法写出来</p>
<ol>
<li>锚点</li>
</ol>
<p>使用锚点链接是一种简单的返回顶部的功能实现。该实现主要在页面顶部放置一个指定名称的锚点链接，然后在页面下方放置一个返回到该锚点的链接，用户点击该链接即可返回到该锚点所在的顶部位置</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;topAnchor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#topAnchor&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>scrollTop</li>
</ol>
<p>scrollTop 属性表示被隐藏在内容区域上方的像素数。元素未滚动时，scrollTop 的值为 0，如果元素被垂直滚动了，scrollTop 的值大于 0，且表示元素上方不可见内容的像素宽度</p>
<p>由于 scrollTop 是可写的，可以利用 scrollTop 来实现回到顶部的功能</p>
<p>[注意]关于页面的 scrollTop 的兼容问题详细内容<a href="http://www.cnblogs.com/xiaohuochai/p/5831640.html#anchor4">移步至此</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollTop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.scrollTop = <span class="built_in">document</span>.documentElement.scrollTop = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">btn.onclick = scrollTop;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/scrollTo">scrollTo()</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/scroll">window.scroll()</a></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置滚动行为改为平滑的滚动</span></span><br><span class="line"><span class="built_in">window</span>.scrollTo(&#123;</span><br><span class="line">  top: <span class="number">1000</span>,</span><br><span class="line">  behavior: <span class="string">&quot;smooth&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.scroll(&#123;</span><br><span class="line">  top: <span class="number">100</span>,</span><br><span class="line">  left: <span class="number">100</span>,</span><br><span class="line">  behavior: <span class="string">&quot;smooth&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/scrollBy">Window.scrollBy()</a></li>
</ol>
<blockquote>
<p>在窗口中按指定的偏移量滚动文档。</p>
</blockquote>
<p>向下滚动一页：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.scrollBy(<span class="number">0</span>, <span class="built_in">window</span>.innerHeight);</span><br></pre></td></tr></table></figure>

<p>向上滚动一页：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.scrollBy(<span class="number">0</span>, -<span class="built_in">window</span>.innerHeight);</span><br></pre></td></tr></table></figure>

<p>使用 options：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.scrollBy(&#123;</span><br><span class="line">  top: <span class="number">100</span>,</span><br><span class="line">  left: <span class="number">100</span>,</span><br><span class="line">  behavior: <span class="string">&quot;smooth&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>4.【软技能】你在的公司有没有做代码审查（CodeReview）？如果有是怎么做的？如果没有你觉得应该怎么做才更好？</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1、有独立的代码审查部门，定期发送邮件给相关人员，里面有本部门全部项目的代码质量统计，在代码过差时依次向上级发通知</span><br><span class="line">2、依据每个组内风格，有的组在每次合并生产环境都会review</span><br><span class="line">3、总的来说代码审查是好事，但如果出现咸鱼池塘以及产品流程不规范导致迭代需求过多而不合理，会造成很多困扰，自身也可能流于形式，一定要结合实际情况来看</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-17-天-2019-10-13"><a href="#第-17-天-2019-10-13" class="headerlink" title="第 17 天 (2019.10.13)"></a>第 17 天 (2019.10.13)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/54">你认为 table 的作用和优缺点是什么呢？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/55">解释下 CSS sprites 的原理和优缺点分别是什么？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/56">typeof(‘abc’)和 typeof ‘abc’都是 string, 那么 typeof 是操作符还是函数？</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/57">说说你对 SVN 和 GIT 的理解和区别</a></li>
</ul>
<p>1、【html】你认为 table 的作用和优缺点是什么呢？</p>
<p><strong>解析：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">优点：样式简单，构建方便，兼容良好</span><br><span class="line">缺点：在于会多处非常多的 DOM 节点（想想一个 td 里面再来一个 table），会导致页面加载变慢、影响加载和渲染，维护麻烦，不利于 SEO（table 原本就不是用来布局的）。也因此，在 CSS 成熟之后，table 布局马上就变成历史了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】解释下 CSS sprites 的原理和优缺点分别是什么？</p>
<p>CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position 可以用数字精确的定位出<a href="https://baike.baidu.com/item/%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87">背景图片</a>的位置。</p>
<p><strong>优点：</strong></p>
<ul>
<li>减少网页的 http 请求，大大的提高页面的性能</li>
<li>减少图片的字节</li>
<li>解决了网页设计师在图片命名上的困扰</li>
<li>更换风格方便，维护起来更加方便</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>在图片合并的时候，要留好足够的空间，防止板块内出现不必要的背景；最痛苦的是在宽屏，高分辨率的屏幕下的自适应页面，你的图片如果不够宽，很容易出现背景断裂；</li>
<li>CSS Sprites 在开发的时候比较麻烦，通过<a href="https://baike.baidu.com/item/photoshop">photoshop</a>或其他工具测量计算每一个背景单元的精确位置</li>
</ul>
<p>3、【js】typeof(‘abc’)和 typeof ‘abc’都是 string, 那么 typeof 是操作符还是函数？</p>
<p><code>typeof</code> 是<strong>操作符</strong>，不是函数。可以添加括号，但是括号的作用是进行分组而非函数的调用。</p>
<blockquote>
<p>参考自 &lt;JavaScript 高级程序设计&gt;</p>
</blockquote>
<p>4、【软技能】 说说你对 SVN 和 GIT 的理解和区别 ？</p>
<p><strong>解析：</strong> <a href="https://www.jianshu.com/p/bfec042349ca">话说 Svn 与 Git 的区别</a></p>
<ul>
<li><p><strong>最核心的区别</strong> ：Git 是<strong>分布式</strong>SCM，而 SVN 是基于<strong>服务器</strong>的，也就是说每个开发者本地都有一套 git 库，每个人维护自己的版本（或者合并其他人的版本），而 SVN 是每个人写完代码后都及时的 checkin 到服务器上，进行合并。</p>
</li>
<li><p>Git 把内容按元数据方式存储，而 SVN 是按文件</p>
</li>
<li><p>Git 没有一个全局版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。</p>
</li>
<li><p>Git 的内容的完整性要优于 SVN: GIT 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</p>
</li>
<li><p>Git 下载下来后，在 OffLine 状态下可以看到所有的 Log,SVN 不可以。</p>
</li>
<li><p>刚开始用时很狗血的一点，SVN 必须先 Update 才能 Commit,忘记了合并时就会出现一些错误，git 还是比较少的出现这种情况。</p>
</li>
<li><p>克隆一份全新的目录以同样拥有五个分支来说，SVN 是同时复製 5 个版本的文件,也就是说重复五次同样的动作。而 Git 只是获取文件的每个版本的 元素，然后只载入主要的分支(master)在我的经验,克隆一个拥有将近一万个提交(commit),五个分支,每个分支有大约 1500 个文件的 SVN,耗了将近一个小时！而 Git 只用了区区的 1 分钟！</p>
</li>
<li><p>版本库（repository):SVN 只能有一个指定中央版本库。当这个中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。而 Git 可以有无限个版本库。</p>
<p>…..</p>
</li>
</ul>
<p>最后总结一下：</p>
<p>SVN 的特点是简单，只是需要一个放代码的地方时用是 OK 的。</p>
<p>Git 的特点版本控制可以不依赖网络做任何事情，对分支和合并有更好的支持(当然这是开发者最关心的地方)，不过想各位能更好使用它，需要花点时间尝试下。</p>
<h3 id="第-18-天-2019-10-14"><a href="#第-18-天-2019-10-14" class="headerlink" title="第 18 天 (2019.10.14)"></a>第 18 天 (2019.10.14)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/58">怎样在页面上实现一个圆形的可点击区域？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/59">什么是 FOUC？你是如何避免 FOUC 的？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/60">你理解的”use strict”;是什么?使用它有什么优缺点？</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/61">你如何看待团建的？你们团建一般都怎么实施？</a></li>
</ul>
<p>1、【html】怎样在页面上实现一个圆形的可点击区域？</p>
<ul>
<li>DOM 元素配合 <code>border-radius: 50%</code> 即可实现圆形点击区域。<a href="https://codepen.io/Konata9/pen/zgNJVy?editors=1111">例子</a></li>
<li>利用 <code>&lt;map&gt;</code> 和 <code>&lt;area&gt;</code> 标签设置圆形点击区域。参考文章:<a href="https://www.zhangxinxu.com/wordpress/2017/05/html-area-map/">HTML 标签及在实际开发中的应用</a></li>
<li>利用 SVG 作出圆形，然后添加点击事件。</li>
<li>如果在 <code>canvas</code> 上，就需要画出圆形，然后计算鼠标的坐标是否落在圆内。</li>
</ul>
<p>2、【css】什么是 FOUC？你是如何避免 FOUC 的？</p>
<p><strong>解析：</strong> <a href="https://www.cnblogs.com/xianyulaodi/p/5198603.html">什么是 FOUC？如何避免 FOUC？</a></p>
<p><strong>什么叫做 FOUC 浏览器样式闪烁</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">如果使用import方法对css进行导入,会导致某些页面在Windows 下的Internet Explorer出现一些奇怪的现象</span><br><span class="line"></span><br><span class="line">以无样式显示页面内容的瞬间闪烁,</span><br><span class="line"></span><br><span class="line">这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>原因大致为：</p>
<ol>
<li>使用 import 方法导入样式表。</li>
<li>将样式表放在页面底部</li>
<li>有几个样式表，放在 html 结构的不同位置。</li>
</ol>
<p>其实原理很清楚：当样式表晚于结构性 html 加载，当加载到此样式表时，页面将停止之前的渲染。</p>
<p>此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。</p>
<p><strong>解决方法</strong> ：使用 link 标签将样式表放在文档 head 中</p>
<p>3、【js】 你理解的”use strict”;是什么?使用它有什么优缺点？</p>
<p><strong>解析：</strong> <a href="https://www.runoob.com/js/js-strict.html">JavaScript 严格模式(use strict)</a></p>
<blockquote>
<p>JavaScript 严格模式（strict mode）即在严格的条件下运行。</p>
</blockquote>
<p>严格模式，其实就是更严格了</p>
<blockquote>
<p>设立”严格模式”的目的，主要有以下几个：</p>
<ul>
<li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的 Javascript 做好铺垫。</li>
</ul>
</blockquote>
<p>我放几个常见的吧，详情可以去下面的文章中看</p>
<ol>
<li>禁止 this 关键字指向全局对象 （严格模式下的 全局中的 this 是 undefined 不是 window）</li>
<li>禁止在函数内部遍历调用栈</li>
<li>全局变量必须显式声明</li>
<li>arguments 不再追踪参数的变化</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  b = <span class="number">1</span>; <span class="comment">//Uncaught ReferenceError: b is not defined</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</a><br><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html">http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html</a></p>
<p>4、【软技能】你如何看待团建的？你们团建一般都怎么实施？</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">公司希望团建加强团队的凝聚力，大家可能在想：怎么可能能加强，吃喝玩乐，玩几个游戏就可以加强了？其实公司加强的是对公司有认可度的那群人的凝聚力，而不是那群打酱油，每天骂公司、摸鱼的那群人的凝聚力。</span><br><span class="line">团建人太多了确实没太大的意义，更多就是完成公司的政治任务，对外宣传。我经常是参加团建的时候去认识公司的那些高级领导，和他们聊聊天，混个脸熟。后面我更多就带着小组的人一起出去浪，或者带着其他想和我们一起出去浪的同事出去浪，很多时候都是 AA 或者公司出一小部分，因为只要走公司账，他们经常玩不尽兴，总想着钱太少，玩的没意思，并且又有占便宜的心理，总之会玩的不舒服，所以很多时候我们都是自费出去玩。大家都是在外面打工的一群人，周末有很大一部分人想出去玩但是一个人不知道干啥，所以有一群人出去玩就会玩的比较好。</span><br><span class="line">个人做法、看法，随意评价</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-19-天-2019-10-16"><a href="#第-19-天-2019-10-16" class="headerlink" title="第 19 天 (2019.10.16)"></a>第 19 天 (2019.10.16)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/62">说说你对 html 中的置换元素和非置换元素的理解</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/63">css 的属性 content 有什么作用呢？有哪些场景可以用到？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/64">“attribute”和”property”有什么不同？</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/65">最近都流行些什么？你经常会浏览哪些网站？</a></li>
</ul>
<p>1、【html】 说说你对 html 中的置换元素和非置换元素的理解 ？</p>
<p><strong>置换元素</strong></p>
<p>置换元素是指：浏览器根据元素的标签和属性，来决定元素的具体显示内容。</p>
<p>例如：浏览器根据&lt;_img_ &gt;标签的 src 属性显示图片。根据标签的 type 属性决定显示输入框还是按钮。</p>
<blockquote>
<p>置换元素在其显示中生成了框，这也就是有的内联元素能够设置宽高的原因。</p>
</blockquote>
<p>html 中的&lt;_img_&gt;&lt;_input_&gt;&lt;_textarea_&gt;&lt;_select_&gt;&lt;_object_&gt;都是置换元素，这些置换元素往往没有实际内容，即是一个空元素。</p>
<p><strong>非置换元素</strong></p>
<p>浏览器中的大多数元素都是不可置换元素，即其内容直接展示给浏览器。</p>
<p>例如&lt;_label_&gt;标签，&lt;_p_&gt;标签里的内容会被浏览器直接显示给用户。</p>
<p>2、【css】 css 的属性 content 有什么作用呢？有哪些场景可以用到？</p>
<p><strong>解析：</strong> <a href="https://xiangshuo.blog.csdn.net/article/details/89843456">CSS 属性 content 有什么作用呢？有哪些场景可以用到？</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content">MDN:content</a></p>
<p>CSS 的 <code>content</code> CSS 属性用于在元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before"><code>::before</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after"><code>::after</code></a> 伪元素中插入内容。使用<code>content</code> 属性插入的内容都是匿名的<em>可替换元素。</em></p>
<p><strong>场景：</strong></p>
<ol>
<li><p>content: string value 字符串</p>
<p>可以加入任何字符，包括 Unicode 编码等各种字符。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://www.xunlei.com/&quot;</span> <span class="attr">title</span>=<span class="string">&quot;精彩，一下就有&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span>精彩，一下就有<span class="tag">&lt;/<span class="name">a</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"></span><br><span class="line">.demo:after&#123; content: &quot;↗&quot; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们还可以通过 <code>content</code> 内字符串的变化，实现类似 加载中… 的动画效果</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.demo</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: dot <span class="number">1.6s</span> linear both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframe</span> dot &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  33% &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;..&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  66% &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;...&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20190508094105804.gif"></p>
<ol start="3">
<li>content: uri value 外部资源，用于引用媒体文件，图片，图标，SVG 等。</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.demo</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">url</span>(https://img-vip-ssl.a.<span class="number">88</span>cdn.com/img/xunleiadmin/<span class="number">5</span>b9889e14dcdc.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、【js】 “attribute”和”property”有什么不同？</p>
<p><strong>attribute</strong> 是我们在 <strong>html</strong> 代码中经常看到的键值对</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;the-input&quot;</span> type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;Name:&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中的 input 节点有三个 attribute:</p>
<ul>
<li>id : the-input</li>
<li>type : text</li>
<li>value : Name:</li>
</ul>
<p><strong>property</strong> 是 attribute 对应的 DOM 节点的 对象属性 (Object field),</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HTMLInputElement.id === <span class="string">&quot;the-input&quot;</span>;</span><br><span class="line">HTMLInputElement.type === <span class="string">&quot;text&quot;</span>;</span><br><span class="line">HTMLInputElement.value === <span class="string">&quot;Name:&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>区别：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;the-input&quot;</span> type=<span class="string">&quot;typo&quot;</span> value=<span class="string">&quot;Name:&quot;</span> /&gt; <span class="comment">// 在页面加载后,</span></span><br><span class="line">我们在这个input中输入 <span class="string">&quot;Jack&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>让我们来看看上面这个 input 节点的 attribute 和 property:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// attribute still remains the original value</span></span><br><span class="line">input.getAttribute(<span class="string">&quot;id&quot;</span>); <span class="comment">// the-input</span></span><br><span class="line">input.getAttribute(<span class="string">&quot;type&quot;</span>); <span class="comment">// typo</span></span><br><span class="line">input.getAttribute(<span class="string">&quot;value&quot;</span>); <span class="comment">// Name:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// property is a different story</span></span><br><span class="line">input.id; <span class="comment">// the-input</span></span><br><span class="line">input.type; <span class="comment">//  text</span></span><br><span class="line">input.value; <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>

<p>可以看到, 在 attribute 中, 值仍然是 html 代码中的值. 而在 property 中, type 被自动修正为了 <strong>text</strong>, 而 value 随着用户改变 input 的输入, 也变更为了 <strong>Jack</strong></p>
<p><strong>这就是 attribute 和 Property 间的区别:</strong></p>
<p>attribute 会始终保持 html 代码中的初始值, 而 Property 是有可能变化的.</p>
<blockquote>
<p>其实, 我们从这两个单词的名称也能看出些端倪:</p>
</blockquote>
<p><strong>attribute</strong> 从语义上, 更倾向于不可变更的</p>
<p>而 <strong>property</strong> 从语义上更倾向于在其生命周期中是可变的</p>
<p><strong>Attribute or Property 可以自定义吗?</strong> ：attribute 可以 property 不行</p>
<p>4、【软技能】最近都流行些什么？你经常会浏览哪些网站？</p>
<p>慕课网、掘金、github、stackoverflow/segmentfault、Google、相关技术官网文档</p>
<h3 id="第-20-天-2019-10-17"><a href="#第-20-天-2019-10-17" class="headerlink" title="第 20 天 (2019.10.17)"></a>第 20 天 (2019.10.17)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/66">请描述 HTML 元素的显示优先级</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/67">要让 Chrome 支持小于 12px 的文字怎么做？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/68">写一个验证身份证号的方法</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/69">你会手写原生 js 代码吗？</a></li>
</ul>
<p>1、【html】请描述 HTML 元素的显示优先级</p>
<p><strong>解析：</strong> <a href="https://www.jianshu.com/p/868a7d16fb68">HTML 元素的显示优先级</a></p>
<p><strong>帧元素&gt;HTML 元素优先，表单元素总&gt;非表单元素优先</strong><br>层级显示优先级： <code>frameset &gt; 表单元素 &gt; 非表单元素</code></p>
<ul>
<li>表单元素包括：文本输入框，密码输入框，单选框，复选框，文本输入域，列表框等等；</li>
<li>非表单元素包括：连接（a），div,table,span 等。</li>
</ul>
<p>所有的 html 元素又可以根据其显示分成两类：有窗口元素以及无窗口元素。有窗口元素总是显示在无窗口元素的前面。<br>有窗口元素包括：select 元素，object 元素，以及 frames 元素等等。<br>无窗口元素：大部分 html 元素都是无窗口元素。</p>
<p>按照浏览器类型比较，HTML 元素的显示次序也有所不同：</p>
<p>2、【css】要让 Chrome 支持小于 12px 的文字怎么做？</p>
<p><strong>解析：</strong></p>
<p>Chrome 中有最小字号的限制，一般为 12px。原因是 Chrome 认为小于这个字号会影响阅读。</p>
<p>当需要小于 12px 字体的时候，有以下几个方法可以使用。</p>
<ul>
<li><p>-webkit-text-size-adjust:none; 这个属性在高版本的 Chrome 中已经被废除。</p>
</li>
<li><p>使用 <code>transform: scale(0.5, 0.5)</code>，但使用 transform</p>
<p>需要注意下面几点：</p>
<ul>
<li><code>transform</code> 对行内元素无效，因此要么使用 <code>display: block;</code> 要么使用 <code>display: inline-block;</code></li>
<li><code>transform</code> 即使进行了缩放，原来元素还是会占据对应的位置。因此需要做调整，最好是在外面再包一层元素，以免影响其他元素。</li>
</ul>
</li>
<li><p>作为图片。</p>
</li>
</ul>
<p>最好的办法还是进行切图，或者就不要使用小于 12px 的字体。</p>
<p>3、【js】 写一个验证身份证号的方法</p>
<blockquote>
<p>分析：身份证号码的组成：地址码 6 位+年份码 4 位+月份码 2 位+日期码 2 位+顺序码 3 位+校验码 1 位</p>
</blockquote>
<p><strong>解析：</strong></p>
<ol>
<li>粗暴型: 只考虑位数、最后的 x \d{17}[\dXx]</li>
<li>一般型: /^\d{6}\d{4}(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])\d{3}[\dXx]$/</li>
</ol>
<p>4、【软技能】你会手写原生 js 代码吗？</p>
<p><strong>解析：</strong></p>
<p>其实是要看你理解原生的定义了。不管现在用的什么框架，我们很多写的业务代码不都是原生的嘛。还有很多公用的方法，一般用的是原生的 js。</p>
<h3 id="第-21-天-2019-10-18"><a href="#第-21-天-2019-10-18" class="headerlink" title="第 21 天 (2019.10.18)"></a>第 21 天 (2019.10.18)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/70">谈谈你对 input 元素中 readonly 和 disabled 属性的理解</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/71">说说你对 line-height 是如何理解的？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/72">写一个方法验证是否为中文</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/73">来说说你对重绘和重排的理解，以及如何优化？</a></li>
</ul>
<p>1、【html】 谈谈你对 input 元素中 readonly 和 disabled 属性的理解</p>
<p><strong>解析：</strong></p>
<ul>
<li>相同点：都会使文本框变成只读，不可编辑。</li>
<li>不同点：<br>1.disabled 属性在将 input 文本框变成只读不可编辑的同时，还会使文本框变灰，但是 readonly 不会。<br>2.disabled 属性修饰后的文本框内容，在不可编辑的同时，通过 js 也是获取不到的。但是用 readonly 修饰后的文本框内容，是可以通过 js 获取到的，也就只是简单的不可编辑而已！<br>3.disabled 属性对 input 文本框，单选 radio,多选 checkbox 都适用，但是 readonly 就不适用，用它修饰后的单选以及多选按钮仍然是可以编辑状态的。</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">总结了前面老哥们的回答，再加上自己查了一下。</span><br><span class="line"></span><br><span class="line">在表现上 readonly 和 disabled 都不能让用户对 input 进行编辑。但从含义上两者还是有较大的差别的。</span><br><span class="line">readonly 直译为 “只读”，一般用于只允许用户填写一次的信息，提交过一次之后，就不允许再次修改了。</span><br><span class="line"></span><br><span class="line">disabled 直译为 “禁用”，即这个 input 就是不允许填写和使用的（可能是因为权限或者其他原因）。</span><br><span class="line">因此在外观上，readonly 与普通 input 无异，只是点击后无法进行编辑；而 disabled 的 input 呈灰色，也不允许点击。从这两点其实也可以看出，对于 input 的事件，readonly 会响应，而 disabled 是不响应的。并且在传输数据上，disabled 的数据是不会被获取和上传，readonly 的数据会被获取和上传。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】 说说你对 line-height 是如何理解的？</p>
<p><code>line-height</code> 在日常用的最多的是让单行文字垂直居中（其实不需要设置 <code>height</code>，一个 <code>line-height</code> 即可）。因为 <code>line-height - font-size</code> 为行距，一般会近似平分到文字的上下两边，使文字看上去垂直居中。如果需要多行文字的垂直居中，还需要加上 <code>vertical-align: middle;</code>。</p>
<p><code>line-height</code> 可以不设置单位，表示 <code>font-size</code> 的倍数。</p>
<p>另外对于非替换元素的纯内联元素，其高度是由 <code>line-height</code> 所决定的。</p>
<p>3【js】 写一个方法验证是否为中文</p>
<blockquote>
<p>由于中文比较特殊，最稳妥的还是使用 <code>unicode</code> 来进行匹配。这两个 <code>unicode</code> 分别表示第一个和最后一个汉字。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isChinese</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> re = <span class="regexp">/^[\u4e00-\u9fa5]+$/</span>;</span><br><span class="line">  <span class="keyword">return</span> re.test(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、【软技能】来说说你对重绘和重排的理解，以及如何优化？</p>
<p><strong>重绘：</strong></p>
<p>当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。<br>触发重绘的条件：改变元素外观属性。如：color，background-color，font-size 等。</p>
<p><strong>重排(回流)：</strong></p>
<p>当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。<br>重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。<br>所以，<strong>重排必定会引发重绘，但重绘不一定会引发重排</strong>。<br>　　触发重排的条件：任何页面布局和几何属性的改变都会触发重排，<br>比如：<br>　　 1、页面渲染初始化；(无法避免)<br>　　 2、添加或删除可见的 DOM 元素；<br>　　 3、元素位置的改变，或者使用动画；<br>　　 4、元素尺寸的改变——大小，外边距，边框；<br>　　 5、浏览器窗口尺寸的变化（resize 事件发生时）；<br>　　 6、填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；<br>触发重排的条件：改变元素的大小 位置 等如：width、height、pading、margin、position 等，　添加删除 DOM 操作等<br><strong>重绘重排的代价：耗时，导致浏览器卡慢。</strong></p>
<p><strong>优化</strong></p>
<p>1、浏览器自己的优化：浏览器会维护 1 个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会 flush 队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。<br>2、我们要注意的优化：我们要减少重绘和重排就是要减少对渲染树的操作，则我们可以合并多次的 DOM 和样式的修改。并减少对 style 样式的请求。<br>（1）直接改变元素的 className<br>（2）display：none；先设置元素为 display：none；然后进行页面布局等操作；设置完成后将元素设置为 display：block；这样的话就只引发两次重绘和重排；<br>（3）不要经常访问浏览器的 flush 队列属性；如果一定要访问，可以利用缓存。将访问的值存储起来，接下来使用就不会再引发回流；<br>（4）使用 cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；<br>（5）将需要多次重排的元素，position 属性设为 absolute 或 fixed，元素脱离了文档流，它的变化不会影响到其他元素；<br>（6）如果需要创建多个 DOM 节点，可以使用 DocumentFragment 创建完后一次性的加入 document；</p>
<h3 id="第-22-天-2019-10-20"><a href="#第-22-天-2019-10-20" class="headerlink" title="第 22 天 (2019.10.20)"></a>第 22 天 (2019.10.20)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/74">js 放在 html 的<code>和</code>有什么区别？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/75">说说浏览器解析 CSS 选择器的过程？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/76">你对 new 操作符的理解是什么？手动实现一个 new 方法</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/77">前端工程师这个职位你是怎么样理解的？聊聊它的前景？</a></li>
</ul>
<p>1、【html】 js 放在 html 的&lt;_body_&gt;和&lt;_head_ &gt;有什么区别？</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">js 放在 &lt;head&gt; 中，如果不添加 async 或者 defer 时，当浏览器遇到 script 时，会阻塞 DOM 树的构建，进而影响页面的加载。当 js 文件较多时，页面白屏的时间也会变长。</span><br><span class="line"></span><br><span class="line">在这个过程中，如果解析器遇到了一个脚本(script)，它就会停下来，并且执行这个脚本，然后才会继续解析 HTML。如果遇到了一个引用外部资源的脚本(script)，它就必须停下来等待这个脚本资源的下载，而这个行为会导致一个或者多个的网络往返，并且会延迟页面的首次渲染时间。</span><br><span class="line"></span><br><span class="line">把 js 放到 &lt;body&gt; 里（一般在 &lt;/body&gt; 的上面）时，由于 DOM 时顺序解析的，因此 js 不会阻塞 DOM 的解析。对于必须要在 DOM 解析前就要加载的 js，我们需要放在 &lt;head&gt; 中。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】说说浏览器解析 CSS 选择器的过程？</p>
<p><strong>解析：</strong> 浏览器对于 CSS 选择器的解析过程是从右向左的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.class</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  // css 属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是这样的一个结构，浏览器会从右向左开始解析。因为一般来说，最右侧的节点范围反而会比较大，越向左限定的条件就越多。也因此 CSS 的选择器设计上不宜嵌套过多，会带来性能上的问题。</p>
<p>3、【js】你对 new 操作符的理解是什么？手动实现一个 new 方法</p>
<p><strong>解析：</strong></p>
<p><strong>new 的理解</strong></p>
<blockquote>
<p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一</p>
</blockquote>
<p><strong>new 步骤</strong></p>
<p>模拟 new 操作前，要先知道 new 操作是发生了什么，就拿<code>new Object()</code>举例:</p>
<ol>
<li>创建一个新对象</li>
<li>把新对象的原型指向构造函数的 prototype</li>
<li>把构造函数里的 this 指向新对象</li>
<li>返回这个新对象</li>
</ol>
<p><strong>构造函数：</strong></p>
<p>先准备一个构造函数来<code>new</code>使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructorFunction</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">constructorFunction.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>原生 new：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> constructorFunction(<span class="string">&quot;willian&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name, obj.age); <span class="comment">//&#x27;willian&#x27;, 18</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.say()); <span class="comment">//Hello willian</span></span><br></pre></td></tr></table></figure>

<p><strong>模拟 new</strong></p>
<p>模拟的<code>new </code>暂称为<code>newNew </code>（囡..囡 哈哈<del>）<br>使用：<code>newNew(constructor, arg1, arg2, ..) </code>第 0 个参数传入构造函数，1</del>n 个参数是构造函数的形参。<br>使用上面的构造函数试一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newObj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 1. 创建一个新对象</span></span><br><span class="line">  <span class="keyword">var</span> Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 得到构造函数</span></span><br><span class="line">  newObj.__proto__ = Con.prototype;</span><br><span class="line">  <span class="comment">// 2. 把新对象的原型指向构造函数的prototype</span></span><br><span class="line">  <span class="keyword">var</span> res = Con.apply(newObj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 3. 把构造函数里的this指向新对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&quot;object&quot;</span> ? res : newObj;</span><br><span class="line">  <span class="comment">// 4. 返回新对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = newNew(constructorFunction, <span class="string">&quot;willian&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name, obj.age); <span class="comment">//&#x27;willian&#x27;, 18</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.say()); <span class="comment">//Hello willian</span></span><br></pre></td></tr></table></figure>

<p>得到和 new 一样的答案，说明模拟成功。<br>你也可以 F12 打开控制台试一试。<br>以上参考：</p>
<ol>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/13">mqyqingfeng/Blog#13</a></li>
<li><a href="https://blog.csdn.net/liwenfei123/article/details/80580883">https://blog.csdn.net/liwenfei123/article/details/80580883</a></li>
</ol>
<p>3、【软技能】 前端工程师这个职位你是怎么样理解的？聊聊它的前景？</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">广义的来说，只要涉及展示的都属于前端，包括各种系统，图片，动画，看得见就可以。从这个角度来说，前端永远不会被抛弃，会被淘汰的只有个体，因为个体是有极限，有局限的。</span><br><span class="line">个人需要精确的定位，例如web工程师，也可以是电影特效工程师，工程师还分为软件硬件呢。</span><br><span class="line"></span><br><span class="line">前景</span><br><span class="line">具体到互联网行业的前端前景，在可见的范围内，前端承担的责任会增加而不是减少，保持进步就不会被淘汰，这点对于任何行业都一样，被抛弃的根本原因在于自身没有匹配需求的能力，而不是客观因素，那只是诱因，且必然发生。</span><br><span class="line">话说本人是先从事一段时间后端才渐渐偏向前端的，正是因为看得见，便于分享的东西更吸引人。不是后端做不到，只是觉得旅途会更轻松一些</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">通过各种终端来向用户展示数据，或者给用户提供一些和后台的交互接口。</span><br><span class="line">前景：首先，在我看来，一切和用户交互的终端都可以属于前端。并且随着现在跨端开发框架的兴起，比如Electron框架等，也使得前端的那套开发技术栈以及开发流程可以复制到桌面端来，使得前端的范畴越来越广泛。</span><br><span class="line">并且，随着AR，VR技术的兴起，手机app中应用了大量的3维场景来提高用户体验，比如手机app上看房，看车，甚至是看一个城市的街景，都已经有了3D的场景，并且用户还能进行简单的操作。而这些都对前端提出了更高的要求</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-23-天（2019-10-21）"><a href="#第-23-天（2019-10-21）" class="headerlink" title="第 23 天（2019.10.21）"></a>第 23 天（2019.10.21）</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/78">关于<code>*form*</code>标签的编码类型属性你有一些了解？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/79">说说 CSS 的优先级是如何计算的？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/80">0.1 + 0.2、0.1 + 0.3 和 0.1 * 0.2 分别等于多少？并解释下为什么？</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/81">说说一件或几件（介绍下除了工作外）你觉得能为你面试加分的事</a></li>
</ul>
<p>1、【html】 第 23 天关于&lt;_form_&gt;标签的 enctype 属性你有什么了解？</p>
<p><strong>解析：</strong></p>
<p><code>&lt;form&gt;</code>标签的<code>enctype</code>属性，用于控制表单上传的数据的编码格式。其值和 HTTP 请求的<code>Content-type</code>值相同。在数据提交到服务器之前，会以<code>enctype</code>值进行编码。</p>
<p><code>enctype</code> 对应的值如下</p>
<table>
<thead>
<tr>
<th>值</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>应用程序/ x-www-form-urlencoded</td>
<td>默认值，预设所有字符转进行编码（将空格转换为“ +”符号，特殊字符转换为 ASCII HEX 值）</td>
</tr>
<tr>
<td>多部分/表单数据</td>
<td>不会对字符进行编码，当表单中有文件时必须要此编码</td>
</tr>
<tr>
<td>文字/纯文字</td>
<td>将空格转换为“ +”符号，但不编码特殊字符</td>
</tr>
</tbody></table>
<p>参考文章：<br><a href="https://www.runoob.com/tags/att-form-enctype.html">HTML <code>form</code> enctype 属性</a></p>
<p>2、【css】说说 CSS 的优先级是如何计算的？</p>
<p><strong>解析：</strong> <a href="https://github.com/ZhChen7/Technical-interview/blob/master/1%20HTML-CSS/1%20%20CSS%E6%9D%83%E9%87%8D%E5%8F%8A%E5%85%B6%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F.md">点击此处</a></p>
<p>3、【js】 0.1 + 0.2、0.1 + 0.3 和 0.1 * 0.2 分别等于多少？并解释下为什么？</p>
<p><strong>解析：</strong></p>
<blockquote>
<p>用一句话概括就是：</p>
<p>EcmaScrpt 规范定义 Number 的类型遵循了 IEEE754-2008 中的 64 位浮点数规则定义的小数后的有效位数至多为 52 位导致计算出现精度丢失问题！</p>
</blockquote>
<p>这个问题也算是经常遇到的面试题之一了，楼上说的对，简单来说就是 js 中采用 IEEE754 的双精度标准，因为精度不足导致的问题，只是二进制表示 0.1 时这这样表示<code>1001100110011...</code>（0011 无线循环），那么这些循环的数字被 js 裁剪后，就会出现精度丢失的问题，也就造成了<code>0.1</code>不再是<code> 0.1 了</code>，而是变成了<code>0.100000000000000002</code></p>
<p>我们可以来测试一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.100000000000000002</span> === <span class="number">0.1</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>那么同样的，0.2 在二进制也是无限循环的，被裁剪后也失去了精度变成了<code>0.200000000000000002</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.200000000000000002</span> === <span class="number">0.2</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>由此我们可以得出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.30000000000000004</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>所以自然<code>0.1+0.2!=0.3</code>。<br>那么如何解决这个问题；使用原生最简单的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span> + <span class="number">0.2</span>).toFixed(<span class="number">10</span>)) === <span class="number">0.3</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>参考：<br>深度剖析 0.1 +0.2 === 0.30000000000000004 的原因：<a href="https://www.jianshu.com/p/d6b81e4e25e3">https</a> ://<a href="http://www.jianshu.com/p/d6b81e4e25e3">www.jianshu.com/p/d6b81e4e25e3</a></p>
<p>【软技能】 说说一件或几件（介绍下除了工作外）你觉得能为你面试加分的事</p>
<p>比如可以这么回答：</p>
<ol>
<li>每年都要跑满 1000 公里，已经坚持 3 年了</li>
<li>我风雨无阻每天早上 4：30 起床坚持阅读，坚持了 10 年，已经习惯了！</li>
<li>我坚持每周至少三次去锻炼身体</li>
<li>……<br>可以从坚持、勇敢、适应环境、担当、人际关系等个人性格特点方面回答。</li>
</ol>
<h3 id="第-24-天（2019-10-22）"><a href="#第-24-天（2019-10-22）" class="headerlink" title="第 24 天（2019.10.22）"></a>第 24 天（2019.10.22）</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/82">说说你对属性 data-的理解</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/83">你有用过 CSS 预处理器吗？喜欢用哪个？原理是什么？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/84">如何快速让一个数组乱序，写出来</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/85">你经历过老板要求兼容 IE 吗？IE 几？有什么感悟？</a><a href="https://github.com/haizlin/fe-interview/issues/85">https://github.com/haizlin/fe-interview/issues/85</a>)</li>
</ul>
<p>1、【html】 说说你对属性 data-的理解？</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">首先定义一下：data-是h5对自定义标签属性扩展的知识点，可以存储自定义属性，可以通过js获取到，一般会存储业务需要的数据，和vue中的bind很类似的</span><br><span class="line">是暂存非用户输入的数据</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】你有用过 CSS 预处理器吗？喜欢用哪个？原理是什么？</p>
<p>它能让你的 CSS 具备更加简洁、适应性更强、可读性更强、层级关系更加明显、更易于代码的维护等诸多好处。<br>CSS 预处理器种类繁多，目前 Sass、Less、用的比较多。<br>使用功能：<br>1、嵌套：反映层级和约束<br>2、变量和计算： 减少重复代码<br>3、Extend 和 Mixin 代码片段 (用的少)<br>4、循环：适用于复杂有规律的样式<br>5、import css 文件模块化<br>具体使用方法 均可百度</p>
<p>3、【js】如何快速让一个数组乱序，写出来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如何快速让一个数组乱序，写出来</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.sort(<span class="function">() =&gt;</span> (<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="number">1</span> : <span class="number">-1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// 乱序</span></span><br></pre></td></tr></table></figure>

<p>4、【软技能】 你经历过老板要求兼容 IE 吗？IE 几？有什么感悟</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">IE6，7一年，IE8半年，IE9一直以来的最低标准。</span><br><span class="line">近半年PC项目直接Chrome，移动端项目直接-webkit-</span><br><span class="line">总结就是最近没有兼容问题，爽。</span><br><span class="line">感受就是兼容确实没啥大问题，你知道了IE的兼容问题之后尽量避开和熟练掌握对应的hack方法，其实也没有特别恐怖，怎么说呢，就是解决问题吧。</span><br><span class="line">稳住，我们能赢！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-25-天-2019-10-23"><a href="#第-25-天-2019-10-23" class="headerlink" title="第 25 天 (2019.10.23)"></a>第 25 天 (2019.10.23)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/86">请说说&lt;_script_&gt;、&lt;_script async_&gt;和&lt;_script defer_&gt;的区别 </a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/87">在页面中的应该使用奇数还是偶数的字体？为什么呢？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/88">写一个判断设备来源的方法</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/89">说说你工作中遇到过比较难的技术问题是什么？是如何解决的？</a></li>
</ul>
<p>1、【html】 请说说&lt;_script_&gt;、&lt;_script async_&gt;和&lt;_script defer_&gt;的区别</p>
<p>单纯的 <code>&lt;script&gt;</code> 会阻塞 DOM 的渲染，如果放在 <code>&lt;head&gt;</code> 标签中，对页面的显示会有延迟。如果是用过 <code>src</code> 引入外部资源时，浏览器会先停止解析下载外部资源，之后再执行其中的 <code>javaScript</code>（即立即加载并渲染）。</p>
<p>在添加 <code>async</code> 或者 <code>defer</code> 之后，<code>&lt;script&gt;</code> 的下载不会阻塞 DOM 的渲染。两者的区别如下：</p>
<ul>
<li><code>async</code> 在脚本下载完成后立即执行（此时会阻塞 DOM 的渲染），并且多个 <code>async</code> 脚本存在时，执行的顺序取决于下载完成的顺序。因此对于有前后依赖关系的脚本（比如 jQuery 以及依赖 jQuery 的组件库，就不适合 <code>async</code>）</li>
<li><code>defer</code> 在的脚本执行放在 DOM 渲染之后（对于老的浏览器如果不支持 <code>defer</code> 就不行了）。并且多个脚本时，其执行顺序时按照引入顺序执行的。比较符合实际项目众多的需求，但为了兼容老版本浏览器，最佳的实践还是把 <code>&lt;script&gt;</code> 放在 <code>&lt;/body&gt;</code> 前。</li>
</ul>
<p>参考文章：<br><a href="https://www.wakuwakubank.com/posts/614-javascript-async-defer/">スクリプトの非同期読み込み(async, defer の違い)</a><br><a href="https://segmentfault.com/q/1010000000640869">defer 和 async 的区别</a></p>
<p>2、【css】 在页面中的应该使用奇数还是偶数的字体？为什么呢？</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">常用偶数号字体,但奇数号字体也没关系,例如 知乎正文使用15px字体,豆瓣电影使用13px字体</span><br><span class="line">UI设计师导出的设计稿一般都是偶数号字体</span><br><span class="line">偶数字号容易和页面其他标签的其他属性形成比例关系</span><br><span class="line">Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，</span><br><span class="line">而 13、15、17 px 时用的是小一号的点阵（即每个字占的空间大了 1 px，但点阵没变），于是略显稀</span><br><span class="line">疏。(没试过)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】 写一个判断设备来源的方法</p>
<blockquote>
<p>根据 navigator.userAgent 来判断</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deviceType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> ua = navigator.userAgent;</span><br><span class="line">       <span class="keyword">var</span> agent = [<span class="string">&quot;Android&quot;</span>, <span class="string">&quot;iPhone&quot;</span>, <span class="string">&quot;SymbianOS&quot;</span>, <span class="string">&quot;Windows Phone&quot;</span>, <span class="string">&quot;iPad&quot;</span>, <span class="string">&quot;iPod&quot;</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, i&lt;agent.length; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(ua.indexOf(agent[i])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               alert(agent[i])</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4、【软技能】说说你工作中遇到过比较难的技术问题是什么？是如何解决的？</p>
<blockquote>
<p>这是在面试中经常被问到的一个问题，目的是查看面试者解决问题的能力。这里不做详细的某个技术难点来讲，因为可能你认为很难得问题，在别人那里根本不是事，就讲一下回答这个问题的思路吧。<br>这里的问题代表某个 bug 或某个难搞的需求。</p>
</blockquote>
<p>回答思路：</p>
<ol>
<li>问题出现的背景，比如说：‘在使用 Vue 开发 xxx 功能时中遇到 xxx…’</li>
<li>问题出现的原因在哪里，如果定位到的。比如：’在使用 xx 调试发现的问题出现在 xx..’</li>
<li>查找问题解决方法，比如：‘在 xx 论坛看到解决方法，在某某交流群内提问，询问身边(网上)的技术大佬’</li>
<li>问题解决后达到了什么效果，比如：‘加载速度提升了约 4 倍，受到领导同事的一致好评..’</li>
<li>问题解决后有什么感悟或收获，比如：‘原来使用 xx 方法就能 xx，记录到我的 bug-log 中..’</li>
</ol>
<h3 id="第-26-天-2019-10-24"><a href="#第-26-天-2019-10-24" class="headerlink" title="第 26 天 (2019.10.24)"></a>第 26 天 (2019.10.24)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/90">解释下你对 GBK 和 UTF-8 的理解？并说说页面上产生乱码的可能原因</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/91">说说你对 z-index 的理解</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/92">说说 bind、call、apply 的区别？并手写实现一个 bind 的方法</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/93">你对 Git 的 branch 及工作流的理解是什么？</a></li>
</ul>
<p>1、【html】 解释下你对 GBK 和 UTF-8 的理解？并说说页面上产生乱码的可能原因</p>
<p><strong>gbk 和 utf8 的理解</strong></p>
<p>我们这里将以最简单最容易理解的方式来描述 GBK 和 UTF8 的区别，以及它们分别是什么。</p>
<p>GBK 编码：是指中国的中文字符，其它它包含了简体中文与繁体中文字符，另外还有一种字符“gb2312”，这种字符仅能存储简体中文字符。</p>
<p>UTF-8 编码：它是一种全国家通过的一种编码，如果你的网站涉及到多个国家的语言，那么建议你选择 UTF-8 编码。</p>
<p><strong>GBK 和 UTF8 有什么区别？</strong></p>
<p>UTF8 编码格式很强大，支持所有国家的语言，正是因为它的强大，才会导致它占用的空间大小要比 GBK 大，对于网站打开速度而言，也是有一定影响的。</p>
<p>GBK 编码格式，它的功能少，仅限于中文字符，当然它所占用的空间大小会随着它的功能而减少，打开网页的速度比较快。</p>
<p>2、【css】说说你对 z-index 的理解？</p>
<p><strong>z-index 理解</strong></p>
<p>当网页上出现多个由绝对定位（position:absolute）或固定定位（position:fixed）所产生的浮动层时，必然就会产生一个问题，就是当这些层的位置产生重合时，谁在谁的上面呢？或者说谁看得见、谁看不见呢？这时候就可以通过设置<code>z-index</code>的值来解决，这个值较大的就在上面，较小的在下面。</p>
<blockquote>
<p><code>z-index</code>的意思就是在 z 轴的顺序，如果说网页是由 x 轴和 y 轴所决定的一个平面，那么 z 轴就是垂直于屏幕的一条虚拟坐标轴，浮动层就在这个坐标轴上，那么它们的顺序号就决定了谁上谁下了。</p>
</blockquote>
<p>参考：</p>
<ul>
<li>关于 z-index 那些你不知道的事：<a href="https://webdesign.tutsplus.com/zh-hans/articles/what-you-may-not-know-about-the-z-index-property--webdesign-16892">https://webdesign.tutsplus.com/zh-hans/articles/what-you-may-not-know-about-the-z-index-property--webdesign-16892</a></li>
<li>MDN[z-index]： <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index">https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index</a></li>
</ul>
<p>3、【js】 说说 bind、call、apply 的区别？并手写实现一个 bind 的方法</p>
<p><code>call</code>和<code>apply</code>都是为了解决改变<code>this</code>的指向。作用都是相同的，只是传参的方式不同。</p>
<p>除了第一个参数外，<code>call</code>可以接收一个参数列表，<code>apply</code>只接受一个参数数组。 <code>bind</code>绑定完之后返回一个新的函数，不执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context = window</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">  <span class="comment">// 执行完后干掉</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context = window</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  <span class="comment">// 判断 arguments[1] 是不是 undefined</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, args.concat(...arguments));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4、【软技能】 你对 Git 的 branch 及工作流的理解是什么？</p>
<p>待续~</p>
<h3 id="第-27-天-2019-10-25"><a href="#第-27-天-2019-10-25" class="headerlink" title="第 27 天 (2019.10.25)"></a>第 27 天 (2019.10.25)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/94">说说你对影子(Shadow)DOM 的了解</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/95">怎样修改 chrome 记住密码后自动填充表单的黄色背景？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/96">说说你对 arguments 的理解，它是数组吗？</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/97">你为什么离职呢？</a></li>
</ul>
<p>1、【html】说说你对影子(Shadow)DOM 的了解</p>
<blockquote>
<p><a href="https://juejin.im/post/59f2ef2d6fb9a045076ee831">影子节点 ShadowDOM</a></p>
</blockquote>
<p><code>Shadow DOM</code> 可以想象成我们在 Vue 或者 React 中使用的一个个组件，是一种将 HTML 结构、Style 封装起来的结构。我们熟悉的 <code>&lt;video&gt;</code> 标签，其实就是 <code>Shadow DOM</code> 的封装。</p>
<p>借用 MDN 上的图，可以看到 <code>Shadow DOM</code> 允许我们在 DOM 文档中插入一个 DOM 的子树。<code>Shadow Tree</code> 会挂在 <code>Shadow host</code> 对应的 DOM 上。之后，<code>Shadow DOM</code> 与外层 DOM 不会相互影响，因此可以放心用来做组件。</p>
<p><img src="https://camo.githubusercontent.com/d64532b4dc47ac438a7a0614887f198e4d0f8dfa/68747470733a2f2f6d646e2e6d6f7a696c6c6164656d6f732e6f72672f66696c65732f31353738382f736861646f772d646f6d2e706e67"></p>
<p>具体的例子可以参考 MDN 给出的案例<a href="https://github.com/mdn/web-components-examples/tree/master/popup-info-box-web-component">``</a></p>
<p>这个例子告诉我们可以利用 <code>Shadow DOM</code> 封装自己的 <code>tag</code> 标签，并且可以在网页中使用。</p>
<p>参考文章：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM">使用 shadow DOM</a><br><a href="https://aotu.io/notes/2016/06/24/Shadow-DOM/index.html">神奇的 Shadow DOM</a></p>
<p>2、【css】怎样修改 chrome 记住密码后自动填充表单的黄色背景？</p>
<p>设置表单属性 autocomplete=”off” 或者改变背景颜色为白色或透明</p>
<p>3、【js】说说你对 arguments 的理解，它是数组吗？</p>
<blockquote>
<p><code>arguments</code>是一个对象。</p>
<p>js 不能像 java 一样实现重载，<code>arguments</code>对象可以模拟重载。</p>
<p>js 中每个函数都会有<code>arguments</code>这个实例，它引用着函数的实参，可以用数组下标的方式”[]”引用<code>arguments</code>的元素。<code>arguments.length</code>为函数实参个数，<code>arguments.callee</code>引用函数自身。</p>
<p>arguments 他的特性和使用方法</p>
</blockquote>
<p><strong>特性：</strong></p>
<ol>
<li>arguments 对象和 Function 是分不开的。</li>
<li>因为 arguments 这个对象不能显式创建。</li>
<li>arguments 对象只有函数开始时才可用。</li>
</ol>
<p><strong>使用方法：</strong></p>
<p>虽然 arguments 对象并不是一个数组，但是访问单个参数的方式与访问数组元素的方式相同</p>
<p>例如：</p>
<p>arguments[0],arguments[1]…</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">arguments 不是数组，是类数组。</span><br><span class="line">类数组 转 数组的方法有</span><br><span class="line"></span><br><span class="line">[...arguments]</span><br><span class="line">Array.from(arguments)</span><br><span class="line">Array.prototype.slice.call(arguments)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-28-天-2019-10-26"><a href="#第-28-天-2019-10-26" class="headerlink" title="第 28 天 (2019.10.26)"></a>第 28 天 (2019.10.26)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/98">说说你对<code>&lt;meta&gt;</code>标签的理解</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/99">rgba()和 opacity 这两个的透明效果有什么区别呢？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/100">解释下这段代码的意思！</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/101">在浏览器中输入 url 到页面显示出来的过程发生了什么？</a></li>
</ul>
<p>1、【html】 说说你对&lt;_meta_ &gt;标签的理解</p>
<p><strong>解析：</strong><a href="https://juejin.im/entry/588074c62f301e00696b481d">关于 HTML 中 meta 标签的理解和总结</a></p>
<p><strong>简介</strong></p>
<blockquote>
<p>这儿采用英文版 W3school 的解释:</p>
<p>The <meta> tag provides metadata about the HTML document. Metadata will not be displayed on the page, but will be machine parsable.</p>
</blockquote>
<p>不难看出，其中的关键是 metadata，中文名叫元数据，是用于描述数据的数据。它不会显示在页面上，但是机器却可以识别。这么一来 meta 标签的作用方式就很好理解了。</p>
<p><strong>用处</strong></p>
<p>meta 常用于定义页面的说明，关键字，最后修改日期，和其它的元数据。这些元数据将服务于浏览器（如何布局或重载页面），搜索引擎和其它网络服务</p>
<p><strong>组成</strong></p>
<p><strong>1、name 属性</strong></p>
<p>name 属性主要用于描述网页，比如网页的关键词，叙述等。与之对应的属性值为 content，content 中的内容是对 name 填入类型的具体描述，便于搜索引擎抓取。<br>meta 标签中 name 属性语法格式是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;参数&quot;</span> <span class="attr">content</span>=<span class="string">&quot;具体的描述&quot;</span> /&gt;</span>。</span><br></pre></td></tr></table></figure>

<p>其中 name 属性共有以下几种参数。**(A-C 为常用属性)**</p>
<ul>
<li><p>A. keywords(关键字)</p>
<ul>
<li>说明：用于告诉搜索引擎，你网页的关键字</li>
</ul>
<p>举例：</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Lxxyx,博客，文科生，前端&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>B. description(网站内容的描述)</p>
<ul>
<li>说明：用于告诉搜索引擎，你网站的主要内容。</li>
</ul>
<p>举例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;description&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;文科生，热爱前端与编程。目前大二，这是我的前端博客&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C. viewport(移动端的窗口)</p>
<ul>
<li>说明：这个概念较为复杂，具体的会在下篇博文中讲述。<br>这个属性常用于设计移动端网页。在用 bootstrap,AmazeUI 等框架时候都有用过 viewport。</li>
</ul>
<p>举例（常用范例）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>D. robots(定义搜索引擎爬虫的索引方式)</p>
<ul>
<li>说明：robots 用来告诉爬虫哪些页面需要索引，哪些页面不需要索引。<br>content 的参数有 all,none,index,noindex,follow,nofollow。默认是 all</li>
</ul>
<p>举例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;none&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体参数如下：</p>
<p>1.none : 搜索引擎将忽略此网页，等价于 noindex，nofollow。<br>2.noindex : 搜索引擎不索引此网页。<br>3.nofollow: 搜索引擎不继续通过此网页的链接索引搜索其它的网页。<br>4.all : 搜索引擎将索引此网页与继续通过此网页的链接索引，等价于 index，follow。<br>5.index : 搜索引擎索引此网页。<br>6.follow : 搜索引擎继续通过此网页的链接索引搜索其它的网页。</p>
</li>
<li><p>E. author(作者)</p>
<ul>
<li>说明：用于标注网页作者</li>
</ul>
<p>举例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Lxxyx,841380530@qq.com&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>F. generator(网页制作软件)</p>
<ul>
<li>说明：用于标明网页是什么软件做的</li>
</ul>
<p>举例: (不知道能不能这样写)：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;generator&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Sublime Text3&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>G. copyright(版权)</p>
<ul>
<li>说明：用于标注版权信息</li>
</ul>
<p>举例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;copyright&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Lxxyx&quot;</span> /&gt;</span> //代表该网站为Lxxyx个人版权所有。</span><br></pre></td></tr></table></figure>
</li>
<li><p>H. revisit-after(搜索引擎爬虫重访时间)</p>
<ul>
<li>说明：如果页面不是经常更新，为了减轻搜索引擎爬虫对服务器带来的压力，可以设置一个爬虫的重访时间。如果重访时间过短，爬虫将按它们定义的默认时间来访问。<br>举例：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;revisit-after&quot;</span> <span class="attr">content</span>=<span class="string">&quot;7 days&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>I. renderer(双核浏览器渲染方式)</p>
<ul>
<li>说明：renderer 是为双核浏览器准备的，用于指定双核浏览器默认以何种方式渲染页面。比如说 360 浏览器。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;webkit&quot;</span> /&gt;</span> //默认webkit内核</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie-comp&quot;</span> /&gt;</span> //默认IE兼容模式</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie-stand&quot;</span> /&gt;</span> //默认IE标准模式</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>2、http-equiv 属性</strong></p>
<blockquote>
<p>这个我所认为的 http-equiv 意思的简介。<br><code>相当于HTTP的作用，比如说定义些HTTP参数啥的。</code></p>
</blockquote>
<p>meta 标签中 http-equiv 属性语法格式是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;参数&quot;</span> <span class="attr">content</span>=<span class="string">&quot;具体的描述&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 http-equiv 属性主要有以下几种参数：</p>
<ul>
<li><p>A. content-Type(设定网页字符集)(推荐使用 HTML5 的方式)</p>
<ul>
<li>说明：用于设定网页字符集，便于浏览器解析与渲染页面</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line">//旧的HTML，不推荐</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span> //HTML5设定网页字符集的方式，推荐使用UTF-8</span><br></pre></td></tr></table></figure>
</li>
<li><p>B. X-UA-Compatible(浏览器采取何种版本渲染当前页面)</p>
<ul>
<li>说明：用于告知浏览器以何种版本来渲染页面。（一般都设置为最新模式，在各大框架中这个设置也很常见。）</li>
</ul>
<p>举例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span> /&gt;</span></span><br><span class="line">//指定IE和Chrome使用最新版本渲染当前页面</span><br></pre></td></tr></table></figure>
</li>
<li><p>C. cache-control(指定请求和响应遵循的缓存机制)</p>
</li>
</ul>
<p><strong>用法 1.</strong></p>
<p>说明：指导浏览器如何缓存某个响应以及缓存多长时间。这一段内容我在网上找了很久，但都没有找到满意的。<br>最后终于在 Google Developers 中发现了我想要的答案。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/1/19/5dc80e2e097679bc7c9822ccc293489c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>举例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;cache-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>共有以下几种用法：</p>
<ol>
<li>no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。</li>
<li>no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）</li>
<li>public : 缓存所有响应，但并非必须。因为 max-age 也可以做到相同效果</li>
<li>private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说 CDN 就不允许缓存 private 的响应）</li>
<li>maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60 表示响应可以再缓存和重用 60 秒。</li>
</ol>
<blockquote>
<p><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn#cache-control">参考链接：HTTP 缓存</a></p>
</blockquote>
<p><strong>用法 2.(禁止百度自动转码)</strong></p>
<p>说明：用于禁止当前页面在移动端浏览时，被百度自动转码。虽然百度的本意是好的，但是转码效果很多时候却不尽人意。所以可以在 head 中加入例子中的那句话，就可以避免百度自动转码了。<br>举例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Cache-Control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-siteapp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>D. expires(网页到期时间)<ul>
<li>说明:用于设定网页的到期时间，过期后网页必须到服务器上重新传输。<br>举例：</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;expires&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Sunday 26 October 2016 01:00 GMT&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>E. refresh(自动刷新并指向某页面)<ul>
<li>说明：网页将在设定的时间内，自动刷新并调向设定的网址。<br>举例:</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;refresh&quot;</span> content=<span class="string">&quot;2；URL=http://www.lxxyx.win/&quot;</span>&gt; <span class="comment">//意思是2秒后跳转向我的博客</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>F. Set-Cookie(cookie 设定)<ul>
<li>说明：如果网页过期。那么这个网页存在本地的 cookies 也会被自动删除。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;Set-Cookie&quot;</span> content=<span class="string">&quot;name, date&quot;</span>&gt; <span class="comment">//格式</span></span><br><span class="line"></span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Set-Cookie&quot;</span> content=<span class="string">&quot;User=Lxxyx; path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT&quot;</span>&gt; <span class="comment">//具体范例</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】 rgba()和 opacity 这两个的透明效果有什么区别呢？</p>
<p>1.<code>opacity</code> 是属性，<code>rgba()</code>是函数，计算之后是个属性值； 2.<code>opacity</code> 作用于元素和元素的内容，内容会继承元素的透明度，取值 0-1； 3.<code>rgba()</code> 一般作为背景色 <code>background-color</code> 或者颜色 <code>color</code> 的属性值，透明度由其中的 <code>alpha</code> 值生效，取值 0-1；</p>
<p><strong>扩展：</strong> 1.<code>transparent</code> 也是透明，是个属性值，颜色值，跟<code>#000</code>是一类，不过它是关键字来描述。 2.如何隐藏一个元素？</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">回复@xiangshuo1992</span><br><span class="line">隐藏元素可以从属性上进行隐藏，</span><br><span class="line">display：none 通过定义自身的隐藏，并没有在页面存在dom节点，所以重新显示的时候，会导致页面重排。</span><br><span class="line">visibility：hidden, 上面的不同，虽为隐藏，但在页面上还是有dom节点，个人认为比display：none较优。</span><br><span class="line">opacity:1 透明度 给元素定义 隐藏、透明 是独立的透明属性,</span><br><span class="line">transparent 透明颜色 是作为透明的颜色值使用，常见用在border隐藏做三角形,</span><br><span class="line">rgba(0,0,0,1) 是颜色值的一种复合写法，既能显示颜色也能配合透明效果,</span><br><span class="line">z-index=-1 定义层级属性若平常的页面显示为一，想看不到显示，可以把层级降低 用平常页面成为遮罩层，达到隐藏效果，换而言之，想突出一个元素也可把层级调大，类似于绝对定位的绝对效果。</span><br><span class="line">, 还有一种是通过css3新增 用transform变化属性 rotate旋转 角度，也是可以达到隐藏效果，这里就涉及三维空间的思考。</span><br><span class="line">欢迎大家，提出补充和有问题的地方。大家相互交流</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">@hbl045 visibility：hidden 视觉上隐藏了，但是DOM布局占位还在，所以有可能会影响现有的布局，应用场景并不多</span><br><span class="line"></span><br><span class="line">隐藏元素也可以 transform: scale(0); 跟 visibility：hidden 一样，占位也是一直在的。</span><br><span class="line">也可以设置宽高为零</span><br><span class="line">还可以通过定位或者 translate 移出可视区域。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】解释下这段代码的意思！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[].forEach.call($$(<span class="string">&quot;*&quot;</span>), <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  a.style.outline =</span><br><span class="line">    <span class="string">&quot;1px solid #&quot;</span> + (~~(<span class="built_in">Math</span>.random() * (<span class="number">1</span> &lt;&lt; <span class="number">24</span>))).toString(<span class="number">16</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<blockquote>
<p>随机颜色获取：‘#’+(~~(Math.random() * (1 &lt;&lt; 24))).toString(16)</p>
</blockquote>
<p><strong>作用</strong></p>
<blockquote>
<p>在你的 Chrome 浏览器的控制台中输入这段代码，你会发现不同 HTML 层都被使用不同的颜色添加了一个高亮的边框。是不是非常酷？但是，简单来说，这段代码只是首先获取了所有的页面元素，然后使用一个不同的颜色为它们添加了一个 1px 的边框。</p>
</blockquote>
<p><strong>解析</strong></p>
<ul>
<li><code>[].forEach.call() </code>=&gt; 调用引用数组的 forEach 方法</li>
<li><code>$$(&#39;*&#39;) </code>=&gt; <code>document.querySelectorAll(&#39;*&#39;)</code></li>
<li><code>~~a</code> =&gt; <code>parseInt(a)</code></li>
<li><code>1&lt;&lt;24</code> =&gt; 对二进数 1 小数点右移 24 位</li>
<li><code>(parseInt(Math.random()*(1&lt;&lt;24)).toString(16))</code> =&gt; 获得了一个位于<code>0-16777216</code>之间的随机整数，也就是随机颜色，再使用<code>toString(16)</code>将它转化为十六进制数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $$(&#x27;*&#x27;) 为获取所有 dom 元素，返回数组</span></span><br><span class="line">[].forEach.call($$(<span class="string">&quot;*&quot;</span>), <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// forEach 的回调函数，这里的 a 是数组中每个 dom 元素，不是 a 标签</span></span><br><span class="line">  a.style.outline =</span><br><span class="line">    <span class="comment">// ～～是取整 1&lt;&lt;24 是位运算 结果为 16777216</span></span><br><span class="line">    <span class="comment">// 之后的 toString(16) 为进行 16 进制的转换 即颜色</span></span><br><span class="line">    <span class="string">&quot;1px solid #&quot;</span> + (~~(<span class="built_in">Math</span>.random() * (<span class="number">1</span> &lt;&lt; <span class="number">24</span>))).toString(<span class="number">16</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>因此这段代码的意思为，给页面所有 dom 元素添加随机颜色的边框。</p>
<p>4、【软技能】在浏览器中输入 url 到页面显示出来的过程发生了什么？</p>
<p>总体来说分为以下几个过程: <a href="https://segmentfault.com/a/1190000006879700">从输入 URL 到页面加载发生了什么</a></p>
<ol>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h3 id="第-29-天-2019-10-27"><a href="#第-29-天-2019-10-27" class="headerlink" title="第 29 天 (2019.10.27)"></a>第 29 天 (2019.10.27)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/102">你了解什么是无障碍 web（WAI）吗？在开发过程中要怎么做呢？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/103">请描述 css 的权重计算规则</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/104">写一个获取数组的最大值、最小值的方法</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/105">在工作中能让你最有成就感的是什么？并介绍下你最得意的作品吧</a></li>
</ul>
<p>1、【html】你了解什么是无障碍 web（WAI）吗？在开发过程中要怎么做呢？</p>
<p>无障碍 web 是指能让视觉障碍的人也能根据屏幕阅读器的提示阅读网页。这一块只知道一个大致概念，国内使用较少（甚至还遇到过加了 <code>title</code> 被测试提 bug 的情况）</p>
<p>目前能想到的只有下面几点：</p>
<ul>
<li>尽可能地使用语义化标签，如 <code>&lt;section&gt;</code>, <code>&lt;article&gt;</code> 等标签</li>
<li><code>img</code> 标签添加 <code>alt</code></li>
<li><code>button</code> 或者按钮上添加 <code>title</code></li>
<li>表单尽量使用 <code>label</code> for 可以和控件的 id 进行关联</li>
</ul>
<p>参考文章：<br><a href="https://mp.weixin.qq.com/s/3QNXBpGB0ZiroV8OGnXCbA">无障碍 Web</a></p>
<p>2、【css】 请描述 css 的权重计算规则</p>
<p>权重值计算</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>案例</th>
<th>权重值</th>
</tr>
</thead>
<tbody><tr>
<td>!important</td>
<td>!important</td>
<td>Infinity</td>
</tr>
<tr>
<td>内联样式</td>
<td>style=”..”</td>
<td>1000</td>
</tr>
<tr>
<td>ID</td>
<td>#id</td>
<td>100</td>
</tr>
<tr>
<td>class</td>
<td>.class</td>
<td>10</td>
</tr>
<tr>
<td>属性</td>
<td>[type=’text’]</td>
<td>10</td>
</tr>
<tr>
<td>伪类</td>
<td>:hover</td>
<td>10</td>
</tr>
<tr>
<td>标签</td>
<td>p</td>
<td>1</td>
</tr>
<tr>
<td>伪元素</td>
<td>::first-line</td>
<td>1</td>
</tr>
<tr>
<td>相邻选择器、子代选择器、通配符</td>
<td>* &gt; +</td>
<td>0</td>
</tr>
</tbody></table>
<p><strong>比较规则：</strong></p>
<ul>
<li>1000&gt;100。也就是说从左往右逐个等级比较，前一等级相等才往后比。</li>
<li>在权重相同的情况下，后面的样式会覆盖掉前面的样式。</li>
<li>继承属性没有权重值</li>
<li>通配符、子选择器、相邻选择器等的。虽然权值为 0，但是也比继承的样式优先。</li>
<li>ie6 以上才支持<code>important</code>，并且尽量少用它。</li>
</ul>
<p>3、【js】 写一个获取数组的最大值、最小值的方法</p>
<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.max = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>es6:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(...array);</span><br></pre></td></tr></table></figure>

<p>4、【软技能】在工作中能让你最有成就感的是什么？并介绍下你最得意的作品吧</p>
<h3 id="第-30-天-2019-10-28"><a href="#第-30-天-2019-10-28" class="headerlink" title="第 30 天 (2019.10.28)"></a>第 30 天 (2019.10.28)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/106">网页上的验证码是为了解决什么问题？说说你了解的验证码种类有哪些</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/107">描述下你所了解的图片格式及使用场景</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/108">写一个方法判断字符串是否为回文字符串</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/109">解释下 CRLF 是什么？</a></li>
</ul>
<p>1、【html】 网页上的验证码是为了解决什么问题？说说你了解的验证码种类有哪些</p>
<p><strong>解决的问题：</strong></p>
<ol>
<li>防止机器行为，确定是人为操作，比如登陆、发帖等。</li>
<li>保护服务器，比如 12306 买票的时候，各种抢购的时候。</li>
</ol>
<p><strong>验证码的类型：</strong></p>
<blockquote>
<p>其实这种方式本质上是出于对系统的保护</p>
</blockquote>
<ol>
<li>滑动</li>
<li>手机验证码</li>
<li>图形验证码</li>
</ol>
<p>2、【css】 描述下你所了解的图片格式及使用场景</p>
<p>通常网页在显示的图片（图形）的时候，有以下几种格式：GIF、PNG、JPG、SVG，还有个比较新的 WebP 格式。</p>
<p>▍GIF</p>
<p>优点：GIF 是动态的；支持无损耗压缩和透明度。</p>
<p>缺点：的详细的图片和写实摄影图像会丢失颜色信息；在大多数情况下，无损耗压缩效果不如 JPEG 格式或 PNG 格式；GIF 支持有限的透明度，没有半透明效果或褪色效果。</p>
<p>适用场景：主要用于比较小的动态图标。</p>
<p>▍PNG</p>
<p>优点：PNG 格式图片是无损压缩的图片，能在保证最不失真的情况下尽可能压缩图像文件的大小；图片质量高；色彩表现好；支持透明效果；提供锋利的线条和边缘，所以做出的 logo 等小图标效果会更好；更好地展示文字、颜色相近的图片。</p>
<p>缺点：占内存大,会导致网页加载速度慢；对于需要高保真的较复杂的图像，PNG 虽然能无损压缩，但图片文件较大，不适合应用在 Web 页面上。</p>
<p>适用场景：主要用于小图标或颜色简单对比强烈的小的背景图。</p>
<p>▍JPG</p>
<p>优点：占用内存小，网页加载速度快。</p>
<p>缺点：JPG 格式图片是有损压缩的图片，有损压缩会使原始图片数据质量下降，即 JPG 会在压缩图片时降低品质。</p>
<p>适用场景：由于这种格式图片对色彩表现比较好，所以适用于色彩丰富的图片。主要用于摄影作品或者大的背景图等。不合适文字比较多的图片。</p>
<p>▍SVG</p>
<p>优点：SVG 是矢量图形，不受像素影响，在不同平台上都表现良好；可以通过 JS 控制实现动画效果。</p>
<p>缺点：DOM 比正常的图形慢，而且如果其结点多而杂，就更慢；不能与 HTML 内容集成。</p>
<p>适用场景：主要用于设计模型的展示等。</p>
<p>▍WebP</p>
<p>优点：WebP 格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有 JPEG 的 2/3，并能节省大量的服务器宽带资源和数据空间。</p>
<p>缺点：相较编码 JPEG 文件，编码同样质量的 WebP 文件需要占用更多的计算资源。</p>
<p>适用场景：WebP 既支持有损压缩也支持无损压缩。将来可能是 JPEG 的代替品。</p>
<p>3、【js】写一个方法判断字符串是否为回文字符串</p>
<blockquote>
<p>考点：正则表达式、数组 API</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s.length === <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> str = s.replace(<span class="regexp">/[^a-zA-Z0-9]/g</span>, <span class="string">&quot;&quot;</span>).toLowerCase();</span><br><span class="line">  <span class="keyword">const</span> strReverse = str.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> str === strReverse;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4、【软技能】 解释下 CRLF 是什么？</p>
<blockquote>
<p>CRLF 是 carriagereturnlinefeed 的缩写。中文意思是回车换行。</p>
</blockquote>
<h3 id="第-31-天-2019-10-29"><a href="#第-31-天-2019-10-29" class="headerlink" title="第 31 天 (2019.10.29)"></a>第 31 天 (2019.10.29)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/110">DOM 和 BOM 有什么区别？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/111">让网页的字体变得清晰，变细用 CSS 怎么做？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/112">写一个方法把 0 和 1 互转（0 置 1，1 置 0）</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/113">对于有压力时，你是怎么抗压的？</a></li>
</ul>
<p>1、【html】 DOM 和 BOM 有什么区别？</p>
<blockquote>
<p>BOM 是 Browser Object Model 的缩写，即浏览器对象模型。DOM 是 Document Object Model 的缩写，即文档对象模型。他们都是浏览器提供给 JavaScript 的 API 接口。</p>
</blockquote>
<p><strong>BOM 指 浏览器对象模型</strong></p>
<p>提供了独立于内容而与浏览器窗口进行交互的对象。描述了与浏览器进行交互的方法和接口，可以对浏览器窗口进行访问和操作，譬如可以弹出新的窗口，改变状态栏中的文本。</p>
<p><strong>DOM 指 文档对象模型</strong></p>
<p>DOM 是针对 HTML 的基于树的 API。描述了处理网页内容的方法和接口，是 HTML 的 API，DOM 把整个页面规划成由节点层级构成的文档。</p>
<p>注意: 只有 JS 的宿主环境是浏览器的时候才有 DOM 和 BOM ，在 Node 中是没有这两个对象的。</p>
<p><img src="http://static.zxinc520.com/blog/20191029/g9qOHtCPLxyr.png?imageslim" alt="mark"></p>
<p>2、【css】 让网页的字体变得清晰，变细用 CSS 怎么做？</p>
<p><strong>解析：</strong></p>
<ul>
<li>第一个反应是想到 <code>font-weight: lighter;</code> ，简单测试了下，是有效的，不过没有多平台测试。</li>
<li>第二个想到的是 <code>font-family</code> 设置偏细的字体</li>
<li>第三个是在重置样式里见过，针对 MAC，IOS 平台，有个 <code>-webkit-webkit-font-smoothing: antialiased</code> 样式。</li>
</ul>
<p>3、【js】 写一个方法把 0 和 1 互转（0 置 1，1 置 0）</p>
<blockquote>
<p>学学 js 里面中的特殊符号用法，了解写</p>
</blockquote>
<p>定义 <code>var a</code>：</p>
<ul>
<li>!a &amp;&amp; 1 || 0 ;</li>
<li>~a+2</li>
<li>+!a</li>
<li>a === 1 ? 0 : 1 （ 三元表达式 ）</li>
</ul>
<p>4、【软技能】 对于有压力时，你是怎么抗压的？</p>
<p>现代人有点压力的正常的，我觉得抗压也是每一个成年人都要掌握的。<br>或者说排解压力比较准确吧，每个人都不一样，这里我就分享自己的解压方式吧。<br>解压方式：</p>
<ol>
<li>听歌，压力大的时候在网易云上听会自己喜欢的歌。</li>
<li>运动，如果有时间就去运动吧，有时间就去打球、跑步，运动完之后一天的压力和疲惫都会减轻了很多。</li>
<li>找朋友倾诉，记住要找知心朋友，尽量不要找家人，不要让家人担心。</li>
</ol>
<p><strong>其实我觉得最重要的一点是：提高自己的能力，让那些对你有压力的事情变得简单，你自然就不会有压力的。</strong></p>
<h3 id="第-32-天-2019-10-30"><a href="#第-32-天-2019-10-30" class="headerlink" title="第 32 天 (2019.10.30)"></a>第 32 天 (2019.10.30)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/114">说说你对 HTML 元素的显示优先级的理解</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/115">说下 line-height 三种赋值方式有何区别？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/116">造成内存泄漏的操作有哪些？</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/117">你在上一家公司工作流程是怎么样的，如何与其他人协作的？是怎样跨部门合作的？</a></li>
</ul>
<p>1、【html】 说说你对 HTML 元素的显示优先级的理解</p>
<p><strong>解析：</strong> <a href="https://www.jianshu.com/p/868a7d16fb68">HTML 元素的显示优先级</a> <u>与 20 题一样</u></p>
<p><strong>考点</strong>： <a href="https://www.icode9.com/tags-frameset-0.html">frameset</a>,<a href="https://www.icode9.com/tags-%E4%BC%98%E5%85%88%E7%BA%A7-0.html">优先级</a>,<a href="https://www.icode9.com/tags-%E5%85%83%E7%B4%A0-0.html">元素</a>,<a href="https://www.icode9.com/tags-html-0.html">html</a>,<a href="https://www.icode9.com/tags-%E8%A1%A8%E5%8D%95-0.html">表单</a>,<a href="https://www.icode9.com/tags-%E9%9D%A2%E8%AF%95-0.html">面试</a>,<a href="https://www.icode9.com/tags-HTML-0.html">HTML</a>,<a href="https://www.icode9.com/tags-%E7%AA%97%E5%8F%A3-0.html">窗口</a></p>
<p><strong>帧元素&gt;HTML 元素优先，表单元素总&gt;非表单元素优先</strong><br>层级显示优先级： <code>frameset &gt; 表单元素 &gt; 非表单元素</code></p>
<ul>
<li>表单元素包括：文本输入框，密码输入框，单选框，复选框，文本输入域，列表框等等；</li>
<li>非表单元素包括：连接（a），div,table,span 等。</li>
</ul>
<p>所有的 html 元素又可以根据其显示分成两类：有窗口元素以及无窗口元素。有窗口元素总是显示在无窗口元素的前面。<br>有窗口元素包括：select 元素，object 元素，以及 frames 元素等等。<br>无窗口元素：大部分 html 元素都是无窗口元素。</p>
<p>按照浏览器类型比较，HTML 元素的显示次序也有所不同：</p>
<p>2、【css】说下 line-height 三种赋值方式有何区别？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>line-height: 1.5em;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>line-height: 1.5;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2018/1/28/1613cfa1c9610935?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>可以看到，当设置<code>line-height: 1.5em</code>时，很明显子 div 的文字已经超出自己的行高范围了，设置<code>line-height: 1.5</code>时子 div 的文字没有超出自己的行高。</p>
<p>这是由于 CSS 继承时的计算方式区别造成的，如示例，当我们给类名为 parent1 的父 div 设置<code>line-height：1.5em</code>时，该 div 的<code>font-size</code>为 14，此时经过计算父 div 的<code>line-height</code>为 14px*1.5=21px，然后子 div 的<code>line-height</code>就会继承 21px 这个值，而子 div 的<code>font-size</code>为 26px，自然会超出自己的行高范围。</p>
<p>而当我们给类名为 parent2 的父 div 设置<code>line-height：1.5</code>时，子 div 会直接继承<code>line-height：1.5</code>，然后计算 26px*1.5=39px，不会超出自己的行高范围。</p>
<p>经过测试<code>line-height: 150%</code>和<code>line-height: 1.5em</code>相同，都是先计算然后把固定的行高继承给子元素，所以我们可以总结一下，<strong>继承 line-height 的时候，带单位的先计算再继承，不带单位的直接继承</strong>。</p>
<p>3、【js】 造成内存泄漏的操作有哪些？</p>
<p><strong>解析：</strong> <a href="https://www.jianshu.com/p/763ba9562864">JS 哪些操作会造成内存泄漏？</a></p>
<p>现在的 GC 好像是越来越牛逼了，有时候感觉无效的闭包都能被回收掉（还没有做过测试）</p>
<ol>
<li>意外的全局变量引起的内存泄漏</li>
<li>闭包引起的内存泄漏（主要是<strong>循环引用</strong> ，其实和 <strong>闭包</strong>的关系不大）</li>
<li>没有清理的 DOM 元素</li>
<li>被遗忘的定时器或者回调</li>
<li>子元素存在引用引起的内存泄漏</li>
</ol>
<h3 id="第-33-天-2019-10-30"><a href="#第-33-天-2019-10-30" class="headerlink" title="第 33 天 (2019.10.30)"></a>第 33 天 (2019.10.30)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/118">html 和 html5 有什么区别呢？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/119">用 CSS 绘制一个三角形</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/120">说说你对 this 的理解</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/121">你对全栈工程师的理解是什么？</a></li>
</ul>
<p>1、【html】html 和 html5 有什么区别呢？</p>
<ol>
<li>HTML5 简化了很多细微的语法，例如 doctype 的声明，只需要写<!doctype html>就行了。HTML5 与 HTML5，XHTML1 兼容，但是与 SGML 不兼容。</li>
<li>新增与语义化标签【header、footer、section、article 等】</li>
<li>canvas 替代 Flash</li>
</ol>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">html4一下是基于SGML（标准通用标记语言）的，H5不是，因为HTML要写很长的DTD规范描述，H5不用写</span><br><span class="line">H5在HTML基础上增加了很多语义化的标签以及canvas和svg，媒体等的支持</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】 用 CSS 绘制一个三角形</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">35px</span> solid lightgreen;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">35px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、【js】说说你对 this 的理解？</p>
<p>基本上可以归为四类，</p>
<ul>
<li>全局 this 是 window （默认指向）</li>
<li>函数 this 是调用者 （隐式指向）</li>
<li>call 和 apply bind 的 this 第一个参数 （显示指向）</li>
<li>构造函数的 this 是 new 之后的新对象 （构造器）</li>
</ul>
<p>4、【软技能】 你对全栈工程师的理解是什么？</p>
<p>首先，我对于全栈工程师的要求很高。</p>
<ol>
<li>独立完成页面</li>
<li>独立完成接口</li>
<li>超强学习能力</li>
</ol>
<h3 id="第-34-天-2019-10-31"><a href="#第-34-天-2019-10-31" class="headerlink" title="第 34 天 (2019.10.31)"></a>第 34 天 (2019.10.31)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/122">Standards 模式和 Quirks 模式有什么区别？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/123">浏览器是怎样判断元素是否和某个 CSS 选择器匹配？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/124">请用 canvas 写一个关于 520 浪漫表白的代码</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/125">你了解什么是技术债务吗？</a></li>
</ul>
<p>1、【html】 Standards 模式和 Quirks 模式有什么区别？</p>
<p>解析：</p>
<p>后来查了下是浏览器渲染模式，最大区别还是盒模型的解释吧</p>
<p>标准盒模型：元素内容的宽度 = width ；元素的实际宽度= width+ 2<em>padding + 2</em>border</p>
<p>怪异盒模型：元素内容宽度 = width - border 2 - paddin 2 ；实际宽度 = width</p>
<p>2、【css】浏览器是怎样判断元素是否和某个 CSS 选择器匹配？</p>
<p>先产生一个元素集合，然后从后往前判断；</p>
<blockquote>
<p>浏览器先产生一个元素集合，这个集合往往由最后一个部分的索引产生（如果没有索引就是所有元素的集合）。然后向上匹配，如果不符合上一个部分，就把元素从集合中删除，直到真个选择器都匹配完，还在集合中的元素就匹配这个选择器了。</p>
</blockquote>
<p><strong>举个例子：</strong></p>
<p>有选择器：<br><code>div.ready #wrapper &gt; .bg-red</code><br>先把所有元素 <code>class</code> 中有 <code>bg-red</code> 的元素拿出来组成一个集合，然后上一层，对每一个集合中的元素，如果元素的 <code>parent id </code>不为 <code>#wrapper </code>则把元素从集合中删去。 再向上，从这个元素的父元素开始向上找，没有找到一个 <code>tagName</code> 为 <code>div</code> 且 <code>class</code> 中有 <code>ready</code> 的元素，就把原来的元素从集合中删去。<br>至此这个选择器匹配结束，所有还在集合中的元素满足。大体就是这样，不过浏览器还会有一些奇怪的优化。<br>如图：</p>
<p><img src="https://user-images.githubusercontent.com/29278068/57994240-c9535e80-7aee-11e9-8f26-9b660fb478b9.jpg"></p>
<p><strong>注意：</strong></p>
<p>1、为什么从后往前匹配因为效率和文档流的解析方向。效率不必说，找元素的父亲和之前的兄弟比遍历所哟儿子快而且方便。关于文档流的解析方向，是因为现在的<code> CSS</code>，一个元素只要确定了这个元素在文档流之前出现过的所有元素，就能确定他的匹配情况；应用在即使 <code>html</code> 没有载入完成，浏览器也能根据已经载入的这一部分信息完全确定出现过的元素的属性。</p>
<p>2、为什么是用集合主要也还是效率。基于<code> CSS Rule</code> 数量远远小于元素数量的假设和索引的运用，遍历每一条 <code>CSS Rule</code> 通过集合筛选，比遍历每一个元素再遍历每一条 <code>Rule</code> 匹配要快得多。</p>
<p>3、【js】 请用 canvas 写一个关于 520 浪漫表白的代码 ？</p>
<p>解析： 嘻嘻嘻~~老衲 阿弥陀佛</p>
<p>4、【软技能】 你了解什么是技术债务吗？</p>
<blockquote>
<p><a href="https://github.com/haizlin/fe-interview/issues/125">参考</a></p>
</blockquote>
<h3 id="第-35-天-2019-11-01"><a href="#第-35-天-2019-11-01" class="headerlink" title="第 35 天 (2019.11.01)"></a>第 35 天 (2019.11.01)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/128">用一个 div 模拟 textarea 的实现</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/129">使用 flex 实现三栏布局，两边固定，中间自适应</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/130">请你解释一个为什么 10.toFixed(10)会报错？</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/131">谈一谈你知道的前端性能优化方案有哪些？</a></li>
</ul>
<p>1、【html】 用一个 div 模拟 textarea 的实现</p>
<p><strong>解析：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.edit</span> &#123;</span></span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    padding: 5px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: <span class="selector-tag">solid</span> 1<span class="selector-tag">px</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    resize: both;</span><br><span class="line">    overflow: auto;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;edit&quot;</span> <span class="attr">contenteditable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  这里是可以编辑的内容，配合容器的 overflow</span><br><span class="line">  ，多行截断，自定义滚动条，简直好用的不要不要的。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、【css】 使用 flex 实现三栏布局，两边固定，中间自适应</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    display: flex;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.left</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: red;</span><br><span class="line">    flex: 0 0 auto;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line">    flex: 1 1 auto;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: salmon;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、【js】 请你解释一个为什么 10.toFixed(10)会报错？</p>
<p>之所以会报错，是因为在这里的 <code>.</code> 发生了歧义，它既可以理解为小数点，也可以理解为对方法的调用。<br>因为这个点紧跟于一个数字之后，按照规范，解释器就把它判断为一个小数点。</p>
<p>所以我们可以这样修改下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>).toFixed(<span class="number">10</span></span><br><span class="line"><span class="number">10.</span>.toFixed(<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span> .toFixed(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span>.toFixed(<span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然出现这个报错是因为前面这个数是整数，如果本来就是小数就不会出现这个报错。</p>
<p>4、【软技能】 谈一谈你知道的前端性能优化方案有哪些？</p>
<p>这个优化的范围挺大，但是总归可以分为 <strong>服务端优化</strong> 和 <strong>客户端优化</strong> 。</p>
<blockquote>
<p>整理如下</p>
</blockquote>
<p><strong>客户端优化</strong></p>
<ul>
<li>减少 http 请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存 ，图片服务器。</li>
<li>使用 CSS 雪碧图（CSS Sprites）CSS Sprites 一句话：将多个图片合并到一张单独的图片，这样就大大减少了页面中图片的 HTTP 请求。</li>
<li>减少 DOM 操作次数，优化 javascript 性能。</li>
<li>少用全局变量、减少 DOM 操作、缓存 DOM 节点查找的结果。减少 IO 读取操作。</li>
<li>延迟加载 | 延迟渲染</li>
<li>图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。</li>
<li>避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示比 div+css 布局慢。</li>
</ul>
<p><strong>服务端优化</strong></p>
<ul>
<li>尽量减少响应的体积，比如用 gzip 压缩，优化图片字节数，压缩 css 和 js；或加快文件读取速度，优化服务端的缓存策略。</li>
<li>客户端优化 dom、css 和 js 的代码和加载顺序；或进行服务器端渲染，减轻客户端渲染的压力。</li>
<li>优化网络路由，比如增加 CDN 缓存；或增加并发处理能力，比如服务端设置多个域名，客户端使用多个域名同时请求资源，增加并发量。</li>
</ul>
<p><strong>最后</strong></p>
<p>对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘 IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。<br>　　减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如 join 查询），减少磁盘 IO 指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。</p>
<p>涉及的知识点太多，从客户端浏览器、渲染机制、缓存、 网络请求、代码压缩合并、图片格式、服务器代理、数据库的查询…..<br>暂时只能想到这么多，觉得自己答得并不是很好，希望有大佬回答一下这个问题。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">缓存</span><br><span class="line">http缓存 设置好cache-control expires Last-modified；</span><br><span class="line">前端缓存 对于一些页面今天配置直接存储到localStorage中；对于长期不发生改变的代码可以直接通过server-work存储到本地；</span><br><span class="line"></span><br><span class="line">优化加载</span><br><span class="line">webpack 开启 tree-shaking 减少代码体积</span><br><span class="line">通过preload prefetch优化加载资源的时间</span><br><span class="line">import(&#x27;&#x27;).then()异步加载资源</span><br><span class="line">图片小于30k的图片直接做成base64；</span><br><span class="line">对于首屏的样式可以直接内嵌到html中；</span><br><span class="line"></span><br><span class="line">服务端渲染</span><br><span class="line">SSR</span><br><span class="line">对于首页可以直接通过node jade模板引擎输出，其他页面继续使用前端渲染，优化首屏、SEO</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-36-天-2019-11-02"><a href="#第-36-天-2019-11-02" class="headerlink" title="第 36 天 (2019.11.02)"></a>第 36 天 (2019.11.02)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/132">HTML 与 XHTML 二者有不同?</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/133">写出主流浏览器内核私有属性的 css 前缀</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/134">请手写一个幻灯片的效果</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/135">对于前端安全，你了解多少？说说你对 XSS 和 CSRF 的理解</a></li>
</ul>
<p>1、【html】 HTML 与 XHTML 二者有不同？</p>
<p><strong>解析：</strong> <a href="https://www.jianshu.com/p/8e65f98980bb">HTML、XML、XHTML 有什么区别</a></p>
<p><strong>定义：</strong></p>
<ul>
<li>HTML：HyperText Markup Language / 超文本标记语言</li>
<li>XML: Extensible Markup Language / 可扩展标记语言</li>
<li>XHTML: Extensible Hypertext Markup Language / 可扩展超文本标记语</li>
</ul>
<p><strong>作为一个前端，最熟悉是就是 HTML 了，所以我们先从 HTML 说起。</strong></p>
<p>HTML 是用来描述和定义网页内容的标记语言，是构成网页的最基本的东西。<br>所谓超文本，就是说它除了能标记文本，还能标记其他的内容，比如：图片，链接，音频，视频等。<br>它的作用就是一个规范，告诉所有浏览器都统一标准，比如我给这段文字加个 <code>&lt;p&gt;</code> 标签，那就是告诉浏览器：这是一个段落。我加个 <code>&lt;img&gt;</code> 标签：这是一张图片，别弄错了。浏览器看到后，就会正确解析，产生相应的行为。</p>
<p><strong>然后说一下 XML</strong></p>
<p>它的表现形式就是给一个文档加一堆标签，说明每段文字是干什么的，有什么意义。这样做的目的是方便存储、传输、分享数据，人和机器都可以很方便的阅读。XML 和 HTML 有一个明显的区别就是：HTML 的标签都是预定义的，你不可以自己随便增加，比如你不能自造一个标签叫 <code>&lt;nihao&gt;</code>, 但是 XML 可以，你可以自己“发明”标签————这也是“可扩展的”一个含义。</p>
<p><strong>HTML 和 XML 一结合，就产生了 XHTML</strong></p>
<p>XHTML 就是以 XML 的语法形式来写 HTML.<br>XHTML 出现的原因是：HTML 是一种语法形式比较松散的标记语言，语法要求也不严格。比如大小可以混用，属性值随便你加不加引号，单引号还是双引号也随便你，标签也可以不闭合。HTML 标准的制定者 W3C 一看这样下去不行，所谓无规矩不成方圆，所以就把 XML 的语法形式往 HTML 上一套，出现了 XHTML，所以你也可以把 XHTML 理解为 HTML 的严格语法形式，除此之外，其它方面基本一样。<br>比如 XHTML 有一些强制的要求，如下：</p>
<ol>
<li>必须包含一个文件头声明 <code>&lt;!DOCTYPE&gt;</code></li>
<li>所有元素名必须小写</li>
<li>所有空元素必须关闭</li>
<li>所有属性名必须小写</li>
<li>所有属性值必须加引号</li>
<li>所有布尔值属性必须加上属性值</li>
</ol>
<p>2、【css】 写出主流浏览器内核私有属性的 css 前缀</p>
<p>完善一下：现在用 scss 等预处理器用多了，前缀确实不怎么关注了。</p>
<p>-webkit- (谷歌, Safari, 新版 Opera 浏览器等)<br>-moz- (火狐浏览器)<br>-o- (旧版 Opera 浏览器等)<br>-ms- (IE 浏览器 和 Edge 浏览器)</p>
<p>3、【js】 请手写一个幻灯片（轮播）的效果</p>
<p><strong>思路一</strong> ：元素并排浮动 改变 offset<br><strong>思路二</strong> ：position 层叠 改变 z-Index</p>
<p>4、【软技能】 对于前端安全，你了解多少？说说你对 XSS 和 CSRF 的理解？</p>
<p><strong>解析：</strong> <a href="https://github.com/YvetteLau/Blog/issues/33">源地址</a></p>
<ul>
<li>xss 输入+脚本</li>
<li>csrf 偷信息伪造请求</li>
</ul>
<h3 id="第-37-天-2019-11-02"><a href="#第-37-天-2019-11-02" class="headerlink" title="第 37 天 (2019.11.02)"></a>第 37 天 (2019.11.02)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/136">html5 哪些标签可以优化 SEO?</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/137">不使用 border 画出 1px 高的线，在不同浏览器的标准和怪异模式下都能保持效果一样</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/138">找到字符串中最长的单词，并返回它的长度</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/139">如果让你快速使用一门你不熟悉的新技术，你该怎么办？</a></li>
</ul>
<p>1、【html】 html5 哪些标签可以优化 SEO?</p>
<p><strong>解析：</strong></p>
<p>meta 信息中的 title，description，keyword。尽量使用语义化的标签，不要都是 div</p>
<p>优化 SEO 应该是可以给爬虫有比较明确的含义的标签。尽可能地不要使用 <code>div</code> 到底。</p>
<ul>
<li>meta: meta 标签中的 keywords 和 description</li>
<li>h1-h6</li>
<li>nav</li>
<li>section</li>
<li>article</li>
<li>footer</li>
<li>header</li>
</ul>
<p>2、【css】不使用 border 画出 1px 高的线，在不同浏览器的标准和怪异模式下都能保持效果一样</p>
<p><strong>解析：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 1px; width: 100%;background: black&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、【js】 找到字符串中最长的单词，并返回它的长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;aaa b cc, hello word&quot;</span>;</span><br><span class="line">str.split(<span class="regexp">/\s|,/</span>).reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> (acc &gt; cur.length ? acc : cur.length));</span><br></pre></td></tr></table></figure>

<p>4、【软技能】如果让你快速使用一门你不熟悉的新技术，你该怎么办？</p>
<p>我现在的做法：<br>1、一定先去官网查看官方文档和 API，其他别人写的教程无视。<br>2、下载官方 Demo 运行学习。<br>3、自己练习 1~2 个 Demo，涵盖常用的重要的 API 的使用，实践学习理解，有问题就谷歌。<br>4、运用到项目中。</p>
<h3 id="第-38-天-2019-11-04"><a href="#第-38-天-2019-11-04" class="headerlink" title="第 38 天 (2019.11.04)"></a>第 38 天 (2019.11.04)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/140">说说你对 cookie 和 session 的理解</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/141">实现单行文本居中和多行文本左对齐并超出显示”…”</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/142">说说你对 eval 的理解</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/143">你知道网页三剑客指的是什么吗？你有用过 Dreamwear 吗？</a></li>
</ul>
<p>1、【html】说说你对 cookie 和 session 的理解？</p>
<p><strong>解析：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">由于 http 是无状态的，服务端没法记录客户端的状态。因此 cookie 和 session 本身就是为了记录客户端的状态。</span><br><span class="line"></span><br><span class="line">只是 cookie 是存放在客户端而 session 是记录在服务端。cookie 可以在客户端生成也可以由服务器生成传给客户端，通过 name=value 的形式存储数据。</span><br><span class="line"></span><br><span class="line">一般 cookie 会记录一个由服务端生成的 token，session 同样会记录这个 token。服务端就可以通过 token 来鉴别身份。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">cookie: 可以通过客户端, 服务端设置, 容量小, 可以通过设置domain来实现同步登录, 除了name, value, 它还有多个选项, domain, path, secure, expires, 客户端和服务端可以通过cookie来通讯, 传递信息</span><br><span class="line"></span><br><span class="line">session: 由服务端设置并发起, 是服务端对于用户行为的一种凭证, 通常也是由cookie来维持这种关系, 比如session_id, 或者现在webstorm设置的Webstorm-bb00fc34等! 通过这种维持两者的关系,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">cookie: name=value 形式，可以设置过期时间，一般用来保持状态，不然每次都要登录</span><br><span class="line"></span><br><span class="line">session：也是保存状态，在服务端产生，一些敏感信息放在服务端session，然后产生一个 sessionId,通过 cookie 传到客户端，然后每次客户端请求会带cookie，服务端从cookie中获取sessionID，从而获取敏感信息。不过浏览器一关就没了，不关过一会儿也会失效</span><br><span class="line"></span><br><span class="line">把session放入cookie中便有了session cookie 2223</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、【css】 实现单行文本居中和多行文本左对齐并超出显示”…”</p>
<p><strong>解析：</strong> 有点懵<del>~</del></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.multi</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden</span><br><span class="line">  text-overflow: ellipsis</span><br><span class="line">  display: -webkit-box</span><br><span class="line">  -webkit-line-clamp: <span class="number">3</span></span><br><span class="line">  -webkit-box-orient: vertical</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、【js】 说说你对 eval 的理解？</p>
<p><code>eval()</code> 相当于一个小型的 js 解析器，接受一个字符串，可以把字符串解析成 js 代码并执行，所以有很有大的安全隐患，并且写进去的代码都是字符串，不利于维护，使用它执行代码性能也会大大折扣，所以正常情况下不建议使用</p>
<p>执行 js 代码，有性能问题，又可以执行一些恶意代码。webpack 中处理 soucemap 就用到了 eval，所有一个东西用途还是需要看场景。</p>
<h3 id="第-39-天-2019-11-08"><a href="#第-39-天-2019-11-08" class="headerlink" title="第 39 天 (2019.11.08)"></a>第 39 天 (2019.11.08)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/144">title 与 h1、b 与 strong、i 与 em 的区别分别是什么？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/145">写出你知道的 CSS 水平和垂直居中的方法</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/146">说说你对模块化的理解</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/147">公钥加密和私钥加密是什么？</a></li>
</ul>
<p>1、【html】 title 与 h1、b 与 strong、i 与 em 的区别分别是什么？</p>
<p>关于 <code>title</code> 和 <code>h1</code>，<code>title</code> 是网页的标题。主要面向的对象是搜索引擎和通过搜索结果过来的人（面向外人，可以理解为报纸首页的标题）。而 <code>h1</code> 是网页内部的标题，是给已经进到页面的人看的（可以理解为报纸某个版面的大标题）。从人类的语境上来理解，两者并没有差别。</p>
<p><code>b</code> 与 <code>strong</code> 的效果人眼上是无法区分的。在语义上，<code>b</code> 仅表示加粗既装饰用，我们应该使用 CSS 而不应该使用 <code>b</code>；而 <code>strong</code> 则表示被包围的内容很重要，是语气上的感觉。对于搜索引擎来说，会把 <code>b</code> 和 <code>strong</code> 视为同一含义。因此我们在使用上需要注意。</p>
<p><code>i</code> 与 <code>em</code> 的区别类似 <code>b</code> 和 <code>strong</code> 的区别。<code>i</code> 用于斜体展示，我们应该使用 CSS 而不应该使用 <code>i</code>；而 <code>em</code> 则是对内容的强调，但程度没有 <code>strong</code> 那么高。同样，对搜索引擎来说，两者是没有区别的。</p>
<p>3、【js】 说说你对模块化的理解？</p>
<p>模块化解决了代码污染的问题。提高了代码的重复率以及让多人合作编程了可能。</p>
<p><strong>模块化分为：</strong></p>
<ul>
<li>AMD: require.js 为代表，依赖前置，一律先加载再使用。</li>
<li>CMD: sea.js 为代表，依赖就近原则。</li>
<li>UMD: 同时支持 AMD 和 CMD 方法。</li>
<li>ES6 import/export</li>
</ul>
<p>4、【软技能】 公钥加密和私钥加密是什么？</p>
<p>公钥加密，私钥解密吧。非对称加密的方式，比如 rsa 方式。对称加密 des</p>
<h3 id="第-40-天-2019-11-17"><a href="#第-40-天-2019-11-17" class="headerlink" title="第 40 天 (2019.11.17)"></a>第 40 天 (2019.11.17)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/148">html5 都有哪些新的特性？移除了哪些元素？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/149">怎么才能让图文不可复制？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/150">为什么会有跨域问题？怎么解决跨域？</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/151">说说你对 NodeJs 的理解及用途</a></li>
</ul>
<p>1、【html】 html5 都有哪些新的特性？移除了哪些元素？</p>
<ol>
<li>语义化的标签，header,footer,nav,section,article 等。</li>
<li>表单类型增多，date,datetime,email,range,url,time 等。</li>
<li>视频音频标签，localstorage,sessionstorage 等。canvas，拖动的 api。</li>
<li>移除了 basefont，big，center，font,s，strike，tt，u，frame，frameset，noframes；</li>
</ol>
<p>2、【css】 怎么才能让图文不可复制 ?</p>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/user-select">MDN</a></p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.unselectable</span> &#123;</span><br><span class="line">  <span class="attribute">-moz-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-ms-user-select</span>: none;</span><br><span class="line">  <span class="attribute">user-select</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、【js】 为什么会有跨域问题？怎么解决跨域？</p>
<blockquote>
<p>跨域一句话的理解就是：服务端和请求端的地址不一样。</p>
</blockquote>
<p>浏览器为了安全，产生了同源策略，协议、域名、端口有一个不同，就会产生跨域。跨域方式有 jsonp,代理方式，cors，domain 改变主域相同，postmessage 也可以</p>
<p><strong>什么是跨域</strong></p>
<p>Ajax 的便利性大家都清楚，可以在不向服务器提交完整的页面的情况下，实现局部更新页面。但是浏览器处于对安全方面的考虑，不允许跨域调用其他页面的对象。<br>其实这个也不能怪浏览器，假设谁都可以随随便便向你发送请求，那样有很大的安全隐患。<br>根据浏览器的同源策略, 只有当协议，域名，端口相同的时候才算是同源, 反之则均视为是一个跨域的请求.<br>也就是说我刚刚的 Vue 端口是<code>8081</code>，服务端端口是<code>8080</code>，端口不一样，因为同源策略的存在 ，所有我的请求会失败。</p>
<p><strong>怎么解决跨域</strong> <a href="https://github.com/haizlin/fe-interview/issues/150">参考</a></p>
<ol>
<li>JSONP</li>
<li>CORS</li>
<li>Server Proxy</li>
</ol>
<p><strong>总结</strong></p>
<p>常用的跨域方式基本就是这三种：</p>
<ol>
<li>JSONP<br>优点是可以兼容老浏览器，缺点是只能发送 GET 请求</li>
<li>CORS<br>优点简单方便，支持 post 请求，缺点是需要后端的配合,不支持老版浏览器。。</li>
<li>Server Proxy<br>优点是前端正常发送 ajax 请求，缺点是后端会二次请求。</li>
</ol>
<p>参考资料：</p>
<ul>
<li>跨域资源共享 CORS 详解[阮一峰的博客]：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></li>
<li>关于跨域，你想知道的全在这里：<a href="https://zhuanlan.zhihu.com/p/25778815">https://zhuanlan.zhihu.com/p/25778815</a></li>
<li>不要再问我跨域的问题了[sf]：<a href="https://segmentfault.com/a/1190000015597029">https://segmentfault.com/a/1190000015597029</a></li>
<li>关于跨域,以及跨域的几种方式[cnblog]：<a href="https://www.cnblogs.com/chenshishuo/p/4919224.html">https://www.cnblogs.com/chenshishuo/p/4919224.html</a></li>
<li>浏览器的同源策略[MDN]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></li>
</ul>
<p>4、【软技能】说说你对 NodeJs 的理解及用途？</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/33578075">Node.js 是用来做什么的？</a></p>
</blockquote>
<p>Node.js 是一个 javascript 运行环境。它让 javascript 可以开发后端程序，实现几乎其他后端语言实现的所有功能，可以与 PHP、Java、Python、.NET、Ruby 等后端语言平起平坐。</p>
<p>Nodejs 是基于 V8 引擎，V8 是 Google 发布的开源 JavaScript 引擎，本身就是用于 Chrome 浏览器的 js 解释部分，但是 Ryan Dahl 这哥们，鬼才般的，把这个 V8 搬到了服务器上，用于做服务器的软件。</p>
<p>优势：</p>
<ol>
<li>Nodejs 语法完全是 js 语法，只要你懂 js 基础就可以学会 Nodejs 后端开发</li>
<li>NodeJs 超强的高并发能力</li>
<li>实现高性能服务器</li>
<li>开发周期短、开发成本低、学习成本低</li>
</ol>
<p><strong>Node.js 能干什么</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20181107112112563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzQyNzIw,size_16,color_FFFFFF,t_70"></p>
<h3 id="第-41-天-2019-11-17"><a href="#第-41-天-2019-11-17" class="headerlink" title="第 41 天 (2019.11.17)"></a>第 41 天 (2019.11.17)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/152">webSocket 怎么做兼容处理？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/153">怎么让英文单词的首字母大写？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/154">说说你对 IIFE 的理解</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/155">你有自己的博客吗？平时自己有写一些技术文章吗？</a></li>
</ul>
<p>1、【html】 webSocket 怎么做兼容处理？</p>
<blockquote>
<p><a href="https://juejin.im/post/5aef0e9c518825673a20754d">如何解决 WebSocket 的兼容性</a></p>
</blockquote>
<p>2、【css】怎么让英文单词的首字母大写？</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">  <span class="attribute">text-transform</span>: capitalize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Keyword values */</span></span><br><span class="line"><span class="selector-tag">text-transform</span>: <span class="selector-tag">capitalize</span>;</span><br><span class="line"><span class="selector-tag">text-transform</span>: <span class="selector-tag">uppercase</span>;</span><br><span class="line"><span class="selector-tag">text-transform</span>: <span class="selector-tag">lowercase</span>;</span><br><span class="line"><span class="selector-tag">text-transform</span>: <span class="selector-tag">none</span>;</span><br><span class="line"><span class="selector-tag">text-transform</span>: <span class="selector-tag">full-width</span>;</span><br></pre></td></tr></table></figure>

<p>capitalize<br>这个关键字强制每个单词的首字母转换为大写。</p>
<p>uppercase<br>这个关键字强制所有字符被转换为大写。</p>
<p>lowercase<br>这个关键字强制所有字符被转换为小写。</p>
<p>none<br>这个关键字阻止所有字符的大小写被转换。</p>
<p>full-width （实验性属性值）<br>这个关键字强制字符 — 主要是表意字符和拉丁文字 — 书写进一个方形里，并允许它们按照一般的东亚文字（比如中文或日文）对齐。</p>
<p>除了以上，还有一些基本上不会用到的默认值等，就不多说了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="selector-tag">text-transform</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="selector-tag">text-transform</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">text-transform</span>: <span class="selector-tag">unset</span>;</span><br></pre></td></tr></table></figure>

<p>3、【js】说说你对 IIFE 的理解</p>
<blockquote>
<p>最大的作用是创建一个<strong>独立的作用域</strong></p>
</blockquote>
<p>用 IIFE（匿名函数立即执行）实现，针对<strong>不需要复用的功能模块</strong>可以用 IIFE 完全消除全局变量，所以一般 IIFE 都是用来辅助命名空间/模块化方式的</p>
<h3 id="第-42-天-2019-11-18"><a href="#第-42-天-2019-11-18" class="headerlink" title="第 42 天 (2019.11.18)"></a>第 42 天 (2019.11.18)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/156">解释下什么是 ISISO8859-2 字符集？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/158">重置（初始化）css 的作用是什么？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/157">window 对象和 document 对象有干什么区别？</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/159">你现在在团队是什么角色，有起到了什么显著的作用吗？</a></li>
</ul>
<p>1、【html】解释下什么是 ISISO8859-2 字符集？</p>
<p>当今开发环境下，对于一个字符集，通常情况下，我们只需要有两个认识：</p>
<blockquote>
<ul>
<li>它是 UTF-8 吗？</li>
<li>如果不是，那它兼容 UTF-8 吗？</li>
</ul>
</blockquote>
<p>对于 ISO-8859，回答是：</p>
<blockquote>
<p>它不是 UTF-8，但它兼容 UTF-8。它是 UTF-8 的子集。</p>
</blockquote>
<p>当然，知道了也没用。你还是用 UTF-8。</p>
<blockquote>
<p>注：你如果接手一个遗留项目，可能会接触到和 UTF-8 不同的其他字符集。你的开发体验通常会很差，因为其他工具都用 UTF-8。所以，最好的方法是：不要接手非 UTF-8 的遗留项目。</p>
</blockquote>
<hr>
<p>这个知识点在非科班的来看算是比较偏门的了。<br>查了一下才知道，原来是 Ascll 扩展部分的字符集。</p>
<blockquote>
<p>ISO/IEC 8859-1，又称 Latin-1 或“西欧语言”，ISO/IEC 8859-2 Latin-2 或“中欧语言”，是国际标准化组织内 ISO/IEC 8859 的 8 位字符集。它以 ASCII 为基础，在空置的 0xA0-0xFF 的范围内，加入 192 个字母及符号，藉以供使用变音符号的拉丁字母语言使用。</p>
</blockquote>
<p>我觉得可以把它看做是 Ascll 码的一部分</p>
<p>2、【css】 第 42 天 重置（初始化）css 的作用是什么？</p>
<blockquote>
<p>我理解的，简单讲主要是为了 统一各个浏览器自带的默认样式而诞生的。</p>
</blockquote>
<p>这是一个，还有就是 <strong>视觉问题</strong> ，浏览器默认样式会影响我们的设计还原，而且默认样式一般不够美观，满足不了定制化的视觉需求，达不到视觉产品的信息传达目标。</p>
<p>3、【js】 window 对象和 document 对象有什么区别？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Window是浏览器的对象可以称为宿主对象。宿主对象包括（Bom，<span class="built_in">setTimeout</span>，storage，work Server等 ）</span><br><span class="line">Document是文档对象，以html形式展示。是<span class="built_in">window</span>对象里面的 一部分。</span><br><span class="line"></span><br><span class="line">## window对象</span><br><span class="line">   代表浏览器中的一个打开的窗口或者框架，<span class="built_in">window</span>对象会在或者每次出现时被自动创建，在客户端JavaScript中，Window对象是全局对象<span class="built_in">global</span>，所有的表达式都在当前的环境中计算，要引用当前的窗口不需要特殊的语法，可以把那个窗口属性作为全局变量使用，例如：可以只写<span class="built_in">document</span>，而不必写<span class="built_in">window</span>.document。同样可以把窗口的对象方法当做函数来使用，如：只写alert()，而不必写<span class="built_in">window</span>.alert.</span><br><span class="line"><span class="built_in">window</span>对象实现了核心JavaScript所定义的全局属性和方法。</span><br><span class="line"></span><br><span class="line">## document对象</span><br><span class="line">   代表整个HTML文档，可以用来访问页面中的所有元素 。</span><br><span class="line">每一个载入浏览器的HTML文档都会成为<span class="built_in">document</span>对象。<span class="built_in">document</span>对象使我们可以使用脚本(js)中对HTML页面中的所有元素进行访问。</span><br><span class="line"><span class="built_in">document</span>对象是<span class="built_in">window</span>对象的一部分可以通过<span class="built_in">window</span>.document属性对其进行访问</span><br><span class="line">HTMLDocument接口进行了扩展，定义HTML专用的属性和方法，很多属性和方法都是HTMLCollection对象，其中保存了对锚、表单、链接以及其他可脚本元素的引用。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-43-天-2019-05-29"><a href="#第-43-天-2019-05-29" class="headerlink" title="第 43 天 (2019.05.29)"></a>第 43 天 (2019.05.29)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/161">如何让元素固定在页面底部？有哪些比较好的实践？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/162">span 与 span 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/163">JQuery 的源码看过吗？能不能简单概括一下它的实现原理？</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/164">最近在学什么？能谈谈你未来 3，5 年给自己的规划吗？</a></li>
</ul>
<p>1、【html】 如何让元素固定在页面底部？有哪些比较好的实践？</p>
<p>解析：这个是在结构的底部还是视图的底部 ，视图底部就是 fixed，结构的底部就是 sticky footer 布局咯~</p>
<p>2、【css】span 与 span 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</p>
<blockquote>
<p><a href="https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/">张鑫旭</a></p>
</blockquote>
<ol>
<li><p>方法之移除空格</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;space&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;##&quot;&gt;</span><br><span class="line">    惆怅&lt;/a&gt;&lt;a href=&quot;##&quot;&gt;</span><br><span class="line">    淡定&lt;/a&gt;&lt;a href=&quot;##&quot;&gt;</span><br><span class="line">    热血&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 margin 负值</p>
</li>
<li><p>让闭合标签吃胶囊</p>
</li>
<li><p>使用 font-size:0</p>
</li>
<li><p>使用 letter-spacing</p>
</li>
<li><p>使用 word-spacing</p>
</li>
<li><p>其他成品方法</p>
</li>
</ol>
<p>3、【js】JQuery 的源码看过吗？能不能简单概括一下它的实现原理？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window, undefined, document</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params">prop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jQuery.prototype.init();</span><br><span class="line">  &#125;</span><br><span class="line">  jQuery.prototype = &#123;</span><br><span class="line">    contructor: jQuery,</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> (<span class="params">prop</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">  jQuery.prototype.init.prototype = jQuery.prototype;</span><br><span class="line">  <span class="built_in">window</span>[<span class="string">&quot;jQuery&quot;</span>] = <span class="built_in">window</span>[<span class="string">&quot;$&quot;</span>] = <span class="keyword">new</span> jQuery();</span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="literal">undefined</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>

<p>jQuery 是通过封装浏览器原生的 DOM API 实现 dom 元素的选取，然后封装到 jQuery 对象中去，同时根据浏览器检测对不同浏览器操作不同的 APi .jQuery 对象上高度集成了超的 API。当然 jQuery 还有做的更多比如，我们可以 new jQuery(‘div’),也可以直接$(‘div’),这个巧妙地运算就是上面init方法；如果页面已经有$时，jQuery 会先将$接管把之前$的全局名保存下来 等后面使用是在释放、。。。大致了解。</p>
<p>4、【软技能】 最近在学什么？能谈谈你未来 3，5 年给自己的规划吗？</p>
<h3 id="第-44-天-2019-11-19"><a href="#第-44-天-2019-11-19" class="headerlink" title="第 44 天 (2019.11.19)"></a>第 44 天 (2019.11.19)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/165">说说 video 标签中预加载视频用到的属性是什么？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/166">手写一个满屏品字布局的方案</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/167">深度克隆对象的方法有哪些，并把你认为最好的写出来</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/168">说说你对 http、https、http2 的理解</a></li>
</ul>
<p>1、【html】 说说 video 标签中预加载视频用到的属性是什么？</p>
<blockquote>
<p>preload</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>autoplay</td>
<td>autoplay</td>
<td>如果出现该属性，则视频在就绪后马上播放。</td>
</tr>
<tr>
<td>controls</td>
<td>controls</td>
<td>如果出现该属性，则向用户显示控件，比如播放按钮。</td>
</tr>
<tr>
<td>height</td>
<td>pixels</td>
<td>设置视频播放器的高度。</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>如果出现该属性，则当媒介文件完成播放后再次开始播放。</td>
</tr>
<tr>
<td>preload</td>
<td>preload</td>
<td>如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td>
</tr>
<tr>
<td>src</td>
<td>url</td>
<td>要播放的视频的 URL。</td>
</tr>
<tr>
<td>width</td>
<td>pixels</td>
<td>设置视频播放器的宽度。</td>
</tr>
</tbody></table>
<p>2、【css】手写一个满屏品字布局的方案？</p>
<blockquote>
<p>flex 、float、grid 布局</p>
</blockquote>
<p>3、【js】 深度克隆对象的方法有哪些，并把你认为最好的写出来</p>
<blockquote>
<p><a href="https://juejin.im/post/5abb55ee6fb9a028e33b7e0a">面试官:请你实现一个深克隆</a></p>
</blockquote>
<p>1、前几年微博上流传着一个传说中最便捷实现深克隆的方法, JSON 对象 parse 方法可以将 JSON 字符串反序列化成 JS 对象，stringify 方法可以将 JS 对象序列化成 JSON 字符串,这两个方法结合起来就能产生一个便捷的深克隆.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(oldObj));</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：</p>
<ol>
<li><p>它无法实现对函数 、RegExp 等特殊对象的克隆</p>
</li>
<li><p>会抛弃对象的 constructor,所有的构造函数会指向 Object</p>
</li>
<li><p>对象有循环引用,会报错</p>
</li>
<li><p>构造一个深克隆函数</p>
</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626bc7a5caf947c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>4、【软技能】说说你对 http、https、http2 的理解？</p>
<blockquote>
<p><a href="https://juejin.im/post/5d4a47226fb9a06b0a275f33">说说你对 http、https、http2.0 的理解？</a></p>
</blockquote>
<h3 id="第-45-天-2019-11-23"><a href="#第-45-天-2019-11-23" class="headerlink" title="第 45 天 (2019.11.23)"></a>第 45 天 (2019.11.23)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/169">xml 与 html 有什么区别？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/170">你知道的等高布局有多少种？写出来</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/171">写出几种创建对象的方式，并说说他们的区别是什么？</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/172">从你的角度上来讲，你觉得如何管理前端团队？</a></li>
</ul>
<p>1、【html】 xml 与 html 有什么区别？</p>
<blockquote>
<p>XML：<br>必须闭合；元素嵌套正确；标签小写； 必须有根元素</p>
</blockquote>
<ol>
<li>html 不区分大小写，xml 区分大小写</li>
<li>html 可以没有闭合标签，xml 必须有闭合标签</li>
<li>html 可以拥有不带值的属性名，xml 中所有的属性必须带值</li>
<li>html 是用于显示数据，xml 主要用于描述，存放数据</li>
<li>XML 的多个空格不会被合并成一个空格，而 HTML 会。</li>
</ol>
<p>2、【css】 你知道的等高布局有多少种？写出来</p>
<blockquote>
<p><a href="https://juejin.im/post/5b0fb34151882515662238fd">常用的多列等高布局</a></p>
</blockquote>
<ol>
<li><p>使用负 margin-bottom 和正 padding-bottom 对冲实现</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.Article</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span> -<span class="number">9999px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">9999px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#4577dc</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>flex 布局</p>
</li>
<li><p>模仿 table 布局</p>
</li>
<li><p>grid 布局</p>
</li>
<li><p>js 计算</p>
</li>
</ol>
<p>3、【js】 写出几种创建对象的方式，并说说他们的区别是什么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 创建, 不推荐  ---new 实例化</span></span><br><span class="line"><span class="keyword">const</span> b = &#123;&#125;; <span class="comment">// 赋值, 性能比a要好  --字面量</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="built_in">Object</span>.create(); <span class="comment">// 继承创建, Object.create(null) 很多框架都有用来做性能优化</span></span><br></pre></td></tr></table></figure>

<p><strong>new Object()</strong></p>
<p>直接通过构造函数创建一个新对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; new Object()</span><br><span class="line">&#x2F;&#x2F;等同于 var obj &#x3D; &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用字面量的方式更简单，其实他俩是一样的。<br>优点是足够简单，缺点是每个对象都是独立的。</p>
<p><strong>工厂模式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  obj.name = name;</span><br><span class="line">  obj.age = age;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Anson = createObj(<span class="string">&quot;Anson&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Anson);</span><br><span class="line"><span class="comment">//&#123;name: &quot;Anson&quot;, age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<p>优点是 可以解决创建多个相似对象的问题，缺点是 无法识别对象的类型。</p>
<p><strong>构造函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>, <span class="number">13</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br><span class="line"><span class="comment">//Person &#123;name: &quot;小明&quot;, age: 13, sayName: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<p>优点是 可以创建特定类型的对象，缺点是 多个实例重复创建方法</p>
<p><strong>（构造函数+原型）组合模式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;小白&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br><span class="line"><span class="comment">//Person &#123;name: &quot;小白&quot;, age: 18&#125; __proto__ -&gt; sayName: ƒ ()</span></span><br></pre></td></tr></table></figure>

<p>优点 多个实例引用一个原型上的方法 比较常用</p>
<p><strong>动态原型</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span>.sayName != <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;小红&quot;</span>, <span class="number">15</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br><span class="line"><span class="comment">//Person &#123;name: &quot;小红&quot;, age: 15&#125; 动态创建sayName: ƒ ()</span></span><br></pre></td></tr></table></figure>

<p>优点 可以判断某个方法是否有效，来决定是否需要初始化原型，if 只会在仅在碰到第一个实例调用方法<br>时会执行，此后所有实例共享此方法，需要注意的一点是，不能重新原型对象。</p>
<p><strong>寄生构造函数模式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">&quot;her&quot;</span>, <span class="number">18</span>, <span class="string">&quot;Front-end Engineer&quot;</span>);</span><br><span class="line">friend.sayName();</span><br><span class="line"><span class="comment">//her</span></span><br></pre></td></tr></table></figure>

<p>除了使用<code>new</code>操作符，其他的和工厂函数一样，可以为对象创建构造函数。</p>
<p><strong>稳妥模式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o=&#123;&#125;;</span><br><span class="line">    o.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(name) &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = (<span class="string">&#x27;小亮&#x27;</span>，<span class="number">24</span>);</span><br><span class="line">person.sayName();<span class="comment">//’小亮‘</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了使用<code>person.sayName()</code>之外 ，没有办法在访问到 name 的值，适合在某些安全执行环景下使用。</p>
<p><strong>Object.create()</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  isHuman: <span class="literal">false</span>,</span><br><span class="line">  printIntroduction: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>. Am I human? <span class="subst">$&#123;<span class="built_in">this</span>.isHuman&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.create(person);</span><br><span class="line"></span><br><span class="line">me.name = <span class="string">&quot;Matthew&quot;</span>; <span class="comment">// &quot;name&quot; is a property set on &quot;me&quot;, but not on &quot;person&quot;</span></span><br><span class="line">me.isHuman = <span class="literal">true</span>; <span class="comment">// inherited properties can be overwritten</span></span><br><span class="line"></span><br><span class="line">me.printIntroduction();</span><br><span class="line"><span class="comment">// expected output: &quot;My name is Matthew. Am I human? true&quot;</span></span><br></pre></td></tr></table></figure>

<p>传入一个原型对象，创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>，实现继承。</p>
<p><strong>参考：</strong>《JavaScript 高级程序设计第三版》、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">MDN</a></p>
<h3 id="第-46-天-2019-11-24"><a href="#第-46-天-2019-11-24" class="headerlink" title="第 46 天 (2019.11.24)"></a>第 46 天 (2019.11.24)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/173">页面中怎么嵌入 Flash？有哪些方法？写出来</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/174">说说你对媒体查询的理解</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/175">写一个使两个整数进行交换的方法（不能使用临时变量）</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/176">说说你对本项目的看法及建议</a></li>
</ul>
<p>1、【html】 页面中怎么嵌入 Flash？有哪些方法？写出来</p>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/%E5%85%B6%E4%BB%96%E5%B5%8C%E5%85%A5%E6%8A%80%E6%9C%AF">从对象到 iframe - 其他嵌入技术</a></p>
<p>看一些能让您在网页中嵌入各种内容类型的元素： <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe">``</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed">``</a> 和<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object">``</a> 元素。<code>&lt;iframe&gt;</code>用于嵌入其他网页，另外两个元素则允许您嵌入 PDF，SVG，甚至 Flash — 一种正在被淘汰的技术，但您仍然会时不时的看到它。</p>
<table>
<thead>
<tr>
<th>预备知识：</th>
<th>基本的计算机素养，<a href="https://developer.mozilla.org/zh-CN/Learn/Getting_started_with_the_web/Installing_basic_software">安装基础软件</a>，<a href="https://developer.mozilla.org/zh-CN/Learn/Getting_started_with_the_web/Dealing_with_files">文件处理</a> 的基本知识，熟悉 HTML 基础知识（阅读 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML/Getting_started">开始学习 HTML</a>）以及本模块中以前的文章。</th>
</tr>
</thead>
<tbody><tr>
<td>学习目标：</td>
<td>要了解如何使用<code>&lt;object&gt;、</code><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed">``</a>以及<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe">``</a>在网页中嵌入部件，例如 Flash 电影或其他网页。</td>
</tr>
</tbody></table>
<p>&lt;_embed_ &gt;和&lt;_object_ &gt;元素</p>
<p>&lt;_embed_ &gt;和&lt;_object_ &gt;元素的功能不同于<code>&lt;iframe&gt;</code>—— 这些元素是用来嵌入多种类型的外部内容的通用嵌入工具，其中包括像 Java 小程序和 Flash，PDF（可在浏览器中显示为一个 PDF 插件）这样的插件技术，甚至像视频，SVG 和图像的内容！</p>
<p><strong>注意</strong>：<strong>插件</strong>是一种对浏览器原生无法读取的内容提供访问权限的软件。</p>
</blockquote>
<p><strong>页面中怎么嵌入 Flash？</strong></p>
<ol>
<li>object + embed 传统的方法</li>
<li>单 object</li>
<li>双 object</li>
<li>flex 提供的标准方法</li>
<li>swfobject</li>
<li>单 embed 显示 ie7 和 ff3 下都能正常显示</li>
</ol>
<p>2、【css】 说说你对媒体查询的理解？</p>
<blockquote>
<p>为了适应不同的设备终端</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190522114353452.png"></p>
<p>3、【js】 写一个使两个整数进行交换的方法（不能使用临时变量）</p>
<p><strong>解析：</strong></p>
<ul>
<li>ES5</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line">a = b + a;</span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure>

<ul>
<li>ES6</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b] = [b, a];</span><br></pre></td></tr></table></figure>

<p>异或取值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a ^= b;</span><br><span class="line">b ^= a;</span><br><span class="line">a ^= b;</span><br></pre></td></tr></table></figure>

<h3 id="第-47-天-2019-12-05"><a href="#第-47-天-2019-12-05" class="headerlink" title="第 47 天 (2019.12.05)"></a>第 47 天 (2019.12.05)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/177">HTML5 如何使用音频和视频？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/178">你是怎样抽离样式模块的？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/179">请说说你对事件冒泡机制的理解？</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/180">如果 HR 说要做背调，还要你给出近三个月的银行流水，你该怎么办？</a></li>
</ul>
<p>1、【html】HTML5 如何使用音频和视频？</p>
<p>HTML5 新标签可以直接用 video 和 audio，但是想要自动播放还有些兼容性问题，在手机上各浏览器需要做兼容处理。</p>
<p>2、【css】你是怎样抽离样式模块的？</p>
<p>样式模块？<br>通过组件化思想，用 <a href="https://github.com/Tencent/tmt-workflow/wiki/%E2%92%9B-%5B%E8%A7%84%E8%8C%83%5D--CSS-BEM-%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83">BEM </a>方式命名。</p>
<p>3、【js】 <a href="https://github.com/haizlin/fe-interview/issues/179">请说说你对事件冒泡机制的理解？</a></p>
<p>按照 W3C 事件模型，事件流按照次序依次为<code>捕获阶段</code>， <code>目标阶段</code>，<code>冒泡阶段</code>。如果事件绑定时候，禁止了冒泡，则事件流会停止在目标阶段。</p>
<p>先说两个有关 DOM 事件流的概念<code>事件冒泡</code>和<code>事件捕获</code>。</p>
<ul>
<li>事件冒泡： 事件沿着 DOM 树向上通知</li>
<li>事件捕获：和事件冒泡相反，事件沿着 DOM 数向下通知</li>
</ul>
<p>开发者可以自己决定事件处理注册到捕获阶段，或者是冒泡阶段。<br><code>element1.addEventListener(&#39;click&#39;,doSomething2,true)</code> 如果最后一个参数为 true，则注册到捕获阶段。</p>
<p><strong>事件委托(事件代理)</strong><br>介绍完上面的，事件委托是时候登场了。事件委托简单说起来就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>
<h3 id="第-48-天-2019-12-05"><a href="#第-48-天-2019-12-05" class="headerlink" title="第 48 天 (2019.12.05)"></a>第 48 天 (2019.12.05)</h3><p><strong>总览：</strong></p>
<ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/181">说说你对 WEB 标准和 W3C 的理解与认识？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/182">你知道全屏滚动的原理是什么吗？它用到了 CSS 的那些属性？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/183">你对事件循环有了解吗？说说看！</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/184">最近 996 一词很火，谈谈你对 996 的看法</a></li>
</ul>
<p>1、【html】 说说你对 WEB 标准和 W3C 的理解与认识？</p>
<p><strong>web 标准</strong></p>
<ul>
<li>什么是 web 标准：一系列标准的集合，包括结构化标准语言（html 等）、表现标准语言（css）、行为标准语言（EMCAScript 等）。这些标准大部分由万维网联盟起草和发布</li>
<li>为什么使用 web 标准：为了解决因浏览器版本不同、软硬件设备不同导致的需多版本开发的问题</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">html是名词--表现</span><br><span class="line">css是形容词--结构</span><br><span class="line">javascript是动词--行为</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上这三个东西就形成了一个完整的网页，但是 js 改变时，可以会造成 css 和 html 的混乱，让这三个的界限不是那么清晰。</p>
<p>这个时候，web 标准就出来了，web 标准一般是将该三部分独立分开，使其更具有模块化。</p>
<p>W3C 对 web 标准提出了规范化的要求，也就是在实际编程中的一些代码规范：包含如下几点</p>
<p>1.对于结构要求：（标签规范可以提高搜索引擎对页面的抓取效率，对 SEO 很有帮助）</p>
<p>标签字母要小写<br>标签要闭合<br>标签不允许随意嵌套 2.对于 css 和 js 来说</p>
<p>尽量使用外链 css 样式表和 js 脚本。是结构、表现和行为分为三块，符合规范。同时提高页面渲染速度，提高用户的体验。<br>样式尽量少用行间样式表，使结构与表现分离，标签的 id 和 class 等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版</p>
<p><strong>W3C</strong>：万维网联盟，是一个 web 开发的国际性联盟</p>
<p>2、【css】知道全屏滚动的原理是什么吗？它用到了 CSS 的哪些属性？</p>
<p><strong>一、知识点</strong></p>
<ul>
<li>JS 滚动监听事件</li>
<li>JS 移动端 touch 监听事件</li>
<li>函数节流</li>
<li>DOM 操作</li>
</ul>
<p><strong>二、代码分析</strong></p>
<p><strong>1.CSS</strong></p>
<p>html, body 设置 overflow 为 hidden, 让视图中只包括一个分页;设置滑动分页的长宽都是 100%; 外部容器设置 transition 过渡效果, 并设置为相对定位, 滚动是修改外部容器的 Top 值, 实现滚动效果.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page-container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1000ms</span> ease;</span><br><span class="line">  <span class="attribute">touch-action</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page-item</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.HTML</strong></p>
<p>初始三个分页</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-item&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-item&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-item&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3.JavaScript</strong></p>
<p>1.初始化值<br>容器高度设置为窗口高度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.page-container&quot;</span>);</span><br><span class="line"><span class="comment">// 获取根元素高度, 页面可视高度</span></span><br><span class="line"><span class="keyword">var</span> viewHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line"><span class="comment">// 获取滚动的页数</span></span><br><span class="line"><span class="keyword">var</span> pageNum = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.page-item&quot;</span>).length;</span><br><span class="line"><span class="comment">// 初始化当前位置, 距离原始顶部距离</span></span><br><span class="line"><span class="keyword">var</span> currentPosition = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 设置页面高度</span></span><br><span class="line">container.style.height = viewHeight + <span class="string">&quot;px&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>2.初始化滚动事件<br>向下滚动时, 当 <code>currentPosition</code> 比 <code>-整体分页高度</code> 大的时候(绝对值相比小的时候), 向下滚动;向上滚动时, 当 <code>currentPosition</code> 大于 <code>0</code> 的时候, 向上滚动.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向下滚动页面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goDown</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (currentPosition &gt; -viewHeight * (pageNum - <span class="number">1</span>)) &#123;</span><br><span class="line">    currentPosition = currentPosition - viewHeight;</span><br><span class="line">    container.style.top = currentPosition + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上滚动页面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (currentPosition &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    currentPosition = currentPosition + viewHeight;</span><br><span class="line">    container.style.top = currentPosition + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.节流函数<br>即在规定时间内只会触发一次指定方法, 用于滚动时防止多次触发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle (fn, delay) &#123;</span><br><span class="line">  let baseTime &#x3D; 0</span><br><span class="line">  return function () &#123;</span><br><span class="line">    const currentTime &#x3D; Date.now()</span><br><span class="line">    if (baseTime + delay &lt; currentTime) &#123;</span><br><span class="line">      fn.apply(this, arguments)</span><br><span class="line">      baseTime &#x3D; currentTime</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;js</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.监听鼠标滚动<br>滚动事件<code>firefox</code>与其他浏览器的事件不同, 所以需要进行判断. <code>deltaY</code>大于<code>0</code>的时候, 想下滚动; 反之, 向上滚动.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handlerWheel = throttle(scrollMove, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// https://developer.mozilla.org/en-US/docs/Web/API/Element/mousewheel_event#The_detail_property</span></span><br><span class="line"><span class="comment">// firefox的页面滚动事件其他浏览器不一样</span></span><br><span class="line"><span class="keyword">if</span> (navigator.userAgent.toLowerCase().indexOf(<span class="string">&quot;firefox&quot;</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">&quot;mousewheel&quot;</span>, handlerWheel);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">&quot;DOMMouseScroll&quot;</span>, handlerWheel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollMove</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.deltaY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    goDown();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    goUp();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.监听移动端 touch 操作<br>当 touch 的最终位置大于起始位置时, 则页面向上滚动; 反之, 向下滚动.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> touchStartY = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;touchstart&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  touchStartY = event.touches[<span class="number">0</span>].pageY;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> handleTouchEnd = throttle(touchEnd, <span class="number">500</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;touchend&quot;</span>, handleTouchEnd);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">touchEnd</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> touchEndY = e.changedTouches[<span class="number">0</span>].pageY;</span><br><span class="line">  <span class="keyword">if</span> (touchEndY - touchStartY &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 向上滑动, 页面向下滚动</span></span><br><span class="line">    goDown();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    goUp();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-49-天-2019-12-15"><a href="#第-49-天-2019-12-15" class="headerlink" title="第 49 天 (2019.12.15)"></a>第 49 天 (2019.12.15)</h3><ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/185">说说你对 target=”_blank”的理解？有啥安全性问题？如何防范？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/186">假如设计稿使用了非标准的字体，你该如何去实现它？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/187">写个还剩下多少天过年的倒计时</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/188">你有遇到过字体侵权的事吗？如何解决？</a></li>
</ul>
<p>1【html】说说你对 target=”_blank”的理解？有啥安全性问题？如何防范？</p>
<blockquote>
<p>通常在网页中使用链接时，你很可能会添加一个简单的 target=”_blank” 属性到 a 标签上来让浏览器用一个新的标签页来打开一个 URL 地址。但是这一属性正在成为网络钓鱼者攻击的机会。 <a href="https://zhuanlan.zhihu.com/p/53132574">你从未注意的隐藏危险</a></p>
</blockquote>
<p>2、【css】 假如设计稿使用了非标准的字体，你该如何去实现它？</p>
<p>解析：设计的职责是美观，前端的职责是尽可能还原，设计之所以会使用非标准的字体、甚至侵权的字体是因为不了解技术实现和版权意识。<br>所以先 <strong>沟通</strong> ，告知设计实际的情况，然后在综合考量的情况下应该尽可能去实现，通常采用 <strong>载入字体</strong> 和 <strong>图片化</strong> 的方式。</p>
<p>3、【js】写个还剩下多少天过年的倒计时</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor((<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;2019-12-31&quot;</span>) - <span class="built_in">Date</span>.now()) / (<span class="number">10</span> ** <span class="number">5</span> * <span class="number">36</span> * <span class="number">24</span>));</span><br></pre></td></tr></table></figure>

<h3 id="第-50-天-2019-12-24"><a href="#第-50-天-2019-12-24" class="headerlink" title="第 50 天 (2019.12.24)"></a>第 50 天 (2019.12.24)</h3><ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/189">Ajax 与 Flash 的优缺点分别是什么？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/190">列举 CSS 优化、提高性能的方法</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/191">请写出一个函数求出 N 的阶乘（即 N!）</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/192">说说你对 http、https 的理解</a></li>
</ul>
<p>2、【css】 列举 CSS 优化、提高性能的方法</p>
<p>加载性能</p>
<ol>
<li>压缩 CSS</li>
<li>通过 link 方式加载，而不是<a href="https://github.com/import">@import</a></li>
<li>复合属性其实分开写，执行效率更高，因为 CSS 最终也还是要去解析如 <code>margin-left: left;</code></li>
</ol>
<p>选择器性能</p>
<ol>
<li>尽量少的使用嵌套，可以采用 BEM 的方式来解决命名冲突</li>
<li>尽量少甚至是不使用标签选择器，这个性能实在是差，同样的还有<code>*</code>选择器</li>
<li>利用继承，减少代码量</li>
</ol>
<p>渲染性能</p>
<ol>
<li>慎重使用高性能属性：浮动、定位；</li>
<li>尽量减少页面重排、重绘；</li>
<li>css 雪碧图</li>
<li>自定义 web 字体，尽量少用</li>
<li>尽量减少使用昂贵属性，如 box-shadow/border-radius/filter/透明度/:nth-child 等</li>
<li>使用<code>transform</code>来变换而不是宽高等会造成重绘的属性</li>
</ol>
<p>暂且先这样吧，看来想回答好，得好好梳理下了。</p>
]]></content>
      <categories>
        <category>牛人面试题</category>
        <category>前端面试每日三加一</category>
      </categories>
      <tags>
        <tag>牛人面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>木易杨每日一题</title>
    <url>/2019/09/20/muyiyang/</url>
    <content><![CDATA[<h2 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h2><blockquote>
<p>每天一道大厂前端面试题，一年后再回头，会感谢曾经努力的自己！</p>
<p>待更新状态</p>
<p>今天 2019/12/23 ~ 💪</p>
</blockquote>
<h3 id="第-1-题-（2019-9-19）"><a href="#第-1-题-（2019-9-19）" class="headerlink" title="第 1 题 （2019/9/19）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md#%E7%AC%AC-1-%E9%A2%98%E5%86%99-react--vue-%E9%A1%B9%E7%9B%AE%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8%E5%88%97%E8%A1%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%86%99-key%E5%85%B6%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">第 1 题</a> （2019/9/19）</h3><p><strong>题目</strong>：写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？</p>
<p><strong>公司</strong>：滴滴、饿了么</p>
<p><strong>需了解</strong> ：vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中。可以先了解一下 diff 算法。<br>在交叉对比的时候，当新节点跟旧节点<code>头尾交叉对比</code>没有结果的时候，会根据新节点的 key 去对比旧节点数组中的 key，从而找到相应旧节点（这里对应的是一个 key =&gt; index 的 map 映射）。如果没找到就认为是一个新增节点。而如果没有 key，那么就会采用一种遍历查找的方式去找到对应的旧节点。一种一个 map 映射，另一种是遍历查找。相比而言。map 映射的速度更快。</p>
<p><strong>答案</strong>：</p>
<blockquote>
<p>key 是给每一个 vnode 的唯一 id,可以<code>依靠key</code>,更<code>准确</code>, 更<code>快</code>的拿到 oldVnode 中对应的 vnode 节点。</p>
<p>key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。</p>
</blockquote>
<p>1、更准确</p>
<p>因为带 key 就不是<code>就地复用</code>了，在 sameNode 函数 <code>a.key === b.key</code>对比中可以避免就地复用的情况。所以会更加准确。</p>
<p>2、更快</p>
<p>利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快。(这个观点，就是我最初的那个观点。从这个角度看，map 会比遍历更快。)</p>
<h3 id="第-2-题（2019-9-20）"><a href="#第-2-题（2019-9-20）" class="headerlink" title="第 2 题（2019/9/20）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/4">第 2 题</a>（2019/9/20）</h3><p><strong>题目</strong>：<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code> what &amp; why ?</p>
<p><strong>答案</strong> ：第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是 **真正的答案是[1, NaN, NaN]**。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;12&quot;</span>)); <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;08&quot;</span>)); <span class="comment">//8</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;0x16&quot;</span>)); <span class="comment">//22</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;-12&quot;</span>)); <span class="comment">//-12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;   -12&quot;</span>)); <span class="comment">//-12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;   -  12&quot;</span>)); <span class="comment">///NAN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;124ref&quot;</span>)); <span class="comment">//124</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;ref&quot;</span>)); <span class="comment">//NAN</span></span><br></pre></td></tr></table></figure>

<p>以上几乎就是<code>parseInt</code>函数一个形式参数时的所有情况</p>
<p>radix 形参没指定的时候是<strong>10</strong>，其次他是具有有效范围滴：[2, 36]和特殊值 0<br>下面是英语渣渣的我翻译后，简化的<code>parseInt</code>执行步骤：（ECMAScript 原解析-&gt;<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-parseint-string-radix">传送门</a>）</p>
<ol>
<li>将第一个形参转换为字符串</li>
<li>识别 string 转换是否有<strong>code unit</strong>，如果有 -&gt; <code>-</code>标记为负数，<code>0x</code>或<code>0X</code>则把 radix 赋值为<strong>16</strong></li>
<li>radix 形参（int 类型）是否存在，存在则重新赋值（会对实参进行 Int32 转化，无法转换成 int 类型则不会重新赋值 radix）</li>
<li>radix 为 0，则设置 radix 为默认值 10</li>
<li>如果 radix 为 1，或者大于等于 37，parseInt 直接返回<strong>NaN</strong></li>
<li>如果 radix 为[2, 36]时则代表，string 参数分别是二进制，三进制（如果有得话~）…三十六进制类型</li>
<li>然后对 string 进行的 radix 进制 -&gt; 十进制转换</li>
</ol>
<p>以上就是<code>parseInt</code>转换时的步骤，那么我们来开始解释<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code><br><strong>at first, 答案是[1, NaN, NaN]</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>].map(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(value, index);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(ret);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>这是<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code>内部执行的剖析，<code>value</code>和<code>index</code>相信大家都懂，不懂请自行<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/map">MDN</a>,执行步骤为：<br><code>value=&#39;1&#39;,index=0</code> -&gt; <code>parseInt(value, index)</code><br><code>value=&#39;2&#39;,index=1</code> -&gt; <code>parseInt(value, index)</code><br><code>value=&#39;3&#39;,index=2</code> -&gt; <code>parseInt(value, index)</code><br>抽离出来，其实就是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;1&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;2&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;3&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><code>parseInt(&#39;3&#39;, 2)</code>这是根据二进制对字符串<code>3</code>进行十进制转换对吧！！！<br>exm???有毛病?没毛病，老铁，就是……你家二进制有<code>3</code>?二进制不就是<code>0</code>和<code>1</code>啊</p>
<p>因此返回<strong>NaN</strong>。</p>
<p>解决方案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnInt</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(element, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>].map(returnInt); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="comment">// Actual result is an array of numbers (as expected)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Same as above, but using the concise arrow function syntax</span></span><br><span class="line">[<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>].map(<span class="function">(<span class="params">str</span>) =&gt;</span> <span class="built_in">parseInt</span>(str));</span><br><span class="line"></span><br><span class="line"><span class="comment">// A simpler way to achieve the above, while avoiding the &quot;gotcha&quot;:</span></span><br><span class="line">[<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>].map(<span class="built_in">Number</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// But unlike parseInt(), Number() will also return a float or (resolved) exponential notation:</span></span><br><span class="line">[<span class="string">&quot;1.1&quot;</span>, <span class="string">&quot;2.2e2&quot;</span>, <span class="string">&quot;3e300&quot;</span>].map(<span class="built_in">Number</span>); <span class="comment">// [1.1, 220, 3e+300]</span></span><br><span class="line"><span class="comment">// For comparison, if we use parseInt() on the array above:</span></span><br><span class="line">[<span class="string">&quot;1.1&quot;</span>, <span class="string">&quot;2.2e2&quot;</span>, <span class="string">&quot;3e300&quot;</span>].map(<span class="function">(<span class="params">str</span>) =&gt;</span> <span class="built_in">parseInt</span>(str)); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="第-3-题（2019-9-21）"><a href="#第-3-题（2019-9-21）" class="headerlink" title="第 3 题（2019/9/21）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5">第 3 题</a>（2019/9/21）</h3><p><strong>题目</strong>：什么是防抖和节流？有什么区别？如何实现？</p>
<p><strong>公司</strong> ：挖财</p>
<p><strong>解析</strong> ：</p>
<p>1、<strong>防抖</strong></p>
<blockquote>
<p>触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间</p>
</blockquote>
<p>思路：</p>
<blockquote>
<p>每次触发事件时都取消之前的延时调用方法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>; <span class="comment">// 创建一个标记用来存放定时器的返回值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout); <span class="comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span></span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;防抖成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inp = <span class="built_in">document</span>.getElementById(<span class="string">&quot;inp&quot;</span>);</span><br><span class="line">inp.addEventListener(<span class="string">&quot;input&quot;</span>, debounce(sayHi, <span class="number">500</span>)); <span class="comment">// 防抖</span></span><br></pre></td></tr></table></figure>

<p>提出问题：请问，为什么要 fn.apply(this, arguments);而不是这样 fn()</p>
<p>解答：加上 apply 确保 在 sayHi 函数里的 this 指向的是 input 对象(不然就指向 window 了，不是我们想要的)。<br>这里的箭头函数依旧是指向 input 对象。</p>
<p><img src="http://static.zxinc520.com/blog/20190921/g4jPyh09vVh7.gif" alt="mark"></p>
<p>防抖应用场景：</p>
<ol>
<li>搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。</li>
<li>表单验证</li>
<li>按钮提交事件。</li>
<li>浏览器窗口缩放，resize 事件等。</li>
</ol>
<p>2、<strong>节流</strong></p>
<blockquote>
<p>高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率</p>
</blockquote>
<p>思路：</p>
<blockquote>
<p>每次触发事件时都判断当前是否有等待执行的延时函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span>; <span class="comment">// 通过闭包保存一个标记</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) <span class="keyword">return</span>; <span class="comment">// 在函数开头判断标记是否为true，不为true则return</span></span><br><span class="line">    canRun = <span class="literal">false</span>; <span class="comment">// 立即设置为false</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 将外部传入的函数的执行放在setTimeout中</span></span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      <span class="comment">// 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉</span></span><br><span class="line">      canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.innerWidth, e.target.innerHeight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, throttle(sayHi, <span class="number">500</span>));</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190921/nJbaVeD1wpaz.gif" alt="mark"></p>
<h3 id="第-4-题-2019-9-22"><a href="#第-4-题-2019-9-22" class="headerlink" title="第 4 题 (2019/9/22)"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md#%E7%AC%AC-4-%E9%A2%98%E4%BB%8B%E7%BB%8D%E4%B8%8B-setmapweakset-%E5%92%8C-weakmap-%E7%9A%84%E5%8C%BA%E5%88%AB">第 4 题</a> (2019/9/22)</h3><p><strong>题目</strong> ：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</p>
<p><strong>解析：</strong> <a href="https://muyiy.cn/question/js/4.html">木易杨前端进阶</a></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Set</span><br><span class="line">    成员唯一、无序且不重复</span><br><span class="line">    [value, value]，键值与键名是一致的（或者说只有键值，没有键名）</span><br><span class="line">    可以遍历，方法有：add、delete、has</span><br><span class="line"></span><br><span class="line">WeakSet</span><br><span class="line">    成员都是对象</span><br><span class="line">    成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏</span><br><span class="line">    不能遍历，方法有add、delete、has</span><br><span class="line"></span><br><span class="line">Map</span><br><span class="line">    本质上是键值对的集合，类似集合</span><br><span class="line">    可以遍历，方法很多可以跟各种数据格式转换</span><br><span class="line"></span><br><span class="line">WeakMap</span><br><span class="line">    只接受对象作为键名（null除外），不接受其他类型的值作为键名</span><br><span class="line">    键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的</span><br><span class="line">    不能遍历，方法有get、set、has、delete</span><br><span class="line"></span><br><span class="line"> Set与WeakSet区别:</span><br><span class="line">    1. WeakSet只能存放对象</span><br><span class="line">    2. WeakSet不支持遍历, 没有size熟悉</span><br><span class="line">    3. WeakSet存放的对象不会计入到对象的引用技术, 因此不会影响GC的回收</span><br><span class="line">    4. WeakSet存在的对象如果在外界消失了, 那么在WeakSet里面也会不存在</span><br><span class="line"></span><br><span class="line"> Map与WeakMap区别</span><br><span class="line"> 	1. WeakMap只能接受对象作为键名字(null除外)</span><br><span class="line">	2. WeakMap键名指向对象不会计入对象的引用数</span><br></pre></td></tr></table></figure>

<h3 id="第-5-题-2019-9-22"><a href="#第-5-题-2019-9-22" class="headerlink" title="第 5 题 (2019/9/22)"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/9">第 5 题</a> (2019/9/22)</h3><p><strong>题目：</strong> 介绍下深度优先遍历和广度优先遍历，如何实现？</p>
<p>解析： 我先学习一下啥是 深度优先 和 广度优先… 惭愧！！！</p>
<h3 id="第-6-题-（2019-9-23）"><a href="#第-6-题-（2019-9-23）" class="headerlink" title="第 6 题 （2019/9/23）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/10">第 6 题</a> （2019/9/23）</h3><p><strong>题目</strong> ：请分别用深度优先思想和广度优先思想实现一个拷贝函数？</p>
<blockquote>
<p>弄懂了 优先遍历和广度优先遍历 再来做</p>
</blockquote>
<h3 id="第-7-题-（2019-9-23）"><a href="#第-7-题-（2019-9-23）" class="headerlink" title="第 7 题 （2019/9/23）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20">第 7 题</a> （2019/9/23）</h3><p><strong>题目</strong> ：ES5/ES6 的继承除了写法以外还有什么区别？</p>
<p><strong>解析</strong> ： <a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20">更多</a></p>
<ol>
<li><code>class</code> 声明会提升，但不会初始化赋值。<code>Foo</code> 进入暂时性死区，类似于 <code>let</code>、<code>const</code> 声明变量。</li>
<li><code>class</code> 声明内部会启用严格模式。</li>
<li><code>class</code> 的所有方法（包括静态方法和实例方法）都是不可枚举的。</li>
<li><code>class</code> 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有<code>[[construct]]</code>，不能使用 <code>new</code> 来调用。</li>
<li>必须使用 <code>new</code> 调用 <code>class</code>。</li>
<li><code>class</code> 内部无法重写类名。</li>
</ol>
<h3 id="第-8-题（2019-9-24）"><a href="#第-8-题（2019-9-24）" class="headerlink" title="第 8 题（2019/9/24）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/33">第 8 题</a>（2019/9/24）</h3><p><strong>题目：</strong> setTimeout、Promise、Async/Await 的区别 ？</p>
<p><strong>知识点</strong> ：这里涉及到<code>Microtasks</code>、<code>Macrotasks</code>、event loop 以及 JS 的异步运行机制。<a href="https://github.com/sisterAn/blog/issues/21">可参考</a></p>
<p><strong>解析</strong> ：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">我觉得这题主要是考察这三者在事件循环中的区别，事件循环中分为宏任务队列和微任务队列。</span><br><span class="line">其中 setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；</span><br><span class="line">promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。</span><br></pre></td></tr></table></figure>

<p><strong>1、setTimeout</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>); <span class="comment">//1. 打印 script start</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;settimeout&quot;</span>); <span class="comment">// 4. 打印 settimeout</span></span><br><span class="line">&#125;); <span class="comment">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>); <span class="comment">//3. 打印 script start</span></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;script end-&gt;settimeout</span></span><br></pre></td></tr></table></figure>

<p><strong>2、 Promise</strong></p>
<p>Promise 本身是<strong>同步的立即执行函数</strong>， 当在 executor 中执行 resolve 或者 reject 的时候, 此时是异步操作， 会先执行 then/catch 等，当主栈完成后，才会去调用 resolve/reject 中存放的方法执行，打印 p 的时候，是打印的返回结果，一个 Promise 实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1 end&quot;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;settimeout&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"><span class="comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span></span><br></pre></td></tr></table></figure>

<p>当 JS 主线程执行到 Promise 对象时，</p>
<ul>
<li>promise1.then() 的回调就是一个 task</li>
<li>promise1 是 resolved 或 rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li>
<li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li>
<li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li>
</ul>
<p><strong>3. async/await</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br></pre></td></tr></table></figure>

<p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(func1());</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190924/M0YN5oCKtEhr.png?imageslim" alt="mark"></p>
<p>很显然，func1 的运行结果其实就是一个 Promise 对象。因此我们也可以使用 then 来处理后续逻辑。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func1().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);  <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>await 的含义为等待，也就是 async 函数需要等待 await 后的函数执行完成并且有了返回结果（Promise 对象）之后，才能继续执行下面的代码。await 通过返回一个 Promise 对象来实现同步的效果。</p>
<blockquote>
<p>更多可见 <a href="https://github.com/sisterAn/blog/issues/21">setTimeout、Promise、Async/Await</a></p>
</blockquote>
<h3 id="第-9-题（2019-9-25）"><a href="#第-9-题（2019-9-25）" class="headerlink" title="第 9 题（2019/9/25）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/33">第 9 题</a>（2019/9/25）</h3><p><strong>题目</strong> ： Async/Await 如何通过同步的方式实现异步？</p>
<p><strong>公司</strong> ：头条、微医</p>
<p><strong>解析</strong> ： [Async/Await 如何通过同步的方式实现异步](Async/Await 如何通过同步的方式实现异步)</p>
<p>首先，<code>async/await</code> 是 <code>Generator</code> 的语法糖</p>
<p>先来看一下二者的对比：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Generator</span></span><br><span class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res1 = <span class="keyword">yield</span> readFile(path.resolve(__dirname, <span class="string">&#x27;../data/a.json&#x27;</span>), &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">yield</span> readFile(path.resolve(__dirname, <span class="string">&#x27;../data/b.json&#x27;</span>), &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// async/await</span></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> res1 = <span class="keyword">await</span> readFile(path.resolve(__dirname, <span class="string">&#x27;../data/a.json&#x27;</span>), &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> readFile(path.resolve(__dirname, <span class="string">&#x27;../data/b.json&#x27;</span>), &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = readFile();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，<code>async function</code> 代替了 <code>function*</code>，<code>await</code> 代替了 <code>yield</code>，同时也无需自己手写一个自动执行器 <code>run</code> 了</p>
<p>现在再来看看<code>async/await</code> 的特点：</p>
<ul>
<li>当 <code>await</code> 后面跟的是 Promise 对象时，才会异步执行，其它类型的数据会同步执行</li>
<li>执行 <code>const res = readFile();</code> 返回的仍然是个 Promise 对象，上面代码中的 <code>return &#39;done&#39;;</code> 会直接被下面 <code>then</code> 函数接收到</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// done</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-10-题（2019-9-26）"><a href="#第-10-题（2019-9-26）" class="headerlink" title="第 10 题（2019/9/26）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7">第 10 题</a>（2019/9/26）</h3><p><strong>题目类型</strong> ：异步笔试题</p>
<p><strong>公司</strong> ：头条</p>
<blockquote>
<p>请写出下面代码的运行结果</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    script start</span></span><br><span class="line"><span class="comment">    async1 start</span></span><br><span class="line"><span class="comment">    async2</span></span><br><span class="line"><span class="comment">    promise1</span></span><br><span class="line"><span class="comment">    script end</span></span><br><span class="line"><span class="comment">    async1 end</span></span><br><span class="line"><span class="comment">    promise2</span></span><br><span class="line"><span class="comment">    setTimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="第-11-题-（2019-9-26）"><a href="#第-11-题-（2019-9-26）" class="headerlink" title="第 11 题 （2019/9/26）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/8">第 11 题</a> （2019/9/26）</h3><p><strong>公司</strong> ：携程</p>
<blockquote>
<p>已知如下数组：</p>
<p>var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];</p>
<p>编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.flat(<span class="literal">Infinity</span>))).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;); <span class="comment">//使用 flat</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.toString().split(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">  .sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;)</span><br><span class="line">  .map(<span class="built_in">Number</span>); <span class="comment">//利用 toString()</span></span><br></pre></td></tr></table></figure>

<h3 id="第-12-题-（2019-9-27）"><a href="#第-12-题-（2019-9-27）" class="headerlink" title="第 12 题 （2019/9/27）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/11">第 12 题</a> （2019/9/27）</h3><p><strong>题目：</strong> JS 异步解决方案的发展历程以及优缺点。</p>
<p><strong>公司</strong> ：滴滴、挖财、微医、海康</p>
<p><strong>解析：</strong></p>
<ol>
<li><strong>回调函数（callback）</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// callback 函数体</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：回调地狱，不能用 try catch 捕获错误，不能 return</p>
<p>回调地狱的根本问题在于：</p>
<ul>
<li>缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符</li>
<li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（<strong>控制反转</strong>）</li>
<li>嵌套函数过多的多话，很难处理错误</li>
</ul>
<p><strong>优点</strong> ：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）</p>
<ol start="2">
<li><strong>Promise</strong></li>
</ol>
<p>Promise 就是为了解决 callback 的问题而产生的。</p>
<p>Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装</p>
<p><strong>优点</strong> ：解决了回调地狱的问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax(<span class="string">&quot;XXX1&quot;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 操作逻辑</span></span><br><span class="line">    <span class="keyword">return</span> ajax(<span class="string">&quot;XXX2&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 操作逻辑</span></span><br><span class="line">    <span class="keyword">return</span> ajax(<span class="string">&quot;XXX3&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 操作逻辑</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong> ：无法取消 Promise ，错误需要通过回调函数来捕获</p>
<ol start="3">
<li><strong>Generato</strong></li>
</ol>
<p><strong>特点</strong> ：可以控制函数的执行，可以配合 co 函数库使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> ajax(<span class="string">&quot;XXX1&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">  <span class="keyword">yield</span> ajax(<span class="string">&quot;XXX2&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">  <span class="keyword">yield</span> ajax(<span class="string">&quot;XXX3&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = fetch();</span><br><span class="line"><span class="keyword">let</span> result1 = it.next();</span><br><span class="line"><span class="keyword">let</span> result2 = it.next();</span><br><span class="line"><span class="keyword">let</span> result3 = it.next();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>Async/await</strong></li>
</ol>
<p>async、await 是异步的终极解决方案</p>
<p><strong>优点</strong>：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题</p>
<p><strong>缺点</strong>：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式</span></span><br><span class="line">  <span class="comment">// 如果有依赖性的话，其实就是解决回调地狱的例子了</span></span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">&quot;XXX1&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">&quot;XXX2&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">&quot;XXX3&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来看一个使用 <code>await</code> 的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + (<span class="keyword">await</span> <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>, a); <span class="comment">// -&gt; &#x27;2&#x27; 10</span></span><br><span class="line">&#125;;</span><br><span class="line">b();</span><br><span class="line">a++;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>, a); <span class="comment">// -&gt; &#x27;1&#x27; 1</span></span><br></pre></td></tr></table></figure>

<p>对于以上代码你可能会有疑惑，让我来解释下原因</p>
<ul>
<li>首先函数 <code>b</code> 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 0，因为 <code>await</code> 内部实现了 <code>generator</code> ，<strong>generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来</strong></li>
<li>因为 <code>await</code> 是异步操作，后来的表达式不返回 <code>Promise</code> 的话，就会包装成 <code>Promise.reslove(返回值)</code>，然后会去执行函数外的同步代码</li>
<li>同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 0 + 10</code></li>
</ul>
<p>上述解释中提到了 <code>await</code> 内部实现了 <code>generator</code>，其实 <code>await</code> 就是 <code>generator</code> 加上 <code>Promise</code>的语法糖，且内部实现了自动执行 <code>generator</code>。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。</p>
<h3 id="第-13-题-（2019-9-28）"><a href="#第-13-题-（2019-9-28）" class="headerlink" title="第 13 题 （2019/9/28）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/19">第 13 题</a> （2019/9/28）</h3><p><strong>题目</strong> ：Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？</p>
<p><strong>公司</strong> ：微医</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">看过 Event Loop 基础原理的就明白，Promise构造函数是同步执行，而 .then .catch .啥啥的是异步（还有process.nextTick等等，大家可以查），</span><br><span class="line">而且放到了微队列中，async/await 中，await 前面的是同步，await 后面的是异步，写法上是这样，但是其实是 语法糖，最后还会转为 Promise.then的形式</span><br><span class="line"></span><br><span class="line">.then()当然是同步执行，只不过是.then的cb被放入了微任务队列，产生了异步执行</span><br><span class="line"></span><br><span class="line">promise是微观任务，setTimeout是宏观任务，先执行微观任务，在执行宏观任务；微观任务里，先执行同步再执行异步</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-14-题-（2019-9-29）"><a href="#第-14-题-（2019-9-29）" class="headerlink" title="第 14 题 （2019/9/29）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/12">第 14 题</a> （2019/9/29）</h3><p><strong>题目</strong> ：情人节福利题，如何实现一个 new ？</p>
<p><strong>公司</strong>：兑吧</p>
<p><strong>解析</strong> ： <a href="https://alexzhong22c.github.io/2017/08/12/js-new-happen/#%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%BB%93%E6%9E%9C%E8%A7%A3%E6%9E%90">new 创建对象的过程发生了什么</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new 的作用</span></span><br><span class="line"><span class="comment">// 创建一个新对象obj</span></span><br><span class="line"><span class="comment">// 把obj的__proto__指向Dog.prototype 实现继承</span></span><br><span class="line"><span class="comment">// 执行构造函数，传递参数，改变this指向 Dog.call(obj, ...args)</span></span><br><span class="line"><span class="comment">// 最后把obj赋值给sanmao</span></span><br><span class="line"><span class="keyword">var</span> _new = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">constructor</span> = Array.prototype.shift.call(arguments);</span><br><span class="line">  let args = arguments;</span><br><span class="line">  const obj = new Object();</span><br><span class="line">  obj.__proto__ = <span class="keyword">constructor</span>.prototype;</span><br><span class="line">  <span class="keyword">constructor</span>.call(obj, ...args);</span><br><span class="line">  return obj;</span><br><span class="line">&#125;;</span><br><span class="line">var simao = _new(Dog, &quot;simao&quot;);</span><br><span class="line">simao.bark();</span><br><span class="line">simao.sayName();</span><br><span class="line">console.log(simao instanceof Dog); // true</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样写是不是简单点啊</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">fn, ...arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">  <span class="keyword">const</span> ret = fn.apply(obj, arg);</span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-15-题-（2019-9-30）"><a href="#第-15-题-（2019-9-30）" class="headerlink" title="第 15 题 （2019/9/30）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/14">第 15 题</a> （2019/9/30）</h3><p><strong>题目</strong> ：简单讲解一下 http2 的多路复用</p>
<p><strong>公司</strong>：网易</p>
<p><strong>解析</strong> ：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">在 HTTP/1 中，每次请求都会建立一次HTTP连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：</span><br><span class="line"></span><br><span class="line">    第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）</span><br><span class="line"></span><br><span class="line">    第二个：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。</span><br><span class="line"></span><br><span class="line">HTTP/2的多路复用就是为了解决上述的两个性能问题。</span><br><span class="line">在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。</span><br><span class="line">帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</span><br><span class="line">多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-16-题-（2019-10-01）"><a href="#第-16-题-（2019-10-01）" class="headerlink" title="第 16 题 （2019/10/01）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/15">第 16 题</a> （2019/10/01）</h3><p><strong>题目</strong> ：谈谈你对 TCP 三次握手和四次挥手的理解</p>
<p><strong>解析</strong> ：<a href="https://juejin.im/post/5ccd0dfc6fb9a0324a08bb73">关于三次握手与四次挥手面试官想考我们什么？— 不看后悔系列</a></p>
<p>三次握手：</p>
<ol>
<li>第一次握手：客户端给服务器发送一个 SYN 报文。</li>
<li>第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。</li>
<li>第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。</li>
<li>服务器收到 ACK 报文之后，三次握手建立完成。</li>
</ol>
<blockquote>
<p><strong>这里我顺便解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以</strong>：<br>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。<br>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>
</blockquote>
<p>四次挥手:</p>
<ol>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于<strong>FIN_WAIT1</strong>状态。</li>
<li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <strong>CLOSE_WAIT</strong>状态。</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <strong>LAST_ACK</strong> 的状态。</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 <strong>TIME_WAIT</strong> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li>
<li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li>
</ol>
<p>这里特别需要主要的就是<strong>TIME_WAIT</strong>这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p>
<p>至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p>
<h3 id="第-17-题-（2019-10-08）"><a href="#第-17-题-（2019-10-08）" class="headerlink" title="第 17 题 （2019/10/08）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/21">第 17 题</a> （2019/10/08）</h3><p><strong>题目</strong> ： A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态 ？</p>
<blockquote>
<p>如果 A 与 B 建立了正常连接后，从未相互发过数据，这个时候 B 突然机器重启，问 A 此时处于 TCP 什么状态？如何消除服务器程序中的这个状态？（超纲题，了解即可）</p>
</blockquote>
<h3 id="第-18-题-（2019-10-08）"><a href="#第-18-题-（2019-10-08）" class="headerlink" title="第 18 题 （2019/10/08）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/17">第 18 题</a> （2019/10/08）</h3><p><strong>题目</strong> ：React 中 setState 什么时候是同步的，什么时候是异步的？</p>
<p><strong>公司</strong> ：微医 <a href="https://juejin.im/post/5ac1aaad6fb9a028d444bb87">React 中 setState 真的是异步的吗</a></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1.在组件生命周期中或者react事件绑定中，setState是通过异步更新的。</span><br><span class="line">2.在延时的回调或者原生事件绑定的回调中调用setState不一定是异步的。</span><br><span class="line">这个结果并不说明setState异步执行的说法是错误的，更加准确的说法应该是setState不能保证同步执行。</span><br><span class="line">Dan Abramov也多次提到今后会将setState彻底改造为异步的，从js conf中提到的suspend新特新也印证了这一点。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">这里所说的同步异步，并非真正的同步异步，通常是同步执行的。</span><br><span class="line">这里的异步指的是多个状态会合成到一起进行批量更新。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-19-题-（2019-10-08）"><a href="#第-19-题-（2019-10-08）" class="headerlink" title="第 19 题  （2019/10/08）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/18">第 19 题 </a> （2019/10/08）</h3><p><strong>题目</strong> ：React setState 笔试题，下面的代码输出什么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      val: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">val</span>: <span class="built_in">this</span>.state.val + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.val); <span class="comment">// 第 1 次 log</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">val</span>: <span class="built_in">this</span>.state.val + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.val); <span class="comment">// 第 2 次 log</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123; <span class="attr">val</span>: <span class="built_in">this</span>.state.val + <span class="number">1</span> &#125;);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.val); <span class="comment">// 第 3 次 log</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.setState(&#123; <span class="attr">val</span>: <span class="built_in">this</span>.state.val + <span class="number">1</span> &#125;);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.val); <span class="comment">// 第 4 次 log</span></span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、第一次和第二次都是在 react 自身生命周期内，触发时 isBatchingUpdates 为 <span class="literal">true</span>，所以并不会直接执行更新 state，而是加入了 dirtyComponents，所以打印时获取的都是更新前的状态 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、两次 setState 时，获取到 <span class="built_in">this</span>.state.val 都是 <span class="number">0</span>，所以执行时都是将 <span class="number">0</span> 设置成 <span class="number">1</span>，在 react 内部会被合并掉，只执行一次。设置完成后 state.val 值为 <span class="number">1</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、<span class="built_in">setTimeout</span> 中的代码，触发时 isBatchingUpdates 为 <span class="literal">false</span>，所以能够直接进行更新，所以连着输出 <span class="number">2</span>，<span class="number">3</span>。</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出： 0 0 2 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-20-题-（2019-10-09）"><a href="#第-20-题-（2019-10-09）" class="headerlink" title="第 20 题  （2019/10/09）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/22">第 20 题 </a> （2019/10/09）</h3><p><strong>题目</strong> ：介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？</p>
<p><strong>解析</strong> ：</p>
<p><strong>1、npm 模块安装机制：</strong></p>
<ul>
<li>发出<code>npm install</code>命令</li>
<li>查询 node_modules 目录之中是否已经存在指定模块<ul>
<li>若存在，不再重新安装</li>
<li>若不存在<ul>
<li>npm 向 registry 查询模块压缩包的网址</li>
<li>下载压缩包，存放在根目录下的<code>.npm</code>目录里</li>
<li>解压压缩包到当前项目的<code>node_modules</code>目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>2、npm 实现原理</strong></p>
<p>输入 npm install 命令并敲下回车后，会经历如下几个阶段（以 npm 5.5.1 为例）：</p>
<ol>
<li><strong>执行工程自身 preinstall</strong></li>
</ol>
<p>当前 npm 工程如果定义了 preinstall 钩子此时会被执行。</p>
<ol start="2">
<li><strong>确定首层依赖模块</strong></li>
</ol>
<p>首先需要做的是确定工程中的首层依赖，也就是 dependencies 和 devDependencies 属性中直接指定的模块（假设此时没有添加 npm install 参数）。</p>
<p>工程本身是整棵依赖树的根节点，每个首层依赖模块都是根节点下面的一棵子树，npm 会开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点。</p>
<ol start="3">
<li><strong>获取模块</strong></li>
</ol>
<p>获取模块是一个递归的过程，分为以下几步：</p>
<ul>
<li>获取模块信息。在下载一个模块之前，首先要确定其版本，这是因为 package.json 中往往是 semantic version（semver，语义化版本）。此时如果版本描述文件（npm-shrinkwrap.json 或 package-lock.json）中有该模块信息直接拿即可，如果没有则从仓库获取。如 packaeg.json 中某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。</li>
<li>获取模块实体。上一步会获取到模块的压缩包地址（resolved 字段），npm 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。</li>
<li>查找该模块依赖，如果有依赖则回到第 1 步，如果没有则停止。</li>
</ul>
<ol start="4">
<li><strong>模块扁平化（dedupe）</strong></li>
</ol>
<p>上一步获取到的是一棵完整的依赖树，其中可能包含大量重复模块。比如 A 模块依赖于 loadsh，B 模块同样依赖于 lodash。在 npm3 以前会严格按照依赖树的结构进行安装，因此会造成模块冗余。</p>
<p>从 npm3 开始默认加入了一个 dedupe 的过程。它会遍历所有节点，逐个将模块放在根节点下面，也就是 node-modules 的第一层。当发现有<strong>重复模块</strong>时，则将其丢弃。</p>
<p>这里需要对<strong>重复模块</strong>进行一个定义，它指的是<strong>模块名相同</strong>且 <strong>semver 兼容。每个 semver 都对应一段版本允许范围，如果两个模块的版本允许范围存在交集，那么就可以得到一个兼容</strong>版本，而不必版本号完全一致，这可以使更多冗余模块在 dedupe 过程中被去掉。</p>
<p>比如 node-modules 下 foo 模块依赖 lodash@^1.0.0，bar 模块依赖 lodash@^1.1.0，则 <strong>^1.1.0</strong> 为兼容版本。</p>
<p>而当 foo 依赖 lodash@^2.0.0，bar 依赖 lodash@^1.1.0，则依据 semver 的规则，二者不存在兼容版本。会将一个版本放在 node_modules 中，另一个仍保留在依赖树里。</p>
<p>举个例子，假设一个依赖树原本是这样：</p>
<p>node_modules<br>– foo<br>—- lodash@version1</p>
<p>– bar<br>—- lodash@version2</p>
<p>假设 version1 和 version2 是兼容版本，则经过 dedupe 会成为下面的形式：</p>
<p>node_modules<br>– foo</p>
<p>– bar</p>
<p>– lodash（保留的版本为兼容版本）</p>
<p>假设 version1 和 version2 为非兼容版本，则后面的版本保留在依赖树中：</p>
<p>node_modules<br>– foo<br>– lodash@version1</p>
<p>– bar<br>—- lodash@version2</p>
<ol start="5">
<li><strong>安装模块</strong></li>
</ol>
<p>这一步将会更新工程中的 node_modules，并执行模块中的生命周期函数（按照 preinstall、install、postinstall 的顺序）。</p>
<ol start="6">
<li><strong>执行工程自身生命周期</strong></li>
</ol>
<p>当前 npm 工程如果定义了钩子此时会被执行（按照 install、postinstall、prepublish、prepare 的顺序）。</p>
<p>最后一步是生成或更新版本描述文件，npm install 过程完成。</p>
<p>参考 <a href="http://www.ruanyifeng.com/blog/2016/01/npm-install.html">npm 模块安装机制简介</a></p>
<p><a href="https://www.bbsmax.com/A/qVdemmnEdP/">详解 npm 的模块安装机制</a></p>
<p><a href="https://www.zhihu.com/question/66629910">npm install 的实现原理</a></p>
<h3 id="第-21-题-（2019-10-10）"><a href="#第-21-题-（2019-10-10）" class="headerlink" title="第 21 题 （2019/10/10）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/23">第 21 题</a> （2019/10/10）</h3><p><strong>题目：</strong> 有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣</p>
<blockquote>
<p>Object.prototype.toString.call() 、 instanceof 以及 Array.isArray()</p>
</blockquote>
<p><strong>解析：</strong></p>
<p><strong>1、Object.prototype.toString.call()</strong></p>
<p>每一个继承 Object 的对象都有 <code>toString</code> 方法，如果 <code>toString</code> 方法没有重写的话，会返回 <code>[Object type]</code>，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 <code>toString</code> 方法时，会直接返回都是内容的字符串，所以我们需要使用 call 或者 apply 方法来改变 toString 方法的执行上下文。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> an = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;An&quot;</span>];</span><br><span class="line">an.toString(); <span class="comment">// &quot;Hello,An&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(an); <span class="comment">// &quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure>

<p>这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&quot;An&quot;</span>); <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>); <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>(<span class="number">1</span>)); <span class="comment">// &quot;[object Symbol]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>); <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;); <span class="comment">// &quot;[object Function]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123; <span class="attr">name</span>: <span class="string">&quot;An&quot;</span> &#125;); <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Object.prototype.toString.call()</code> 常用于判断浏览器内置对象时。</p>
<p>更多实现可见 <a href="https://juejin.im/post/591647550ce4630069df1c4a">谈谈 Object.prototype.toString</a></p>
<p><strong>2、instanceof</strong></p>
<p><code>instanceof</code> 的内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code>。</p>
<p>使用 <code>instanceof</code>判断一个对象是否为数组，<code>instanceof</code> 会判断这个对象的原型链上是否会找到对应的 <code>Array</code> 的原型，找到返回 <code>true</code>，否则返回 <code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但 <code>instanceof</code> 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>3、Array.isArray()</strong></p>
<ul>
<li><p>功能：用来判断对象是否为数组</p>
</li>
<li><p>instanceof 与 isArray</p>
<p>当检测 Array 实例时，<code>Array.isArray</code> 优于 <code>instanceof</code> ，因为 <code>Array.isArray</code> 可以检测出 <code>iframes</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">xArray = <span class="built_in">window</span>.frames[<span class="built_in">window</span>.frames.length - <span class="number">1</span>].Array;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> xArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Correctly checking for Array</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Considered harmful, because doesn&#x27;t work though iframes</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.isArray()</code> 与 <code>Object.prototype.toString.call()</code></p>
<p><code>Array.isArray()</code>是 ES5 新增的方法，当不存在 <code>Array.isArray()</code> ，可以用 <code>Object.prototype.toString.call()</code> 实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!Array.isArray) &#123;</span><br><span class="line">  Array.isArray &#x3D; function(arg) &#123;</span><br><span class="line">    return Object.prototype.toString.call(arg) &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="第-22-题-（2019-10-11）"><a href="#第-22-题-（2019-10-11）" class="headerlink" title="第 22 题 （2019/10/11）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24">第 22 题</a> （2019/10/11）</h3><p><strong>题目：</strong> 介绍下重绘和回流（Repaint &amp; Reflow），以及如何进行优化？</p>
<p><strong>解析：</strong> <a href="https://juejin.im/post/5a9923e9518825558251c96a">浏览器的回流与重绘 (Reflow &amp; Repaint)</a></p>
<p><strong>1、浏览器渲染机制</strong></p>
<ul>
<li>浏览器采用流式布局模型（<code>Flow Based Layout</code>）</li>
<li>浏览器会把<code>HTML</code>解析成<code>DOM</code>，把<code>CSS</code>解析成<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并就产生了渲染树（<code>Render Tree</code>）。</li>
<li>有了<code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</li>
<li>由于浏览器使用流式布局，对<code>Render Tree</code>的计算通常只需要遍历一次就可以完成，<strong>但 table 及其内部元素除外，他们可能需要多次计算，通常要花 3 倍于同等元素的时间，这也是为什么要避免使用 table 布局的原因之一</strong>。</li>
</ul>
<p><strong>2、重绘</strong></p>
<p>由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如<code>outline</code>, <code>visibility</code>, <code>color</code>、<code>background-color</code>等，重绘的代价是高昂的，因为浏览器必须验证 DOM 树上其他节点元素的可见性。</p>
<p><strong>3、回流</strong></p>
<p>回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及 DOM 中紧随其后的节点、祖先节点元素的随后的回流。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;error&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>我的组件<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>错误：<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>错误的描述…<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>错误纠正<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一步<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二步<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的 HTML 片段中，对该段落(<code>&lt;p&gt;</code>标签)回流将会引发强烈的回流，因为它是一个子节点。这也导致了祖先的回流（<code>div.error</code>和<code>body</code> – 视浏览器而定）。此外，<code>&lt;h5&gt;</code>和<code>&lt;ol&gt;</code>也会有简单的回流，因为其在 DOM 中在回流元素之后。<strong>大部分的回流将导致页面的重新渲染。</strong></p>
<p><strong>回流必定会发生重绘，重绘不一定会引发回流。</strong></p>
<p><strong>4、浏览器优化</strong></p>
<p>现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即 16.6ms）才会清空队列，但当你<strong>获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值</strong>。</p>
<p>主要包括以下属性或方法：</p>
<ul>
<li><code>offsetTop</code>、<code>offsetLeft</code>、<code>offsetWidth</code>、<code>offsetHeight</code></li>
<li><code>scrollTop</code>、<code>scrollLeft</code>、<code>scrollWidth</code>、<code>scrollHeight</code></li>
<li><code>clientTop</code>、<code>clientLeft</code>、<code>clientWidth</code>、<code>clientHeight</code></li>
<li><code>width</code>、<code>height</code></li>
<li><code>getComputedStyle()</code></li>
<li><code>getBoundingClientRect()</code></li>
</ul>
<p>所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列<strong>。</strong></p>
<p><strong>5、减少重绘与回流</strong></p>
<ol>
<li><p>CSS</p>
<ul>
<li><p><strong>使用 transform 替代 top</strong></p>
</li>
<li><p><strong>使用 visibility 替换 display: none</strong> ，因为前者只会引起重绘，后者会引发回流（改变了布局</p>
</li>
<li><p><strong>避免使用 table 布局</strong>，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局。</p>
</li>
<li><p><strong>尽可能在 DOM 树的最末端改变 class</strong>，回流是不可避免的，但可以减少其影响。尽可能在 DOM 树的最末端改变 class，可以限制了回流的范围，使其影响尽可能少的节点。</p>
</li>
<li><p><strong>避免设置多层内联样式</strong>，CSS 选择符<strong>从右往左</strong>匹配查找，避免节点层级过多。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  span &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">  div &gt; a &gt; span &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 <code>span</code> 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 <code>span</code> 标签，然后找到 <code>span</code> 标签上的 <code>a</code> 标签，最后再去找到 <code>div</code> 标签，然后给符合这种条件的 <code>span</code> 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写<strong>过于具体</strong>的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证<strong>层级扁平</strong>。</p>
</li>
<li><p><strong>将动画效果应用到 position 属性为 absolute 或 fixed 的元素上</strong>，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 <code>requestAnimationFrame</code>，详见<a href="https://github.com/LuNaHaiJiao/blog/issues/30">探讨 requestAnimationFrame</a>。</p>
</li>
<li><p><strong>避免使用 CSS 表达式</strong>，可能会引发回流。</p>
</li>
<li><p><strong>将频繁重绘或者回流的节点设置为图层</strong>，图层能够阻止该节点的渲染行为影响别的节点，例如<code>will-change</code>、<code>video</code>、<code>iframe</code>等标签，浏览器会自动将该节点变为图层。</p>
</li>
<li><p><strong>CSS3 硬件加速（GPU 加速）</strong>，使用 css3 硬件加速，可以让<code>transform</code>、<code>opacity</code>、<code>filters</code>这些动画不会引起回流重绘 。但是对于动画的其它属性，比如<code>background-color</code>这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</p>
</li>
</ul>
</li>
<li><p>JavaScript</p>
<ul>
<li><strong>避免频繁操作样式</strong>，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li>
<li><strong>避免频繁操作 DOM</strong>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM操作</code>，最后再把它添加到文档中。</li>
<li><strong>避免频繁读取会引发回流/重绘的属性</strong>，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li><strong>对具有复杂动画的元素使用绝对定位</strong>，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
</li>
</ol>
<p>详见<a href="https://github.com/sisterAn/blog/issues/33">浏览器的重绘与回流（Repaint、Reflow）</a></p>
<h3 id="第-23-题-（2019-10-12）"><a href="#第-23-题-（2019-10-12）" class="headerlink" title="第 23 题 （2019/10/12）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/25">第 23 题 </a>（2019/10/12）</h3><p><strong>题目：</strong> 介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景</p>
<p><strong>解析：</strong></p>
<p>我们先来看下这两个模式的实现结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20190329182209470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmODcyOTE0MzM0,size_16,color_FFFFFF,t_70"></p>
<p>观察者模式： 观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。</p>
<p>发布订阅模式： 订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Topic），当发布者（Publisher）发布该事件（Publish topic）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。</p>
<p><strong>区别：</strong></p>
<p>观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心。</p>
<p>观察者模式由具体目标调度，每个被订阅的目标里面都需要有对观察者的处理，这种处理方式比较直接粗暴，但是会造成代码的冗余。</p>
<p>而发布订阅模式中统一由调度中心进行处理，订阅者和发布者互不干扰，消除了发布者和订阅者之间的依赖。这样一方面实现了解耦，还有就是可以实现更细粒度的一些控制。比如发布者发布了很多消息，但是不想所有的订阅者都接收到，就可以在调度中心做一些处理，类似于权限控制之类的。还可以做一些节流操作。</p>
<p><strong>观察者模式是不是发布订阅模式</strong></p>
<p>网上关于这个问题的回答，出现了两极分化，有认为发布订阅模式就是观察者模式的，也有认为观察者模式和发布订阅模式是真不一样的。</p>
<p>其实我不知道发布订阅模式是不是观察者模式，就像我不知道辨别模式的关键是设计意图还是设计结构（理念），虽然《JavaScript 设计模式与开发实践》一书中说了分辨模式的关键是意图而不是结构。</p>
<p>如果以结构来分辨模式，发布订阅模式相比观察者模式多了一个中间件订阅器，所以发布订阅模式是不同于观察者模式的；如果以意图来分辨模式，他们都是实现了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新，那么他们就是同一种模式，发布订阅模式是在观察者模式的基础上做的优化升级。</p>
<p>不过，不管他们是不是同一个设计模式，他们的实现方式确实有差别，我们在使用的时候应该根据场景来判断选择哪个。</p>
<h3 id="第-24-题-（2019-10-13）"><a href="#第-24-题-（2019-10-13）" class="headerlink" title="第 24 题 （2019/10/13）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/45">第 24 题</a> （2019/10/13）</h3><p><strong>题目：</strong> 聊聊 Redux 和 Vuex 的设计思想</p>
<p><strong>解析：</strong> <a href="https://juejin.im/post/5b6d75dce51d4533d20487b0">关于 Flux,Vuex,Redux 的思考</a> <a href="http://www.ruanyifeng.com/blog/2016/01/flux.html">Flux 架构入门教程</a></p>
<p>Flux 是一种前端状态管理架构思想，专门解决软件的结构问题。<br>基于 Flux 的设计思想，出现了一批前端状态管理框架。<br>他们给出了一些库用于实现 Flux 的思想，并在 Flux 的基础上做了一些改进。<br>在这些框架里，当前最热门的莫过于 Redux 和 Vuex 了</p>
<p><strong>Flux</strong></p>
<p>Flux 数据流的顺序是:</p>
<p>View 发起 Action-&gt;Action 传递到 Dispatcher-&gt;Dispatcher 将通知 Store-&gt;Store 的状态改变通知 View 进行改变</p>
<p><strong>Redux</strong></p>
<p>Redux 相对于 Flux 的改进：</p>
<ul>
<li>把 store 和 Dispatcher 合并,结构更加简单清晰</li>
<li>新增 state 角色，代表每个时间点 store 对应的值，对状态的管理更加明确</li>
</ul>
<p>Redux 数据流的顺序是:</p>
<p>View 调用 store.dispatch 发起 Action-&gt;store 接受 Action(action 传入 reducer 函数,reducer 函数返回一个新的 state)-&gt;通知 store.subscribe 订阅的重新渲染函数</p>
<p>ps:<a href="https://link.juejin.im/?target=https://github.com/reactjs/redux/tree/master/examples/counter">阮一峰老师的 Redux+React 小 demo</a></p>
<p><strong>Vuex</strong></p>
<p>Vuex 是专门为 Vue 设计的状态管理框架,<br>同样基于 Flux 架构，并吸收了 Redux 的优点</p>
<p>Vuex 相对于 Redux 的不同点有:</p>
<ul>
<li>改进了 Redux 中的 Action 和 Reducer 函数，以 mutations 变化函数取代 Reducer，<br>无需 switch,只需在对应的 mutation 函数里改变 state 值即可</li>
<li>由于 Vue 自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的 State 即可</li>
</ul>
<p>Vuex 数据流的顺序是:</p>
<p>View 调用 store.commit 提交对应的请求到 Store 中对应的 mutation 函数-&gt;store 改变(vue 检测到数据变化自动渲染)</p>
<h3 id="第-25-题-（2019-10-14）"><a href="#第-25-题-（2019-10-14）" class="headerlink" title="第 25 题 （2019/10/14）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/26">第 25 题</a> （2019/10/14）</h3><p><strong>题目：</strong> 说说浏览器和 Node 事件循环的区别</p>
<p><strong>解析：</strong></p>
<p><strong>浏览器</strong></p>
<p><strong>关于微任务和宏任务在浏览器的执行顺序是这样的：</strong></p>
<ul>
<li>执行一只 task（宏任务）</li>
<li>执行完 micro-task 队列 （微任务）</li>
</ul>
<p>如此循环往复下去</p>
<blockquote>
<p>浏览器的 task（宏任务）执行顺序在 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">html#event-loops</a> 里面有讲就不翻译了<br>常见的 task（宏任务） 比如：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。<br>常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5 新特性) 等。</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/10/1683863633586974?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p><strong>Node</strong></p>
<p>Node 的事件循环是 libuv 实现的，引用一张官网的图：</p>
<p><img src="https://user-images.githubusercontent.com/20101525/53734427-eba9e880-3ebe-11e9-8511-eb4948e336ae.png"></p>
<p>大体的 task（宏任务）执行顺序是这样的：</p>
<ul>
<li>timers 定时器：本阶段执行已经安排的 setTimeout() 和 setInterval() 的回调函数。</li>
<li>pending callbacks 待定回调：执行延迟到下一个循环迭代的 I/O 回调。</li>
<li>idle, prepare：仅系统内部使用。</li>
<li>poll 轮询：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate() 排定的之外），其余情况 node 将在此处阻塞。</li>
<li>check 检测：setImmediate() 回调函数在这里执行。</li>
<li>close callbacks 关闭的回调函数：一些准备关闭的回调函数，如：socket.on(‘close’, …)。</li>
</ul>
<p><strong>微任务和宏任务在 Node 的执行顺序</strong></p>
<p>Node 10 以前：</p>
<ul>
<li>执行完一个阶段的所有任务</li>
<li>执行完 nextTick 队列里面的内容</li>
<li>然后执行完微任务队列的内容</li>
</ul>
<p>Node 11 以后：<br>和浏览器的行为统一了，都是每执行一个宏任务就执行完微任务队列</p>
<h3 id="第-26-题-（2019-10-16）"><a href="#第-26-题-（2019-10-16）" class="headerlink" title="第 26 题 （2019/10/16）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/28">第 26 题</a> （2019/10/16）</h3><p><strong>题目：</strong> 介绍模块化发展历程</p>
<blockquote>
<p>可从 IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module、<code>&lt;script type=&quot;module&quot;&gt;</code> 这几个角度考虑。</p>
</blockquote>
<p><strong>解析：</strong> <a href="https://www.processon.com/view/link/5c8409bbe4b02b2ce492286a">es6,amd,smd,commonjs 思维导图</a></p>
<p>模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。</p>
<p><strong>IIFE</strong>： 使用自执行函数来编写模块化，特点：<strong>在一个单独的函数作用域中执行代码，避免变量冲突</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    data: [],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>AMD</strong>： 使用 requireJS 来编写模块化，特点：<strong>依赖必须提前声明好</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="string">&quot;./index.js&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// code 就是index.js 返回的内容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>CMD</strong>： 使用 seaJS 来编写模块化，特点：<strong>支持动态引入依赖文件</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> indexCode = <span class="built_in">require</span>(<span class="string">&quot;./index.js&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>CommonJS</strong>： nodejs 中自带的模块化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>UMD</strong>：兼容 AMD，CommonJS 模块化语法。</p>
<p>**webpack(require.ensure)**：webpack 2.x 版本中的代码分割。</p>
<p><strong>ES Modules</strong>： ES6 引入的模块化，支持 import 来引入另一个 js 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="第-27-题-（2019-10-16）"><a href="#第-27-题-（2019-10-16）" class="headerlink" title="第 27 题 （2019/10/16）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/30">第 27 题</a> （2019/10/16）</h3><p><strong>题目：</strong> 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？。</p>
<p><strong>解析：</strong></p>
<p>在 ES5 中，顶层对象的属性和全局变量是等价的，var 命令和 function 命令声明的全局变量，自然也是顶层对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.f); <span class="comment">// f()&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>但 ES6 规定，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，但 let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> bb = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.aa); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.bb); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>在函数的内部属性<code>[[Scopes]]</code>中找到了</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/8/1678e8be5c831804?imageslim"></p>
<blockquote>
<p>如上图，在全局作用域中用<code>const</code>声明的变量在函数<code>noop</code>中可以正常访问，没有问题。我用<code>dir</code>方法打印出函数<code>noop</code>的属性，最后在<code>[[Scopes]]</code>属性内找到了消失的全局变量<code>abcd</code>。</p>
</blockquote>
<h3 id="第-28-题-（2019-10-17）"><a href="#第-28-题-（2019-10-17）" class="headerlink" title="第 28 题 （2019/10/17）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/31">第 28 题</a> （2019/10/17）</h3><p><strong>题目：</strong> cookie 和 token 都存放在 header 中，为什么不会劫持 token？</p>
<p><strong>解析：</strong></p>
<ol>
<li>首先 token 不是防止 XSS 的，而是为了防止 CSRF 的；</li>
<li>CSRF 攻击的原因是浏览器会自动带上 cookie，而浏览器不会自动带上 token</li>
</ol>
<hr>
<blockquote>
<p>cookie：登陆后后端生成一个 sessionid 放在 cookie 中返回给客户端，并且服务端一直记录着这个 sessionid，客户端以后每次请求都会带上这个 sessionid，服务端通过这个 sessionid 来验证身份之类的操作。所以别人拿到了 cookie 拿到了 sessionid 后，就可以完全替代你。</p>
</blockquote>
<blockquote>
<p>token：登陆后后端不返回一个 token 给客户端，客户端将这个 token 存储起来，然后每次客户端请求都需要开发者手动将 token 放在 header 中带过去，服务端每次只需要对这个 token 进行验证就能使用 token 中的信息来进行下一步操作了。</p>
</blockquote>
<blockquote>
<p>xss：用户通过各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本获取信息，发起请求，之类的操作。</p>
</blockquote>
<blockquote>
<p>csrf：跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了 web 中用户身份验证的一个漏洞：<strong>简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的</strong>。csrf 并不能够拿到用户的任何信息，它只是欺骗用户浏览器，让其以用户的名义进行操作。</p>
</blockquote>
<blockquote>
<p>csrf 例子：假如一家银行用以运行转账操作的 URL 地址如下： <a href="http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</a><br>那么，一个恶意攻击者可以在另一个网站上放置如下代码： <code>&lt;img src=&quot;&lt;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&gt;&quot;&gt;</code><br>如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 资金。</p>
</blockquote>
<p>上面的两种攻击方式，如果被 xss 攻击了，不管是 token 还是 cookie，都能被拿到，所以对于 xss 攻击来说，cookie 和 token 没有什么区别。但是对于 csrf 来说就有区别了。</p>
<p>以上面的 csrf 攻击为例：</p>
<ul>
<li>cookie：用户点击了链接，cookie 未失效，导致发起请求后后端以为是用户正常操作，于是进行扣款操作。</li>
<li>token：用户点击链接，由于浏览器不会自动带上 token，所以即使发了请求，后端的 token 验证不会通过，所以不会进行扣款操作。</li>
</ul>
<p>这是个人理解的为什么只劫持 cookie 不劫持 token 的原因。</p>
<h3 id="第-29-题-（2019-10-17）"><a href="#第-29-题-（2019-10-17）" class="headerlink" title="第 29 题  （2019/10/17）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/34">第 29 题 </a> （2019/10/17）</h3><p><strong>题目：</strong> 聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的</p>
<p><strong>解析：</strong></p>
<p>VM 主要做了两件微小的事情：</p>
<ul>
<li>从 M 到 V 的映射（Data Binding），这样可以大量节省你人肉来 update View 的代码（将数据绑定到 view）</li>
<li>从 V 到 M 的事件监听（DOM Listeners），这样你的 Model 会随着 View 触发事件而改变 （view 改变的时候改变数据）</li>
</ul>
<p><strong>1、M 到 V 实现</strong></p>
<p>做到这件事的第一步是形成类似于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// template</span></span><br><span class="line"><span class="keyword">var</span> tpl = <span class="string">&#x27;&lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">// data</span></span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">text: ‘This is some text‘</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// magic process</span></span><br><span class="line">template(tpl, data); <span class="comment">// &#x27;&lt;p&gt;This is some text&lt;/p&gt;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>中间的 magic process 是模板引擎所做的事情，已经有非常多种模板引擎可供选择</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://developer.mozilla.org/en/docs/JavaScript_templates">JavaScript templates</a></li>
</ul>
<p>当然你比较喜欢造轮子的话也可以自己实现一个</p>
<ul>
<li><a href="https://link.zhihu.com/?target=http://kyleslight.net/article/27">一个 JavaScript 模板引擎的实现</a></li>
</ul>
<p>无论是 Angular 的 $scope，React 的 state 还是 Vue 的 data 都提供了一个较为核心的 model 对象用来保存模型的状态；它们的模板引擎稍有差别，不过大体思路相似；拿到渲染后的 string 接下来做什么不言而喻了（中间还有很多处理，例如利用 model 的 diff 来最小量更新 view ）。</p>
<p>但是仅仅是这样并不够，我们需要知道什么时候来更新 view（ 即 render ），一般来说主要的 VM 做了以下几种选择：</p>
<ul>
<li>VM 实例初始化时</li>
<li>model 动态修改时</li>
</ul>
<p>其中初始化拿到 model 对象然后 render 没什么好讲的；model 被修改的时候如何监听属性的改变是一个问题，目前有以下几种思路：</p>
<ul>
<li>借助于 Object 的 observe 方法</li>
<li>自己在 set，以及数组的常用操作里触发 change 事件</li>
<li>手动 setState()，然后在里面触发 change 事件</li>
</ul>
<p>知道了触发 render 的时机以及如何 render，一个简单的 M 到 V 映射就实现了。</p>
<p><strong>2、V 到 M 实现</strong></p>
<p>从 V 到 M 主要由两类（ 虽然本质上都是监听 DOM ）构成，一类是用户自定义的 listener， 一类是 VM 自动处理的含有 value 属性元素的 listener</p>
<p>第一类类似于你在 Vue 里用 v-on 时绑定的那样，VM 在实例化得时候可以将所有用户自定义的 listener 一次性代理到根元素上，这些 listener 可以访问到你的 model 对象，这样你就可以在 listener 中改变 model</p>
<p>第二类类似于对含有 v-model 与 value 元素的自动处理，我们期望的是例如在一个输入框内</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;message&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>输入值，那么我与之对应的 model 属性 message 也会随之改变，相当于 VM 做了一个默认的 listener，它会监听这些元素的改变然后自动改变 model，具体如何实现相信你也明白了</p>
<h3 id="第-30-题-（2019-10-18）"><a href="#第-30-题-（2019-10-18）" class="headerlink" title="第 30 题 （2019/10/18）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/39">第 30 题</a> （2019/10/18）</h3><p><strong>题目：</strong> 两个数组合并成一个数组</p>
<blockquote>
<p>请把两个数组 [‘A1’, ‘A2’, ‘B1’, ‘B2’, ‘C1’, ‘C2’, ‘D1’, ‘D2’] 和 [‘A’, ‘B’, ‘C’, ‘D’]，合并为 [‘A1’, ‘A2’, ‘A’, ‘B1’, ‘B2’, ‘B’, ‘C1’, ‘C2’, ‘C’, ‘D1’, ‘D2’, ‘D’]。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MergeArray</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a2 = arr2.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item + <span class="number">3</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> arr = [...arr1, ...a2].sort();</span><br><span class="line">  <span class="keyword">return</span> arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.includes(<span class="number">3</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> item.split(<span class="string">&quot;&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-31-题-（2019-10-18）"><a href="#第-31-题-（2019-10-18）" class="headerlink" title="第 31 题 （2019/10/18）"></a>第 31 题 （2019/10/18）</h3><p><strong>题目：</strong> 改造下面的代码，使之输出 0 - 9，写出你能想到的所有解法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<ol>
<li>使用闭包：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  (<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 let</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-32-题-（2019-10-19）"><a href="#第-32-题-（2019-10-19）" class="headerlink" title="第 32 题 （2019/10/19）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/47">第 32 题</a> （2019/10/19）</h3><p><strong>题目：</strong> Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法。</p>
<p><strong>解析：</strong></p>
<p>作者：尤雨溪</p>
<p>链接：<a href="https://www.zhihu.com/question/31809713/answer/53544875">https://www.zhihu.com/question/31809713/answer/53544875</a></p>
<p>来源：知乎</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p><strong>1. 原生 DOM 操作 vs. 通过框架封装操作。</strong></p>
<p>这是一个性能 vs. 可维护性的取舍。框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。</p>
<p><strong>2. 对 React 的 Virtual DOM 的误解。</strong></p>
<p>React 从来没有说过 “React 比原生操作 DOM 快”。React 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作… 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。</p>
<p>我们可以比较一下 innerHTML vs. Virtual DOM 的重绘性能消耗：</p>
<ul>
<li>innerHTML: render html string <strong>O(template size)</strong> + 重新创建所有 DOM 元素 <strong>O(DOM size)</strong></li>
<li>Virtual DOM: render Virtual DOM + diff <strong>O(template size)</strong> + 必要的 DOM 更新 <strong>O(DOM change)</strong></li>
</ul>
<p>Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。前面说了，和 DOM 操作比起来，js 计算是极其便宜的。这才是为什么要有 Virtual DOM：它保证了 1）不管你的数据变化多少，每次重绘的性能都可以接受；2) 你依然可以用类似 innerHTML 的思路去写你的应用。</p>
<p><strong>3. MVVM vs. Virtual DOM</strong></p>
<p>相比起 React，其他 MVVM 系框架比如 Angular, Knockout 以及 Vue、Avalon 采用的都是数据绑定：通过 Directive/Binding 对象，观察数据变化并保留对实际 DOM 元素的引用，当有数据变化时进行对应的操作。MVVM 的变化检查是数据层面的，而 React 的检查是 DOM 结构层面的。MVVM 的性能也根据变动检测的实现原理有所不同：Angular 的脏检查使得任何变动都有固定的</p>
<p>O(watcher count)</p>
<p>的代价；Knockout/Vue/Avalon 都采用了依赖收集，在 js 和 DOM 层面都是</p>
<p>O(change)</p>
<p>：</p>
<ul>
<li>脏检查：scope digest <strong>O(watcher count)</strong> + 必要 DOM 更新 <strong>O(DOM change)</strong></li>
<li>依赖收集：重新收集依赖 <strong>O(data change)</strong> + 必要 DOM 更新 <strong>O(DOM change)</strong></li>
</ul>
<p>可以看到，Angular 最不效率的地方在于任何小变动都有的和 watcher 数量相关的性能代价。但是！当所有数据都变了的时候，Angular 其实并不吃亏。依赖收集在初始化和数据变化的时候都需要重新收集依赖，这个代价在小量更新的时候几乎可以忽略，但在数据量庞大的时候也会产生一定的消耗。</p>
<p>MVVM 渲染列表的时候，由于每一行都有自己的数据作用域，所以通常都是每一行有一个对应的 ViewModel 实例，或者是一个稍微轻量一些的利用原型继承的 “scope” 对象，但也有一定的代价。所以，MVVM 列表渲染的初始化几乎一定比 React 慢，因为创建 ViewModel / scope 实例比起 Virtual DOM 来说要昂贵很多。这里所有 MVVM 实现的一个共同问题就是在列表渲染的数据源变动时，尤其是当数据是全新的对象时，如何有效地复用已经创建的 ViewModel 实例和 DOM 元素。假如没有任何复用方面的优化，由于数据是 “全新” 的，MVVM 实际上需要销毁之前的所有实例，重新创建所有实例，最后再进行一次渲染！这就是为什么题目里链接的 angular/knockout 实现都相对比较慢。相比之下，React 的变动检查由于是 DOM 结构层面的，即使是全新的数据，只要最后渲染结果没变，那么就不需要做无用功。</p>
<p>Angular 和 Vue 都提供了列表重绘的优化机制，也就是 “提示” 框架如何有效地复用实例和 DOM 元素。比如数据库里的同一个对象，在两次前端 API 调用里面会成为不同的对象，但是它们依然有一样的 uid。这时候你就可以提示 track by uid 来让 Angular 知道，这两个对象其实是同一份数据。那么原来这份数据对应的实例和 DOM 元素都可以复用，只需要更新变动了的部分。或者，你也可以直接 track by $index 来进行 “原地复用”：直接根据在数组里的位置进行复用。在题目给出的例子里，如果 angular 实现加上 track by $index 的话，后续重绘是不会比 React 慢多少的。甚至在 dbmonster 测试中，Angular 和 Vue 用了 track by $index 以后都比 React 快: <a href="https://link.zhihu.com/?target=http://vuejs.github.io/js-repaint-perfs/">dbmon</a> (注意 Angular 默认版本无优化，优化过的在下面）</p>
<p>顺道说一句，React 渲染列表的时候也需要提供 key 这个特殊 prop，本质上和 track-by 是一回事。</p>
<p><strong>4. 性能比较也要看场合</strong></p>
<p>在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求。Virtual DOM 为了提升小量数据更新时的性能，也需要针对性的优化，比如 shouldComponentUpdate 或是 immutable data。</p>
<ul>
<li>初始渲染：Virtual DOM &gt; 脏检查 &gt;= 依赖收集</li>
<li>小量数据更新：依赖收集 &gt;&gt; Virtual DOM + 优化 &gt; 脏检查（无法优化） &gt; Virtual DOM 无优化</li>
<li>大量数据更新：脏检查 + 优化 &gt;= 依赖收集 + 优化 &gt; Virtual DOM（无法/无需优化）&gt;&gt; MVVM 无优化</li>
</ul>
<p>不要天真地以为 Virtual DOM 就是快，diff 不是免费的，batching 么 MVVM 也能做，而且最终 patch 的时候还不是要用原生 API。在我看来 Virtual DOM 真正的价值从来都不是性能，而是它 1) 为函数式的 UI 编程方式打开了大门；2) 可以渲染到 DOM 以外的 backend，比如 ReactNative。</p>
<h3 id="第-33-题-（2019-10-20）"><a href="#第-33-题-（2019-10-20）" class="headerlink" title="第 33 题 （2019/10/20）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/48">第 33 题</a> （2019/10/20）</h3><p><strong>题目：</strong> 下面的代码打印什么内容，为什么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p>非严格模式：【输出函数体】</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ƒ b()&#123;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>严格模式：【报错】</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&quot;Uncaught TypeError: Assignment to constant variable.&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>针对这题，在知乎上看到别人的回答说：</p>
<ol>
<li>函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。</li>
<li>对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。</li>
<li>IIFE 中的函数是函数表达式，而不是函数声明。</li>
</ol>
<p>实际上，有点类似于以下代码，但不完全相同，因为使用 const 不管在什么模式下，都会 TypeError 类型的错误</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const foo &#x3D; function () &#123;</span><br><span class="line">foo &#x3D; 10;</span><br><span class="line">console.log(foo)</span><br><span class="line">&#125;</span><br><span class="line">(foo)() &#x2F;&#x2F; Uncaught TypeError: Assignment to constant variable.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>我的理解是，b 函数是一个相当于用 const 定义的常量，内部无法进行重新赋值，如果在严格模式下，会报错”Uncaught TypeError: Assignment to constant variable.”<br>例如下面的：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var b &#x3D; 10;</span><br><span class="line">(function b() &#123;</span><br><span class="line">&#39;use strict&#39;</span><br><span class="line">b &#x3D; 20;</span><br><span class="line">console.log(b)</span><br><span class="line">&#125;)() &#x2F;&#x2F; &quot;Uncaught TypeError: Assignment to constant variable.&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p>这个回答主要表达的是：函数表达式的函数名只在该函数内部有效，且绑定是常量类似 const，不能修改</p>
<h3 id="第-34-题（2019-10-21）"><a href="#第-34-题（2019-10-21）" class="headerlink" title="第 34 题（2019/10/21）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/51">第 34 题</a>（2019/10/21）</h3><p><strong>题目：</strong> 简单改造下面的代码，使之分别打印 10 和 20。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>打印 20：</p>
<p>方法一：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)(b);</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>打印 10：</p>
<p>方法一：（挂载在 全局 window 上）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)(b);</span><br></pre></td></tr></table></figure>

<p>方法二： （挂载在 b 函数（函数也是特殊的对象）上）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  b.b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)(b);</span><br></pre></td></tr></table></figure>

<h3 id="第-35-题-（2019-10-22）"><a href="#第-35-题-（2019-10-22）" class="headerlink" title="第 35 题  （2019/10/22）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/51">第 35 题 </a> （2019/10/22）</h3><p><strong>题目</strong>：浏览器缓存读取规则 ?</p>
<blockquote>
<p>可以分成 Service Worker、Memory Cache、Disk Cache 和 Push Cache，那请求的时候 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache 中？</p>
</blockquote>
<p><strong>解析：</strong> <a href="https://www.jianshu.com/p/54cc04190252">深入理解浏览器的缓存机制</a> <a href="https://juejin.im/post/5c22ee806fb9a049fb43b2c5?utm_source=gold_browser_extension">一文读懂前端缓存</a></p>
<p>对于第一个问题前面的文章都说得很详细了我这里就不再多余述<br>第二个问题可以参考我写的<a href="https://jayzangwill.github.io/blog/2019/02/07/cache/">博文</a> <strong>命中强制缓存时，该从哪拿缓存</strong><br>小节。总的来说：</p>
<ol>
<li>如果开启了 Service Worker 首先会从 Service Worker 中拿</li>
<li>如果新开一个以前打开过的页面缓存会从 Disk Cache 中拿（称为是命中强缓存）</li>
<li>刷新当前页面时浏览器会根据当前运行环境内存来决定是从 Memory Cache 还是从 Disk Cache 中拿（可以看到下图最后几个文件有时候是从 Memory Cache 中拿有时候是从 Disk Cache 中拿）</li>
</ol>
<h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://camo.githubusercontent.com/6254fa34eb5e693a51cb2b5b2eb257f38f0b1634/68747470733a2f2f6a61797a616e6777696c6c2e6769746875622e696f2f626c6f672f696d672f63616368652f7765697a68695f312e676966"></h6><h3 id="第-36-题-（2019-10-22）"><a href="#第-36-题-（2019-10-22）" class="headerlink" title="第 36 题 （2019/10/22）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/54">第 36 题</a> （2019/10/22）</h3><p><strong>题目：</strong> 使用迭代的方式实现 flatten 函数。</p>
<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用迭代的方式实现flatten函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用递归的方式处理</span></span><br><span class="line"><span class="comment"> * wrap内保存结果ret</span></span><br><span class="line"><span class="comment"> * 返回一个递归函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, [<span class="number">7</span>, [<span class="number">8</span>]]]];</span><br><span class="line"><span class="built_in">console</span>.log(wrap()(arr));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.constructor === <span class="built_in">Array</span>) &#123;</span><br><span class="line">        ret.concat(flatten(item));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret.push(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-37-题-（2019-10-22）"><a href="#第-37-题-（2019-10-22）" class="headerlink" title="第 37 题 （2019/10/22）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/65">第 37 题</a> （2019/10/22）</h3><p><strong>题目：</strong> 为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？</p>
<p><strong>解析：</strong> 待续…</p>
<h3 id="第-38-题-（2019-10-23）"><a href="#第-38-题-（2019-10-23）" class="headerlink" title="第 38 题  （2019/10/23）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/57">第 38 题 </a> （2019/10/23）</h3><p><strong>题目：</strong> 下面代码中 a 在什么情况下会打印 1？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = ?;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>)&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>公司：</strong> 京东</p>
<p><strong>考点</strong>： 隐式类型转换</p>
<p><strong>解析：</strong> <a href="https://yq.aliyun.com/articles/399499">从 (a==1&amp;&amp;a==2&amp;&amp;a==3) 成立中看 javascript 的隐式类型转换</a></p>
<p><strong>关于 === 于 ==</strong></p>
<blockquote>
<p>但是我比较喜欢的一本书 <code> You don&#39;t know JS</code>,中作者也写道过一个我比较赞同的观点</p>
<p>很多开发者认为 === 的行为更加容易预测，从而主张使用 === 而远离 ==。我认为这种观点是非常短视的，如果你花点时间去搞清楚它的工作原理，== 将是你开发的强大工具</p>
</blockquote>
<ol>
<li>运算子是对象时候的 valueOf toString 方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  i: <span class="number">1</span>,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.i++;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>); <span class="comment">//1</span></span><br><span class="line">  <span class="built_in">console</span>.log(a.i); <span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果原始类型的值和对象比较，对象会转为原始类型的值，再进行比较。<code>(我想到的也是这种方法)</code>，对象转换成原始类型的值，算法是先调用<code>valueOf</code>方法；如果返回的还是对象，再接着调用<code>toString</code>方法。我们每次比较时候都会执行方法返回 <code>a</code> 的 <code>i</code> 属性同时也改变 <code>i</code> 的值,所以上面 <code>if</code> 执行完以后 <code>a</code> 的 <code>i</code> 属性已经变为了 4，<strong>这里也表现出了 == 比较是有可能会对变量带来副作用的</strong></p>
<p><strong>利用数组的特性</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.join = a.shift;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个答案还是比较巧妙的，我们知道 <code>array</code> 也属于对象，应该和对象的规则一样。关于 <code>array</code> 的原型链上的 <code>toString</code> 方法</p>
<blockquote>
<p>对于数组对象，toString 方法返回一个字符串，该字符串由数组中的每个元素的 toString() 返回值经调用 join() 方法连接（由逗号隔开）组成。</p>
</blockquote>
<p>可以看到数组 <code>toString</code> 会调用本身的 <code>join</code> 方法，这里把自己的<code>join</code>方法该写为<code>shift</code>,每次返回第一个元素，而且原数组删除第一个值，正好可以使判断成立。<strong>这里 == 比较也带来的副作用</strong></p>
<p><strong>利用 with 关键字</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">a</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>with</code> 也是被严重建议不使用的对象，这里也是利用它的特性在代码块里面利用对象的 <code>get</code> 方法动态返回 <code>i</code>.</p>
<p><strong>和 with 类似修改 window 的 get 方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++val;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;yay&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道我们用的全局变量也相当于 <code>window</code> 对象上的一个属性，这里用<code>defineProperty</code> 定义了 <code>a</code>的 <code>get</code> 也使得其动态返回值。和<code>with</code> 有一些类似。</p>
<p><strong>es6 的 Symbol 特性</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; [<span class="built_in">Symbol</span>.toPrimitive]: (<span class="function">(<span class="params">i</span>) =&gt;</span> <span class="function">() =&gt;</span> ++i)(<span class="number">0</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><code>ES6</code> 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。我们之前在定义类的内部私有属性时候习惯用 <code>__xxx</code> ,这种命名方式避免别人定义相同的属性名覆盖原来的属性，有了 <code>Symbol </code> 之后我们完全可以用 <code>Symbol</code>值来代替这种方法，而且完全不用担心被覆盖。</p>
<p>除了定义自己使用的 <code>Symbol</code> 值以外，<code>ES6</code> 还提供了 11 个内置的 <code>Symbol</code> 值，指向语言内部使用的方法。<code>Symbol.toPrimitive</code>就是其中一个，它指向一个方法，表示该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。这里就是改变这个属性，把它的值改为一个 <code>闭包</code> 返回的函数。</p>
<h3 id="第-39-题-（2019-10-24）"><a href="#第-39-题-（2019-10-24）" class="headerlink" title="第 39 题 （2019/10/24）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/59">第 39 题</a> （2019/10/24）</h3><p><strong>题目：</strong> 介绍下 BFC 及其应用</p>
<p><strong>解析：</strong></p>
<p>BFC 就是块级格式上下文，是页面盒模型布局中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。创建 BFC 的方式有：</p>
<ol>
<li>html 根元素</li>
<li>float 浮动</li>
<li>绝对定位</li>
<li>overflow 不为 visiable</li>
<li>display 为表格布局或者弹性布局</li>
</ol>
<p>BFC 主要的作用是：</p>
<ol>
<li>清除浮动</li>
<li>防止同一 BFC 容器中的相邻元素间的外边距重叠问题</li>
</ol>
<h3 id="第-40-题-（2019-10-25）"><a href="#第-40-题-（2019-10-25）" class="headerlink" title="第 40 题  （2019/10/25）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/60">第 40 题 </a> （2019/10/25）</h3><p><strong>题目：</strong> 在 Vue 中，子组件为何不可以修改父组件传递的 Prop?</p>
<blockquote>
<p>如果修改了，Vue 是如何监控到属性的修改并给出警告的。</p>
</blockquote>
<p><strong>解析：</strong></p>
<ol>
<li>子组件为何不可以修改父组件传递的 Prop<br>单向数据流，易于监测数据的流动，出现了错误可以更加迅速的定位到错误发生的位置。</li>
<li>如果修改了，Vue 是如何监控到属性的修改并给出警告的。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> hyphenatedKey = hyphenate(key);</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">    config.isReservedAttr(hyphenatedKey)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">&#x27;&quot;&#x27;</span> +</span><br><span class="line">        hyphenatedKey +</span><br><span class="line">        <span class="string">&#x27;&quot; is a reserved attribute and cannot be used as component prop.&#x27;</span>,</span><br><span class="line">      vm</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  defineReactive$$<span class="number">1</span>(props, key, value, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">&quot;Avoid mutating a prop directly since the value will be &quot;</span> +</span><br><span class="line">          <span class="string">&quot;overwritten whenever the parent component re-renders. &quot;</span> +</span><br><span class="line">          <span class="string">&quot;Instead, use a data or computed property based on the prop&#x27;s &quot;</span> +</span><br><span class="line">          <span class="string">&#x27;value. Prop being mutated: &quot;&#x27;</span> +</span><br><span class="line">          key +</span><br><span class="line">          <span class="string">&#x27;&quot;&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 initProps 的时候，在 defineReactive 时通过判断是否在开发环境，如果是开发环境，会在触发 set 的时候判断是否此 key 是否处于 updatingChildren 中被修改，如果不是，说明此修改来自子组件，触发 warning 提示。</p>
<blockquote>
<p>需要特别注意的是，当你从子组件修改的 prop 属于基础类型时会触发提示。 这种情况下，你是无法修改父组件的数据源的， 因为基础类型赋值时是值拷贝。你直接将另一个非基础类型（Object, array）赋值到此 key 时也会触发提示(但实际上不会影响父组件的数据源)， 当你修改 object 的属性时不会触发提示，并且会修改父组件数据源的数据。</p>
</blockquote>
<h3 id="第-41-题-（2019-10-25）"><a href="#第-41-题-（2019-10-25）" class="headerlink" title="第 41 题 （2019/10/25）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/61">第 41 题</a> （2019/10/25）</h3><p><strong>题目：</strong> 下面代码输出什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">  a = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//20</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong> 分别为 undefined 　 10 　 20，原因是作用域问题，在内部声名 var a = 20;相当于先声明 var a;然后再执行赋值操作，这是在ＩＩＦＥ内形成的独立作用域，如果把 var a=20 注释掉，那么 a 只有在外部有声明，显示的就是外部的Ａ变量的值了。结果Ａ会是 10 　 5 　 5</p>
<h3 id="第-42-题-（2019-10-25）"><a href="#第-42-题-（2019-10-25）" class="headerlink" title="第 42 题  （2019/10/25）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/63">第 42 题 </a> （2019/10/25）</h3><p><strong>题目：</strong> 实现一个 sleep 函数</p>
<blockquote>
<p>比如 sleep(1000) 意味着等待 1000 毫秒，可从 Promise、Generator、Async/Await 等角度实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Promise1</span></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, time));</span><br><span class="line">&#125;;</span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Generator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">sleepGenerator</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">sleepGenerator(<span class="number">1000</span>)</span><br><span class="line">  .next()</span><br><span class="line">  .value.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//async</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, time));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> out = <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">output();</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">callback, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&quot;function&quot;</span>) <span class="built_in">setTimeout</span>(callback, time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">sleep(output, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/ImagineCode/article/details/81089107">Promise | 自个写一个 Promise | Generator</a></li>
</ul>
<h3 id="第-43-题-（2019-10-26）"><a href="#第-43-题-（2019-10-26）" class="headerlink" title="第 43 题 （2019/10/26）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/66">第 43 题</a> （2019/10/26）</h3><p><strong>题目：</strong> 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果</p>
<p><strong>解析：</strong></p>
<p>原题目：</p>
<blockquote>
<p>使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果</p>
</blockquote>
<p>我的答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">102</span>, <span class="number">15</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">3</span>, <span class="number">8</span>];</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>根据 MDN 上对<code>Array.sort()</code>的解释，默认的排序方法会将数组元素转换为字符串，然后比较字符串中字符的 UTF-16 编码顺序来进行排序。所以<code>&#39;102&#39;</code> 会排在 <code>&#39;15&#39;</code> 前面。以下是 MDN 中的解释原文：</p>
<blockquote>
<p>The sort() method sorts the elements of an array in place and returns the array. The default sort order is built upon converting the elements into strings, then comparing their sequences of UTF-16 code units values.</p>
</blockquote>
<h3 id="第-44-题-（2019-10-26）"><a href="#第-44-题-（2019-10-26）" class="headerlink" title="第 44 题 （2019/10/26）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/70">第 44 题 </a>（2019/10/26）</h3><p><strong>题目：</strong> 介绍 HTTPS 握手过程</p>
<p><strong>解析：</strong> ~~</p>
<h3 id="第-45-题-（2019-10-26）"><a href="#第-45-题-（2019-10-26）" class="headerlink" title="第 45 题  （2019/10/26）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/74">第 45 题 </a> （2019/10/26）</h3><p><strong>题目：</strong> HTTPS 握手过程中，客户端如何验证证书的合法性</p>
<p><strong>解析：</strong> ~~</p>
<h3 id="第-46-题-（2019-10-26）"><a href="#第-46-题-（2019-10-26）" class="headerlink" title="第 46 题  （2019/10/26）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/76">第 46 题 </a> （2019/10/26）</h3><p><strong>题目：</strong> 输出以下代码执行的结果并解释为什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="number">4</span>,</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">  splice: <span class="built_in">Array</span>.prototype.splice,</span><br><span class="line">  push: <span class="built_in">Array</span>.prototype.push,</span><br><span class="line">&#125;;</span><br><span class="line">obj.push(<span class="number">1</span>);</span><br><span class="line">obj.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">    Object(4) [empty × 2, 1, 2, splice: ƒ, push: ƒ]</span></span><br><span class="line"><span class="comment">    2: 1</span></span><br><span class="line"><span class="comment">    3: 2</span></span><br><span class="line"><span class="comment">    length: 4</span></span><br><span class="line"><span class="comment">    push: ƒ push()</span></span><br><span class="line"><span class="comment">    splice: ƒ splice()</span></span><br><span class="line"><span class="comment">    __proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>我的理解是这样的<br>1: call push 这个方法如果对象有 length 属性，length 属性会加 1 并且返回，这个是在某本书的上看到的，一直记得。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push#Description">MDN</a></p>
<blockquote>
<p>push 方法将值追加到数组中。</p>
<p>push 方法有意具有通用性。该方法和 call() 或 apply() 一起使用时，可应用在类似数组的对象上。push 方法根据 length 属性来决定从哪里开始插入给定的值。如果 length 不能被转成一个数值，则插入的元素索引为 0，包括 length 不存在时。当 length 不存在时，将会创建它。</p>
<p>唯一的原生类数组（array-like）对象是 Strings，尽管如此，它们并不适用该方法，因为字符串是不可改变的。</p>
</blockquote>
<ol>
<li>调用 push 方法的时候会在调用对象的 key=length 的地方做一个赋值，不管前面 key 有没有值，也就是说在调用 push 的时候 对象实际被理解为了[0:undefined,1:undefined,2:3,3:4],<br>这样也就有了结果里面的<br>key===2 value =1<br>key===3 value =2 3.额外的<br>这个对象如果有 push 和 splice 会输出会转换为数组，下图为去掉 splice</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/11674767/55370329-b8459280-552c-11e9-96ec-0924b03f70a4.png"></p>
<p>包含 splice 方法</p>
<p><img src="https://user-images.githubusercontent.com/11674767/55370427-065a9600-552d-11e9-9525-236038e73009.png"></p>
<h3 id="第-47-题-（2019-10-27）"><a href="#第-47-题-（2019-10-27）" class="headerlink" title="第 47 题  （2019/10/27）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/81">第 47 题 </a> （2019/10/27）</h3><p><strong>题目：</strong> 双向绑定和 vuex 是否冲突</p>
<p><strong>解析：</strong></p>
<p>在严格模式下直接使用确实会有问题。<br>解决方案：</p>
<blockquote>
<p>官网说的比较详细<br><a href="https://vuex.vuejs.org/zh/guide/forms.html">https://vuex.vuejs.org/zh/guide/forms.html</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;message&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    message: &#123;</span><br><span class="line">        set (value) &#123;</span><br><span class="line">            <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;updateMessage&#x27;</span>, value);</span><br><span class="line">        &#125;,</span><br><span class="line">        get () &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.obj.message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mutations: &#123;</span><br><span class="line">    UPDATE_MESSAGE (state, v) &#123;</span><br><span class="line">        state.obj.message = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">actions: &#123;</span><br><span class="line">    update_message (&#123; commit &#125;, v) &#123;</span><br><span class="line">        commit(<span class="string">&#x27;UPDATE_MESSAGE&#x27;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-48-题-（2019-10-27）"><a href="#第-48-题-（2019-10-27）" class="headerlink" title="第 48 题 （2019/10/27）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/84">第 48 题</a> （2019/10/27）</h3><p><strong>题目：</strong> call 和 apply 的区别是什么，哪个性能更好一些</p>
<p><strong>解析：</strong></p>
<blockquote>
<p><code>**call()**</code> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p>
<p><strong>apply()</strong> 方法调用一个具有给定<code>this</code>值的函数，以及作为一个数组（或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects">类似数组对象</a>）提供的参数。</p>
</blockquote>
<ol>
<li>Function.prototype.apply 和 Function.prototype.call 的作用是一样的，区别在于传入参数的不同；</li>
<li>第一个参数都是，指定函数体内 this 的指向；</li>
<li>第二个参数开始不同，apply 是传入<strong>带下标的集合</strong>，数组或者类数组，apply 把它传给函数作为参数，call 从第二个开始<strong>传入的参数是不固定的，都会传给函数作为参数</strong>。</li>
<li>call 比 apply 的性能要好，平常可以多用 call, call 传入参数的格式正是内部所需要的格式，参考<a href="https://github.com/noneven/__/issues/6">call 和 apply 的性能对比</a></li>
</ol>
<h3 id="第-49-题-（2019-10-27）"><a href="#第-49-题-（2019-10-27）" class="headerlink" title="第 49 题  （2019/10/27）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/87">第 49 题 </a> （2019/10/27）</h3><p><strong>题目：</strong> 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？</p>
<p><strong>解析：</strong> <a href="https://www.zhihu.com/question/36411025">数据埋点是什么？设置埋点的意义是什么？</a></p>
<blockquote>
<p><strong>1. 埋点是什么？</strong></p>
<p>所谓“埋点”，是 <strong>数据采集领域</strong>（尤其是用户行为数据采集领域）的术语，指的是针对特定用户行为或事件进行捕获、处理和发送的相关技术及其实施过程。比如用户某个 icon 点击次数、观看某个视频的时长等等。</p>
<p>埋点的技术实质，是先监听软件应用运行过程中的事件，当需要关注的事件发生时进行判断和捕获。</p>
<p>特别注意需要明确事件发生时间点、判别条件，这里如果遇到不清楚的，需要和开发沟通清楚，避免采集数据与理想存在差异。例如：期望采集某个 app 的某个广告的有效曝光数，有效曝光的判别条件是停留时长超过 1 秒且有效加载出广告内容。</p>
<p><strong>解答：</strong></p>
</blockquote>
<p>作用：工作中，用于前端监控，比如曝光等等，谷歌和百度的都是用的 1x1 像素的透明 gif 图片；<br>why?</p>
<ol>
<li>没有跨域问题，一般这种上报数据，代码要写通用的；（排除 ajax）</li>
<li>不会阻塞页面加载，影响用户的体验，只要 new Image 对象就好了；（排除 JS/CSS 文件资源方式上报）</li>
<li>在所有图片中，体积最小；（比较 PNG/JPG）</li>
</ol>
<h3 id="第-50-题-（2019-10-28）"><a href="#第-50-题-（2019-10-28）" class="headerlink" title="第 50 题 （2019/10/28）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/88">第 50 题 </a>（2019/10/28）</h3><p><strong>题目：</strong> 实现 (5).add(3).minus(2) 功能。</p>
<blockquote>
<p>例： 5 + 3 - 2，结果为 6</p>
</blockquote>
<p><strong>公司</strong>：百度</p>
<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() + num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.prototype.minus = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() - num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">5</span>).add(<span class="number">3</span>).minus(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h3 id="第-51-题-（2019-10-28）"><a href="#第-51-题-（2019-10-28）" class="headerlink" title="第 51 题 （2019/10/28）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/90">第 51 题</a> （2019/10/28）</h3><p><strong>题目：</strong> Vue 的响应式原理中 Object.defineProperty 有什么缺陷？</p>
<blockquote>
<p>为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？</p>
</blockquote>
<p><strong>解析：</strong> 不懂<del>~</del></p>
<h3 id="第-52-题-（2019-10-28）"><a href="#第-52-题-（2019-10-28）" class="headerlink" title="第 52 题 （2019/10/28）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/92">第 52 题</a> （2019/10/28）</h3><p><strong>题目：</strong> 怎么让一个 div 水平垂直居中</p>
<p><strong>解析：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>1、利用 flex</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、绝对定位</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 或 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、网格布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">justify-self</span>: center;</span><br><span class="line">  <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  &amp;::before &#123;</span><br><span class="line">    <span class="selector-tag">content</span>: &quot;&quot;;</span><br><span class="line">    <span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br><span class="line">    <span class="selector-tag">width</span>: 0;</span><br><span class="line">    <span class="selector-tag">height</span>: 100%;</span><br><span class="line">    <span class="selector-tag">vertical-align</span>: <span class="selector-tag">middle</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、补充</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: table-cell</span><br><span class="line">vertical-align: middle;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-53-题-（2019-10-29）"><a href="#第-53-题-（2019-10-29）" class="headerlink" title="第 53 题 （2019/10/29）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/93">第 53 题</a> （2019/10/29）</h3><p><strong>题目：</strong> 输出以下代码的执行结果并解释为什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x = a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b.x); <span class="comment">//&#123; n: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//&#123; n: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//&#123; n: 1, x: &#123; n: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先，a和b同时引用了&#123;n:2&#125;对象，接着执行到a.x &#x3D; a &#x3D; &#123;n：2&#125;语句，尽管赋值是从右到左的没错，但是.的优先级比&#x3D;要高，所以这里首先执行a.x，相当于为a（或者b）所指向的&#123;n:1&#125;对象新增了一个属性x，即此时对象将变为&#123;n:1;x:undefined&#125;。之后按正常情况，从右到左进行赋值，此时执行a &#x3D;&#123;n:2&#125;的时候，a的引用改变，指向了新对象&#123;n：2&#125;,而b依然指向的是旧对象。之后执行a.x &#x3D; &#123;n：2&#125;的时候，并不会重新解析一遍a，而是沿用最初解析a.x时候的a，也即旧对象，故此时旧对象的x的值为&#123;n：2&#125;，旧对象为 &#123;n:1;x:&#123;n：2&#125;&#125;，它被b引用着。</span><br><span class="line">后面输出a.x的时候，又要解析a了，此时的a是指向新对象的a，而这个新对象是没有x属性的，故访问时输出undefined；而访问b.x的时候，将输出旧对象的x的值，即&#123;n:2&#125;。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-54-题-（2019-10-29）"><a href="#第-54-题-（2019-10-29）" class="headerlink" title="第 54 题  （2019/10/29）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/94">第 54 题 </a> （2019/10/29）</h3><p><strong>题目：</strong> 冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？</p>
<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BubbleSort</span>(<span class="params">nums, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j + <span class="number">1</span>] &lt; nums[j]) &#123;</span><br><span class="line">        [nums[j], nums[j + <span class="number">1</span>]] = [nums[j + <span class="number">1</span>], nums[j]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>性质：</p>
<p>1、时间复杂度：O(n^2)</p>
<p>2、空间复杂度：O(1)</p>
<p>3、稳定排序</p>
<p>4、原地排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改进冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort1</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        pos = j;</span><br><span class="line">        <span class="keyword">const</span> temp = arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i = pos;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-55-题-（2019-10-30）"><a href="#第-55-题-（2019-10-30）" class="headerlink" title="第 55 题 （2019/10/30）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/96">第 55 题</a> （2019/10/30）</h3><p><strong>题目：</strong> 某公司 1 到 12 月份的销售额存在一个对象里面</p>
<blockquote>
<p>如下：{1:222, 2:123, 5:888}，请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null]。</p>
</blockquote>
<blockquote>
<p><code>**Array.from()**</code> 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="number">1</span>: <span class="number">222</span>, <span class="number">2</span>: <span class="number">123</span>, <span class="number">5</span>: <span class="number">888</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.length = <span class="number">13</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(obj).slice(<span class="number">1</span>).map(item = &gt; &#123;</span><br><span class="line">        <span class="keyword">return</span>  item === <span class="literal">undefined</span> ? <span class="literal">null</span> : item</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f(obj))</span><br><span class="line"><span class="comment">//[ 222, 123, null, null, 888, null, null, null, null, null, null, null ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-56-题-（2019-10-30）"><a href="#第-56-题-（2019-10-30）" class="headerlink" title="第 56 题 （2019/10/30）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/98">第 56 题</a> （2019/10/30）</h3><p><strong>题目：</strong> 要求设计 LazyMan 类，实现以下功能。</p>
<p><strong>考点</strong>：数据结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">LazyMan(<span class="string">&quot;Tony&quot;</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"></span><br><span class="line">LazyMan(<span class="string">&quot;Tony&quot;</span>).sleep(<span class="number">10</span>).eat(<span class="string">&quot;lunch&quot;</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"><span class="comment">// 等待了10秒...</span></span><br><span class="line"><span class="comment">// I am eating lunch</span></span><br><span class="line"></span><br><span class="line">LazyMan(<span class="string">&quot;Tony&quot;</span>).eat(<span class="string">&quot;lunch&quot;</span>).sleep(<span class="number">10</span>).eat(<span class="string">&quot;dinner&quot;</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"><span class="comment">// I am eating lunch</span></span><br><span class="line"><span class="comment">// 等待了10秒...</span></span><br><span class="line"><span class="comment">// I am eating diner</span></span><br><span class="line"></span><br><span class="line">LazyMan(<span class="string">&quot;Tony&quot;</span>)</span><br><span class="line">  .eat(<span class="string">&quot;lunch&quot;</span>)</span><br><span class="line">  .eat(<span class="string">&quot;dinner&quot;</span>)</span><br><span class="line">  .sleepFirst(<span class="number">5</span>)</span><br><span class="line">  .sleep(<span class="number">10</span>)</span><br><span class="line">  .eat(<span class="string">&quot;junk food&quot;</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"><span class="comment">// 等待了5秒...</span></span><br><span class="line"><span class="comment">// I am eating lunch</span></span><br><span class="line"><span class="comment">// I am eating dinner</span></span><br><span class="line"><span class="comment">// 等待了10秒...</span></span><br><span class="line"><span class="comment">// I am eating junk food</span></span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong> <del>~</del></p>
<h3 id="第-57-题（2019-10-31）"><a href="#第-57-题（2019-10-31）" class="headerlink" title="第 57 题（2019/10/31）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/100">第 57 题</a>（2019/10/31）</h3><p><strong>题目：</strong> 分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。</p>
<p><strong>解析：</strong></p>
<blockquote>
<p>总结一下：</p>
</blockquote>
<p><strong>结构:</strong><br>display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击，<br>visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击<br>opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击</p>
<p><strong>继承：</strong><br>display: none 和 opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。<br>visibility: hidden：是继承属性，子孙节点消失由于继承了 hidden，通过设置 visibility: visible;可以让子孙节点显式。</p>
<p><strong>性能：</strong><br>displaynone : 修改元素会造成文档回流,读屏器不会读取 display: none 元素内容，性能消耗较大<br>visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取 visibility: hidden 元素内容<br>opacity: 0 ： 修改元素会造成重绘，性能消耗较少</p>
<p><strong>联系</strong> ：它们都能让元素不可见</p>
<h3 id="第-58-题（2019-10-31）"><a href="#第-58-题（2019-10-31）" class="headerlink" title="第 58 题（2019/10/31）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/101">第 58 题</a>（2019/10/31）</h3><p><strong>题目：</strong> 第 58 题：箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？</p>
<p><strong>解析：</strong></p>
<blockquote>
<p>引入箭头函数有两个方面的作用：更简短的函数并且不绑定 this</p>
</blockquote>
<p>箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：</p>
<ol>
<li>箭头函数<strong>没有 this</strong>，它会从自己的<strong>作用域链</strong>的上一层继承 this（因此无法使用 apply / call / bind 进行绑定 this 值）；</li>
<li>不可以使用 <strong>arguments 对象</strong>，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>不可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield">yield 命令</a>，因此箭头函数不能用作 Generator 函数。</li>
<li>无法使用 <strong>new 实例化对象</strong>，因为普通构造函数通过 new 实例化对象时 this 指向实例对象，而箭头函数没有 this 值，同时 箭头函数也没有 prototype。</li>
</ol>
<p>new 过程大致是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFunc</span>(<span class="params">father, ...rest</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">  result.__proto__ = father.prototype;</span><br><span class="line">  <span class="keyword">var</span> result2 = father.apply(result, rest);</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (<span class="keyword">typeof</span> result2 === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result2 === <span class="string">&quot;function&quot;</span>) &amp;&amp;</span><br><span class="line">    result2 !== <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> result2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-59-题-（2019-10-31）"><a href="#第-59-题-（2019-10-31）" class="headerlink" title="第 59 题 （2019/10/31）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/102">第 59 题</a> （2019/10/31）</h3><p><strong>题目：</strong> 给定两个数组，写一个方法来计算它们的交集。</p>
<blockquote>
<p>例如：给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">  nums2 = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="comment">// 有个问题， [NaN].indexOf(NaN) === -1</span></span><br><span class="line"><span class="keyword">var</span> newArr1 = nums1.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nums2.indexOf(item) &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">var</span> newArr2 = nums1.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> nums2.includes(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="第-60-题-（2019-10-31）"><a href="#第-60-题-（2019-10-31）" class="headerlink" title="第 60 题 （2019/10/31）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/105">第 60 题</a> （2019/10/31）</h3><p><strong>题目：</strong> 已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。</p>
<blockquote>
<p>&lt;img src=”1.jpg” style=”width:480px!important;”&gt;</p>
</blockquote>
<p><strong>解决方案：</strong></p>
<ol>
<li><code>max-width: 300px</code></li>
<li><code>transform: scale(0.625,0.625) </code></li>
<li><code>zoom: 0.625</code>; <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@viewport/zoom">MDN：zoom</a></li>
<li>解法：</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br><span class="line"><span class="selector-tag">padding</span>: 0 90<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>js：<code>document.getElementsByTagName(&#39;img&#39;)[0].style.width=&#39;300px&#39;</code></li>
</ol>
<h3 id="第-61-题-（2019-11-01）"><a href="#第-61-题-（2019-11-01）" class="headerlink" title="第 61 题 （2019/11/01）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/106">第 61 题</a> （2019/11/01）</h3><p><strong>题目：</strong> 介绍下如何实现 token 加密 ?</p>
<p><strong>解析：</strong></p>
<blockquote>
<p>这个题目是问：生成 token 的方法，比如 <strong>JWT</strong>，还是说利用加密算法，比如对称加密或者非对称加密 加密生成后的 token ?</p>
</blockquote>
<p>这边也是这么做的，后端根据 token 来查权限和是否登录以及失效等</p>
<blockquote>
<p>token 加密方式：</p>
<ul>
<li>服务器通过私钥对一部分信息进行加密生成签名，并将签名和数据拼接在一起作为 token 的一部分。例如 JWT。</li>
<li>使用客户端的 UA 或其他数据作为干扰码对 token 进行加密。</li>
</ul>
</blockquote>
<p>相关参考文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/e0ac7c3067eb">Token - 服务端身份验证的流行方案</a></li>
<li><a href="https://ninghao.net/blog/2834">基于 Token 的身份验证：JSON Web Token</a></li>
</ul>
<blockquote>
<p>jwt 举例</p>
<ol>
<li>需要一个 secret（随机数）</li>
<li>后端利用 secret 和加密算法(如：HMAC-SHA256)对 payload(如账号密码)生成一个字符串(token)，返回前端</li>
<li>前端每次 request 在 header 中带上 token</li>
<li>后端用同样的算法解密</li>
</ol>
</blockquote>
<p>这边也是这么做的，后端根据 token 来查权限和是否登录以及失效等</p>
<h3 id="第-62-题-（2019-11-01）"><a href="#第-62-题-（2019-11-01）" class="headerlink" title="第 62 题  （2019/11/01）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/107">第 62 题 </a> （2019/11/01）</h3><p><strong>题目：</strong> redux 为什么要把 reducer 设计成纯函数</p>
<p><strong>解析：</strong> 学习 react ~~</p>
<h3 id="第-63-题（2019-11-02）"><a href="#第-63-题（2019-11-02）" class="headerlink" title="第 63 题（2019/11/02）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/108">第 63 题</a>（2019/11/02）</h3><p><strong>题目：</strong> 如何设计实现无缝轮播如何设计实现无缝轮播</p>
<p><strong>解析：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">无限轮播基本插件都可以做到,不过要使用原生代码实现无缝滚动的话我可以提点思路,</span><br><span class="line">因为轮播图基本都在ul盒子里面的li元素,</span><br><span class="line">首先获取第一个li元素和最后一个li元素,</span><br><span class="line">克隆第一个li元素,和最后一个li元素,</span><br><span class="line">分别插入到lastli的后面和firstli的前面,</span><br><span class="line">然后监听滚动事件,如果滑动距离超过x或-x,让其实现跳转下一张图或者跳转上一张,(此处最好设置滑动距离),</span><br><span class="line">然后在滑动最后一张实现最后一张和克隆第一张的无缝转换,当到克隆的第一张的时候停下的时候,,让其切入真的第一张,则实现无线滑动,向前滑动同理</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-64-题（2019-11-02）"><a href="#第-64-题（2019-11-02）" class="headerlink" title="第 64 题（2019/11/02）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/109">第 64 题</a>（2019/11/02）</h3><p><strong>题目：</strong>模拟实现一个 Promise.finally</p>
<p><strong>知识点</strong> ：异步</p>
<p><strong>解析：</strong></p>
<h3 id="第-65-题-（2019-11-02）"><a href="#第-65-题-（2019-11-02）" class="headerlink" title="第 65 题 （2019/11/02）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/111">第 65 题</a> （2019/11/02）</h3><p><strong>题目：</strong> <code>a.b.c.d</code> 和 <code>a[&#39;b&#39;][&#39;c&#39;][&#39;d&#39;]</code>，哪个性能更高？</p>
<p><strong>解析：</strong></p>
<p>应该是 <code>a.b.c.d</code> 比 <code>a[&#39;b&#39;][&#39;c&#39;][&#39;d&#39;]</code> 性能高点，后者还要考虑 <code>[ ]</code> 中是变量的情况，再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点。<br>下图是两者的 <a href="https://segmentfault.com/a/1190000016231512">AST</a> (抽象语法树) 对比：</p>
<p><img src="https://user-images.githubusercontent.com/9009389/56872978-501d9a00-6a61-11e9-9e69-85ff00c031fc.png"></p>
<h3 id="第-66-题-（2019-11-02）"><a href="#第-66-题-（2019-11-02）" class="headerlink" title="第 66 题 （2019/11/02）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/112">第 66 题</a> （2019/11/02）</h3><p><strong>题目：</strong> ES6 代码转成 ES5 代码的实现思路是什么</p>
<p><strong>解析：</strong></p>
<p>回到正题上来，说到 ES6 代码转成 ES5 代码，我们肯定会想到 Babel。所以，我们可以参考 Babel 的实现方式。</p>
<p>那么 Babel 是如何把 ES6 转成 ES5 呢，其大致分为三步：</p>
<ul>
<li>将代码字符串解析成抽象语法树，即所谓的 <a href="https://segmentfault.com/a/1190000016231512">AST</a></li>
<li>对 <a href="https://segmentfault.com/a/1190000016231512">AST</a> 进行处理，在这个阶段可以对 ES6 代码进行相应转换，即转成 ES5 代码</li>
<li>根据处理后的 <a href="https://segmentfault.com/a/1190000016231512">AST</a> 再生成代码字符串</li>
</ul>
<p>基于此，其实我们自己就可以实现一个简单的“编译器”，用于把 ES6 代码转成 ES5。</p>
<p>比如，可以使用 <code>@babel/parser</code> 的 <code>parse</code> 方法，将代码字符串解析成 AST；使用 <code>@babel/core</code> 的 <code>transformFromAstSync</code> 方法，对 AST 进行处理，将其转成 ES5 并生成相应的代码字符串；过程中，可能还需要使用 <code>@babel/traverse</code> 来获取依赖文件等。对此感兴趣的可以看看<a href="https://github.com/FishPlusOrange/easy-webpack">这个</a>。</p>
<h3 id="第-67-题-（2019-11-03）"><a href="#第-67-题-（2019-11-03）" class="headerlink" title="第 67 题 （2019/11/03）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/113">第 67 题</a> （2019/11/03）</h3><p><strong>题目：</strong> 数组编程题</p>
<blockquote>
<p>随机生成一个长度为 10 的整数类型的数组，例如 <code>[2, 10, 3, 4, 5, 11, 10, 11, 20]</code>，将其排列成一个新数组，要求新数组形式如下，例如 <code>[[2, 3, 4, 5], [10, 11], [20]]</code>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	我理解是：去重排序数组后，分类连续数列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> initArr = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getRandomIntInclusive(<span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个两数之间的随机整数，包括两个数在内</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomIntInclusive</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  min = <span class="built_in">Math</span>.ceil(min);</span><br><span class="line">  max = <span class="built_in">Math</span>.floor(max);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min; <span class="comment">//含最大值，含最小值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newarr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">var</span> pre = <span class="number">0</span>,</span><br><span class="line">    cur = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> xarr = [newarr[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">var</span> Finllyarr = [];</span><br><span class="line">  <span class="keyword">while</span> (cur &lt;= newarr.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newarr[cur] - newarr[pre] === count) &#123;</span><br><span class="line">      xarr.push(newarr[cur]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pre = cur;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">      Finllyarr.push(xarr);</span><br><span class="line">      xarr = [newarr[pre]];</span><br><span class="line">    &#125;</span><br><span class="line">    cur++;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Finllyarr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(GetArr(initArr));</span><br></pre></td></tr></table></figure>

<h3 id="第-68-题-（2019-11-04）"><a href="#第-68-题-（2019-11-04）" class="headerlink" title="第 68 题 （2019/11/04）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/115">第 68 题</a> （2019/11/04）</h3><p><strong>题目：</strong> 如何解决移动端 Retina 屏 1px 像素问题</p>
<p><strong>解析：</strong> <a href="https://juejin.im/entry/584e427361ff4b006cd22c7c">7 种方法解决移动端 Retina 屏幕 1px 边框问题</a></p>
<ol>
<li>0.5px 边框</li>
<li>使用 border-image 实现</li>
<li>使用 background-image 实现</li>
<li>多背景渐变实现</li>
<li>使用 box-shadow 模拟边框</li>
<li>viewport + rem 实现</li>
<li>伪类 + transform 实现</li>
</ol>
<h3 id="第-69-题-（2019-11-07）"><a href="#第-69-题-（2019-11-07）" class="headerlink" title="第 69 题 （2019/11/07）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/116">第 69 题</a> （2019/11/07）</h3><p><strong>题目：</strong> 如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC’ 变成 ‘aBc’ 。</p>
<p>解析</p>
<ol>
<li>利用 ASCII 码 （A: 65 ，Z：90，a：97，z：122）</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Getstr</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">    .split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.charCodeAt() &lt;= <span class="number">90</span> &amp;&amp; item.charCodeAt() &gt;= <span class="number">65</span>)</span><br><span class="line">        <span class="keyword">return</span> item.toLowerCase();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> item.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用 小技巧</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Getstr</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">    .split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item === item.toUpperCase()</span><br><span class="line">        ? item.toLowerCase()</span><br><span class="line">        : item.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-70-题-（2019-11-08）"><a href="#第-70-题-（2019-11-08）" class="headerlink" title="第 70 题 （2019/11/08）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/118">第 70 题</a> （2019/11/08）</h3><p><strong>题目：</strong> 介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的</p>
<p><strong>解析：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1.当修改了一个或多个文件；</span><br><span class="line">2.文件系统接收更改并通知webpack；</span><br><span class="line">3.webpack重新编译构建一个或多个模块，并通知HMR服务器进行更新；</span><br><span class="line">4.HMR Server 使用webSocket通知HMR runtime 需要更新，HMR运行时通过HTTP请求更新jsonp；</span><br><span class="line">5.HMR运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-71-题-（2019-11-14）"><a href="#第-71-题-（2019-11-14）" class="headerlink" title="第 71 题 （2019/11/14）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/119">第 71 题</a> （2019/11/14）</h3><p><strong>题目：</strong> 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。</p>
<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为 T 的 length 是一定的，所以在循环S的的时候 ，循环当前项 i 后面至少还有 T.length 个元素</span></span><br><span class="line"><span class="keyword">const</span> find = <span class="function">(<span class="params">S, T</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (S.length &lt; T.length) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; S.length - T.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (S.substr(i, T.length) === T) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：</span></span><br><span class="line"><span class="keyword">const</span> find = <span class="function">(<span class="params">S, T</span>) =&gt;</span> S.search(T);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：</span></span><br><span class="line"><span class="keyword">const</span> find = <span class="function">(<span class="params">S, T</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> matched = S.match(T);</span><br><span class="line">  <span class="keyword">return</span> matched ? matched.index : <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第-72-题-（2019-11-15）"><a href="#第-72-题-（2019-11-15）" class="headerlink" title="第 72 题 （2019/11/15）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/121">第 72 题</a> （2019/11/15）</h3><p><strong>题目：</strong>为什么普通 <code>for</code> 循环的性能远远高于 <code>forEach</code> 的性能，请解释其中的原因。</p>
<p><strong>解析：</strong></p>
<ul>
<li>for 循环没有任何额外的函数调用栈和上下文；</li>
<li>forEach 函数签名实际上是</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>它不是普通的 for 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能；</p>
<h3 id="第-73-题-（2019-11-15）"><a href="#第-73-题-（2019-11-15）" class="headerlink" title="第 73 题 （2019/11/15）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/122">第 73 题</a> （2019/11/15）</h3><p><strong>题目：</strong> 介绍下 BFC、IFC、GFC 和 FFC</p>
<p><strong>解析：</strong></p>
<p><strong>BFC（Block formatting contexts）：块级格式上下文</strong><br>页面上的一个隔离的渲染区域，那么他是如何产生的呢？可以触发 BFC 的元素有 float、position、overflow、display：table-cell/ inline-block/table-caption ；BFC 有什么作用呢？比如说实现多栏布局’</p>
<p><strong>IFC（Inline formatting contexts）：内联格式上下文</strong><br>IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding/margin 影响)IFC 中的 line box 一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与与 line box 之间，使得 line box 宽度缩短。 同个 ifc 下的多个 line box 高度会不同<br>IFC 中时不可能有块级元素的，当插入块级元素时（如 p 中插入 div）会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。<br>那么 IFC 一般有什么用呢？<br>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。<br>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</p>
<p><strong>GFC（GrideLayout formatting contexts）：网格布局格式化上下文</strong><br>当为一个元素设置 display 值为 grid 的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。那么 GFC 有什么用呢，和 table 又有什么区别呢？首先同样是一个二维的表格，但 GridLayout 会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。</p>
<p><strong>FFC（Flex formatting contexts）:自适应格式上下文</strong><br>display 值为 flex 或者 inline-flex 的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少 safari 和 chrome 还是 OK 的，毕竟这俩在移动端才是王道。Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。</p>
<p><a href="http://www.cnblogs.com/dingyufenglian/p/4845477.html">在这</a></p>
<h3 id="第-74-题-（2019-11-16）"><a href="#第-74-题-（2019-11-16）" class="headerlink" title="第 74 题  （2019/11/16）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/123">第 74 题 </a> （2019/11/16）</h3><p><strong>题目：</strong> 使用 JavaScript Proxy 实现简单的数据绑定</p>
<p><strong>解析：</strong> ~~</p>
<h3 id="第-75-题-（2019-11-17）"><a href="#第-75-题-（2019-11-17）" class="headerlink" title="第 75 题 （2019/11/17）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/124">第 75 题</a> （2019/11/17）</h3><p><strong>题目：</strong> 数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少</p>
<p><strong>解析：</strong></p>
<p><strong>考点：</strong> <u>JavaScript 数组底层原理</u></p>
<p>数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)</p>
<p>得出结论：<strong>消耗时间几乎一致，差异可以忽略不计</strong></p>
<blockquote>
<p>Chrome 浏览器 JS 引擎 V8 中，数组有两种存储模式，一种是类似 C 语言中的线性结构存储（索引值连续，且都是正整数的情况下），一种是采用 Hash 结构存储（索引值为负数，数组稀疏，间隔比较大）；</p>
</blockquote>
<p>JavaScript 没有真正意义上的数组，所有的数组其实是对象，其“索引”看起来是数字，其实会被转换成字符串，作为属性名（对象的 key）来使用。所以无论是取第 1 个还是取第 10 万个元素，都是用 key 精确查找哈希表的过程，其消耗时间大致相同。</p>
<blockquote>
<p>推荐一下这篇文章：<a href="https://juejin.im/entry/59ae664d518825244d207196">深究 JavaScript 数组</a></p>
</blockquote>
<h3 id="第-76-题-（2019-11-17）"><a href="#第-76-题-（2019-11-17）" class="headerlink" title="第 76 题 （2019/11/17）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/125">第 76 题</a> （2019/11/17）</h3><blockquote>
<p>输出以下代码运行结果</p>
<p><strong>考点</strong> ：这题考察的是对象的键名的转换。</p>
<ul>
<li>对象的键名只能是字符串和 Symbol 类型。</li>
<li>其他类型的键名会被转换成字符串类型。</li>
<li>对象转字符串默认会调用 toString 方法。</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="string">&#x27;123&#x27;</span>, c=<span class="number">123</span>;</span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a[b]);  <span class="comment">//c</span></span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="built_in">Symbol</span>(<span class="string">&#x27;123&#x27;</span>), c=<span class="built_in">Symbol</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a[b]); <span class="comment">//b</span></span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">// example 3</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=&#123;<span class="attr">key</span>:<span class="string">&#x27;123&#x27;</span>&#125;, c=&#123;<span class="attr">key</span>:<span class="string">&#x27;456&#x27;</span>&#125;;</span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a[b]); <span class="comment">//c</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="string">&#x27;123&#x27;</span>, c=<span class="number">123</span>;</span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 的键名会被转换成字符串&#x27;123&#x27;，这里会把 b 覆盖掉。</span></span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 c</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=<span class="built_in">Symbol</span>(<span class="string">&#x27;123&#x27;</span>), c=<span class="built_in">Symbol</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b 是 Symbol 类型，不需要转换。</span></span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 是 Symbol 类型，不需要转换。任何一个 Symbol 类型的值都是不相等的，所以不会覆盖掉 b。</span></span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 b</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 3</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;&#125;, b=&#123;<span class="attr">key</span>:<span class="string">&#x27;123&#x27;</span>&#125;, c=&#123;<span class="attr">key</span>:<span class="string">&#x27;456&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b 不是字符串也不是 Symbol 类型，需要转换成字符串。</span></span><br><span class="line"><span class="comment">// 对象类型会调用 toString 方法转换成字符串 [object Object]。</span></span><br><span class="line">a[b]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 不是字符串也不是 Symbol 类型，需要转换成字符串。</span></span><br><span class="line"><span class="comment">// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。</span></span><br><span class="line">a[c]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 c</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-77-题-（2019-11-18）"><a href="#第-77-题-（2019-11-18）" class="headerlink" title="第 77 题 （2019/11/18）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/126">第 77 题</a> （2019/11/18）</h3><p><strong>题目：</strong></p>
<blockquote>
<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] 和 k = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: [<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步: [<span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">向右旋转 <span class="number">3</span> 步: [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">-1</span>, <span class="number">-100</span>, <span class="number">3</span>, <span class="number">99</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出: [<span class="number">3</span>, <span class="number">99</span>, <span class="number">-1</span>, <span class="number">-100</span>]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: [<span class="number">99</span>, <span class="number">-1</span>, <span class="number">-100</span>, <span class="number">3</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步: [<span class="number">3</span>, <span class="number">99</span>, <span class="number">-1</span>, <span class="number">-100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rotateArr</span>(<span class="params">arr, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    arr.unshift(arr.pop());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-78-题-（2019-11-18）"><a href="#第-78-题-（2019-11-18）" class="headerlink" title="第 78 题  （2019/11/18）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/128">第 78 题 </a> （2019/11/18）</h3><p><strong>题目</strong> ：Vue 的父组件和子组件生命周期钩子执行顺序是什么</p>
<p><strong>解析：</strong></p>
<blockquote>
<p>总结：<u>从外到内，再从内到外</u></p>
</blockquote>
<ol>
<li>加载渲染过程<br><code>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</code></li>
<li>子组件更新过程<br><code>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</code></li>
<li>父组件更新过程<br><code>父beforeUpdate-&gt;父updated</code></li>
<li>销毁过程<br><code>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</code></li>
</ol>
<p><img src="https://segmentfault.com/img/bVbePUv?w=302&h=298"></p>
<h3 id="第-79-题-（2019-11-18）"><a href="#第-79-题-（2019-11-18）" class="headerlink" title="第 79 题 （2019/11/18）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/129">第 79 题</a> （2019/11/18）</h3><p><strong>题目：</strong> input 搜索如何防抖，如何处理中文输入</p>
<p><strong>解析：</strong> <a href="https://segmentfault.com/a/1190000013094932">input 事件中文触发多次问题研究</a></p>
<p>简易防抖：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-80-题-（2019-11-19）"><a href="#第-80-题-（2019-11-19）" class="headerlink" title="第 80 题 （2019/11/19）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/130">第 80 题</a> （2019/11/19）</h3><p><strong>题目：</strong> 介绍下 Promise.all 使用、原理实现及错误处理</p>
<h3 id="第-81-题-（2019-11-19）"><a href="#第-81-题-（2019-11-19）" class="headerlink" title="第 81 题 （2019/11/19）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/131">第 81 题</a> （2019/11/19）</h3><p><strong>题目：</strong> 打印出 1 - 10000 之间的所有对称数</p>
<blockquote>
<p>例如：121、1331 等</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num.toString() === num.toString().split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (f(i)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-82-题-（2019-11-19）"><a href="#第-82-题-（2019-11-19）" class="headerlink" title="第 82 题 （2019/11/19）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/132">第 82 题</a> （2019/11/19）</h3><blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">12</span>];</span><br><span class="line">输出: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<ol>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ol>
</blockquote>
<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Movezero</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] != <span class="number">0</span>) &#123;</span><br><span class="line">      arr[index++] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; arr.length) &#123;</span><br><span class="line">    arr[index++] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-83-题-（2019-11-20）"><a href="#第-83-题-（2019-11-20）" class="headerlink" title="第 83 题 （2019/11/20）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/133">第 83 题</a> （2019/11/20）</h3><p><strong>题目：</strong> var、let 和 const 区别的实现原理是什么</p>
<p><strong>解析：</strong></p>
<p><strong>区别：</strong></p>
<ol>
<li><p>var 声明的变量会挂载在 window 上，而 let 和 const 声明的变量不会</p>
</li>
<li><p>var 声明变量存在变量提升，let 和 const 不存在变量提升</p>
</li>
<li><p>let 和 const 声明形成块作用域，而 var 不存在此作用域</p>
</li>
<li><p>同一作用域下 let 和 const 不能声明同名变量，而 var 可以</p>
</li>
<li><p>let、const 存在暂存死区</p>
</li>
<li><p>const</p>
<ol>
<li>一旦声明必须赋值,不能使用 null 占位。</li>
<li>声明后不能再修改</li>
<li>如果声明的是复合类型数据，可以修改其属性*</li>
</ol>
</li>
</ol>
<p><strong>var、let、const 实现原理</strong></p>
<p>记得 JS 权威指南中有一句很精辟的描述:　”JavaScript 中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里.”</p>
<p>以下属于推测，在网上没查到确凿的原理机制（若有误望指正）：</p>
<p>原理大概是：在 js 解析的时候，优先解析 const，因为它不能修改的是栈内存在的值和地址。然后解析 let 因为没有块作用域可能底层有处理，最后解析 var</p>
<h3 id="第-84-题-（2019-11-21）"><a href="#第-84-题-（2019-11-21）" class="headerlink" title="第 84 题 （2019/11/21）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/134">第 84 题</a> （2019/11/21）</h3><p><strong>题目：</strong> 请实现一个 add 函数，满足以下功能。</p>
<p><strong>知识点</strong> ：函数柯里化 <a href="https://github.com/chokcoco/cnblogsArticle/issues/15">题解</a> <u>运用了函数会自行调用 <code>valueOf</code> 方法这个技巧</u></p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>); 			<span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);  	<span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)；<span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>之前参阅 2 篇文章，可以参考一二。<br>1、<a href="https://github.com/yygmind/blog/issues/36#%E6%80%9D%E8%80%83%E9%A2%98">【进阶 6-1 期】JavaScript 高阶函数浅析</a><br>2、<a href="https://github.com/yygmind/blog/issues/37">【进阶 6-2 期】深入高阶函数应用之柯里化</a></p>
<p>其中第一篇文章给出了前三个功能的实现，并没有覆盖到后面三种。<br>第二篇文章实现了一个通用的柯里化函数，覆盖实现了所有功能。</p>
<p><strong>解析：</strong></p>
<p><strong>去重</strong>（ <u>数字组数</u> ） ：使用高阶函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = arr1.filter(<span class="function">(<span class="params">element, index, self</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> self.indexOf(element) === index;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br><span class="line"><span class="comment">// [1, 2, 3, 5, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="comment">// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]</span></span><br></pre></td></tr></table></figure>

<p>函数作为返回值输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isType = <span class="function">(<span class="params">type</span>) =&gt;</span> <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">&quot;[object &quot;</span> + type + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">isType(<span class="string">&quot;String&quot;</span>)(<span class="string">&quot;123&quot;</span>); <span class="comment">// true</span></span><br><span class="line">isType(<span class="string">&quot;Array&quot;</span>)([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// true</span></span><br><span class="line">isType(<span class="string">&quot;Number&quot;</span>)(<span class="number">123</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;进入add&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arg_fn = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;调用fn&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> add.apply(<span class="literal">null</span>, args.concat(arg_fn));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  fn.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;调用valueOf&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    add(1);</span></span><br><span class="line"><span class="comment">    // 输出如下：</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用valueOf</span></span><br><span class="line"><span class="comment">    // 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    add(1)(2);</span></span><br><span class="line"><span class="comment">    // 输出如下：</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用fn</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用valueOf</span></span><br><span class="line"><span class="comment">    // 3</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    add(1)(2)(3);</span></span><br><span class="line"><span class="comment">    // 输出如下：</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用fn</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用fn</span></span><br><span class="line"><span class="comment">    // 进入add</span></span><br><span class="line"><span class="comment">    // 调用valueOf</span></span><br><span class="line"><span class="comment">    // 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里有个规律，如果只改写 <code>valueOf()</code> 或是 <code>toString()</code> 其中一个，会优先调用被改写了的方法，而如果两个同时改写，则会像 String 转换规则一样，优先查询 <code>valueOf()</code> 方法，在 <code>valueOf() </code>方法返回的是非原始类型的情况下再查询 <code>toString()</code> 方法。</p>
<h3 id="第-85-题-（2019-11-23）"><a href="#第-85-题-（2019-11-23）" class="headerlink" title="第 85 题 （2019/11/23）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/135">第 85 题</a> （2019/11/23）</h3><p><strong>题目：</strong> react-router 里的 <code>&lt;Link&gt;</code> 标签和 <code>&lt;a&gt;</code> 标签有什么区别</p>
<blockquote>
<p>如何禁掉 <code>&lt;a&gt;</code> 标签默认事件，禁掉之后如何实现跳转。</p>
</blockquote>
<p><strong>解析：</strong></p>
<p>从最终渲染的 DOM 来看，这两者都是链接，都是 <code>&lt;a&gt;</code> 标签，区别是：<br><code>&lt;Link&gt;</code> 是 react-router 里实现路由跳转的链接，一般配合 <code>&lt;Route&gt;</code> 使用，react-router 接管了其默认的链接跳转行为，区别于传统的页面跳转，<code>&lt;Link&gt;</code> 的“跳转”行为只会触发相匹配的 <code>&lt;Route&gt;</code> 对应的页面内容更新，而不会刷新整个页面。<br>而 <code>&lt;a&gt;</code> 标签就是普通的超链接了，用于从当前页面跳转到 href 指向的另一个页面（非锚点情况）。</p>
<h3 id="第-86-题-（2019-11-23）"><a href="#第-86-题-（2019-11-23）" class="headerlink" title="第 86 题 （2019/11/23）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/136">第 86 题</a> （2019/11/23）</h3><p><strong>题目：</strong> 周一算法题之「两数之和」</p>
<blockquote>
<p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p>
<p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>公司</strong> ：京东、快手</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Getarr</span>(<span class="params">num, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pre = <span class="number">0</span>,</span><br><span class="line">    cur = num.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (num.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;至少提供2个数字&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (pre &lt; cur) &#123;</span><br><span class="line">    result = num[pre] + num[cur];</span><br><span class="line">    <span class="keyword">if</span> (result &gt; target) &#123;</span><br><span class="line">      cur--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &lt; target) &#123;</span><br><span class="line">      pre++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> [pre, cur];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-87-题-（2019-11-24）"><a href="#第-87-题-（2019-11-24）" class="headerlink" title="第 87 题 （2019/11/24）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/138">第 87 题</a> （2019/11/24）</h3><p><strong>题目：</strong>在输入框中如何判断输入的是一个正确的网址。</p>
<p><strong>解析：</strong> <u>location 可以获取本页面的 URL 信息</u></p>
<blockquote>
<p>不上正则，一个简单的玩法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUrl</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">	a.href = url</span><br><span class="line">	<span class="keyword">return</span> [</span><br><span class="line">		/^(http|https):$/.test(a.protocol), <span class="comment">// &quot;https:&quot; 协议</span></span><br><span class="line">		a.host,  						<span class="comment">//  &quot;baidu.com&quot; =&gt; 端口（port）</span></span><br><span class="line">		a.pathname !== url,				<span class="comment">// &quot;/&quot;</span></span><br><span class="line">		a.pathname !== <span class="string">`/<span class="subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">	].find(<span class="function"><span class="params">x</span> =&gt;</span> !x) === <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用 <code>URL()</code> 构造函数返回一个新创建的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL"><code>URL</code></a> 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUrl</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> URL(url);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isUrl = <span class="function">(<span class="params">urlStr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; href, origin, host, hostname, pathname &#125; = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">    <span class="keyword">return</span> href &amp;&amp; origin &amp;&amp; host &amp;&amp; hostname &amp;&amp; pathname &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>正则：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^(https?:\/\/)?([a-z0<span class="number">-9</span>]\.|[a-z0<span class="number">-9</span>][-a-z0<span class="number">-9</span>]*[a-z0<span class="number">-9</span>]\.)*([a-z]+)(:\d+)?(\/.*)?$/;</span><br></pre></td></tr></table></figure>

<h3 id="第-88-题-（2019-12-04）"><a href="#第-88-题-（2019-12-04）" class="headerlink" title="第 88 题 （2019/12/04）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/139">第 88 题</a> （2019/12/04）</h3><p>以下数据结构中，id 代表部门编号，name 是部门名称，parentId 是父部门编号，为 0 代表一级部门，现在要求实现一个 convert 方法，把原始 list 转换成树形结构，parentId 为多少就挂载在该 id 的属性 children 数组下，结构如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始 list 如下</span></span><br><span class="line"><span class="keyword">let</span> list =[</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">&#x27;部门A&#x27;</span>,<span class="attr">parentId</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">&#x27;部门B&#x27;</span>,<span class="attr">parentId</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:<span class="string">&#x27;部门C&#x27;</span>,<span class="attr">parentId</span>:<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">4</span>,<span class="attr">name</span>:<span class="string">&#x27;部门D&#x27;</span>,<span class="attr">parentId</span>:<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">5</span>,<span class="attr">name</span>:<span class="string">&#x27;部门E&#x27;</span>,<span class="attr">parentId</span>:<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">6</span>,<span class="attr">name</span>:<span class="string">&#x27;部门F&#x27;</span>,<span class="attr">parentId</span>:<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">7</span>,<span class="attr">name</span>:<span class="string">&#x27;部门G&#x27;</span>,<span class="attr">parentId</span>:<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">8</span>,<span class="attr">name</span>:<span class="string">&#x27;部门H&#x27;</span>,<span class="attr">parentId</span>:<span class="number">4</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> result = convert(list, ...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换后的结果如下</span></span><br><span class="line"><span class="keyword">let</span> result = [</span><br><span class="line">    &#123;</span><br><span class="line">      id: <span class="number">1</span>,</span><br><span class="line">      name: <span class="string">&#x27;部门A&#x27;</span>,</span><br><span class="line">      parentId: <span class="number">0</span>,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: <span class="number">3</span>,</span><br><span class="line">          name: <span class="string">&#x27;部门C&#x27;</span>,</span><br><span class="line">          parentId: <span class="number">1</span>,</span><br><span class="line">          children: [</span><br><span class="line">            &#123;</span><br><span class="line">              id: <span class="number">6</span>,</span><br><span class="line">              name: <span class="string">&#x27;部门F&#x27;</span>,</span><br><span class="line">              parentId: <span class="number">3</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">              id: <span class="number">16</span>,</span><br><span class="line">              name: <span class="string">&#x27;部门L&#x27;</span>,</span><br><span class="line">              parentId: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: <span class="number">4</span>,</span><br><span class="line">          name: <span class="string">&#x27;部门D&#x27;</span>,</span><br><span class="line">          parentId: <span class="number">1</span>,</span><br><span class="line">          children: [</span><br><span class="line">            &#123;</span><br><span class="line">              id: <span class="number">8</span>,</span><br><span class="line">              name: <span class="string">&#x27;部门H&#x27;</span>,</span><br><span class="line">              parentId: <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">  ···</span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong> ~~</p>
<h3 id="第-89-题-（2019-12-04）"><a href="#第-89-题-（2019-12-04）" class="headerlink" title="第 89 题 （2019/12/04）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/140">第 89 题</a> （2019/12/04）</h3><p><strong>题目</strong> ：设计并实现 Promise.race()</p>
<p><strong>解析：</strong> 代写~</p>
<h3 id="第-90-题-（2019-12-05）"><a href="#第-90-题-（2019-12-05）" class="headerlink" title="第 90 题 （2019/12/05）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/141">第 90 题</a> （2019/12/05）</h3><p><strong>题目：</strong> 实现模糊搜索结果的关键词高亮显示</p>
<p><img src="http://static.zxinc520.com/blog/20191205/sF0nw6wEI0qf.png?imageslim" alt="mark"></p>
<blockquote>
<p>考虑节流、缓存。其实还可以上列表 diff+定时清理缓存</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>auto complete<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      bdi &#123;</span><br><span class="line">        color: rgb(0, 136, 255);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      li &#123;</span><br><span class="line">        list-style: none;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;inp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, timeout = <span class="number">300</span></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> t;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span></span><br><span class="line">        if (t) &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">clearTimeout</span>(t);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        t = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line">          fn.apply(fn, args);</span><br><span class="line">        &#125;, timeout);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">fn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span></span><br><span class="line">        if (!name) &#123;</span><br><span class="line"><span class="javascript">          container.innerHTML = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        if (cache.get(name)) &#123;</span><br><span class="line">          container.innerHTML = cache.get(name);</span><br><span class="line"><span class="javascript">          <span class="keyword">return</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> res = fn.call(fn, name).join(<span class="string">&quot;&quot;</span>);</span></span><br><span class="line">        cache.set(name, res);</span><br><span class="line">        container.innerHTML = res;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">handleInput</span>(<span class="params">value</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`\(<span class="subst">$&#123;value&#125;</span>\)`</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> search = data.reduce(<span class="function">(<span class="params">res, cur</span>) =&gt;</span> &#123;</span></span><br><span class="line">        if (reg.test(cur)) &#123;</span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> match = <span class="built_in">RegExp</span>.$<span class="number">1</span>;</span></span><br><span class="line"><span class="handlebars"><span class="xml">          res.push(`<span class="tag">&lt;<span class="name">li</span>&gt;</span>$&#123;cur.replace(match, &quot;<span class="tag">&lt;<span class="name">bdi</span>&gt;</span>$&amp;<span class="tag">&lt;/<span class="name">bdi</span>&gt;</span>&quot;)&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>`);</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> res;</span></span><br><span class="line">      &#125;, []);</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> search;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> data = [</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;上海野生动物园&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;上饶野生动物园&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;北京巷子&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;上海中心&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;上海黄埔江&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;迪士尼上海&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;陆家嘴上海中心&quot;</span>,</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> container = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.container&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> memorizeInput = memorize(handleInput);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">&quot;.inp&quot;</span>).addEventListener(</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;input&quot;</span>,</span></span><br><span class="line"><span class="javascript">      debounce(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.target.value);</span></span><br><span class="line">        memorizeInput(e.target.value);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="第-91-题-（2019-12-05）"><a href="#第-91-题-（2019-12-05）" class="headerlink" title="第 91 题 （2019/12/05）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/142">第 91 题</a> （2019/12/05）</h3><p><strong>题目：</strong> 介绍下 HTTPS 中间人攻击</p>
<p><strong>解析：</strong></p>
<p>https 协议由 http + ssl 协议构成，具体的链接过程可参考<a href="https://github.com/lvwxx/blog/issues/3">SSL 或 TLS 握手的概述</a></p>
<p>中间人攻击过程如下：</p>
<ol>
<li>服务器向客户端发送公钥。</li>
<li>攻击者截获公钥，保留在自己手上。</li>
<li>然后攻击者自己生成一个【伪造的】公钥，发给客户端。</li>
<li>客户端收到伪造的公钥后，生成加密 hash 值发给服务器。</li>
<li>攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥。</li>
<li>同时生成假的加密 hash 值，发给服务器。</li>
<li>服务器用私钥解密获得假秘钥。</li>
<li>服务器用加秘钥加密传输信息</li>
</ol>
<p>防范方法：</p>
<ol>
<li>服务端在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性</li>
</ol>
<h3 id="第-92-题-（2019-12-15）"><a href="#第-92-题-（2019-12-15）" class="headerlink" title="第 92 题 （2019/12/15）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/143">第 92 题</a> （2019/12/15）</h3><p><strong>题目：</strong>已知数据格式，实现一个函数 fn 找出链条中所有的父级 id</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="string">&#x27;112&#x27;</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">fn(value) <span class="comment">// 输出 [1， 11， 112]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="string">&quot;112&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">    arr.push(value.slice(<span class="number">0</span>, i + <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.map(<span class="built_in">Number</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第-93-题-（2019-12-15）"><a href="#第-93-题-（2019-12-15）" class="headerlink" title="第 93 题 （2019/12/15）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/144">第 93 题</a> （2019/12/15）</h3><p><strong>题目：</strong> 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log(m+n))。</p>
<p>示例 1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line">nums2 = [<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>中位数是 2.0</p>
<p>示例 2：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">nums2 = [<span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>中位数是(2 + 3) / 2 = 2.5</p>
<p><strong>解析：</strong></p>
<h3 id="第-94-题-（2019-12-15）"><a href="#第-94-题-（2019-12-15）" class="headerlink" title="第 94 题 （2019/12/15）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/145">第 94 题</a> （2019/12/15）</h3><p><strong>题目：</strong> vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？</p>
<p><strong>解析:</strong></p>
<blockquote>
<p>Well, delegation has two main advantages: one is practical - it saves you from having to add (and remove!!) those listeners individually. But Vue already does that for you.</p>
<p>The other one is performance / memory. But since every click listener in a v-vor loop would use the same callback, this is minimal unless you have hundreds or thousands of rows.</p>
<p>And finally, you can use delegation pretty easily by adding an @click listener to the <ul> element instead of the children. But then you have to resort to checks on the click target to evaluate which item in your data it might represent. So I would only use that if you truly find any performance problems without delegation.</p>
</blockquote>
<p>好，委派有两个主要优点：一个是实用的-它使您不必分别添加（和删除！）这些侦听器。 但是 Vue 已经为您做到了。</p>
<p>另一个是性能/内存。 但是，由于 v-vor 循环中的每个单击侦听器都将使用相同的回调，因此除非您有成百上千的行，否则这是最小的。</p>
<p>最后，您可以通过在&lt;_ul_ &gt;元素（而不是子元素）中添加@click 侦听器来轻松使用委派。 但是随后，您必须求助于点击目标，以评估数据中可能代表的项目。 因此，只有在您真正发现任何性能问题而没有委派的情况下，我才使用它。</p>
<h3 id="第-95-题-（2019-12-23）"><a href="#第-95-题-（2019-12-23）" class="headerlink" title="第 95 题 （2019/12/23）"></a><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/148">第 95 题</a> （2019/12/23）</h3><p><strong>题目：</strong> 模拟实现一个深拷贝，并考虑对象相互引用以及 Symbol 拷贝的情况</p>
<p><strong>解析：</strong></p>
<blockquote>
<p>一个不考虑其他数据类型的公共方法，基本满足大部分场景</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">target, cache = new Set()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&quot;object&quot;</span> || cache.has(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target)) &#123;</span><br><span class="line">    target.map(<span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line">      cache.add(t);</span><br><span class="line">      <span class="keyword">return</span> t;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      ...Object.keys(target),</span><br><span class="line">      ...Object.getOwnPropertySymbols(target),</span><br><span class="line">    ].reduce(</span><br><span class="line">      (res, key) =&gt; &#123;</span><br><span class="line">        cache.add(target[key]);</span><br><span class="line">        res[key] = deepCopy(target[key], cache);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">      &#125;,</span><br><span class="line">      target.constructor !== <span class="built_in">Object</span></span><br><span class="line">        ? <span class="built_in">Object</span>.create(target.constructor.prototype)</span><br><span class="line">        : &#123;&#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要问题是</p>
<ol>
<li>symbol 作为 key，不会被遍历到，所以 stringify 和 parse 是不行的</li>
<li>有环引用，stringify 和 parse 也会报错</li>
</ol>
<p>我们另外用<code>getOwnPropertySymbols</code>可以获取 symbol key 可以解决问题 1，用集合记忆曾经遍历过的对象可以解决问题 2。当然，还有很多数据类型要独立去拷贝。比如拷贝一个 RegExp，lodash 是最全的数据类型拷贝了，有空可以研究一下</p>
<p>另外，如果不考虑用 symbol 做 key，还有两种黑科技深拷贝，可以解决环引用的问题，比 stringify 和 parse 优雅强一些</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopyByHistory</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prev = history.state;</span><br><span class="line">  history.replaceState(target, <span class="built_in">document</span>.title);</span><br><span class="line">  <span class="keyword">const</span> res = history.state;</span><br><span class="line">  history.replaceState(prev, <span class="built_in">document</span>.title);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">deepCopyByMessageChannel</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">    channel.port2.onmessage = <span class="function">(<span class="params">ev</span>) =&gt;</span> resolve(ev.data);</span><br><span class="line">    channel.port1.postMessage(target);</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论哪种方法，它们都有一个共性：失去了继承关系，所以剩下的需要我们手动补上去了，故有<code>Object.create(target.constructor.prototype)</code>的操作</p>
</blockquote>
<p>有两个问题：</p>
<ol>
<li>如果 <code>target</code> 是一个数组，拷贝结果没有返回</li>
<li>如果 <code>target</code> 是一个函数，函数没有被深拷贝</li>
</ol>
]]></content>
      <categories>
        <category>牛人面试题</category>
        <category>木易杨每日一题</category>
      </categories>
      <tags>
        <tag>牛人面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>【Step-By-Step】一周面试题深入解析</title>
    <url>/2019/09/20/Step-By-Step/</url>
    <content><![CDATA[<h2 id="【Step-By-Step】一周面试题深入解析-周刊-01"><a href="#【Step-By-Step】一周面试题深入解析-周刊-01" class="headerlink" title="【Step-By-Step】一周面试题深入解析 / 周刊 01"></a>【Step-By-Step】一周面试题深入解析 / 周刊 01</h2><blockquote>
<p>已完结~</p>
<p>今天 2019/11/04 😜 (ง •_•)ง</p>
</blockquote>
<h3 id="1-如何正确判断-this-的指向？-2019-09-19"><a href="#1-如何正确判断-this-的指向？-2019-09-19" class="headerlink" title="1.如何正确判断 this 的指向？(2019-09-19)"></a>1.如何正确判断 this 的指向？(2019-09-19)</h3><p>如果用一句话说明 this 的指向，那么即是: 谁调用它，this 就指向谁。</p>
<p>但是仅通过这句话，我们很多时候并不能准确判断 this 的指向。因此我们需要借助一些规则去帮助自己：</p>
<p>this 的指向可以按照以下顺序判断:</p>
<p><strong>1、全局环境中的 this</strong></p>
<p>浏览器环境：无论是否在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式</a> 下，在全局执行环境中（在任何函数体外部）this 都指向全局对象 <code>window</code>;</p>
<p>node 环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部），this 都是空对象 <code>&#123;&#125;</code></p>
<p><strong>2、是否是 <code>new</code> 绑定</strong></p>
<p>如果是 <code>new</code> 绑定，并且构造函数中没有返回 function 或者是 object，那么 this 指向这个新对象。如下:</p>
<blockquote>
<p>构造函数返回值不是 function 或 object。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> Super(<span class="string">&quot;26&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance.age); <span class="comment">//26</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造函数返回值是 function 或 object，这种情况下 this 指向的是返回的对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">&quot;2&quot;</span> &#125;;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> Super(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance.age); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>你可以想知道为什么会这样？我们来看一下 <code>new</code> 的实现原理:</p>
<ol>
<li>创建一个新对象。</li>
<li>这个新对象会被执行 <code>[[原型]]</code> 连接。</li>
<li>属性和方法被加入到 this 引用的对象中。并执行了构造函数中的方法.</li>
<li>如果函数没有返回其他对象，那么 this 指向这个新对象，否则 this 指向构造函数中返回的对象。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line">  target.__proto__ = func.prototype;</span><br><span class="line">  <span class="keyword">let</span> res = func.call(target);</span><br><span class="line">  <span class="comment">//排除 null 的情况</span></span><br><span class="line">  <span class="keyword">if</span> ((res &amp;&amp; <span class="keyword">typeof</span> res == <span class="string">&quot;object&quot;</span>) || <span class="keyword">typeof</span> res == <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3</strong>、函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么 this 绑定的就是指定的对象【归结为显式绑定】。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  info,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">var</span> info = person.info;</span><br><span class="line">info.call(person); <span class="comment">//20</span></span><br><span class="line">info.apply(person); <span class="comment">//20</span></span><br><span class="line">info.bind(person)(); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<p>这里同样需要注意一种<strong>特殊</strong>情况，如果 call,apply 或者 bind 传入的第一个参数值是 <code>undefined</code> 或者 <code>null</code>，严格模式下 this 的值为传入的值 null /undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node 环境为 global，浏览器环境为 window)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//node环境中:非严格模式 global，严格模式为null</span></span><br><span class="line">  <span class="comment">//浏览器环境中:非严格模式 window，严格模式为null</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  info,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">var</span> info = person.info;</span><br><span class="line"><span class="comment">//严格模式抛出错误；</span></span><br><span class="line"><span class="comment">//非严格模式，node下输出undefined（因为全局的age不会挂在 global 上）</span></span><br><span class="line"><span class="comment">//非严格模式。浏览器环境下输出 28（因为全局的age会挂在 window 上）</span></span><br><span class="line">info.call(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><strong>4、</strong>隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: <code>xxx.fn()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  info,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line">person.info(); <span class="comment">//20;执行的是隐式绑定</span></span><br></pre></td></tr></table></figure>

<p><strong>5、</strong> 默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。</p>
<p>非严格模式： node 环境，执行全局对象 global，浏览器环境，执行全局对象 window。</p>
<p>严格模式：执行 undefined</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="comment">//严格模式；抛错</span></span><br><span class="line"><span class="comment">//非严格模式，node下输出 undefined（因为全局的age不会挂在 global 上）</span></span><br><span class="line"><span class="comment">//非严格模式。浏览器环境下输出 28（因为全局的age会挂在 window 上）</span></span><br><span class="line"><span class="comment">//严格模式抛出，因为 this 此时是 undefined</span></span><br><span class="line">info();</span><br></pre></td></tr></table></figure>

<p><strong>6、</strong> 箭头函数的情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  info: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.age); <span class="comment">//this继承的是外层上下文绑定的this</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">age</span>: <span class="number">28</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> info = obj.info();</span><br><span class="line">info(); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> info2 = obj.info.call(person);</span><br><span class="line">info2(); <span class="comment">//28</span></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/YvetteLau/Step-By-Step/issues/1">点击查看更多</a></p>
<h3 id="2-JS-中原始类型有哪几种？null-是对象吗？原始数据类型和复杂数据类型有什么区别？-2019-09-20"><a href="#2-JS-中原始类型有哪几种？null-是对象吗？原始数据类型和复杂数据类型有什么区别？-2019-09-20" class="headerlink" title="2.JS 中原始类型有哪几种？null 是对象吗？原始数据类型和复杂数据类型有什么区别？(2019-09-20)"></a>2.JS 中原始类型有哪几种？null 是对象吗？原始数据类型和复杂数据类型有什么区别？(2019-09-20)</h3><p><strong>目前，JS 原始类型有六种，分别为:</strong></p>
<ul>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Undefined</li>
<li>Null</li>
<li>Symbol(ES6 新增)</li>
</ul>
<p>ES10 新增了一种基本数据类型：BigInt</p>
<p>复杂数据类型只有一种: Object</p>
<p>null 不是一个对象，尽管 <code>typeof null</code> 输出的是 <code>object</code>，这是一个历史遗留问题，JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，<code>null</code> 表示为全零，所以将它错误的判断为 <code>object</code> 。</p>
<p><strong>基本数据类型和复杂数据类型的区别为:</strong></p>
<p>1、内存的分配不同</p>
<ul>
<li>基本数据类型存储在栈中。</li>
<li>复杂数据类型存储在堆中，栈中存储的变量，是指向堆中的引用地址。</li>
</ul>
<p>2、访问机制不同</p>
<ul>
<li>基本数据类型是按值访问</li>
<li>复杂数据类型按引用访问，JS 不允许直接访问保存在堆内存中的对象，在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值。</li>
</ul>
<p>3、复制变量时不同(a=b)</p>
<ul>
<li>基本数据类型：a=b;是将 b 中保存的原始值的副本赋值给新变量 a，a 和 b 完全独立，互不影响</li>
<li>复杂数据类型：a=b;将 b 保存的对象内存的引用地址赋值给了新变量 a;a 和 b 指向了同一个堆内存地址，其中一个值发生了改变，另一个也会改变。</li>
</ul>
<p>4、参数传递的不同(实参/形参)</p>
<p>函数传参都是按值传递(栈中的存储的内容)：基本数据类型，拷贝的是值；复杂数据类型，拷贝的是引用地址</p>
<blockquote>
<p><a href="https://github.com/YvetteLau/Step-By-Step/issues/5">点击查看更多</a></p>
</blockquote>
<h3 id="3-说一说你对-HTML5-语义化的理解-2019-09-21"><a href="#3-说一说你对-HTML5-语义化的理解-2019-09-21" class="headerlink" title="3.说一说你对 HTML5 语义化的理解(2019-09-21)"></a>3.说一说你对 HTML5 语义化的理解(2019-09-21)</h3><p>语义化意味着顾名思义，HTML5 的语义化指的是合理正确的使用语义化的标签来创建页面结构，如 header,footer,nav，从标签上即可以直观的知道这个标签的作用，而不是滥用 div。</p>
<p><strong>语义化的优点有:</strong></p>
<ul>
<li>代码结构清晰，易于阅读，利于开发和维护</li>
<li>方便其他设备解析（如屏幕阅读器）根据语义渲染网页。</li>
<li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</li>
<li></li>
</ul>
<h3 id="4-如何让-a-1-amp-amp-a-2-amp-amp-a-3-的值为-true？-2019-09-22"><a href="#4-如何让-a-1-amp-amp-a-2-amp-amp-a-3-的值为-true？-2019-09-22" class="headerlink" title="4.如何让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 的值为 true？(2019-09-22)"></a>4.如何让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 的值为 true？(2019-09-22)</h3><blockquote>
<p><a href="https://github.com/YvetteLau/Blog/issues/31">可参考</a></p>
</blockquote>
<p><strong>4.1 利用隐式转换规则</strong></p>
<p><code>==</code> 操作符在左右数据类型不一致时，会先进行隐式转换。</p>
<p><code>a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</code> 的值意味着其不可能是基本数据类型。因为如果 a 是 null 或者是 undefined bool 类型，都不可能返回 true。</p>
<p>因此可以推测 a 是复杂数据类型，JS 中复杂数据类型只有 <code>object</code>，回忆一下，Object 转换为原始类型会调用什么方法？</p>
<ul>
<li>如果部署了 <code>[Symbol.toPrimitive]</code> 接口，那么调用此接口，若返回的不是基本数据类型，抛出错误。</li>
<li>如果没有部署 <code>[Symbol.toPrimitive]</code> 接口，那么根据要转换的类型，先调用 <code>valueOf</code> / <code>toString</code><ol>
<li>非 Date 类型对象，<code>hint</code> 是 <code>default</code> 时，调用顺序为：<code>valueOf</code> &gt;&gt;&gt; <code>toString</code>，即<code>valueOf</code> 返回的不是基本数据类型，才会继续调用 <code>toString</code>，如果<code>toString</code> 返回的还不是基本数据类型，那么抛出错误。</li>
<li>如果 <code>hint</code> 是 <code>string</code>(Date 对象的 hint 默认是 string) ，调用顺序为：<code>toString</code> &gt;&gt;&gt; <code>valueOf</code>，即<code>toString</code> 返回的不是基本数据类型，才会继续调用 <code>valueOf</code>，如果<code>valueOf</code> 返回的还不是基本数据类型，那么抛出错误。</li>
<li>如果 <code>hint</code> 是 <code>number</code>，调用顺序为： <code>valueOf</code> &gt;&gt;&gt; <code>toString</code></li>
</ol>
</li>
</ul>
<p>那么对于这道题，只要 <code>[Symbol.toPrimitive]</code> 接口，第一次返回的值是 1，然后递增，即成功成立。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]: (<span class="function"><span class="keyword">function</span> (<span class="params">hint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//闭包的特性之一：i 不会被回收</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>调用 <code>valueOf</code> 接口的情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  valueOf: (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//闭包的特性之一：i 不会被回收</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>另外，除了 i 自增的方法外，还可以利用 正则，如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  reg: <span class="regexp">/\d/g</span>,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.reg.exec(<span class="number">123</span>)[<span class="number">0</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>4.2 利用数据劫持</strong></p>
<p>使用 <code>Object.defineProperty</code> 定义的属性，在获取属性时，会调用 <code>get</code> 方法。利用这个特性，我们在 <code>window</code> 对象上定义 <code>a</code> 属性，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i++;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>ES6 新增了 <code>Proxy</code> ，此处我们同样可以利用 <code>Proxy</code> 去实现，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    i: <span class="number">1</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">this</span>.i++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>4.3 数组的 <code>toString</code> 接口默认调用数组的 <code>join</code> 方法，重写数组的 <code>join</code> 方法。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.join = a.shift;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>4.4 利用 <code>with</code> 关键字</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">a</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-防抖-debounce-函数的作用是什么？有哪些应用场景，请实现一个防抖函数。-2019-09-23"><a href="#5-防抖-debounce-函数的作用是什么？有哪些应用场景，请实现一个防抖函数。-2019-09-23" class="headerlink" title="5.防抖(debounce)函数的作用是什么？有哪些应用场景，请实现一个防抖函数。(2019-09-23)"></a>5.防抖(debounce)函数的作用是什么？有哪些应用场景，请实现一个防抖函数。(2019-09-23)</h3><blockquote>
<p><a href="http://zxinc520.com/lcj/%225d84756e662e3d49cc2c5b01%22">可参考第三题 </a></p>
</blockquote>
<h4 id="防抖函数的作用"><a href="#防抖函数的作用" class="headerlink" title="防抖函数的作用"></a>防抖函数的作用</h4><p>防抖函数的作用就是控制函数在一定时间内的执行次数。防抖意味着 N 秒内函数只会被执行一次，如果 N 秒内再次被触发，则重新计算延迟时间。</p>
<p>举例说明：小思最近在减肥，但是她非常贪吃。为此，与其男朋友约定好，如果 10 天不吃零食，就可以购买一个包(不要问为什么是包，因为包治百病)。但是如果中间吃了一次零食，那么就要重新计算时间，直到小思坚持 10 天没有吃零食，才能购买一个包。所以，管不住嘴的小思，没有机会买包(悲伤的故事)…这就是<strong>防抖</strong>。</p>
<p>不管吃没吃零食，每 10 天买一个包，中间想买包，忍着，等到第十天的时候再买，这种情况是<strong>节流</strong>。如何控制女朋友的消费，各位攻城狮们，get 到了吗？防抖可比节流有效多了！</p>
<h4 id="防抖应用场景"><a href="#防抖应用场景" class="headerlink" title="防抖应用场景"></a>防抖应用场景</h4><ol>
<li>搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。</li>
<li>表单验证</li>
<li>按钮提交事件。</li>
<li>浏览器窗口缩放，resize 事件等。</li>
</ol>
<h2 id="【Step-By-Step】一周面试题深入解析-周刊-02"><a href="#【Step-By-Step】一周面试题深入解析-周刊-02" class="headerlink" title="【Step-By-Step】一周面试题深入解析 / 周刊 02"></a>【Step-By-Step】一周面试题深入解析 / 周刊 02</h2><blockquote>
<p>本周面试题一览:</p>
</blockquote>
<ul>
<li>节流(throttle)函数的作用是什么？有哪些应用场景，请实现一个节流函数</li>
<li>说一说你对 JS 执行上下文栈和作用域链的理解？</li>
<li>什么是 BFC？BFC 的布局规则是什么？如何创建 BFC？</li>
<li>let、const、var 的区别有哪些？</li>
<li>深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？</li>
</ul>
<h3 id="6-节流-throttle-函数的作用是什么？有哪些应用场景，请实现一个节流函数。-2019-09-24"><a href="#6-节流-throttle-函数的作用是什么？有哪些应用场景，请实现一个节流函数。-2019-09-24" class="headerlink" title="6. 节流(throttle)函数的作用是什么？有哪些应用场景，请实现一个节流函数。(2019-09-24)"></a>6. 节流(throttle)函数的作用是什么？有哪些应用场景，请实现一个节流函数。(2019-09-24)</h3><blockquote>
<p><strong>解析</strong>： <a href="http://zxinc520.com/lcj/%225d84756e662e3d49cc2c5b01%22">可参考第三题 </a></p>
</blockquote>
<p><strong>节流函数的作用：</strong></p>
<p>节流函数的作用是规定一个单位时间，在这个单位时间内最多只能触发一次函数执行，如果这个单位时间内多次触发函数，只能有一次生效。</p>
<p>举例说明：小明的妈妈和小明约定好，如果小明在周考中取得满分，那么当月可以带他去游乐场玩，但是一个月最多只能去一次。</p>
<p>这其实就是一个节流的例子，在一个月的时间内，去游乐场最多只能触发一次。即使这个时间周期内，小明取得多次满分。</p>
<p><strong>节流应用场景：</strong></p>
<p>1.按钮点击事件</p>
<p>2.拖拽事件</p>
<p>3.onScoll</p>
<p>4.计算鼠标移动的距离(mousemove)</p>
<h3 id="7-说一说你对-JS-执行上下文栈和作用域链的理解？-2019-09-24"><a href="#7-说一说你对-JS-执行上下文栈和作用域链的理解？-2019-09-24" class="headerlink" title="7. 说一说你对 JS 执行上下文栈和作用域链的理解？(2019-09-24)"></a>7. 说一说你对 JS 执行上下文栈和作用域链的理解？(2019-09-24)</h3><p><a href="https://tc39.github.io/ecma262/?nsukey=rQHqMrFpKq6JJN//OeubPCslaSTSRyuc/XCznnIDze1SGzwva5SZtzixJ13p2gAlxua95Xa7fraZXwj5tyLRDK33+pNhyfKR/xyzhWNyB/qaIlsDGyQBckNoHQGPveOB24M+cK/gF8Tg1ehUGLWiCvumxdgcQwZOWj2BGfD3n/Y=#sec-execution-contexts">JS 执行上下文</a></p>
<p>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。</p>
<blockquote>
<p>执行上下文类型分为：</p>
</blockquote>
<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li>eval 函数执行上下文(不被推荐)</li>
</ul>
<p>执行上下文创建过程中，需要做以下几件事:</p>
<ol>
<li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。</li>
<li>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。</li>
<li>确定 this 的值，即 ResolveThisBinding</li>
</ol>
<p><strong>作用域</strong></p>
<p><strong>作用域</strong>负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。—— 摘录自《你不知道的 JavaScript》(上卷)</p>
<p>作用域有两种工作模型：词法作用域和动态作用域，JS 采用的是<strong>词法作用域</strong>工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。(<code>with</code> 和 <code>eval</code> 能够修改词法作用域，但是不推荐使用，对此不做特别说明)</p>
<blockquote>
<p>作用域分为：</p>
</blockquote>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域</li>
</ul>
<p><strong>JS 执行上下文栈(后面简称执行栈)</strong></p>
<p>执行栈，也叫做调用栈，具有 <strong>LIFO</strong> (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。</p>
<blockquote>
<p>规则如下：</p>
</blockquote>
<ul>
<li>首次运行 JavaScript 代码的时候,会创建一个全局执行的上下文并 Push 到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 Push 当前执行栈的栈顶。</li>
<li>当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中 Pop 出，上下文的控制权将移动到当前执行栈的下一个执行上下文。</li>
</ul>
<p>以一段代码具体说明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;fun3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fun3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure>

<p><code>Global Execution Context</code> (即全局执行上下文)首先入栈，过程如下：</p>
<p><img src="http://static.zxinc520.com/blog/20190925/KgyYmKIHz7fx.png?imageslim" alt="mark"></p>
<p><strong>作用域链</strong></p>
<p>作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。</p>
<h3 id="8-什么是-BFC？BFC-的布局规则是什么？如何创建-BFC？-2019-09-25"><a href="#8-什么是-BFC？BFC-的布局规则是什么？如何创建-BFC？-2019-09-25" class="headerlink" title="8. 什么是 BFC？BFC 的布局规则是什么？如何创建 BFC？(2019-09-25)"></a>8. 什么是 BFC？BFC 的布局规则是什么？如何创建 BFC？(2019-09-25)</h3><blockquote>
<p>什么是 BFC</p>
<p>BFC 是 Block Formatting Context 的缩写，即块格式化上下文。我们来看一下 CSS2.1 规范中对 BFC 的说明</p>
<p>浮动、绝对定位的元素、非块级盒子的块容器（如 inline-blocks、table-cells 和 table-captions），以及<code>overflow</code>的值不为<code>visible</code>（该值已传播到视区时除外）为其内容建立新的块格式上下文。</p>
</blockquote>
<p><a href="https://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#block-formatting">BFC 布局规则</a></p>
<ul>
<li>BFC 内，盒子依次垂直排列。</li>
<li>BFC 内，两个盒子的垂直距离由 <code>margin</code> 属性决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠【符合合并原则的 margin 合并后是使用大的 margin】</li>
<li>BFC 内，每个盒子的左外边缘接触内部盒子的左边缘（对于从右到左的格式，右边缘接触）。即使在存在浮动的情况下也是如此。除非创建新的 BFC。</li>
<li>BFC 的区域不会与 float box 重叠。</li>
<li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li>计算 BFC 的高度时，浮动元素也参与计算。</li>
</ul>
<p><strong>如何创建 BFC</strong></p>
<ul>
<li>根元素</li>
<li>浮动元素（float 属性不为 none）</li>
<li>position 为 absolute 或 relative</li>
<li>overflow 不为 visible 的块元素</li>
<li>display 为 inline-block, table-cell, table-caption</li>
</ul>
<p><strong>BFC 的应用</strong></p>
<ol>
<li>防止 margin 重叠</li>
</ol>
<p>根据 BFC 规则，同一个 BFC 内的两个两个相邻 Box 的 <code>margin</code> 会发生重叠，因此我们可以在 div 外面再嵌套一层容器，并且触发该容器生成一个 BFC，这样 <code>&lt;div class=&quot;a&quot;&gt;&lt;/div&gt;</code> 就会属于两个 BFC，自然也就不会再发生 <code>margin</code> 重叠</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.a</span>&#123;</span></span><br><span class="line">        height: 100px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        margin: 50px;</span><br><span class="line">        background: pink;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">overflow</span>: <span class="selector-tag">auto</span>; <span class="comment">/*触发生成BFC*/</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>清除内部浮动</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.a</span>&#123;</span></span><br><span class="line">        height: 100px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        margin: 10px;</span><br><span class="line">        background: pink;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span>&#123;</span></span><br><span class="line">        width: 120px;</span><br><span class="line"><span class="css">        <span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;<span class="comment">/*触发生成BFC*/</span></span></span><br><span class="line">        border: 2px solid black;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>container 的高度没有被撑开，如果我们希望 container 的高度能够包含浮动元素，那么可以创建一个新的 BFC，因为根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算。</p>
<ol start="3">
<li>自适应多栏布局</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body&#123;</span><br><span class="line">        width: 500px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.a</span>&#123;</span></span><br><span class="line">        height: 150px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        background: pink;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.b</span>&#123;</span></span><br><span class="line">        height: 200px;</span><br><span class="line"><span class="css">        <span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>; <span class="comment">/*触发生成BFC*/</span></span></span><br><span class="line">        background: blue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190925/zIMIHi7uVOq6.png?imageslim" alt="mark"></p>
<blockquote>
<p>加了 <code>overflow: hidden;</code> 触发生成 BFC</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190925/BFiWOckmwL9V.png?imageslim" alt="mark"></p>
<h3 id="9-let、const、var-的区别有哪些？-2019-09-26"><a href="#9-let、const、var-的区别有哪些？-2019-09-26" class="headerlink" title="9. let、const、var 的区别有哪些？(2019-09-26)"></a>9. let、const、var 的区别有哪些？(2019-09-26)</h3><p><img src="http://static.zxinc520.com/blog/20190926/0imlOVJDQTTd.png?imageslim" alt="mark"></p>
<ol>
<li>let/const 定义的变量不会出现变量提升，而 var 定义的变量会提升。</li>
<li>相同作用域中，let 和 const 不允许重复声明，var 允许重复声明。</li>
<li>cosnt 声明变量时必须设置初始值</li>
<li>const 声明一个只读的常量，这个常量不可改变</li>
<li>let/const 声明的变量仅在块级作用域中有效。而 var 声明的变量在块级作用域外仍能访问到。</li>
<li>顶层作用域中 var 声明的变量挂在 window 上(浏览器环境)</li>
<li>let/const 有暂时性死区的问题，即 let/const 声明的变量，在定义之前都是不可用的。如果使用会抛出错误。</li>
</ol>
<h3 id="10-深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？-2019-09-27"><a href="#10-深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？-2019-09-27" class="headerlink" title="10. 深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？(2019-09-27)"></a>10. 深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？(2019-09-27)</h3><blockquote>
<p>深拷贝和浅拷贝是针对复杂数据类型来说的。</p>
</blockquote>
<p><strong>深拷贝</strong></p>
<blockquote>
<p>深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</p>
</blockquote>
<p><strong>浅拷贝</strong></p>
<blockquote>
<p>浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。</p>
</blockquote>
<p>可以使用 <code>for in</code>、 <code>Object.assign</code>、 扩展运算符 <code>...</code> 、<code>Array.prototype.slice()</code>、<code>Array.prototype.concat()</code> 等，例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="keyword">let</span> obj3 = &#123; ...obj &#125;;</span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">obj.hobbies.push(<span class="string">&quot;coding&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123; name: &#x27;Jack&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3); <span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18,hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看出浅拷贝只最第一层属性进行了拷贝，当第一层的属性值是基本数据类型时，新的对象和原对象互不影响，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性值其指向的是同一块内存地址。来看一下使用 <code>for in</code> 实现浅拷贝。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  newObj[key] = obj[key];</span><br><span class="line">  <span class="comment">//这一步不需要多说吧，复杂数据类型栈中存的是对应的地址，因此赋值操作，相当于两个属性值指向同一个内存空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newObj);</span><br><span class="line"><span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18, hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27; ] &#125;</span></span><br><span class="line">obj.age = <span class="number">20</span>;</span><br><span class="line">obj.hobbies.pop();</span><br><span class="line"><span class="built_in">console</span>.log(newObj);</span><br><span class="line"><span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18, hobbies: [ &#x27;reading&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>深拷贝实现</strong></p>
<blockquote>
<p>深拷贝最简单的实现是: <code>JSON.parse(JSON.stringify(obj))</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">//newObj和obj互不影响</span></span><br><span class="line">obj.hobbies.push(<span class="string">&quot;coding&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18, hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>JSON.parse(JSON.stringify(obj))</code> 是最简单的实现方式，但是有一点缺陷：</p>
<ol>
<li>对象的属性值是函数时，无法拷贝。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(sayHi);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18, hobbies: [ &#x27;reading&#x27;, &#x27;photography&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原型链上的属性无法获取</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Super.prototype.location = <span class="string">&quot;NanJing&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age, hobbies</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Super();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Child(<span class="string">&quot;Yvette&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.location); <span class="comment">//NanJing</span></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123; name: &#x27;Yvette&#x27;, age: 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.location); <span class="comment">//undefined;原型链上的属性无法获取</span></span><br></pre></td></tr></table></figure>

<p>3.不能正确的处理 Date 类型的数据</p>
<p>4.不能处理 RegExp</p>
<p>5.会忽略 symbol</p>
<p>6.会忽略 undefined</p>
<blockquote>
<p>2.实现一个 deepClone 函数</p>
</blockquote>
<ol>
<li>如果是基本数据类型，直接返回</li>
<li>如果是 <code>RegExp</code> 或者 <code>Date</code> 类型，返回对应类型</li>
<li>如果是复杂数据类型，递归。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//递归拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">//如果不是复杂数据类型，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果obj是数组，那么 obj.constructor 是 [Function: Array]</span></span><br><span class="line"><span class="comment">   * 如果obj是对象，那么 obj.constructor 是 [Function: Object]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">let</span> t = <span class="keyword">new</span> obj.constructor();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">//如果 obj[key] 是复杂数据类型，递归</span></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">//是否是自身的属性</span></span><br><span class="line">      t[key] = deepClone(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Super.prototype.location = <span class="string">&quot;NanJing&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age, hobbies</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.hobbies = hobbies;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Super();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Child(<span class="string">&quot;Yvette&quot;</span>, <span class="number">18</span>, [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>]);</span><br><span class="line">obj.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.location); <span class="comment">//NanJing</span></span><br><span class="line"><span class="keyword">let</span> newObj = deepClone(obj);</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.location); <span class="comment">//NanJing 可以获取到原型链上的属性</span></span><br><span class="line">newObj.sayHi(); <span class="comment">//hi 函数属性拷贝正常</span></span><br></pre></td></tr></table></figure>

<h2 id="【Step-By-Step】一周面试题深入解析-周刊-03"><a href="#【Step-By-Step】一周面试题深入解析-周刊-03" class="headerlink" title="【Step-By-Step】一周面试题深入解析 / 周刊 03"></a>【Step-By-Step】一周面试题深入解析 / 周刊 03</h2><blockquote>
<p>本周面试题一览:</p>
</blockquote>
<ul>
<li>什么是 XSS 攻击，XSS 攻击可以分为哪几类？我们如何防范 XSS 攻击？</li>
<li>如何隐藏页面中的某个元素？</li>
<li>浏览器事件代理机制的原理是什么？</li>
<li>setTimeout 倒计时为什么会出现误差？</li>
</ul>
<h3 id="11-什么是-XSS-攻击，XSS-攻击可以分为哪几类？我们如何防范-XSS-攻击？（2019-09-28）"><a href="#11-什么是-XSS-攻击，XSS-攻击可以分为哪几类？我们如何防范-XSS-攻击？（2019-09-28）" class="headerlink" title="11. 什么是 XSS 攻击，XSS 攻击可以分为哪几类？我们如何防范 XSS 攻击？（2019-09-28）"></a>11. 什么是 XSS 攻击，XSS 攻击可以分为哪几类？我们如何防范 XSS 攻击？（2019-09-28）</h3><blockquote>
<p><a href="https://github.com/YvetteLau/Blog/issues/33">源地址</a></p>
</blockquote>
<p><strong>1. XSS 攻击</strong></p>
<p>XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。</p>
<p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击者定义的请求。</p>
<p><strong>XSS 分类</strong></p>
<p>根据攻击的来源，XSS 攻击可以分为存储型(持久性)、反射型(非持久型)和 DOM 型三种。下面我们来详细了解一下这三种 XSS 攻击：</p>
<blockquote>
<p>1.1 反射型 XSS</p>
</blockquote>
<p>当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web 服务器将注入脚本，比如一个错误信息，搜索结果等，未进行过滤直接返回到用户的浏览器上。</p>
<blockquote>
<p>反射型 XSS 的攻击步骤：</p>
</blockquote>
<ol>
<li>攻击者构造出特殊的 <code>URL</code>，其中包含恶意代码。</li>
<li>用户打开带有恶意代码的 <code>URL</code> 时，网站服务端将恶意代码从 <code>URL</code> 中取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p>反射型 XSS 漏洞常见于通过 <code>URL</code> 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 <code>URL</code> 才能生效，攻击者往往会结合多种手段诱导用户点击。</p>
<p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p>
<p>如果不希望被前端拿到 cookie，后端可以设置 <code>httpOnly</code> (不过这不是 <code>XSS攻击</code> 的解决方案，只能降低受损范围)</p>
<blockquote>
<p>如何防范反射型 XSS 攻击</p>
</blockquote>
<p><strong>对字符串进行编码。</strong></p>
<p>对 url 的查询参数进行转义后再输出到页面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&quot;/welcome&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//对查询参数进行编码，避免反射型 XSS攻击</span></span><br><span class="line">  res.send(<span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(req.query.type)&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.2 DOM 型 XSS</p>
</blockquote>
<p>DOM 型 XSS 攻击，实际上就是前端 <code>JavaScript</code> 代码不够严谨，把不可信的内容插入到了页面。在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>.appendChild</code>、<code>document.write()</code>等 API 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 <code>.innerText</code>、<code>.textContent</code>、<code>.setAttribute()</code> 等。</p>
<blockquote>
<p>DOM 型 XSS 的攻击步骤：</p>
</blockquote>
<ol>
<li>攻击者构造出特殊数据，其中包含恶意代码。</li>
<li>用户浏览器执行了恶意代码。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<blockquote>
<p>如何防范 DOM 型 XSS 攻击</p>
</blockquote>
<p>防范 DOM 型 XSS 攻击的核心就是对输入内容进行转义(DOM 中的内联事件监听器和链接跳转都能把字符串作为代码运行，需要对其内容进行检查)。</p>
<p>1.对于<code>url</code>链接(例如图片的<code>src</code>属性)，那么直接使用 <code>encodeURIComponent</code> 来转义。</p>
<p>2.非<code>url</code>，我们可以这样进行编码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeHtml</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">    .replace(<span class="regexp">/&quot;/g</span>, <span class="string">&quot;&amp;quot;&quot;</span>)</span><br><span class="line">    .replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&quot;&amp;apos;&quot;</span>)</span><br><span class="line">    .replace(<span class="regexp">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>)</span><br><span class="line">    .replace(<span class="regexp">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞。</p>
<blockquote>
<p>1.3 存储型 XSS</p>
</blockquote>
<p>恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和 DOM 型 XSS 更大。存储型 XSS 攻击的原因仍然是没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出</p>
<blockquote>
<p>存储型 XSS 的攻击步骤：</p>
</blockquote>
<ol>
<li>攻击者将恶意代码提交到目标网站的数据库中。</li>
<li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>
</ol>
<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>
<blockquote>
<p>如何防范存储型 XSS 攻击：</p>
</blockquote>
<ol>
<li>前端数据传递给服务器之前，先转义/过滤(防范不了抓包修改数据的情况)</li>
<li>服务器接收到数据，在存储到数据库之前，进行转义/过滤</li>
<li>前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤</li>
</ol>
<p><strong>除了谨慎的转义，我们还需要其他一些手段来防范 XSS 攻击:</strong></p>
<p><strong>1.Content Security Policy</strong></p>
<p>在服务端使用 HTTP 的 <code>Content-Security-Policy</code> 头部来指定策略，或者在前端设置 <code>meta</code> 标签。</p>
<p>例如下面的配置只允许加载同域下的资源：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src <span class="string">&#x27;self&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;form-action &#x27;self&#x27;;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>前端和服务端设置 CSP 的效果相同，但是<code>meta</code>无法使用<code>report</code></p>
<p>严格的 CSP 在 XSS 的防范中可以起到以下的作用：</p>
<ol>
<li>禁止加载外域代码，防止复杂的攻击逻辑。</li>
<li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。</li>
<li>禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。</li>
<li>禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。</li>
<li>合理使用上报可以及时发现 XSS，利于尽快修复问题。</li>
</ol>
<p><strong>2.输入内容长度控制</strong></p>
<p>对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。</p>
<p><strong>3.输入内容限制</strong></p>
<p>对于部分输入，可以限定不能包含特殊字符或者仅能输入数字等。</p>
<p><strong>4.其他安全措施</strong></p>
<ul>
<li>HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。</li>
<li>验证码：防止脚本冒充用户提交危险操作。</li>
</ul>
<blockquote>
<p><a href="https://github.com/YvetteLau/Step-By-Step/issues/18">点击查看更多</a></p>
</blockquote>
<h3 id="12-如何隐藏页面中的某个元素？（2019-09-29）"><a href="#12-如何隐藏页面中的某个元素？（2019-09-29）" class="headerlink" title="12.如何隐藏页面中的某个元素？（2019-09-29）"></a>12.如何隐藏页面中的某个元素？（2019-09-29）</h3><p><strong>隐藏类型：</strong></p>
<p>屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类：</p>
<ul>
<li>完全隐藏：元素从渲染树中消失，不占据空间。</li>
<li>视觉上的隐藏：屏幕中不可见，占据空间。</li>
<li>语义上的隐藏：读屏软件不可读，但正常占据空。</li>
</ul>
<p>完全隐藏：</p>
<ol>
<li><code>display</code> 属性(不占据空间)</li>
</ol>
<p>HTML5 新增属性，相当于 <code>display: none</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hidden</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>hidden 属性 (不占据空间)</li>
</ol>
<p>视觉上的隐藏：</p>
<p><strong>利用 <code>position</code> 和 盒模型 将元素移出可视区范围</strong></p>
<ol>
<li><p>设置 <code>posoition</code> 为 <code>absolute</code> 或 <code>fixed</code>，� 通过设置 <code>top</code>、<code>left</code> 等值，将其移出可视区域。(可视区域不占位)</p>
</li>
<li><p>设置 <code>position</code> 为 <code>relative</code>，通过设置 <code>top</code>、<code>left</code> 等值，将其移出可视区域。（可视区域占位）；如希望其在可视区域不占位置，需同时设置 <code>height: 0</code>;</p>
</li>
<li><p>设置 margin 值，将其移出可视区域范围（可视区域占位）；如果希望其在可视区域不占位，需同时设置 <code>height: 0</code>;</p>
</li>
</ol>
<p><strong>利用 transfrom</strong></p>
<ol>
<li>缩放</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>移动 <code>translateX</code>, <code>translateY</code></li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(<span class="selector-tag">-99999px</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>旋转 <code>rotate</code></li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotateY</span>(90<span class="selector-tag">deg</span>);</span><br></pre></td></tr></table></figure>

<p><strong>设置其大小为 0</strong></p>
<ol>
<li>宽高为 0，字体大小为 0</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">height</span>: 0;</span><br><span class="line"><span class="selector-tag">width</span>: 0;</span><br><span class="line"><span class="selector-tag">font-size</span>: 0;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>宽高为 0，超出隐藏</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">height</span>: 0;</span><br><span class="line"><span class="selector-tag">width</span>: 0;</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure>

<p>设置透明度为 0</p>
<p><code>visibility</code>属性</p>
<p>层级覆盖，<code>z-index</code> 属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br><span class="line"><span class="selector-tag">z-index</span>: <span class="selector-tag">-999</span>;</span><br></pre></td></tr></table></figure>

<p>再设置一个层级较高的元素覆盖在此元素上。</p>
<p>clip-path 裁剪</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">clip-path</span>: <span class="selector-tag">polygon</span>(0 0, 0 0, 0 0, 0 0);</span><br></pre></td></tr></table></figure>

<h3 id="13-浏览器事件代理机制的原理是什么？（2019-09-30）"><a href="#13-浏览器事件代理机制的原理是什么？（2019-09-30）" class="headerlink" title="13.浏览器事件代理机制的原理是什么？（2019-09-30）"></a>13.浏览器事件代理机制的原理是什么？（2019-09-30）</h3><p><strong>事件代理机制的原理</strong></p>
<p>事件代理又称为事件委托，在祖先级 DOM 元素绑定一个事件，当触发子孙级 DOM 元素的事件时，利用事件冒泡的原理来触发绑定在祖先级 DOM 的事件。因为事件会从目标元素一层层冒泡至 document 对象。</p>
<p><strong>为什么要事件代理？</strong></p>
<ol>
<li>添加到页面上的事件数量会影响页面的运行性能，如果添加的事件过多，会导致网页的性能下降。采用事件代理的方式，可以大大减少注册事件的个数。</li>
<li>事件代理的当时，某个子孙元素是动态增加的，不需要再次对其进行事件绑定。</li>
<li>不用担心某个注册了事件的 DOM 元素被移除后，可能无法回收其事件处理程序，我们只要把事件处理程序委托给更高层级的元素，就可以避免此问题。</li>
<li>允许给一个事件注册多个监听。</li>
<li>提供了一种更精细的手段控制 <code>listener</code> 的触发阶段(可以选择捕获或者是冒泡)。</li>
<li>对任何 <code>DOM</code> 元素都是有效的，而不仅仅是对 <code>HTML</code> 元素有效。</li>
</ol>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener">addEventListener</a> :</p>
<p>addEventListener 接受 3 个参数，分别是要处理的事件名、实现了 EventListener 接口的对象或者是一个函数、一个对象/一个布尔值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">target.addEventListener(type, listener[, options]);</span><br><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>options(对象) | 可选</strong></p>
<ul>
<li>capture: <code>Boolean</code>。true 表示在捕获阶段触发，false 表示在冒泡阶段触发。默认是 false。</li>
<li>once:<code>Boolean</code>。true 表示 listener 在添加之后最多只调用一次，listener 会在其被调用之后自动移除。默认是 false。</li>
<li>passive: <code>Boolean</code>。true 表示 listener 永远不会调用 <code>preventDefault()</code>。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。默认是 false。</li>
</ul>
<p><strong>useCapture(Boolean) | 可选</strong></p>
<p><code>useCapture</code> 默认为 false。表示冒泡阶段调用事件处理程序，若设置为 true，表示在捕获阶段调用事件处理程序。</p>
<blockquote>
<p>如将页面中的所有 click 事件都代理到 document 上:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获阶段调用调用事件处理程序，eventPhase是 1;</span></span><br><span class="line"><span class="comment">     * 处于目标，eventPhase是2</span></span><br><span class="line"><span class="comment">     * 冒泡阶段调用事件处理程序，eventPhase是 3；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.eventPhase);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>与 <code>addEventListener</code> 相对应的是 <code>removeEventListener</code>,用于移除事件监听。</p>
<h3 id="14-setTimeout-倒计时为什么会出现误差？-（2019-10-08）"><a href="#14-setTimeout-倒计时为什么会出现误差？-（2019-10-08）" class="headerlink" title="14. setTimeout 倒计时为什么会出现误差？ （2019-10-08）"></a>14. setTimeout 倒计时为什么会出现误差？ （2019-10-08）</h3><p><code>setTimeout</code> 只能保证延时或间隔不小于设定的时间。因为它实际上只是将回调添加到了宏任务队列中，但是如果主线程上有任务还没有执行完成，它必须要等待。</p>
<p>如果你对前面这句话不是非常理解，那么有必要了解一下 JS 的运行机制。</p>
<p><strong>JS 的运行机制</strong></p>
<p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</p>
<p>（2）主线程之外，还存在”任务队列”(task queue)。</p>
<p>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p>
<p>（4）主线程不断重复上面的第三步。</p>
<p>如 <code>setTimeout(()=&gt;&#123;callback();&#125;, 1000)</code> ，即表示在 1s 之后将 <code>callback</code> 放到宏任务队列中，当 1s 的时间到达时，如果主线程上有其它任务在执行，那么 <code>callback</code> 就必须要等待，另外 <code>callback</code> 的执行也需要时间，因此 <code>setTimeout</code> 的时间间隔是有误差的，它只能保证延时不小于设置的时间。</p>
<p><strong>如何减少 <code>setTimeout</code> 的误差</strong></p>
<p>我们只能减少执行多次的 <code>setTimeout</code> 的误差，例如倒计时功能。</p>
<p>倒计时的时间通常都是从服务端获取的。造成误差的原因：</p>
<p>1.没有考虑误差时间（函数执行的时间/其它代码的阻塞）</p>
<p>2.没有考虑浏览器的“休眠”</p>
<p>完全消除 <code>setTimeout</code>的误差是不可能的，但是我们减少 <code>setTimeout</code> 的误差。通过对下一次任务的调用时间进行修正，来减少误差。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> countdown = <span class="number">5000</span>; <span class="comment">//服务器返回的倒计时时间</span></span><br><span class="line"><span class="keyword">let</span> interval = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">let</span> timer = <span class="built_in">setTimeout</span>(countDownStart, interval); <span class="comment">//首次执行</span></span><br><span class="line"><span class="comment">//定时器测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countDownStart</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="keyword">const</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">const</span> nextInterval = interval - offset; <span class="comment">//修正后的延时时间</span></span><br><span class="line">  <span class="keyword">if</span> (nextInterval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    nextInterval = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  countdown -= interval;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&quot;误差：&quot;</span> +</span><br><span class="line">      offset +</span><br><span class="line">      <span class="string">&quot;ms，下一次执行：&quot;</span> +</span><br><span class="line">      nextInterval +</span><br><span class="line">      <span class="string">&quot;ms后，离活动开始还有：&quot;</span> +</span><br><span class="line">      countdown +</span><br><span class="line">      <span class="string">&quot;ms&quot;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (countdown &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(countDownStart, nextInterval);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前页面是不可见的，那么倒计时会出现大于 100ms 的误差时间。因此在页面显示时，应该重新从服务端获取剩余时间进行倒计时。当然，为了更好的性能，当倒计时不可见(Tab 页切换/倒计时内容不在可视区时)，可以选择停止倒计时。</p>
<p>为此，我们可以监听 <code>visibityChange</code> 事件进行处理。</p>
<blockquote>
<p><a href="https://github.com/YvetteLau/Step-By-Step/issues/21">点击查看更多</a></p>
</blockquote>
<h2 id="【Step-By-Step】一周面试题深入解析-周刊-04"><a href="#【Step-By-Step】一周面试题深入解析-周刊-04" class="headerlink" title="【Step-By-Step】一周面试题深入解析 / 周刊 04"></a>【Step-By-Step】一周面试题深入解析 / 周刊 04</h2><blockquote>
<p>本周面试题一览:</p>
</blockquote>
<ul>
<li><a href="https://github.com/YvetteLau/Blog/issues/34">什么是闭包？闭包的作用是什么？</a></li>
<li>实现 Promise.all 方法</li>
<li>异步加载 js 脚本的方法有哪些？</li>
<li>请实现一个 flattenDeep 函数，把嵌套的数组扁平化</li>
<li>可迭代对象有什么特点？</li>
</ul>
<h3 id="15-什么是闭包？闭包的作用是什么？-（2019-10-09）"><a href="#15-什么是闭包？闭包的作用是什么？-（2019-10-09）" class="headerlink" title="15. 什么是闭包？闭包的作用是什么？ （2019-10-09）"></a>15. 什么是闭包？闭包的作用是什么？ （2019-10-09）</h3><p><strong>什么是闭包？</strong></p>
<p>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包最常用的方式就是在一个函数内部创建另一个函数。</p>
<p><strong>闭包的作用：</strong></p>
<ol>
<li>能够访问函数定义时所在的词法作用域(阻止其被回收)。</li>
<li>私有化变量</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">10</span>; <span class="comment">//私有变量</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getX: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = base();</span><br><span class="line"><span class="built_in">console</span>.log(obj.getX()); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>模拟块级作用域</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建模块</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;Yvette&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">20</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    sayName,</span><br><span class="line">    sayAge,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> info = coolModule();</span><br><span class="line">info.sayName(); <span class="comment">//&#x27;Yvette&#x27;</span></span><br></pre></td></tr></table></figure>

<p>模块模式具有两个必备的条件(来自《你不知道的 JavaScript》)</p>
<ul>
<li>必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)</li>
<li>封闭函数必须返回至少<strong>一个</strong>内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li>
</ul>
<p>闭包的缺点</p>
<p>闭包会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p>
<h3 id="16-实现-Promise-all-方法-（2019-10-10）"><a href="#16-实现-Promise-all-方法-（2019-10-10）" class="headerlink" title="16. 实现 Promise.all 方法 （2019-10-10）"></a>16. 实现 Promise.all 方法 （2019-10-10）</h3><p>在实现 Promise.all 方法之前，我们首先要知道 Promise.all 的功能和特点，因为在清楚了 Promise.all 功能和特点的情况下，我们才能进一步去写实现。</p>
<p><strong>Promise.all 功能</strong></p>
<p><code>Promise.all(iterable)</code> 返回一个新的 Promise 实例。此实例在 <code>iterable</code> 参数内所有的 <code>promise</code> 都 <code>fulfilled</code> 或者参数中不包含 <code>promise</code> 时，状态变成 <code>fulfilled</code>；如果参数中 <code>promise</code> 有一个失败<code>rejected</code>，此实例回调失败，失败原因的是第一个失败 <code>promise</code> 的返回结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>p 的状态由 p1,p2,p3 决定，分成以下；两种情况：</p>
<p>（1）只有 p1、p2、p3 的状态都变成 <code>fulfilled</code>，p 的状态才会变成 <code>fulfilled</code>，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</p>
<p>（2）只要 p1、p2、p3 之中有一个被 <code>rejected</code>，p 的状态就变成 <code>rejected</code>，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</p>
<p><strong>Promise.all 的特点</strong></p>
<blockquote>
<p>Promise.all 的返回值是一个 promise 实例</p>
</blockquote>
<ul>
<li>如果传入的参数为空的可迭代对象，<code>Promise.all</code> 会 <strong>同步</strong> 返回一个已完成状态的 <code>promise</code></li>
<li>如果传入的参数中不包含任何 promise,<code>Promise.all</code> 会 <strong>异步</strong> 返回一个已完成状态的 <code>promise</code></li>
<li>其它情况下，<code>Promise.all</code> 返回一个 <strong>处理中（pending）</strong> 状态的 <code>promise</code>.</li>
</ul>
<blockquote>
<p>Promise.all 返回的 promise 的状态</p>
</blockquote>
<ul>
<li>如果传入的参数中的 promise 都变成完成状态，<code>Promise.all</code> 返回的 <code>promise</code> 异步地变为完成。</li>
<li>如果传入的参数中，有一个 <code>promise</code> 失败，<code>Promise.all</code> 异步地将失败的那个结果给失败状态的回调函数，而不管其它 <code>promise</code> 是否完成</li>
<li>在任何情况下，<code>Promise.all</code> 返回的 <code>promise</code> 的完成状态的结果都是一个数组</li>
</ul>
<p><strong>Promise.all 实现</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//Array.from 将可迭代对象转换成数组</span></span><br><span class="line">    promises = <span class="built_in">Array</span>.from(promises);</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve([]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> result = [];</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        <span class="comment">//考虑到 i 可能是 thenable 对象也可能是普通值</span></span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i]).then(</span><br><span class="line">          (data) =&gt; &#123;</span><br><span class="line">            result[i] = data;</span><br><span class="line">            <span class="keyword">if</span> (++index === promises.length) &#123;</span><br><span class="line">              <span class="comment">//所有的 promises 状态都是 fulfilled，promise.all返回的实例才变成 fulfilled 态</span></span><br><span class="line">              resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          (err) =&gt; &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="17-异步加载-js-脚本的方法有哪些？-（2019-10-11）"><a href="#17-异步加载-js-脚本的方法有哪些？-（2019-10-11）" class="headerlink" title="17. 异步加载 js 脚本的方法有哪些？ （2019-10-11）"></a>17. 异步加载 js 脚本的方法有哪些？ （2019-10-11）</h3><ol>
<li><code>&lt;script&gt;</code> 标签中增加 <code>async</code>(html5) 或者 <code>defer</code>(html4) 属性,脚本就会异步加载。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;../XXX.js&quot;</span> defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>defer</code> 和 <code>async</code> 的区别在于：</p>
<ul>
<li><code>defer</code> 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），在 window.onload 之前执行；</li>
<li><code>async</code> 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。</li>
<li>如果有多个 <code>defer</code> 脚本，会按照它们在页面出现的顺序加载</li>
<li>多个 <code>async</code> 脚本不能保证加载顺序</li>
</ul>
<ol start="2">
<li>动态创建 <code>script</code> 标签</li>
</ol>
<p>动态创建的 <code>script</code> ，设置 <code>src</code> 并不会开始下载，而是要添加到文档中，JS 文件才会开始下载。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.src = <span class="string">&quot;XXX.js&quot;</span>;</span><br><span class="line"><span class="comment">// 添加到html文件中才会开始下载</span></span><br><span class="line"><span class="built_in">document</span>.body.append(script);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>XHR 异步加载 JS</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;js/xxx.js&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">eval</span>(xhr.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="18-请实现一个-flattenDeep-函数，把嵌套的数组扁平化-（2019-10-13）"><a href="#18-请实现一个-flattenDeep-函数，把嵌套的数组扁平化-（2019-10-13）" class="headerlink" title="18. 请实现一个 flattenDeep 函数，把嵌套的数组扁平化 （2019-10-13）"></a>18. 请实现一个 flattenDeep 函数，把嵌套的数组扁平化 （2019-10-13）</h3><p><strong>解析：</strong></p>
<ol>
<li>利用 <code>Array.prototype.flat</code></li>
</ol>
<p>ES6 为数组实例新增了 <code>flat</code> 方法，用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数组没有影响。</p>
<p><code>flat</code> 默认只会 “拉平” 一层，如果想要 “拉平” 多层的嵌套数组，需要给 <code>flat</code> 传递一个整数，表示想要拉平的层数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDeep</span>(<span class="params">arr, deepLength</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.flat(deepLength);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flattenDeep([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]], <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDeep</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return arr.join(&#x27;,&#x27;).split(&#x27;,&#x27;).map(Number);</span></span><br><span class="line">  <span class="keyword">return</span> arr.toString().split(<span class="string">&quot;,&quot;</span>).map(<span class="built_in">Number</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flattenDeep([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]]));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用 reduce 和 concat:</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDeep</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(</span><br><span class="line">    (acc, val) =&gt;</span><br><span class="line">      <span class="built_in">Array</span>.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flattenDeep([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]]));</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 stack 无限反嵌套多层嵌套数组</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDeep</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [...input];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="comment">// 使用 pop 从 stack 中取出并移除值</span></span><br><span class="line">    <span class="keyword">const</span> next = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(next)) &#123;</span><br><span class="line">      <span class="comment">// 使用 push 送回内层数组中的元素，不会改动原始输入 original input</span></span><br><span class="line">      stack.push(...next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.push(next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用 reverse 恢复原数组的顺序</span></span><br><span class="line">  <span class="keyword">return</span> res.reverse();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flattenDeep([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]]));</span><br></pre></td></tr></table></figure>

<h3 id="19-可迭代对象有什么特点-（2019-10-14）"><a href="#19-可迭代对象有什么特点-（2019-10-14）" class="headerlink" title="19. 可迭代对象有什么特点 （2019-10-14）"></a>19. 可迭代对象有什么特点 （2019-10-14）</h3><p>ES6 规定，默认的 <code>Iterator</code> 接口部署在数据结构的 <code>Symbol.iterator</code> 属性，换个角度，也可以认为，一个数据结构只要具有 <code>Symbol.iterator</code> 属性(<code>Symbol.iterator</code> 方法对应的是遍历器生成函数，返回的是一个遍历器对象)，那么就可以其认为是可迭代的。</p>
<p><strong>可迭代对象的特点</strong></p>
<ul>
<li>具有 <code>Symbol.iterator</code> 属性，<code>Symbol.iterator()</code> 返回的是一个遍历器对象</li>
<li>可以使用 <code>for ... of</code> 进行循环</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> iter = array[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">//&#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">//&#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">//&#123; value: 3, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>原生具有 <code>Iterator</code> 接口的数据结构：</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<h4 id="自定义一个可迭代对象"><a href="#自定义一个可迭代对象" class="headerlink" title="自定义一个可迭代对象"></a>自定义一个可迭代对象</h4><p>上面我们说，一个对象只有具有正确的 <code>Symbol.iterator</code> 属性，那么其就是可迭代的，因此，我们可以通过给对象新增 <code>Symbol.iterator</code> 使其可迭代</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  job: <span class="string">&quot;engineer&quot;</span>,</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(self);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; keys.length; index++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> self[keys[index]]; <span class="comment">//yield表达式仅能使用在 Generator 函数中</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">//Yvette 18 engineer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="【Step-By-Step】高频面试题深入解析-周刊-05-本周面试题一览"><a href="#【Step-By-Step】高频面试题深入解析-周刊-05-本周面试题一览" class="headerlink" title="【Step-By-Step】高频面试题深入解析 / 周刊 05 本周面试题一览:"></a>【Step-By-Step】高频面试题深入解析 / 周刊 05 本周面试题一览:</h2><blockquote>
<p>本周面试题一览:</p>
<p>####</p>
</blockquote>
<ul>
<li>实现 Promise.race 方法</li>
<li>JSONP 原理及简单实现</li>
<li>实现一个数组去重的方法</li>
<li>清楚浮动的方法有哪些</li>
<li>编写一个通用的柯里化函数 currying</li>
</ul>
<h3 id="20-实现-Promise-race-方法（2019-10-16）"><a href="#20-实现-Promise-race-方法（2019-10-16）" class="headerlink" title="20. 实现 Promise.race 方法（2019-10-16）"></a>20. 实现 Promise.race 方法（2019-10-16）</h3><p>在实现 <code>Promise.race</code> 方法之前，我们首先要知道 <code>Promise.race</code> 的功能和特点，因为在清楚了 <code>Promise.race</code> 功能和特点的情况下，我们才能进一步去写实现。</p>
<p><strong>Promise.race 功能</strong></p>
<p><code>Promise.race(iterable)</code> 返回一个 promise，一旦 <code>iterable</code> 中的一个 <code>promise</code> 状态是 <code>fulfilled</code> / <code>rejected</code> ，那么 <code>Promise.race</code> 返回的 <code>promise</code> 状态是 <code>fulfilled</code> / <code>rejected</code>.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 <code>Promise</code> 实例的返回值，就传递给 p 的回调函数。</p>
<p><strong>Promise.race 的特点</strong></p>
<blockquote>
<p>Promise.race 的返回值是一个 promise 实例</p>
</blockquote>
<ul>
<li>如果传入的参数为空的可迭代对象，那么 <code>Promise.race</code> 返回的 <code>promise</code> 永远是 <code>pending</code> 态</li>
<li>如果传入的参数中不包含任何 <code>promise</code>，<code>Promise.race</code> 会返回一个处理中（pending）的 <code>promise</code></li>
<li>如果 <code>iterable</code> 包含一个或多个非 <code>promise</code> 值或已经解决的 promise，则 <code>Promise.race</code> 将解析为 <code>iterable</code> 中找到的第一个值。</li>
</ul>
<p><strong>Promise.race 的实现</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//promises传入的是可迭代对象(省略参数合法性判断)</span></span><br><span class="line">  promises = <span class="built_in">Array</span>.from(promises); <span class="comment">//将可迭代对象转换为数组</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//空的可迭代对象;</span></span><br><span class="line">      <span class="comment">//用于在pending态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i])</span><br><span class="line">          .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="21-JSONP-原理及简单实现-2019-10-17"><a href="#21-JSONP-原理及简单实现-2019-10-17" class="headerlink" title="21. JSONP 原理及简单实现 (2019-10-17)"></a>21. JSONP 原理及简单实现 (2019-10-17)</h3><p>尽管浏览器有同源策略，但是 <code>&lt;script&gt;</code> 标签的 <code>src</code> 属性不会被同源策略所约束，可以获取任意服务器上的脚本并执行。<code>jsonp</code> 通过插入 <code>script</code> 标签的方式来实现跨域，参数只能通过 <code>url</code> 传入，仅能支持 <code>get</code> 请求。</p>
<p><strong>实现原理:</strong></p>
<ul>
<li>Step1: 创建 callback 方法</li>
<li>Step2: 插入 script 标签</li>
<li>Step3: 后台接受到请求，解析前端传过去的 callback 方法，返回该方法的调用，并且数据作为参数传入该方法</li>
<li>Step4: 前端执行服务端返回的方法调用</li>
</ul>
<p><strong>jsonp 源码实现</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">&#123; url, params, callback &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//创建script标签</span></span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">    <span class="comment">//将回调函数挂在 window 上</span></span><br><span class="line">    <span class="built_in">window</span>[callback] = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      resolve(data);</span><br><span class="line">      <span class="comment">//代码执行后，删除插入的script标签</span></span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(script);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//回调函数加在请求地址上</span></span><br><span class="line">    params = &#123; ...params, callback &#125;; <span class="comment">//wb=b&amp;callback=show</span></span><br><span class="line">    <span class="keyword">let</span> arrs = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      arrs.push(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arrs.join(<span class="string">&quot;&amp;&quot;</span>)&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: <span class="string">&quot;http://localhost:3000/show&quot;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">  &#125;,</span><br><span class="line">  callback: <span class="string">&quot;show&quot;</span>,</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>服务端代码(node):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//express启动一个后台服务</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/show&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; callback &#125; = req.query; <span class="comment">//获取传来的callback函数名，callback是key</span></span><br><span class="line">  res.send(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;Hello!&#x27;)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="22、实现一个数组去重的方法-2019-10-18"><a href="#22、实现一个数组去重的方法-2019-10-18" class="headerlink" title="22、实现一个数组去重的方法 (2019-10-18)"></a>22、实现一个数组去重的方法 (2019-10-18)</h3><ol>
<li>法 1: 利用 ES6 新增数据类型 <code>Set </code> ：[…new Set(arry)</li>
<li>利用 <code>indexOf</code> <code>includes</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">arry</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arry.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.indexOf(arry[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">//如 result 中没有 arry[i],则添加到数组中</span></span><br><span class="line">      result.push(arry[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>利用 <code>reduce</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">arry</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arry.reduce(</span><br><span class="line">    (prev, cur) =&gt; (prev.includes(cur) ? prev : [...prev, cur]),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>利用 <code>Map</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">arry</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arry.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(arry[i])) &#123;</span><br><span class="line">      map.set(arry[i], <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map.set(arry[i], <span class="literal">false</span>);</span><br><span class="line">      result.push(arry[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23、清除浮动的方法有哪些？-2019-10-20"><a href="#23、清除浮动的方法有哪些？-2019-10-20" class="headerlink" title="23、清除浮动的方法有哪些？ (2019-10-20)"></a>23、清除浮动的方法有哪些？ (2019-10-20)</h3><p><strong>解析：</strong></p>
<p>总体来说就两点吧：</p>
<ol>
<li>利用 clear 元素</li>
<li>利用 BFC 布局规则</li>
</ol>
<h3 id="24-编写一个通用的柯里化函数-currying-2019-10-20"><a href="#24-编写一个通用的柯里化函数-currying-2019-10-20" class="headerlink" title="24. 编写一个通用的柯里化函数 currying (2019-10-20)"></a>24. 编写一个通用的柯里化函数 currying (2019-10-20)</h3><p>在开始之前，我们首先需要搞清楚函数<a href="https://github.com/mqyqingfeng/Blog/issues/42">柯里化</a>的概念。</p>
<blockquote>
<p>curry 的这种用途可以理解为：参数复用。本质上是降低通用性，提高适用性。</p>
</blockquote>
<p>函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> currying = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span></span><br><span class="line">  args.length &lt; fn.length</span><br><span class="line">    ? <span class="comment">//参数长度不足时，重新柯里化该函数，等待接受新参数</span></span><br><span class="line">      (...arguments) =&gt; currying(fn, ...args, ...arguments)</span><br><span class="line">    : <span class="comment">//参数长度满足时，执行函数</span></span><br><span class="line">      fn(...args);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumFn</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = currying(sumFn);</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">5</span>)); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>)(<span class="number">3</span>, <span class="number">5</span>)); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>, <span class="number">3</span>)(<span class="number">5</span>)); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数柯里化的主要作用：</p>
</blockquote>
<ul>
<li>参数复用</li>
<li>提前返回 – 返回接受余下的参数且返回结果的新函数</li>
<li>延迟执行 – 返回新函数，等待执行</li>
</ul>
<h2 id="【Step-By-Step】高频面试题深入解析-周刊-06"><a href="#【Step-By-Step】高频面试题深入解析-周刊-06" class="headerlink" title="【Step-By-Step】高频面试题深入解析 / 周刊 06"></a>【Step-By-Step】高频面试题深入解析 / 周刊 06</h2><blockquote>
<p>本周面试题一览:</p>
</blockquote>
<ul>
<li>原型链继承的基本思路是什么？有什么优缺点？</li>
<li>借用构造函数和组合继承基本思路是什么？有什么优缺点？</li>
<li>原型式继承的基本思路是什么？有什么优缺点？</li>
<li>寄生式继承的基本思路是什么？有什么优缺点？</li>
<li>寄生组合式继承的基本思路是什么？有什么优缺点？</li>
</ul>
<p>本周是继承专题，在开始之前，需要先了解构造函数、原型和原型链的相关知识。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>构造函数和普通函数的区别仅在于调用它们的方式不同，任何函数，只要通过 <code>new</code> 操作符来调用，那它就可以作为构造函数；任何函数，如果不通过 <code>new</code> 操作符来调用，那么它就是一个普通函数。</p>
<p>实例拥有 <code>constructor(构造函数)</code> 属性，该属性返回创建实例对象的构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Yvette = <span class="keyword">new</span> Person(<span class="string">&quot;刘小夕&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Yvette.constructor === Person); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>有一点需要说明的是，除了基本数据类型的 <code>constructor</code> 外( <code>null</code> 和 <code>undefined</code> 无 <code>constructor</code> 属性)，<code>constructor</code> 属性是可以被重写的。因此检测对象类型时，<code>instanceof</code> 操作符比 <code>contsrutor</code> 更可靠一些。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> Yvette = <span class="keyword">new</span> Person(<span class="string">&quot;刘小夕&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Yvette.constructor); <span class="comment">//[Function: Person]</span></span><br><span class="line">Yvette.constructor = SuperType;</span><br><span class="line"><span class="built_in">console</span>.log(Yvette.constructor); <span class="comment">//[Function: SuperType]</span></span><br></pre></td></tr></table></figure>

<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>我们创建的每个函数都有 <code>prototype</code> 属性，这个属性指向函数的原型对象。原型对象的<strong>用途</strong>是包含可以由特定类型的所有实例共享的属性和方法。</p>
<p>在默认情况下，所有原型对象都会自动获得一个 <code>constructor</code> 属性，这个属性包含一个指向 <code>prototype</code> 属性所在函数的指针。</p>
<p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针，指向构造函数的原型对象(可以通过实例的 <a href="https://www.zhihu.com/question/34183746"><code>__proto__</code></a> 来访问构造函数的原型对象)。 <a href="https://www.zhihu.com/question/34183746">参考</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f.prototype.sayhi = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> f();</span><br><span class="line"><span class="built_in">console</span>.log(f.prototype); <span class="comment">//f &#123; sayhi: [Function] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.prototype.constructor); <span class="comment">//[Function: f]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__); <span class="comment">//f &#123; sayhi: [Function] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.__proto__); <span class="comment">//[Function]</span></span><br></pre></td></tr></table></figure>

<p>总结： 1.对象有属性<strong>proto</strong>,指向该对象的构造函数的原型对象。 2.方法除了有属性<strong>proto</strong>,还有属性 prototype，prototype 指向该方法的原型对象。</p>
<p>讲完啦，欢迎各种批评指正完善探讨，共同进步~</p>
<p><img src="https://camo.githubusercontent.com/16602b6909621ce63a882221389c062c4d032256/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f7075626c69632f7265736f757263652f66343537303163633431303530346537316462626362643838363165386430632f786d6c6e6f74652f5745425245534f5552434534366564343366333030363430353439383465356332346466373930393962312f3239353432"></p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>简单回顾一下构造函数、原型和实例的关系：</p>
<p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个可以执行原型对象的内部指针(可以通过 <code>__proto</code> 访问)。</p>
<p>假如我们让原型对象等于另一个类型的实例，那么此时原型对象包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。加入另一个原型又是另一个类型的实例，那么上述关系仍然成立，如此层层递进，就构成了实例与原型的链条，这就是原型链的基本概念</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&quot;animal&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getType = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.type);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SimType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">SimType.prototype = <span class="keyword">new</span> SubType();</span><br><span class="line">SimType.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SimType(<span class="string">&quot;刘小夕&quot;</span>);</span><br><span class="line">instance.getType(); <span class="comment">//animal</span></span><br></pre></td></tr></table></figure>

<p><img src="https://camo.githubusercontent.com/bb69ed50e52bf2d899a093cbe685074f28cacc0f/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f7075626c69632f7265736f757263652f66343537303163633431303530346537316462626362643838363165386430632f786d6c6e6f74652f5745425245534f5552434565333233613738316338613737653239363833373531643965333236653139342f3239353434"></p>
<p>调用 <code>instance.getType()</code> 会调用以下的搜索步骤:</p>
<ol>
<li>搜索 <code>instance</code> 实例</li>
<li>搜索 <code>SimType.prototype</code></li>
<li>搜索 <code>SubType.prototype</code></li>
<li>搜索 <code>SuperType.prototype</code>，找到了 <code>getType</code> 方法</li>
</ol>
<p>在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链的末端才会停下来。</p>
<p>所有引用类型都继承了 <code>Object</code>，这个继承也是通过原型链实现的。如果在 <code>SuperType.prototype</code> 还没有找到 <code>getType</code>，就会到 <code>Object.prototype</code>中找(图中少画了一环)。</p>
<h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>原型链继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<p>如 <code>SubType.prototype = new SuperType()</code>;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;Yvette&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(SubType.prototype.constructor) //[Function: SuperType]</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.getName()); <span class="comment">//&#x27;Yvette&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>可以看出 <code>colors</code> 属性会被所有的实例共享(instance1、instance2、…)。</p>
<blockquote>
<p>缺点：</p>
</blockquote>
<ol>
<li>通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享。</li>
<li>在创建子类型的实例时，没有办法在不影响所有对象实例的情况下给超类型的构造函数中传递参数。</li>
</ol>
<h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><p><strong>借用构造函数</strong>的技术，其基本思想为:</p>
<p>在子类型的构造函数中调用超类型构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> intance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;zc&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(intance1.name); <span class="comment">//zc</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>优点:</p>
</blockquote>
<ol>
<li>可以向超类传递参数</li>
<li>解决了原型中包含引用类型值被所有实例共享的问题</li>
</ol>
<blockquote>
<p>缺点:</p>
</blockquote>
<ol>
<li>方法都在构造函数中定义，函数复用无从谈起，另外超类型原型中定义的方法对于子类型而言都是不可见的。</li>
</ol>
<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>组合继承指的是将原型链和借用构造函数技术组合到一块，从而发挥二者之长的一种继承模式。基本思路：</p>
<p>使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// console.log(SuperType)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuberType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuberType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SuberType.prototype.constructor = SuberType;</span><br><span class="line">SuberType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SuberType(<span class="string">&quot;Yvette&quot;</span>, <span class="number">20</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27; ]</span></span><br><span class="line">instance1.sayName(); <span class="comment">//Yvette</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SuberType(<span class="string">&quot;Jack&quot;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">//[ &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ]</span></span><br><span class="line">instance2.sayName(); <span class="comment">//Jack</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>缺点:</p>
</blockquote>
<ul>
<li>无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</li>
</ul>
<blockquote>
<p>优点:</p>
</blockquote>
<ul>
<li>可以向超类传递参数</li>
<li>每个实例都有自己的属性</li>
<li>实现了函数复用</li>
</ul>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><blockquote>
<p><a href="https://juejin.im/post/5b5dcf8351882519790c9a2e">浅拷贝与深拷贝</a></p>
</blockquote>
<p>原型继承的基本思想：</p>
<p>借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>object()</code> 函数内部，先穿甲一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例，从本质上讲，<code>object()</code> 对传入的对象执行了一次浅拷贝。</p>
<p>ECMAScript5 通过新增 <code>Object.create()</code>方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象(可以覆盖原型对象上的同名属性)，在传入一个参数的情况下，<code>Object.create()</code> 和 <code>object()</code> 方法的行为相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="built_in">Object</span>.create(person);</span><br><span class="line">person1.name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">person1.hobbies.push(<span class="string">&quot;coding&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person);</span><br><span class="line">person2.name = <span class="string">&quot;Echo&quot;</span>;</span><br><span class="line">person2.hobbies.push(<span class="string">&quot;running&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.hobbies); <span class="comment">//[ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27;, &#x27;running&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hobbies); <span class="comment">//[ &#x27;reading&#x27;, &#x27;photography&#x27;, &#x27;coding&#x27;, &#x27;running&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>在没有必要创建构造函数，仅让一个对象与另一个对象保持相似的情况下，原型式继承是可以胜任的。</p>
<blockquote>
<p>缺点:</p>
</blockquote>
<p>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。</p>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//以某种方式增强这个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Yvette&quot;</span>,</span><br><span class="line">  hobbies: [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;photography&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = createAnother(person);</span><br><span class="line">person2.sayHi(); <span class="comment">//hi</span></span><br></pre></td></tr></table></figure>

<p>基于 <code>person</code> 返回了一个新对象 -—— <code>person2</code>，新对象不仅具有 <code>person</code> 的所有属性和方法，而且还有自己的 <code>sayHi()</code> 方法。在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。</p>
<blockquote>
<p>缺点：</p>
</blockquote>
<ul>
<li>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。</li>
<li>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。</li>
</ul>
<h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，基本思路：</p>
<p>不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">  prototype.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">  subType.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一步：创建超类型原型的一个副本</li>
<li>第二步：为创建的副本添加 <code>constructor</code> 属性</li>
<li>第三步：将新创建的对象赋值给子类型的原型</li>
</ul>
<p>至此，我们就可以通过调用 <code>inheritPrototype</code> 来替换为子类型原型赋值的语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...code</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuberType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SuberType, SuperType);</span><br><span class="line"><span class="comment">//...code</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>优点:</p>
</blockquote>
<p>只调用了一次超类构造函数，效率更高。避免在<code>SuberType.prototype</code>上面创建不必要的、多余的属性，与其同时，原型链还能保持不变。</p>
<p>因此寄生组合继承是引用类型最理性的继承范式。</p>
<h4 id="ES6-继承"><a href="#ES6-继承" class="headerlink" title="ES6 继承"></a>ES6 继承</h4><p><code>Class</code> 可以通过 extends 关键字实现继承，如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age) &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age, name) &#123;</span><br><span class="line">    <span class="built_in">super</span>(age); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType(<span class="number">22</span>, <span class="string">&quot;刘小夕&quot;</span>);</span><br><span class="line">instance.getAge(); <span class="comment">//22</span></span><br></pre></td></tr></table></figure>

<p>对于 ES6 的 <code>class</code> 需要做以下几点说明：</p>
<ol>
<li>类的数据类型就是函数，类本身就指向构造函数。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> SuperType); <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(SuperType === SuperType.prototype.constructor); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>类的内部所有定义的方法，都是不可枚举的。(ES5 原型上的方法默认是可枚举的)</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(SuperType.prototype);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>constructor</code> 方法是类的默认方法，通过 <code>new</code> 命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code> 方法，如果没有显式定义，一个空的 <code>constructor</code> 方法会被默认添加。</li>
<li><code>Class</code> 不能像构造函数那样直接调用，会抛出错误。</li>
</ol>
<p>使用 <code>extends</code> 关键字实现继承，有一点需要特别说明：</p>
<ul>
<li>子类必须在 <code>constructor</code> 中调用 <code>super</code> 方法，否则新建实例时会报错。如果没有子类没有定义 <code>constructor</code> 方法，那么这个方法会被默认添加。在子类的构造函数中，只有调用 <code>super</code> 之后，才能使用 <code>this</code>关键字，否则报错。这是因为子类实例的构建，基于父类实例，只有 super 方法才能调用父类实例。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="built_in">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="【Step-By-Step】高频面试题深入解析-周刊-07"><a href="#【Step-By-Step】高频面试题深入解析-周刊-07" class="headerlink" title="【Step-By-Step】高频面试题深入解析 / 周刊 07"></a>【Step-By-Step】高频面试题深入解析 / 周刊 07</h2><blockquote>
<p>本周面试题一览:</p>
</blockquote>
<ul>
<li><a href="https://github.com/YvetteLau/Step-By-Step/issues/39">实现一个 JSON.stringify</a></li>
<li><a href="https://github.com/YvetteLau/Step-By-Step/issues/40">实现一个 JSON.parse</a></li>
<li><a href="https://github.com/YvetteLau/Step-By-Step/issues/41">实现一个观察者模式</a></li>
<li><a href="https://github.com/YvetteLau/Step-By-Step/issues/42">使用 CSS 让一个元素水平垂直居中有哪些方式</a></li>
<li><a href="https://github.com/YvetteLau/Step-By-Step/issues/43">ES6 模块和 CommonJS 模块有哪些差异？</a></li>
</ul>
<h3 id="1-实现一个-JSON-stringify-（2019-10-27）"><a href="#1-实现一个-JSON-stringify-（2019-10-27）" class="headerlink" title="1. 实现一个 JSON.stringify （2019-10-27）"></a>1. 实现一个 <code>JSON.stringify</code> （2019-10-27）</h3><p><code>JSON.stringify([, replacer [, space])</code> 方法是将一个 JavaScript 值(对象或者数组)转换为一个 JSON 字符串。此处模拟实现，不考虑可选的第二个参数 <code>replacer</code> 和第三个参数 <code>space</code>，如果对这两个参数的作用还不了解，建议阅读 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">MDN</a> 文档。</p>
<blockquote>
<p><code>JSON.stringify()</code> 将值转换成对应的 <code>JSON</code> 格式:</p>
</blockquote>
<p>1、基本数据类型：</p>
<ul>
<li>undefined 转换之后仍是 undefined(类型也是 <code>undefined</code>)</li>
<li>boolean 值转换之后是字符串 <code>&quot;false&quot;/&quot;true&quot;</code></li>
<li>number 类型(除了 <code>NaN</code> 和 <code>Infinity</code>)转换之后是字符串类型的数值</li>
<li>symbol 转换之后是 <code>undefined</code></li>
<li>null 转换之后是字符串 <code>&quot;null&quot;</code></li>
<li>string 转换之后仍是 string</li>
<li><code>NaN</code> 和 <code>Infinity</code> 转换之后是字符串 <code>&quot;null&quot;</code></li>
</ul>
<p>2、如果是函数类型</p>
<ul>
<li>转换之后是 <code>undefined</code></li>
</ul>
<p>3、如果是对象类型(非函数)</p>
<ul>
<li>如果有 <code>toJSON()</code> 方法，那么序列化 <code>toJSON()</code> 的返回值。</li>
<li>如果是一个数组<ul>
<li>如果属性值中出现了 <code>undefined</code>、任意的函数以及 <code>symbol</code>，转换成字符串 <code>&quot;null&quot;</code></li>
</ul>
</li>
<li>如果是 <code>RegExp</code> 对象。<br>返回 <code>&#123;&#125;</code> (类型是 string)</li>
<li>如果是 <code>Date</code> 对象，返回 <code>Date</code> 的 <code>toJSON</code> 字符串值</li>
<li>如果是普通对象；<ul>
<li>如果属性值中出现了 <code>undefined</code>、任意的函数以及 symbol 值，忽略。</li>
<li>所有以 <code>symbol</code> 为属性键的属性都会被完全忽略掉。</li>
</ul>
</li>
</ul>
<p>4、对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。</p>
<blockquote>
<p>模拟实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonStringify</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dataType = <span class="keyword">typeof</span> data;</span><br><span class="line">  <span class="keyword">if</span> (dataType !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = data;</span><br><span class="line">    <span class="comment">//data 可能是 string/number/null/undefined/boolean</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(data) || data === <span class="literal">Infinity</span>) &#123;</span><br><span class="line">      <span class="comment">//NaN 和 Infinity 序列化返回 &quot;null&quot;</span></span><br><span class="line">      result = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      dataType === <span class="string">&quot;function&quot;</span> ||</span><br><span class="line">      dataType === <span class="string">&quot;undefined&quot;</span> ||</span><br><span class="line">      dataType === <span class="string">&quot;symbol&quot;</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">//function 、undefined 、symbol 序列化返回 undefined</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataType === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      result = <span class="string">&#x27;&quot;&#x27;</span> + data + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//boolean 返回 String()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(result);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataType === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.toJSON &amp;&amp; <span class="keyword">typeof</span> data.toJSON === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> jsonStringify(data.toJSON());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> result = [];</span><br><span class="line">      <span class="comment">//如果是数组</span></span><br><span class="line">      <span class="comment">//toJSON 方法可以存在于原型链中</span></span><br><span class="line">      data.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          <span class="keyword">typeof</span> item === <span class="string">&quot;undefined&quot;</span> ||</span><br><span class="line">          <span class="keyword">typeof</span> item === <span class="string">&quot;function&quot;</span> ||</span><br><span class="line">          <span class="keyword">typeof</span> item === <span class="string">&quot;symbol&quot;</span></span><br><span class="line">        ) &#123;</span><br><span class="line">          result[index] = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          result[index] = jsonStringify(item);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      result = <span class="string">&quot;[&quot;</span> + result + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> result.replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//普通对象</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 循环引用抛错(暂未检测，循环引用时，堆栈溢出)</span></span><br><span class="line"><span class="comment">       * symbol key 忽略</span></span><br><span class="line"><span class="comment">       * undefined、函数、symbol 为属性值，被忽略</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">let</span> result = [];</span><br><span class="line">      <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&quot;symbol&quot;</span>) &#123;</span><br><span class="line">          <span class="comment">//key 如果是symbol对象，忽略</span></span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            data[item] !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">            <span class="keyword">typeof</span> data[item] !== <span class="string">&quot;function&quot;</span> &amp;&amp;</span><br><span class="line">            <span class="keyword">typeof</span> data[item] !== <span class="string">&quot;symbol&quot;</span></span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="comment">//键值如果是 undefined、函数、symbol 为属性值，忽略</span></span><br><span class="line">            result.push(<span class="string">&#x27;&quot;&#x27;</span> + item + <span class="string">&#x27;&quot;&#x27;</span> + <span class="string">&quot;:&quot;</span> + jsonStringify(data[item]));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> (<span class="string">&quot;&#123;&quot;</span> + result + <span class="string">&quot;&#125;&quot;</span>).replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-实现一个-JSON-parse-（2019-10-28）"><a href="#2-实现一个-JSON-parse-（2019-10-28）" class="headerlink" title="2. 实现一个 JSON.parse  （2019-10-28）"></a>2. 实现一个 <code>JSON.parse </code> （2019-10-28）</h3><p><code>JSON.parse(JSON.parse(text[, reviver])</code> 方法用来解析 JSON 字符串，构造由字符串描述的 JavaScript 值或对象。提供可选的 reviver 函数用以在返回之前对所得到的对象执行变换。此处模拟实现，不考虑可选的第二个参数 <code>reviver</code> ，如果对这个参数的作用还不了解，建议阅读 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">MDN</a> 文档。</p>
<p><strong>第一种方式 eval</strong></p>
<p>最简单，最直观的方式就是调用 <code>eval</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;小姐姐&quot;, &quot;age&quot;:20&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> + json + <span class="string">&quot;)&quot;</span>); <span class="comment">// obj 就是 json 反序列化之后得到的对象</span></span><br></pre></td></tr></table></figure>

<p>直接调用 <code>eval</code> 存在 <code>XSS</code> 漏洞，数据中可能不是 <code>json</code> 数据，而是可执行的 <code>JavaScript</code> 代码。因此，在调用 <code>eval</code> 之前，需要对数据进行校验。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rx_one = <span class="regexp">/^[\],:&#123;&#125;\s]*$/</span>;</span><br><span class="line"><span class="keyword">var</span> rx_two = <span class="regexp">/\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_three = <span class="regexp">/&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_four = <span class="regexp">/(?:^|:|,)(?:\s*\[)+/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  rx_one.test(</span><br><span class="line">    json.replace(rx_two, <span class="string">&quot;@&quot;</span>).replace(rx_three, <span class="string">&quot;]&quot;</span>).replace(rx_four, <span class="string">&quot;&quot;</span>)</span><br><span class="line">  )</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> + json + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JSON</code> 是 JS 的子集，可以直接交给 <code>eval</code> 运行。</p>
<p><strong>第二种方式 <code>new Function</code></strong></p>
<p><code>Function</code> 与 <code>eval</code> 有相同的字符串参数特性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;小姐姐&quot;, &quot;age&quot;:20&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;return &quot;</span> + json)();</span><br></pre></td></tr></table></figure>

<h3 id="3-实现一个观察者模式-（2019-10-29）"><a href="#3-实现一个观察者模式-（2019-10-29）" class="headerlink" title="3. 实现一个观察者模式 （2019-10-29）"></a>3. 实现一个观察者模式 （2019-10-29）</h3><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯。</p>
<p>观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有一家猎人工会，其中每个猎人都具有发布任务(publish)，订阅任务(subscribe)的功能</span></span><br><span class="line"><span class="comment">//他们都有一个订阅列表来记录谁订阅了自己</span></span><br><span class="line"><span class="comment">//定义一个猎人类</span></span><br><span class="line"><span class="comment">//包括姓名，级别，订阅列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hunter</span>(<span class="params">name, level</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.level = level;</span><br><span class="line">  <span class="built_in">this</span>.list = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Hunter.prototype.publish = <span class="function"><span class="keyword">function</span> (<span class="params">money</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.level + <span class="string">&quot;猎人&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;寻求帮助&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.list.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">    item(money);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Hunter.prototype.subscribe = <span class="function"><span class="keyword">function</span> (<span class="params">targrt, fn</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.level + <span class="string">&quot;猎人&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;订阅了&quot;</span> + targrt.name);</span><br><span class="line">  targrt.list.push(fn);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//猎人工会走来了几个猎人</span></span><br><span class="line"><span class="keyword">let</span> hunterMing = <span class="keyword">new</span> Hunter(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;黄金&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hunterJin = <span class="keyword">new</span> Hunter(<span class="string">&quot;小金&quot;</span>, <span class="string">&quot;白银&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hunterZhang = <span class="keyword">new</span> Hunter(<span class="string">&quot;小张&quot;</span>, <span class="string">&quot;黄金&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> hunterPeter = <span class="keyword">new</span> Hunter(<span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;青铜&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Peter等级较低，可能需要帮助，所以小明，小金，小张都订阅了Peter</span></span><br><span class="line">hunterMing.subscribe(hunterPeter, <span class="function"><span class="keyword">function</span> (<span class="params">money</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&quot;小明表示：&quot;</span> + (money &gt; <span class="number">200</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;暂时很忙，不能&quot;</span>) + <span class="string">&quot;给予帮助&quot;</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line">hunterJin.subscribe(hunterPeter, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;小金表示：给予帮助&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">hunterZhang.subscribe(hunterPeter, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;小张表示：给予帮助&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Peter遇到困难，赏金198寻求帮助</span></span><br><span class="line">hunterPeter.publish(<span class="number">198</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//猎人们(观察者)关联他们感兴趣的猎人(目标对象)，如Peter，当Peter有困难时，会自动通知给他们（观察者）</span></span><br></pre></td></tr></table></figure>

<h3 id="5-ES6-模块和-CommonJS-模块有哪些差异？（2019-10-30）"><a href="#5-ES6-模块和-CommonJS-模块有哪些差异？（2019-10-30）" class="headerlink" title="5. ES6 模块和 CommonJS 模块有哪些差异？（2019-10-30）"></a>5. ES6 模块和 <code>CommonJS</code> 模块有哪些差异？（2019-10-30）</h3><blockquote>
<p><a href="https://github.com/YvetteLau/Blog/issues/38">参考</a></p>
</blockquote>
<ol>
<li><code>CommonJS</code> 模块是运行时加载，ES6 模块是编译时输出接口。</li>
</ol>
<ul>
<li>ES6 模块在编译时，就能确定模块的依赖关系，以及输入和输出的变量。ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>
<li><code>CommonJS</code> 加载的是一个对象，该对象只有在脚本运行完才会生成。</li>
</ul>
<ol start="2">
<li><code>CommonJS</code> 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
</ol>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">- `CommonJS` 输出的是一个值的拷贝(注意基本数据类型/复杂数据类型)</span><br><span class="line"></span><br><span class="line">- ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>ES6 模块自动采用严格模式，无论模块头部是否写了 <code>&quot;use strict&quot;;</code></li>
<li>require 可以做动态加载，<code>import</code> 语句做不到，<code>import</code> 语句必须位于顶层作用域中。</li>
<li>ES6 模块的输入变量是只读的，不能对其进行重新赋值</li>
<li>当使用 require 命令加载某个模块时，就会运行整个模块的代码。</li>
<li>当使用 require 命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</li>
</ol>
]]></content>
      <categories>
        <category>牛人面试题</category>
        <category>Step-By-Step</category>
      </categories>
      <tags>
        <tag>牛人面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试中的复杂度分析</title>
    <url>/2019/09/11/ComplexityAnalysis/</url>
    <content><![CDATA[<h1 id="面试中的复杂度分析"><a href="#面试中的复杂度分析" class="headerlink" title="面试中的复杂度分析"></a>面试中的复杂度分析</h1><blockquote>
<p>很多同学一提起复杂度分析就头疼，马上想起了《算法导论》中复杂的数学推导。但其实在一般的企业面试中，对复杂度的分析要求并没有那么高，但也是绕不过去的坎儿。在这一章，和大家介绍一下，面试中需要掌握的复杂度分析。…</p>
</blockquote>
<h2 id="2-1-究竟什么是大-O（Big-O）"><a href="#2-1-究竟什么是大-O（Big-O）" class="headerlink" title="2-1 究竟什么是大 O（Big O）"></a>2-1 究竟什么是大 O（Big O）</h2><h4 id="大-O？"><a href="#大-O？" class="headerlink" title="大 O？"></a>大 O？</h4><ul>
<li>n 表示数据规模</li>
<li>O（f(n)）表示运行算法所需要执行的指令数，和 f(n) 成正比</li>
</ul>
<h4 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h4><ul>
<li>二分查找法 O(logn) — 所需执行指令数 ：a * logn</li>
<li>寻找 数组中的最大/最小值 O(n) — 所需执行指令数 ：b * n</li>
<li>归并排序算法 O(nlogn) — 所需执行指令数 ：c * nlogn</li>
<li>选择排序法 O(n^2) — 所需执行指令数 ：d * n^2</li>
</ul>
<h3 id="到底什么是-Big-O？"><a href="#到底什么是-Big-O？" class="headerlink" title="到底什么是 Big O？"></a>到底什么是 Big O？</h3><p><img src="http://static.zxinc520.com/blog/20190909/61aLQ2wE8prQ.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190909/2PO7UfwEDOpW.png?imageslim" alt="mark"></p>
<p><strong>在学术界</strong>，严格来讲，O(f(n)) 表示算法执行的上界</p>
<p>归并排序算法的时间复杂度是 O(nlogn)的，同时也是 O（n^2）</p>
<p><strong>在业界</strong>，我们就使用 O 来表示算法执行的最低上界</p>
<p>我们一般不会说归并排序是 O(n^2)的</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>O（nlogn + n）= O （nlogn）</li>
<li>O（nlogn + n^2）=O（n^2）</li>
</ul>
<h4 id="无法判断"><a href="#无法判断" class="headerlink" title="无法判断"></a>无法判断</h4><ul>
<li><p>O（AlogA + B） – A 与 B 无法确定</p>
</li>
<li><p>O（AlogA + B ^2）</p>
</li>
<li><p>对邻接表实现的图进行遍历</p>
<ul>
<li>时间复杂度：O（ V + E ）</li>
</ul>
</li>
</ul>
<h3 id="一个时间复杂度的问题"><a href="#一个时间复杂度的问题" class="headerlink" title="一个时间复杂度的问题"></a>一个时间复杂度的问题</h3><p>有一个字符串数组，将数组中的每一个字符串按照字母序排序；之后再将整个字符串数组按照字典序排序。整个操作的时间复杂度？</p>
<p><img src="http://static.zxinc520.com/blog/20190909/8cfiXUHkirne.png?imageslim" alt="mark"></p>
<p>正确解答：</p>
<ul>
<li>假设最长的字符串长度为 s ；数组中有 n 个字符串</li>
<li>对每个字符串排序：O（slogs）</li>
<li>将数组中的每一个字符串按照字母序排序：O（n * slog(s) ）</li>
<li>将整个字符串数组按照字典序排序：O（s * nlog(n) ）</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190909/Q5nKtKe1dCi7.png?imageslim" alt="mark"></p>
<h3 id="算法复杂度在有些情况是用例相关的"><a href="#算法复杂度在有些情况是用例相关的" class="headerlink" title="算法复杂度在有些情况是用例相关的"></a>算法复杂度在有些情况是用例相关的</h3><ul>
<li><p>插入排序 O（n ^ 2）</p>
<ul>
<li>最差情况：O（n ^ 2）</li>
<li>最好情况：O（n）</li>
<li>平均情况：O（n ^ 2）</li>
</ul>
</li>
<li><p>快速排序算法 O （nlogn）</p>
<ul>
<li>最差情况：O（n ^ 2）</li>
<li>最好情况：O（ nlogn ）</li>
<li>平均情况：O（ nlogn ）</li>
</ul>
</li>
</ul>
<h2 id="2-2-对数据规模有一个概念"><a href="#2-2-对数据规模有一个概念" class="headerlink" title="2-2 对数据规模有一个概念"></a>2-2 对数据规模有一个概念</h2><h3 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h3><p>对 10 ^ 5 的数据进行选择排序，结果计算机假死？</p>
<ul>
<li>如果要想在 1s 之内解决问题：<ul>
<li>O（n ^ 2）的算法可以处理大约 10 ^ 4 级别的数据</li>
<li>O（ n ）的算法可以处理大约 10 ^ 8 级别的数据</li>
<li>O（ nlogn ）的算法可以处理大约 10 ^7 级别的数据</li>
</ul>
</li>
</ul>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul>
<li>多开一个辅助的数组：O（n）</li>
<li>多开一个辅助的二维数组：O（n ^ 2）</li>
<li>多开常数空间：O（1）</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190909/7uFcA2L2OHhI.png?imageslim" alt="mark"></p>
<h2 id="2-3-简单的复杂度分析"><a href="#2-3-简单的复杂度分析" class="headerlink" title="2-3 简单的复杂度分析"></a>2-3 简单的复杂度分析</h2><h3 id="O（1）："><a href="#O（1）：" class="headerlink" title="O（1）："></a>O（1）：</h3><p><img src="http://static.zxinc520.com/blog/20190909/wmyLLvW5hvGh.png?imageslim" alt="mark"></p>
<h3 id="O（-n-）："><a href="#O（-n-）：" class="headerlink" title="O（ n ）："></a>O（ n ）：</h3><p><img src="http://static.zxinc520.com/blog/20190909/R4zqgJ9zJqqs.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190909/fujJT4N78Ybh.png?imageslim" alt="mark"></p>
<p>1/2 *n 次 swap 操作也是：O(n) 。</p>
<h3 id="O（n-2）-选择排序"><a href="#O（n-2）-选择排序" class="headerlink" title="O（n ^ 2）: ( 选择排序 )"></a>O（n ^ 2）: ( 选择排序 )</h3><p><img src="http://static.zxinc520.com/blog/20190909/HPtrTeSx6DsB.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190909/rh5JcB9dA8ux.png?imageslim" alt="mark"></p>
<p>并不是所有双重循环都是 O（n ^ 2）：例如 【因为里面的循环次数是固定的 】</p>
<p><img src="http://static.zxinc520.com/blog/20190909/Vs0lBjzBPEi9.png?imageslim" alt="mark"></p>
<p>下面算法是 O（logn）级别的： 【 自增并不是每次都加 1 】</p>
<p><img src="http://static.zxinc520.com/blog/20190909/QJC2YLSAOdAk.png?imageslim" alt="mark"></p>
<p>下面算法是 O（ sqrt (n) ）【 判断 n 是不是 一个素数】</p>
<p><img src="http://static.zxinc520.com/blog/20190909/QeClcFN8EsWa.png?imageslim" alt="mark"></p>
<h3 id="O（logn）：（-二分查找法-）"><a href="#O（logn）：（-二分查找法-）" class="headerlink" title="O（logn）：（ 二分查找法 ）"></a>O（logn）：（ 二分查找法 ）</h3><p><img src="http://static.zxinc520.com/blog/20190909/HCC3KITFnmlL.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190909/Y18HXPKRMICe.png?imageslim" alt="mark"></p>
<h4 id="整形转成字符串"><a href="#整形转成字符串" class="headerlink" title="整形转成字符串"></a>整形转成字符串</h4><p><img src="http://static.zxinc520.com/blog/20190909/gDCAKNS0NtKo.png?imageslim" alt="mark"></p>
<h3 id="log-以-2-为底-和-以-10-为底有区别吗"><a href="#log-以-2-为底-和-以-10-为底有区别吗" class="headerlink" title="log 以 2 为底 和 以 10 为底有区别吗"></a>log 以 2 为底 和 以 10 为底有区别吗</h3><p><img src="http://static.zxinc520.com/blog/20190909/hhkkzyo7uTJM.png?imageslim" alt="mark"></p>
<h2 id="2-4-亲自试验自己算法的时间复杂度"><a href="#2-4-亲自试验自己算法的时间复杂度" class="headerlink" title="2-4 亲自试验自己算法的时间复杂度"></a>2-4 亲自试验自己算法的时间复杂度</h2><h3 id="复杂度实验"><a href="#复杂度实验" class="headerlink" title="复杂度实验"></a>复杂度实验</h3><p>实验，观察趋势</p>
<p>每次 将数据规模提高两倍，看时间的变化</p>
<h2 id="2-5-递归算法的复杂度分析"><a href="#2-5-递归算法的复杂度分析" class="headerlink" title="2-5 递归算法的复杂度分析"></a>2-5 递归算法的复杂度分析</h2><blockquote>
<p>不是有递归的函数就一定是 O（ nlogn ）！</p>
</blockquote>
<h3 id="递归中进行一次递归调用的复杂度分析"><a href="#递归中进行一次递归调用的复杂度分析" class="headerlink" title="递归中进行一次递归调用的复杂度分析"></a>递归中进行一次递归调用的复杂度分析</h3><p>二分法使用递归：</p>
<p><img src="http://static.zxinc520.com/blog/20190911/Vrm1PVyknLyf.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190911/HKc9QUhHzufd.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190911/Mrr5oypWBxGk.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190911/1hAzDU4ifP7w.png?imageslim" alt="mark"></p>
<p>引申：上述 函数增加求 负次幂？</p>
<h3 id="递归中进行多次递归调用"><a href="#递归中进行多次递归调用" class="headerlink" title="递归中进行多次递归调用"></a>递归中进行多次递归调用</h3><p><img src="http://static.zxinc520.com/blog/20190911/DmVGKhPNOvil.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190911/vlrGbmrXl4uo.png?imageslim" alt="mark"></p>
<p>深度不一样，并不是所有 多次递归调用 的时间复杂度 为：O（2 ^ n）</p>
<p><img src="http://static.zxinc520.com/blog/20190911/copG1I1hd0ya.png?imageslim" alt="mark"></p>
<h4 id="递归函数的时间复杂度"><a href="#递归函数的时间复杂度" class="headerlink" title="递归函数的时间复杂度"></a>递归函数的时间复杂度</h4><p>查阅 <strong>主定理</strong> （面试一般不考察）</p>
<h2 id="2-6-均摊时间复杂度分析（Amortized-Time-Analysis）"><a href="#2-6-均摊时间复杂度分析（Amortized-Time-Analysis）" class="headerlink" title="2-6 均摊时间复杂度分析（Amortized Time Analysis）"></a>2-6 均摊时间复杂度分析（Amortized Time Analysis）</h2><p><img src="http://static.zxinc520.com/blog/20190911/lH5rYQsGwqtN.png?imageslim" alt="mark"></p>
<h2 id="2-7-避免复杂度的震荡"><a href="#2-7-避免复杂度的震荡" class="headerlink" title="2-7 避免复杂度的震荡"></a>2-7 避免复杂度的震荡</h2><p><img src="http://static.zxinc520.com/blog/20190911/glngyIU8g3Mi.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190911/AFsH4CLIkIE3.png?imageslim" alt="mark"></p>
<h3 id="复杂度的震荡的解决方案"><a href="#复杂度的震荡的解决方案" class="headerlink" title="复杂度的震荡的解决方案"></a>复杂度的震荡的解决方案</h3><p><img src="http://static.zxinc520.com/blog/20190911/hwAvgAw9rUM1.png?imageslim" alt="mark"></p>
]]></content>
      <categories>
        <category>玩转算法面试</category>
      </categories>
      <tags>
        <tag>算法面试</tag>
        <tag>算法</tag>
        <tag>大 O？</tag>
        <tag>复杂度分析</tag>
      </tags>
  </entry>
  <entry>
    <title>算法面试到底是什么鬼</title>
    <url>/2019/09/09/AlgorithmForTheInterview01/</url>
    <content><![CDATA[<h1 id="算法面试到底是什么鬼"><a href="#算法面试到底是什么鬼" class="headerlink" title="算法面试到底是什么鬼?"></a>算法面试到底是什么鬼?</h1><blockquote>
<p>玩转算法面试 从真题到思维全面提升算法思维</p>
<p>为了面试，更为了提升你的算法思维</p>
<p>一提起算法面试，很多同学就会心有余悸。可其实，大多数企业的算法面试，并没有那么可怕。并不是一定要啃完整本《算法导论》，才能玩儿转算法面试；也并不是只有 ACM 参赛选手，才能笑傲算法面试。恰恰相反，大多数算法面试关注的算法思维，其实很基础。在这一章，和大家聊一聊，算法面试，到底是什么鬼？…</p>
</blockquote>
<h2 id="1-1-算法面试不仅仅是正确的回答问题"><a href="#1-1-算法面试不仅仅是正确的回答问题" class="headerlink" title="1-1 算法面试不仅仅是正确的回答问题"></a>1-1 算法面试不仅仅是正确的回答问题</h2><h4 id="算法面试是什么？"><a href="#算法面试是什么？" class="headerlink" title="算法面试是什么？"></a>算法面试是什么？</h4><ul>
<li>让大家在面对面试中的算法问题时，有一个合理的思考路径<ul>
<li>不代表能够“正确”回答每一个算法问题，但是合理的思考方向其实更重要，这也是正确完成算法面试问题的前提</li>
<li>算法面试优秀不意味着技术面试优秀</li>
<li>技术面试优秀不意味着能够拿到 Offer</li>
</ul>
</li>
</ul>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><h4 id="问题：对一组数据进行排序"><a href="#问题：对一组数据进行排序" class="headerlink" title="问题：对一组数据进行排序"></a>问题：对一组数据进行排序</h4><p>不假思索思考方向：</p>
<ul>
<li>快速排序算法 O（nlogn）</li>
</ul>
<p><strong>正确的方式</strong>是：应该和面试官探讨（ <strong>思考路径</strong> ）：</p>
<ul>
<li>这组数据有什么样的特征？<ul>
<li>有没有可能包含有大量重复的元素？</li>
<li>如果有这种可能的话，三路快排是更好的选择。</li>
</ul>
</li>
<li>这组数据有什么样的特征？<ul>
<li>是否大部分数据距离它正确的位置很近？是否近乎有序？</li>
<li>如果是这样的话，插入排序是更好的选择</li>
</ul>
</li>
<li>这组数据有什么样的特征？<ul>
<li>是否数据的取值范围非常有限？比如对学生成绩排序</li>
<li>如果是这样的话，计数排序是更好的选择</li>
</ul>
</li>
<li>对排序有什么额外的要求？<ul>
<li>是否需要稳定排序？</li>
<li>如果是的话，归并排序是更好的选择</li>
</ul>
</li>
<li>数据的存储状况是怎么样的？<ul>
<li>是否是使用链表存储的？</li>
<li>如果是的话，归并排序是更好的选择</li>
</ul>
</li>
<li>数据的存储状态是怎样的？<ul>
<li>数据的大小是否可以装载在内存里？</li>
<li>数据量很大，或者内存很小，不足以装载在内存里，需要使用外排序算法</li>
</ul>
</li>
</ul>
<h2 id="1-2-什么是“正确”的回答一个算法问题"><a href="#1-2-什么是“正确”的回答一个算法问题" class="headerlink" title="1-2 什么是“正确”的回答一个算法问题"></a>1-2 什么是“正确”的回答一个算法问题</h2><p><strong>正确</strong> 还包含对问题的独到见解；优化；代码规范；容错性</p>
<p>如果是 非常难的问题，对你的竞争对手来说，也是难的。</p>
<p>关键在于你所表达出的解决问题的思路</p>
<p>甚至通过表达解题思路的方向，得出结论：这个问题的解决方案，应该在哪一个领域，我可以通过查阅或者进一步学习解决问题</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul>
<li>项目经历 和 项目中遇到的实际问题</li>
<li>你遇到的印象最深的 bug 是什么？</li>
<li>面向对象</li>
<li>设计模式</li>
<li>网络相关；安全相关；内存相关；并发相关</li>
<li>系统设计；scalability</li>
</ul>
<p>技术面试只是面试的一部分。面试不仅仅是考察你的技术水平，还是了解你的过去以及形成的思考行为方式</p>
<p>关于过去：参与项目至关重要</p>
<h4 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h4><ul>
<li>本科生<ul>
<li>毕业设计</li>
<li>其它课程设计(大作业，大一点的程序设计等等)</li>
</ul>
</li>
<li>如何找到项目？<ul>
<li>实习</li>
<li>参与实战课程学习<ul>
<li>慕课网</li>
<li>Coursera</li>
</ul>
</li>
</ul>
</li>
<li>创建自己的项目<ul>
<li>自己做小应用：计划表；备忘录；播放器…</li>
<li>自己解决小问题：爬虫；数据分析；词频统计</li>
<li>“不是项目” 的项目：一本优秀的技术书籍的代码整理等…</li>
<li>分享：自己的技术博客；github 等等…</li>
</ul>
</li>
</ul>
<h4 id="行为类问题"><a href="#行为类问题" class="headerlink" title="行为类问题"></a>行为类问题</h4><p>通过过去了解你的思考行为方式？</p>
<ul>
<li>遇到的最大的挑战？</li>
<li>犯过的错误？</li>
<li>遭遇的失败？</li>
<li>最享受的工作内容？</li>
<li>遇到冲突的处理方式？</li>
<li>做的最与众不同的事儿？</li>
</ul>
<h4 id="准备好合适的问题问面试官"><a href="#准备好合适的问题问面试官" class="headerlink" title="准备好合适的问题问面试官"></a>准备好合适的问题问面试官</h4><ul>
<li>整个小组的大概运行模式是怎样的？</li>
<li>整个项目的后续规划是如何的？</li>
<li>这个产品中的某个问题是如何解决的？</li>
<li>为什么会选择某些技术？标准？</li>
<li>我对某个技术很感兴趣，在你的小组中我会有怎样的机会深入这种技术？</li>
</ul>
<p><strong>算法面试仍然是非常重要的一部分</strong></p>
<h2 id="1-3-如何准备算法面试"><a href="#1-3-如何准备算法面试" class="headerlink" title="1-3 如何准备算法面试"></a>1-3 如何准备算法面试</h2><p>准备面试 和 准备算法面试 是两个概念</p>
<p>算法面试 ，只是面试中的一个环节</p>
<h2 id="算法面试并没有那么难"><a href="#算法面试并没有那么难" class="headerlink" title="算法面试并没有那么难"></a>算法面试并没有那么难</h2><ul>
<li>远远不需要啃完一本 《算法导论》<ul>
<li>过于强调理论证明</li>
</ul>
</li>
<li>高级数据结构 和 算法面试提及的概率很低<ul>
<li>红黑树</li>
<li>计算几何</li>
<li>B - Tree</li>
<li>数论</li>
<li>斐波那契堆</li>
<li>FFT</li>
</ul>
</li>
</ul>
<p><strong>算法面试远远不需要达到信息学竞赛的水平</strong> 。</p>
<p><img src="http://static.zxinc520.com/blog/20190908/CNmOn2PupuUn.png?imageslim" alt="mark"></p>
<h3 id="算法面试的准备范围"><a href="#算法面试的准备范围" class="headerlink" title="算法面试的准备范围"></a>算法面试的准备范围</h3><ul>
<li>不要轻视基础算法 和 数据结构，而只关注 “有意思” 的题目</li>
</ul>
<p>重点关注：</p>
<ul>
<li>各种排序算法</li>
<li>基础数据结构和算法的实现：如堆、二叉树、图….</li>
<li>基础数据结构的使用：如链表、栈、队列、哈希表、图、Trie、并查集…</li>
<li>基础算法：深度优先、广度优先、二分查找、递归…</li>
<li>基本算法思想：递归、分治、回溯搜索、贪心、动态规划…</li>
</ul>
<h3 id="选择合适的-OJ"><a href="#选择合适的-OJ" class="headerlink" title="选择合适的 OJ"></a>选择合适的 OJ</h3><blockquote>
<p>OJ：online judge</p>
<p>在线判题系统</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190908/iW0zhuflnMIs.png?imageslim" alt="mark"></p>
<h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><ul>
<li><a href="https://leetcode-cn.com/">LeetCode</a> （ 源于真实的面试问题 ）</li>
<li><a href="https://www.hackerrank.com/">HackerRank</a> （ 对问题分类很详细 ，更难一点，辅助作用）</li>
</ul>
<p><strong>注意</strong>： 在学习和实践做题之间，要掌握平衡</p>
<h2 id="1-4-解决算法面试问题的整体思路"><a href="#1-4-解决算法面试问题的整体思路" class="headerlink" title="1-4 解决算法面试问题的整体思路"></a>1-4 解决算法面试问题的整体思路</h2><h3 id="注意题目中的条件"><a href="#注意题目中的条件" class="headerlink" title="注意题目中的条件"></a>注意题目中的条件</h3><ul>
<li>给定一个有序数组…<ul>
<li><strong>有序</strong>： 是不是可以使用二分查找法</li>
</ul>
</li>
<li>有一些题目中的条件本质是暗示：<ul>
<li>设计一个 O（nlogn）的算法<ul>
<li>分治法</li>
</ul>
</li>
<li>无需考虑额外的空间<ul>
<li>开辟额外的空间</li>
</ul>
</li>
<li>数据规模大概是 10000<ul>
<li>O（n 的二次方）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="当没有思路的时候"><a href="#当没有思路的时候" class="headerlink" title="当没有思路的时候"></a>当没有思路的时候</h3><ul>
<li>自己给自己几个简单的测试用例，试验一下</li>
<li>不要忽视暴力解法。暴力解法通常是思考的起点</li>
</ul>
<h4 id="不要忽视暴力法"><a href="#不要忽视暴力法" class="headerlink" title="不要忽视暴力法"></a>不要忽视暴力法</h4><p><img src="http://static.zxinc520.com/blog/20190908/4H4HSG2k68nE.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190908/DTm490pyX7Vm.png?imageslim" alt="mark"></p>
<h2 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h2><h3 id="无头绪的思路"><a href="#无头绪的思路" class="headerlink" title="无头绪的思路"></a>无头绪的思路</h3><ul>
<li>遍历常见的算法思路</li>
<li>遍历常见的数据结构</li>
<li>空间 和 时间的 交换 （ 哈希表 ）</li>
<li>预处理信息 （ 排序 ）</li>
<li>在瓶颈处寻找答案：O（nlogn）+ O（n ∧ 2）；O（n∧3）</li>
</ul>
<h3 id="实际编写问题"><a href="#实际编写问题" class="headerlink" title="实际编写问题"></a>实际编写问题</h3><ul>
<li>极端条件的判断<ul>
<li>数组为空？字符串为空？数量为 0? 指针为 NULL ？</li>
</ul>
</li>
<li>变量名</li>
<li>模块化，复用性</li>
</ul>
]]></content>
      <categories>
        <category>玩转算法面试</category>
      </categories>
      <tags>
        <tag>算法面试</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>组件化和 React</title>
    <url>/2019/09/07/ReactTheory/</url>
    <content><![CDATA[<h1 id="组件化和-React"><a href="#组件化和-React" class="headerlink" title="组件化和 React"></a>组件化和 React</h1><blockquote>
<p>本章先带领学生做一个 React 的实例，熟悉 React 开发环境、以及 <strong>组件化</strong> 的概念。然后，通过实例来讲解 React 的 <strong>实现原理</strong>，包括 <strong>JSX 的本质</strong> 、<strong>虚拟 DOM 和 JSX 的结合</strong>、以及 <strong>setState</strong> 。最后，<strong>对比 vue 和 React</strong> ，分析两者的异同。</p>
<p>组件化和 React 高级面试知识点</p>
<p>Think great thoughts and you will be great!</p>
<p>心怀伟大的理想，你将会变得伟大。</p>
</blockquote>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>是否做过 React 开发？</li>
<li>React 以及组件化的一些核心概念</li>
<li>实现流程</li>
</ul>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul>
<li>说一下对组件化的理解</li>
<li>JSX 本质是什么？</li>
<li>JSX 和 vdom 的关系？</li>
<li>说一下 setState 的过程</li>
<li>阐述一下对 React 和 Vue 的 认识</li>
</ul>
<h4 id="回顾-React"><a href="#回顾-React" class="headerlink" title="回顾 React"></a>回顾 <a href="https://zh-hans.reactjs.org/">React</a></h4><ol>
<li><p>创建一个基本的 React 应用</p>
<p><a href="https://github.com/facebookincubator/create-react-app">Create React App</a> 是一个用于<strong>学习 React</strong> 的舒适环境，也是用 React 创建<strong>新的单页应用</strong>的最佳方式。</p>
<p>它会配置你的开发环境，以便使你能够使用最新的 JavaScript 特性，提供良好的开发体验，并为生产环境优化你的应用程序。你需要在你的机器上安装 Node &gt;= 8.10 和 npm &gt;= 5.6。要创建项目，请执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
</li>
<li><p>用 React 实现 <strong>to-do-list</strong> ：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      list: [],</span><br><span class="line">      title: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> list = <span class="built_in">this</span>.state.list;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">&quot;text&quot;</span></span><br><span class="line">          value=&#123;<span class="built_in">this</span>.state.title&#125;</span><br><span class="line">          onChange=&#123;<span class="built_in">this</span>.changeHandle.bind(<span class="built_in">this</span>)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.clickHandle.bind(<span class="built_in">this</span>)&#125;&gt;Submit&lt;/button&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span> &#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">          &#125;)&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeHandle(e) &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      title: e.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addTitle(title) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentList = <span class="built_in">this</span>.state.list;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      list: currentList.concat(title),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.list);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clickHandle(e) &#123;</span><br><span class="line">    <span class="keyword">const</span> title = <span class="built_in">this</span>.state.title;</span><br><span class="line">    <span class="built_in">this</span>.addTitle(title);</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      title: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Todo;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190907/GRlG7LRoeKp7.gif" alt="mark"></p>
<h2 id="7-1-说一下对组件化的理解"><a href="#7-1-说一下对组件化的理解" class="headerlink" title="7-1 说一下对组件化的理解"></a>7-1 说一下对组件化的理解</h2><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>组件的 <strong>封装</strong></li>
<li>组件的 <strong>复用</strong></li>
</ul>
<h4 id="组件的封装"><a href="#组件的封装" class="headerlink" title="组件的封装"></a>组件的封装</h4><ul>
<li>视图</li>
<li>数据</li>
<li>变化逻辑 （ 数据驱动视图变化 ）</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190907/m1BCsjY31wOd.png?imageslim" alt="mark"></p>
<h4 id="组件的-复用"><a href="#组件的-复用" class="headerlink" title="组件的 复用"></a>组件的 复用</h4><ul>
<li>props 传递</li>
<li>复用</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190907/dSD9f5yFTKYD.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190907/dig0u7rhRuJi.png?imageslim" alt="mark"></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><ul>
<li>说一下对组件化的理解？<ul>
<li>组件的封装：封装视图、数据、变化逻辑</li>
<li>组件的复用：props 传递、复用</li>
</ul>
</li>
</ul>
<h2 id="7-2-JSX-本质是什么"><a href="#7-2-JSX-本质是什么" class="headerlink" title="7-2 JSX 本质是什么"></a>7-2 JSX 本质是什么</h2><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>JSX 语法</li>
<li>JSX 解析成 JS</li>
<li>独立的标准</li>
</ul>
<h4 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h4><ul>
<li>html 形式</li>
<li>引入 JS 变量和表达式</li>
<li>if … else …</li>
<li>循环</li>
<li>style 和 className</li>
<li>事件</li>
</ul>
<h4 id="提出疑问"><a href="#提出疑问" class="headerlink" title="提出疑问"></a>提出疑问</h4><ul>
<li>JSX 语法根本无法被浏览器所解析</li>
<li>那么它如何在浏览器运行</li>
</ul>
<h4 id="JSX-解析"><a href="#JSX-解析" class="headerlink" title="JSX 解析"></a>JSX 解析</h4><ul>
<li>JSX 其实是语法糖</li>
<li>开发环境会将 JSX 编译成 JS 代码</li>
<li>JSX 的写法 大大降低了学习成本和 编码工作量</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190907/Xy8TYGeoHcWC.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190907/yjXVnlK8oLfk.png?imageslim" alt="mark"></p>
<h4 id="JSX-独立的标准"><a href="#JSX-独立的标准" class="headerlink" title="JSX 独立的标准"></a>JSX 独立的标准</h4><ul>
<li>JSX 是 React 引入的，但不是 React 独有的</li>
<li>React 已经将它作为一个独立的标准开放，其它项目也可用</li>
<li>React.createElement 是可以自定义修改的</li>
<li>说明：本身功能已经完备；和其它标准兼容和扩展性没问题</li>
</ul>
<h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>JSX 本质是什么？<ul>
<li>JSX 语法（标签、JS 表达式、判断、循环、事件绑定）</li>
<li>JSX 本质就是语法糖，需被解析成 JS 才能运行</li>
<li>JSX 是独立的标准，可被其它项目使用</li>
</ul>
</li>
</ul>
<h2 id="7-3-JSX-和-vdom-的关系"><a href="#7-3-JSX-和-vdom-的关系" class="headerlink" title="7-3 JSX 和 vdom 的关系"></a>7-3 JSX 和 vdom 的关系</h2><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>分析：为何需要 vdom</li>
<li>React.createElement 和 h</li>
<li>何时 patch？</li>
<li>自定义组件的解析</li>
</ul>
<h4 id="为何需要-vdom"><a href="#为何需要-vdom" class="headerlink" title="为何需要 vdom"></a>为何需要 vdom</h4><ul>
<li>vdom 是 React 初次推广开来的，结合 JSX</li>
<li>JSX 就是模板，最终要渲染成 html</li>
<li>初次渲染 + 修改 state 后的 re-render</li>
<li>正好 符合 vdom 的应用场景</li>
</ul>
<h4 id="回顾-vdom"><a href="#回顾-vdom" class="headerlink" title="回顾 vdom"></a>回顾 <a href="http://www.zxinc520.com/lcj/%225d63a1bce9920a5ce05e2c3b%22">vdom</a></h4><ul>
<li>vdom 如何应用，核心 API 是 什么？<ul>
<li>如何使用？ 可用 snabbdom 的 用法 来 举例</li>
<li>核心 函数 ：h 函数，patch 函数</li>
</ul>
</li>
</ul>
<p><strong>核心 API</strong> ：</p>
<ul>
<li>h（’&lt;标签名&gt;’，{ … 属性 … }，[… 子元素 …]）</li>
<li>h（’&lt;标签名&gt;’，{ … 属性 … }，[ ‘….’]）</li>
<li>patch（container，vnode）</li>
<li>patch（vnode，newVnode）</li>
</ul>
<h4 id="React-createElement-和-h"><a href="#React-createElement-和-h" class="headerlink" title="React.createElement 和 h"></a>React.createElement 和 h</h4><p><img src="http://static.zxinc520.com/blog/20190907/hro0P4sQFQug.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190907/3N0XehWXEtQa.png?imageslim" alt="mark"></p>
<h4 id="何时-patch"><a href="#何时-patch" class="headerlink" title="何时 patch"></a>何时 patch</h4><ul>
<li>初次渲染 - ReactDOM.render (&lt; App /&gt;,container)</li>
<li>会触发 patch (container,vnode)</li>
<li>re-render - setState</li>
<li>会触发 patch (vnode,newVnode)</li>
</ul>
<h4 id="自定义组件的解析"><a href="#自定义组件的解析" class="headerlink" title="自定义组件的解析"></a>自定义组件的解析</h4><ul>
<li>‘div’ - 直接渲染 &lt; div&gt; 即可，vdom 可以做到</li>
<li>Input 和 List ，是自定义组件 （class），vdom 默认不认识</li>
<li>因此 Input 和 List 定义的时候 必须声明 render 函数</li>
<li>根据 props 初始化实例，然后执行实例的 render 函数</li>
<li>render 函数返回的还是 vnode 对象</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190907/q3iTc0PViQbi.png?imageslim" alt="mark"></p>
<h3 id="问题解答-1"><a href="#问题解答-1" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>为何需要 vdom：JSX 需要渲染成 html，数据驱动视图</li>
<li>React.createElement 和 h ，都生成 vnode</li>
<li>何时 patch：ReactDOM.render(…) 和 setState</li>
<li>自定义组件的解析：初始化实例，然后执行 render</li>
</ul>
<h2 id="7-4-说一下-setState-的过程"><a href="#7-4-说一下-setState-的过程" class="headerlink" title="7-4 说一下 setState 的过程"></a>7-4 说一下 setState 的过程</h2><h3 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>setState 的异步</li>
<li>vue 修改属性也是 异步</li>
<li>setState 的过程</li>
</ul>
<h4 id="setState-的异步"><a href="#setState-的异步" class="headerlink" title="setState 的异步"></a>setState 的异步</h4><p><img src="http://static.zxinc520.com/blog/20190907/z8fAo7IMaYcs.png?imageslim" alt="mark"></p>
<h4 id="setState-为何需要异步？"><a href="#setState-为何需要异步？" class="headerlink" title="setState 为何需要异步？"></a>setState 为何需要异步？</h4><ul>
<li>可能会一次执行 多次 setState</li>
<li>你无法规定、限制用户如何使用 setState</li>
<li>没必要每次 setState 都重新渲染，考虑性能</li>
<li>即便是每次重新渲染，用户也看不到中间的效果</li>
<li>只看到最后的结果即可</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190907/0E8yvUnt3JOn.png?imageslim" alt="mark"></p>
<h4 id="vue-修改属性也是异步"><a href="#vue-修改属性也是异步" class="headerlink" title="vue 修改属性也是异步"></a>vue 修改属性也是异步</h4><ul>
<li>效果、原因和 setState 一样</li>
<li>对比记忆，印象深刻</li>
</ul>
<h4 id="vue-的整个实现流程"><a href="#vue-的整个实现流程" class="headerlink" title="vue 的整个实现流程"></a>vue 的整个实现流程</h4><ul>
<li>第一步：解析模板成 render 函数</li>
<li>第二步：响应式开始监听</li>
<li>第三步：首次渲染，显示页面，且绑定依赖</li>
<li>第四步：data 属性变化（ <strong>异步</strong> ），触发 rerender</li>
</ul>
<h5 id="data-属性变化"><a href="#data-属性变化" class="headerlink" title="data 属性变化"></a>data 属性变化</h5><ul>
<li>修改属性，被响应式 的 set 监听到</li>
<li>set 中执行 updataComponent （ <strong>异步</strong> ）</li>
<li>updataComponent 重新执行 vm.render()</li>
<li>生成的 vnode 和 prevVnode，通过 patch 进行比较</li>
<li>渲染到 html 中</li>
</ul>
<h4 id="setState-的过程"><a href="#setState-的过程" class="headerlink" title="setState 的过程"></a>setState 的过程</h4><ul>
<li>每个组件实例，都有 renderComponent 方法</li>
<li>执行 renderComponent 会重新执行实例的 render</li>
<li>render 函数返回 newVnode，然后拿到 preVnode</li>
<li>执行 patch （preVnode，newVnode）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* renderComponent方法 大致模拟*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  renderComponent() &#123;</span><br><span class="line">    <span class="keyword">const</span> preVnode = <span class="built_in">this</span>._vnode;</span><br><span class="line">    <span class="keyword">const</span> newVnode = <span class="built_in">this</span>.render();</span><br><span class="line">    patch(preVnode, newVnode);</span><br><span class="line">    <span class="built_in">this</span>._vnode = newVnode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题解答-2"><a href="#问题解答-2" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>setState 的异步：效果、原因</li>
<li>vue 修改属性也是异步：效果、原因</li>
<li>setState 的过程：最终走到 patch(preVnode, newVnode)</li>
</ul>
<h1 id="7-5-总结"><a href="#7-5-总结" class="headerlink" title="7-5 总结"></a>7-5 总结</h1><ul>
<li><p>说一下对组件化的理解？</p>
<ul>
<li>组件的封装：封装视图、数据、变化逻辑</li>
<li>组件的复用：props 传递、复用</li>
</ul>
</li>
<li><p>JSX 本质是什么？</p>
<ul>
<li>JSX 语法（标签、JS 表达式、判断、循环、事件绑定）</li>
<li>JSX 本质就是语法糖，需被解析成 JS 才能运行</li>
<li>JSX 是独立的标准，可被其它项目使用</li>
</ul>
</li>
<li><p>JSX 和 vdom 的关系？</p>
<ul>
<li>为何需要 vdom：JSX 需要渲染成 html，数据驱动视图</li>
<li>React.createElement 和 h ，都生成 vnode</li>
<li>何时 patch：ReactDOM.render(…) 和 setState</li>
<li>自定义组件的解析：初始化实例，然后执行 render</li>
</ul>
</li>
<li><p>说一下 setState 的过程</p>
<ul>
<li>setState 的异步：效果、原因</li>
<li>vue 修改属性也是异步：效果、原因</li>
<li>setState 的过程：最终走到 patch(preVnode, newVnode)</li>
</ul>
</li>
</ul>
<h2 id="7-6-React-Vs-vue"><a href="#7-6-React-Vs-vue" class="headerlink" title="7-6 React Vs vue"></a>7-6 React Vs vue</h2><h3 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>两者的本质区别</li>
<li>看模板和组件化的区别</li>
<li>两者共同点</li>
<li>总结问题的答案</li>
</ul>
<h4 id="两者的本质区别"><a href="#两者的本质区别" class="headerlink" title="两者的本质区别"></a>两者的本质区别</h4><ul>
<li>vue - 本质是 MVVM 框架，由 MVC 发展而来</li>
<li>React - 本质是前端组件化框架，有后端组件化发展而来</li>
</ul>
<h4 id="模板的区别"><a href="#模板的区别" class="headerlink" title="模板的区别"></a>模板的区别</h4><ul>
<li>vue - 使用模板 （ 最初由 angular 提出）</li>
<li>React - 使用 JSX</li>
<li>**模板语法 **上，我更倾向于 JSX</li>
<li><strong>模板分离</strong> 上，我更加倾向于 vue</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190907/3TJdcbF6Ud41.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190907/oPnkXYam0Ovp.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190907/O7ONMqnOcIxs.png?imageslim" alt="mark"></p>
<ul>
<li>模板应该 和 JS 逻辑分离</li>
<li>回顾 ”开放封闭原则“</li>
</ul>
<h4 id="组件化的区别"><a href="#组件化的区别" class="headerlink" title="组件化的区别"></a>组件化的区别</h4><ul>
<li>React 本身就是组件化，没有组件化就不是 React</li>
<li>vue 也支持组件化，不过是在 MVVM 上的扩展</li>
<li>查阅 vue 组件化的文档，洋洋洒洒很多（ 侧面反映 ）</li>
<li>对于组件化，我更倾向于 React，做的彻底而清晰</li>
</ul>
<h4 id="两者的共同点"><a href="#两者的共同点" class="headerlink" title="两者的共同点"></a>两者的共同点</h4><ul>
<li>都支持组件化</li>
<li>都是数据驱动视图</li>
</ul>
<h3 id="问题解答-3"><a href="#问题解答-3" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>阐述一下对 React 和 Vue 的 认识<ul>
<li>国内使用，首推 vue。文档更易读、易学、社区够大</li>
<li>如果团队水平较高，推荐使用 React。组件化 和 JSX</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>MVVM 和 vue</title>
    <url>/2019/09/05/VueTheory/</url>
    <content><![CDATA[<h1 id="MVVM-和-vue"><a href="#MVVM-和-vue" class="headerlink" title="MVVM 和 vue"></a>MVVM 和 vue</h1><blockquote>
<p>本章首先介绍了 <strong>jQuery 开发方式和框架开发方式的区别</strong> ，引导学生进入框架开发的思路转变。然后通过 MVC 模式引入 <strong>MVVM</strong> ，在两者比较让学生更快熟悉 MVVM 。最后结合实例，详细讲解 vue 的 <strong>实现原理</strong> ，包括 <strong>响应式</strong>、<strong>模板解析</strong>、<strong>渲染</strong> 这三大要素。…</p>
<p>高级面试：<strong>vue 知识点</strong></p>
<p>放弃该放弃的是无奈，放弃不该放弃的是无能，不放弃该放弃的是无知，不放弃不该放弃的是执著！</p>
<p>It is helpless to give up the waiver. It is incompetence to give up what should not be given up. It is ignorance that does not give up the waiver. It is attachment that does not give up and should not give up!</p>
</blockquote>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>如何 理解 MVVM</li>
<li>如何 实现 MVVM</li>
<li>是否解读过 vue 源码</li>
</ul>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul>
<li>说一下 使用 jQuery 和 使用框架的区别</li>
<li>说一下 对 MVVM 的理解</li>
<li>vue 中如何实现 <strong>响应式</strong></li>
<li>vue 中如何解析 <strong>模板</strong></li>
<li>vue 的 整个实现流程</li>
</ul>
<h2 id="使用-jQuery-和-使用框架的区别"><a href="#使用-jQuery-和-使用框架的区别" class="headerlink" title="使用 jQuery 和 使用框架的区别"></a>使用 jQuery 和 使用框架的区别</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>jQuery 实现 todo-list</li>
<li>vue 实现 todo-list</li>
<li>jQuery 和 框架的区别</li>
</ul>
<h4 id="jQuery-实现-todo-list"><a href="#jQuery-实现-todo-list" class="headerlink" title="jQuery 实现 todo-list"></a>jQuery 实现 todo-list</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txt-title&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn-submit&quot;</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul-list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> $txtTitle = $(<span class="string">&quot;#txt-title&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> $ulList = $(<span class="string">&quot;#ul-list&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> $btnSubmit = $(<span class="string">&quot;#btn-submit&quot;</span>);</span></span><br><span class="line"><span class="javascript">      $btnSubmit.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> title = $txtTitle.val();</span></span><br><span class="line">        if (!title) &#123;</span><br><span class="line"><span class="javascript">          <span class="keyword">return</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> $li = $(<span class="string">`&lt;li&gt;<span class="subst">$&#123;title&#125;</span>&lt;/li&gt;`</span>);</span></span><br><span class="line">        $ulList.append($li);</span><br><span class="line"><span class="javascript">        $txtTitle.val(<span class="string">&quot;&quot;</span>);</span></span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190902/BaCUCHQ12jJW.gif" alt="mark"></p>
<h4 id="vue-实现-todo-list"><a href="#vue-实现-todo-list" class="headerlink" title="vue 实现 todo-list"></a>vue 实现 todo-list</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;title&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">          title: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line">          list: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">          add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.list.push(<span class="built_in">this</span>.title);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.title = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190903/sQq0jR7s1E7E.gif" alt="mark"></p>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><ul>
<li><strong>数据</strong> 和 <strong>视图</strong> 的分离</li>
<li>以数据驱动视图</li>
</ul>
<h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>说一下 使用 jQuery 和 使用框架的区别 ？<ul>
<li><strong>数据</strong> 和 <strong>视图</strong> 的分离，<u>解耦</u>（ <em>开放封闭原则</em> ）</li>
<li>以数据驱动视图，只关心数据变化，DOM 操作被封装</li>
</ul>
</li>
</ul>
<h2 id="说一下-对-MVVM-的理解"><a href="#说一下-对-MVVM-的理解" class="headerlink" title="说一下 对 MVVM 的理解"></a>说一下 对 MVVM 的理解</h2><blockquote>
<p>目前前端框架中，最为出色的要属 Vue 和 React 了，这俩个框架的核心理念都<strong>是数据驱动页面渲染</strong>，同时他们都是 MVVM 模式的框架，<strong>MVVM 模式</strong> 中的 M 还是固定表示 Modal，V 还是表死 View，这俩个基本都是不会发生变化，一个页面必然需要数据和渲染俩个部分，那么变化的是如何将 Modal 渲染到 View 的过程变了，在 MVVM 模式中，将 View 和 Modal 绑定在一起，只要 Modal 发生了变化，View 就会自动更新，不需要我们认为的再去写如何操作 DOM 更新的过程了</p>
</blockquote>
<h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>MVC</li>
<li>MVVM</li>
<li>关于 ViewModel</li>
</ul>
<h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><ul>
<li>M -Model 数据</li>
<li>V - View 视图、界面</li>
<li>C - Controller 控制器 、逻辑处理</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190903/k21xefObaEwr.png?imageslim" alt="mark"></p>
<p><strong>MVC</strong>模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。</p>
<p>在前端的 <strong>MVC 模式</strong> 中，M 还是表示 Modal 层，负责与后台交互数据，V 表示 View，负责页面上 DOM 的渲染，C 表示绑定在 DOM 元素上的事件，当 Controllor 中的事件被调用，会去调用 Modal 中的数据，然后交给 View 重新渲染数据</p>
<h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><ul>
<li>M - Model 模型、数据</li>
<li>V - View 视图、模板（ 视图和模板是分离的 ）</li>
<li>ViewModel - <strong>连接</strong> Model 和 View</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190903/23g0MdeUf9sw.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190903/1qFclAqzYLGt.png?imageslim" alt="mark"></p>
<h4 id="关于-ViewModel"><a href="#关于-ViewModel" class="headerlink" title="关于 ViewModel"></a>关于 ViewModel</h4><ul>
<li>MVVM 不算是一种创新</li>
<li>但其中的 ViewModel 确实是一种创新</li>
<li>真正 结合前端场景应用的创建</li>
</ul>
<h3 id="问题解答-1"><a href="#问题解答-1" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>说一下 对 MVVM 的理解<ul>
<li>MVVM - Model View ViewModel</li>
<li>三者之间的联系。以及如何对应到各段代码</li>
<li>ViewModel 的理解，联系 View 和 Model</li>
</ul>
</li>
</ul>
<h1 id="MVVM-框架的三大要素"><a href="#MVVM-框架的三大要素" class="headerlink" title="MVVM 框架的三大要素"></a>MVVM 框架的三大要素</h1><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li>再次分析 demo</li>
<li>三要素总结</li>
</ul>
<h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><ul>
<li>响应式：vue 如何监听到 data 的每个属性变化？</li>
<li>模板引擎：vue 的模板如何被解析，指令如何处理？</li>
<li>渲染：vue 的模板如何被渲染成 html？以及渲染过程</li>
</ul>
<h2 id="vue-中如何实现响应式"><a href="#vue-中如何实现响应式" class="headerlink" title="vue 中如何实现响应式"></a>vue 中如何实现响应式</h2><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>什么是响应式？</li>
<li>Object.defineProperty</li>
<li>模拟</li>
</ul>
<h4 id="什么是响应式？"><a href="#什么是响应式？" class="headerlink" title="什么是响应式？"></a>什么是响应式？</h4><ul>
<li>修改 data 属性后，vue 立刻监听到</li>
<li>data 属性被代理到 vm 上</li>
<li>演示</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line"><span class="javascript">          age: <span class="string">&quot;18&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190904/h1SkefYXlHkn.gif" alt="mark"></p>
<h4 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h4><blockquote>
<p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p>
<p><strong>语法</strong> ：Object.defineProperty(obj, prop, descriptor)</p>
<p><strong>参数</strong> ：</p>
<p><u>Object.defineProperty(obj, prop, descriptor)</u></p>
<p><strong>obj</strong> ：要在其上定义属性的对象。</p>
<p><strong>prop</strong> ：要定义或修改的属性的名称。</p>
<p><strong>descriptor</strong> ：将被定义或修改的属性描述符。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">//获取属性的时候，如何监听到？</span></span><br><span class="line">obj.age = <span class="number">26</span>; <span class="comment">//赋值属性的时候，如何监听到？</span></span><br></pre></td></tr></table></figure>

<p><em>Object.defineProperty：</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;get&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;set&quot;</span>);</span><br><span class="line">    name = newVal;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.name);</span><br><span class="line">obj.name = <span class="string">&quot;list&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h3><blockquote>
<p>模拟实现 Vue 如何监听 data</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如何监听data</span></span><br><span class="line"><span class="comment">var vm=new Vue(&#123;</span></span><br><span class="line"><span class="comment">    el:&#x27;张三&#x27;,</span></span><br><span class="line"><span class="comment">    data:&#123;</span></span><br><span class="line"><span class="comment">        name:&#x27;张三&#x27;,</span></span><br><span class="line"><span class="comment">        age:20</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟实现</span></span><br><span class="line"><span class="keyword">var</span> vm = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">  price: <span class="number">100</span>,</span><br><span class="line">  name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> key, value;</span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> data) &#123;</span><br><span class="line">  <span class="comment">//命中闭包。新建一个函数，保证 key 的独立的作用域</span></span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(vm, key, &#123;</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;get&quot;</span>); <span class="comment">//监听</span></span><br><span class="line">        <span class="keyword">return</span> data[key];</span><br><span class="line">      &#125;,</span><br><span class="line">      set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;set&quot;</span>); <span class="comment">//监听</span></span><br><span class="line">        data[key] = newVal;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190904/P570ewmXOdNX.gif" alt="mark"></p>
<h3 id="问题解答-2"><a href="#问题解答-2" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>什么是响应式？<ul>
<li>关键是理解 Object.defineProperty</li>
<li>将 data 的属性代理到 vm 上</li>
</ul>
</li>
</ul>
<h2 id="vue-中如何解析模板"><a href="#vue-中如何解析模板" class="headerlink" title="vue 中如何解析模板"></a>vue 中如何解析模板</h2><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>模板是什么？</li>
<li>render 函数</li>
<li>render 函数 与 vdom</li>
</ul>
<h4 id="模板是什么？"><a href="#模板是什么？" class="headerlink" title="模板是什么？"></a>模板是什么？</h4><ul>
<li><p>本质：字符串</p>
</li>
<li><p>有逻辑，如 v-if 、v-for 等</p>
</li>
<li><p>与 html 格式很像，但有很大区别</p>
</li>
<li><p>最终还要转换为 html 来显示</p>
</li>
<li><p><strong>模板最终必须转化成 JS 代码</strong> ，因为：</p>
<ul>
<li>有逻辑（v-if、v-for），必须用 JS 才能实现 （ 图灵完备 ）</li>
<li>转换成 html 渲染页面，必须用 JS 才能实现</li>
<li>因此，模板最重要转换成 一个 JS 函数 （render 函数）</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;title&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="render-函数-with-的用法"><a href="#render-函数-with-的用法" class="headerlink" title="render 函数 - with 的用法"></a>render 函数 - with 的用法</h4><blockquote>
<p>with 的用法 — <strong>自己开发的代码尽量不要使用！</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  getAddress: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用 with</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(obj.name);</span><br><span class="line">  alert(obj.age);</span><br><span class="line">  obj.getAddress();</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  getAddress: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 with</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span> (obj) &#123;</span><br><span class="line">    alert(obj.name);</span><br><span class="line">    alert(obj.age);</span><br><span class="line">    getAddress();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure>

<h4 id="render-函数"><a href="#render-函数" class="headerlink" title="render 函数"></a>render 函数</h4><p><img src="http://static.zxinc520.com/blog/20190905/igfqtojmzQ4H.png?imageslim" alt="mark"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>模板中所有信息都包含在了 render 函数中</li>
<li>this 即 vm</li>
<li>price 即 this.price 即 vm.price ，即 data 中的 price</li>
<li>_c 即 this. _c 即 vm. _c</li>
</ul>
<h4 id="render-函数剖析"><a href="#render-函数剖析" class="headerlink" title="render 函数剖析"></a>render 函数剖析</h4><ul>
<li>从哪里可以看到 render 函数？</li>
<li>复杂一点的例子，render 函数是什么样子的？</li>
<li>v- if 、v-for 、v-on 都是怎么处理的？</li>
</ul>
<h4 id="看一下-todo-list-demo-的-render-函数"><a href="#看一下-todo-list-demo-的-render-函数" class="headerlink" title="看一下 todo-list demo 的 render 函数"></a>看一下 todo-list demo 的 render 函数</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;title&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _c(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">id</span>: <span class="string">&quot;app&quot;</span> &#125; &#125;, [</span><br><span class="line">    _c(<span class="string">&quot;div&quot;</span>, [</span><br><span class="line">      _c(<span class="string">&quot;input&quot;</span>, &#123;</span><br><span class="line">        directives: [</span><br><span class="line">          &#123;</span><br><span class="line">            name: <span class="string">&quot;model&quot;</span>,</span><br><span class="line">            rawName: <span class="string">&quot;v-model&quot;</span>,</span><br><span class="line">            value: title,</span><br><span class="line">            expression: <span class="string">&quot;title&quot;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">        attrs: &#123; <span class="attr">type</span>: <span class="string">&quot;text&quot;</span> &#125;,</span><br><span class="line">        domProps: &#123; <span class="attr">value</span>: title &#125;,</span><br><span class="line">        on: &#123;</span><br><span class="line">          input: <span class="function"><span class="keyword">function</span> (<span class="params">$event</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ($event.target.composing) <span class="keyword">return</span>;</span><br><span class="line">            title = $event.target.value;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">      _v(<span class="string">&quot; &quot;</span>),</span><br><span class="line">      _c(<span class="string">&quot;button&quot;</span>, &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: add &#125; &#125;, [_v(<span class="string">&quot;submit&quot;</span>)]),</span><br><span class="line">    ]),</span><br><span class="line">    _v(<span class="string">&quot; &quot;</span>),</span><br><span class="line">    _c(</span><br><span class="line">      <span class="string">&quot;ul&quot;</span>,</span><br><span class="line">      _l(list, <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _c(<span class="string">&quot;li&quot;</span>, [_v(_s(item))]);</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">    ),</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据 todo-list demo 的 render 函数</li>
<li>v- model 是怎么实现的？</li>
<li>v-on :click 是怎么实现的？</li>
<li>v- for 是怎么实现的？</li>
</ul>
<h4 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    vue2.0 开始支持预编译</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    开发环境 ：写模板</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    编译打包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    生产环境：JS</span></span><br><span class="line"><span class="comment">    --------------------------------------------</span></span><br><span class="line"><span class="comment">    React 组件化</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    JSX 模板</span></span><br><span class="line"><span class="comment">    编译 ： -&gt; JS 代码</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><ul>
<li><p>已经解决了 模板中 “逻辑” （v-for、v-if ）的问题</p>
</li>
<li><p>还剩下模板生成 html 问题</p>
</li>
<li><p>另外，vm._c 是什么？ render 函数 返回了什么？</p>
</li>
</ul>
<h5 id="先复习一下-vdom-的知识"><a href="#先复习一下-vdom-的知识" class="headerlink" title="先复习一下 vdom 的知识"></a>先复习一下 vdom 的知识</h5><blockquote>
<p>可参考 <a href="http://zxinc520.com/lcj/%225d63a1bce9920a5ce05e2c3b%22">vdom 篇</a></p>
</blockquote>
<p>vdom 的如何应用，核心 API 是什么？</p>
<ul>
<li>介绍 <a href="https://github.com/snabbdom/snabbdom">snabbdom</a></li>
<li>重做 之前的 demo</li>
<li>核心 API</li>
</ul>
<h5 id="render-函数和-vdom"><a href="#render-函数和-vdom" class="headerlink" title="render 函数和 vdom"></a>render 函数和 vdom</h5><p><img src="http://static.zxinc520.com/blog/20190905/ldxxH0zJ4t3s.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190905/MykHq1vOBFyL.png?imageslim" alt="mark"></p>
<ul>
<li>updataComponent 中实现了 vdom 的 patch</li>
<li>页面首次渲染执行 updataComponent</li>
<li>data 中每次修改属性，执行 updataComponent</li>
</ul>
<h3 id="问题解答-3"><a href="#问题解答-3" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>vue 中如何解析 <strong>模板</strong><ul>
<li>模板：字符串，有逻辑，嵌入 JS 变量……</li>
<li>模板必须转换成 JS 代码（有逻辑，渲染 html，JS 变量）</li>
<li>render 函数是什么样子的</li>
<li>render 函数执行是返回 vnode</li>
<li>updataComponent</li>
</ul>
</li>
</ul>
<h1 id="vue-的整个实现流程"><a href="#vue-的整个实现流程" class="headerlink" title="vue 的整个实现流程"></a>vue 的整个实现流程</h1><h3 id="整个实现流程"><a href="#整个实现流程" class="headerlink" title="整个实现流程"></a>整个实现流程</h3><ul>
<li><p>第一步：解析模板成 render 函数</p>
<ul>
<li>with 的用法</li>
<li>模板中的所有信息都被 render 函数 包含</li>
<li>模板中用到的 data 中的属性，都变成了 JS 变量</li>
<li>模板中的 v-model、v-for、v-on 都变成了 JS 逻辑</li>
<li>render 函数返回 vnode</li>
</ul>
</li>
<li><p>第二步：响应式开始监听</p>
<ul>
<li>Object.defineProperty</li>
<li>将 data 的属性代理到 vm 上</li>
</ul>
</li>
<li><p>第三步：首次渲染，显示页面，且绑定依赖</p>
<ul>
<li>初次渲染，执行 updataComponent ，执行 vm.render()</li>
<li>执行 render 函数，会访问到 vm.list 和 vm.title</li>
<li>会被响应式的 get 方法监听到 （后面详细讲）</li>
<li>执行 updataComponent ，会被 vdom 的 patch 方法</li>
<li>patch 将 vnode 渲染成 DOM ，初次渲染完成</li>
</ul>
<hr>
<ul>
<li>为何要监听 get，直接监听 set 不行吗？</li>
<li>data 中有很多属性，有些被用到，有些可能不被用到</li>
<li>被用到的会走到 get ，不被用到的 不会走到 get</li>
<li>未走到 get 中的属性，set 的时候我们也无需关心</li>
<li><strong>避免不必要的重复渲染</strong></li>
</ul>
</li>
<li><p>第四步：data 属性变化，触发 rerender</p>
<ul>
<li>修改属性，被响应式 的 set 监听到</li>
<li>set 中执行 updataComponent</li>
<li>updataComponent 重新执行 vm.render()</li>
<li>生成的 vnode 和 prevVnode，通过 patch 进行比较</li>
</ul>
</li>
</ul>
<h3 id="问题解答-4"><a href="#问题解答-4" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>vue 的整个实现流程？<ul>
<li>第一步：解析模板成 render 函数</li>
<li>第二步：响应式开始监听</li>
<li>第三步：首次渲染，显示页面，且绑定依赖</li>
<li>第四步：data 属性变化，触发 rerender</li>
</ul>
</li>
</ul>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>说一下 使用 jQuery 和 使用框架的区别</p>
<ul>
<li><strong>数据</strong> 和 <strong>视图</strong> 的分离，<u>解耦</u>（ <em>开放封闭原则</em> ）</li>
<li>以数据驱动视图，只关心数据变化，DOM 操作被封装</li>
</ul>
</li>
<li><p>什么是 MVVM ？</p>
<ul>
<li><p>MVVM - Model View ViewModel</p>
</li>
<li><p>三者之间的联系。以及如何对应到各段代码</p>
</li>
<li><p>ViewModel 的理解，联系 View 和 Model</p>
</li>
</ul>
</li>
</ul>
<h3 id="三要素-1"><a href="#三要素-1" class="headerlink" title="三要素"></a>三要素</h3><ul>
<li><p>响应式：vue 如何监听到 data 的每个属性变化？</p>
</li>
<li><p>模板引擎：vue 的模板如何被解析，指令如何处理？</p>
</li>
<li><p>渲染：vue 的模板如何被渲染成 html？以及渲染过程？</p>
</li>
<li><p>Vue 如何实现响应式？</p>
<ul>
<li>关键是理解 Object.defineProperty</li>
<li>将 data 的属性代理到 vm 上</li>
</ul>
</li>
<li><p>vue 中如何解析 <strong>模板</strong> ？</p>
<ul>
<li>模板：字符串，有逻辑，嵌入 JS 变量……</li>
<li>模板必须转换成 JS 代码（有逻辑，渲染 html，JS 变量）</li>
<li>render 函数是什么样子的</li>
<li>render 函数执行是返回 vnode</li>
<li>updataComponent</li>
</ul>
</li>
<li><p>vue 的整个实现流程？</p>
<ul>
<li>第一步：解析模板成 render 函数</li>
<li>第二步：响应式开始监听</li>
<li>第三步：首次渲染，显示页面，且绑定依赖</li>
<li>第四步：data 属性变化，触发 rerender</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>MVVM</tag>
        <tag>响应式、模板解析、渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序笔记上</title>
    <url>/2019/09/05/WeChatUp/</url>
    <content><![CDATA[<h1 id="微信小程序笔记上"><a href="#微信小程序笔记上" class="headerlink" title="微信小程序笔记上"></a>微信小程序笔记上</h1><blockquote>
<p>微信小程序学习笔记上</p>
<p>初步接触小程序</p>
<p>基础内容介绍</p>
<p>开发者文档</p>
<p>app.js 全局生命周期函数</p>
<p>WXML 数据绑定</p>
<p>通过 wx.request 请求数据</p>
<p>微信小程序里列表渲染</p>
<p>页面相关事件处理函数</p>
<p>True mastery of any skill takes a lifetime.</p>
<p>对任何技能的掌握都需要一生的刻苦操练。</p>
</blockquote>
<h1 id="小程序简介"><a href="#小程序简介" class="headerlink" title="小程序简介"></a>小程序简介</h1><blockquote>
<p>小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</p>
<p>微信小程序使用了前端技术栈 JavaScript/WXML/WXSS。</p>
</blockquote>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/quickstart/basic/introduction.html">相关介绍</a></p>
<p><strong>微信小程序使用了前端技术栈 JavaScript/WXML/WXSS。但和常规的前端开发又有一些区别：</strong> <a href="https://juejin.im/entry/581db98fa0bb9f0058abffea">可以参考</a></p>
<ol>
<li><strong>JavaScript</strong>: 微信小程序的 JavaScript 运行环境即不是 Browser 也不是 Node.js。它运行在微信 App 的上下文中，不能操作 Browser context 下的 DOM，也不能通过 N*ode.js 相关接口访问操作系统 API。所以，严格意义来讲，微信小程序并不是 Html5，虽然开发过程和用到的技术栈和 Html5 是相通的。</li>
<li><strong>WXML：</strong>作为微信小程序的展示层，并不是使用 Html，而是自己发明的基于 XML 语法的描述。</li>
<li><strong>WXSS：</strong>用来修饰展示层的样式。官方的描述是 “ WXSS (WeiXin Style Sheets) 是一套样式语言，用于描述 WXML 的组件样式。WXSS 用来决定 WXML 的组件应该怎么显示。” “我们的 WXSS 具有 CSS 大部分特性…我们对 CSS 进行了扩充以及修改。”基于 CSS2 还是 CSS3？大部分是哪些部分？是否支持 CSS3 里的动画？不得而知。</li>
</ol>
<h4 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h4><p><img src="http://static.zxinc520.com/blog/20190514/yTqqYeB2UoIS.png?imageslim" alt="mark"></p>
<ol>
<li><code>app.js</code>做为小程序的入口，里面有个 App 实例，每个小程序只会有一个 App 实例，小程序启动以后触发 onLaunch 函数执行，获取用户信息</li>
<li><code>app.json</code>是小程序的所有全局配置，<code>pages</code>字段放置所有页面的路径，<code>window</code>字段定义所有页面的顶部背景颜色，文字颜色 详细配置请<a href="https://link.juejin.im/?target=https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html">戳这里 👇</a></li>
<li><code>app.wxss</code>文件就是页面公用的样式，仅支持部分 css 选择器</li>
<li><code>wxml</code>就是我们的 HTML 文件，常用标签为 <code>view</code> 、<code>text</code> 等，没有所谓的<code>div</code>、<code>span</code>、<code>p</code>一类的标签了，我们习惯称它们为组件</li>
</ol>
<hr>
<blockquote>
<p><strong>设计理念：</strong></p>
<p>小程序内部可以理解成一个 mvvm 的框架，分为逻辑层和视图层，逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。</p>
</blockquote>
<hr>
<p><img src="http://static.zxinc520.com/blog/20190514/U6eXvlL8evmQ.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190514/m4UDxEkFa1ae.png?imageslim" alt="mark"></p>
<h2 id="开始上手"><a href="#开始上手" class="headerlink" title="开始上手"></a>开始上手</h2><blockquote>
<p><strong>开始正式学习</strong></p>
<p>基础学习部分</p>
</blockquote>
<h3 id="加载一张图片"><a href="#加载一张图片" class="headerlink" title="加载一张图片"></a>加载一张图片</h3><p><img src="http://static.zxinc520.com/blog/20190514/GnYuPkAo16G5.png?imageslim" alt="mark"></p>
<p>_简单使用样式_：</p>
<p><img src="http://static.zxinc520.com/blog/20190514/gvNQzg8BaF74.png?imageslim" alt="mark"></p>
<h2 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h2><blockquote>
<p>WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。</p>
<p>WXSS 用来决定 WXML 的组件应该怎么显示。 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html">可以参考官网</a></p>
</blockquote>
<p>为了适应广大的前端开发者，WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。</p>
<p>与 CSS 相比，WXSS 扩展的特性有：</p>
<ul>
<li>尺寸单位</li>
<li>样式导入</li>
</ul>
<h2 id="尺寸单位"><a href="#尺寸单位" class="headerlink" title="尺寸单位"></a>尺寸单位</h2><p>​ <strong>rpx</strong>（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。如在 iPhone6 上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px = 750 物理像素，1rpx = 0.5px = 1 物理像素</p>
<p><img src="http://static.zxinc520.com/blog/20190514/57Wa2m8PEEyp.png?imageslim" alt="mark"></p>
<p><strong>建议：</strong> 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。</p>
<p><strong>注意：</strong> 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。</p>
<h2 id="全局样式与局部样式"><a href="#全局样式与局部样式" class="headerlink" title="全局样式与局部样式"></a>全局样式与局部样式</h2><p>定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。</p>
<h2 id="开发者文档"><a href="#开发者文档" class="headerlink" title="开发者文档"></a>开发者文档</h2><blockquote>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/image.html">开发者文档</a></p>
<p><strong>不会</strong> 或 <strong>忘了</strong> 就查文档！</p>
</blockquote>
<h3 id="image"><a href="#image" class="headerlink" title="image:"></a>image:</h3><p>​ <strong>解决图片缩放问题：</strong></p>
<ul>
<li>mode （ 常用下面 2 个属性值缩放图片 ）<ul>
<li>aspectFit：缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。</li>
<li>aspectFill：缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。</li>
</ul>
</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190520/XC3RPCh4fJdY.png?imageslim" alt="mark"></p>
<h3 id="swiper"><a href="#swiper" class="headerlink" title="swiper"></a>swiper</h3><blockquote>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html">看开发者文档</a></p>
<p>轮播组件：调用相应的标签及参数设置</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190520/PgOdEdCQrqvp.gif" alt="mark"></p>
<h2 id="解读-app-json"><a href="#解读-app-json" class="headerlink" title="解读 app.json"></a>解读 app.json</h2><blockquote>
<p>小程序根目录下的 <code>app.json</code> 文件用来对微信小程序进行全局配置。文件内容为一个 JSON 对象，有以下属性：</p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html">可以参考官网</a></p>
</blockquote>
<h3 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h3><blockquote>
<p>用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对于位置的 <code>.json</code>, <code>.js</code>, <code>.wxml</code>, <code>.wxss</code> 四个文件进行处理。</p>
</blockquote>
<h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><blockquote>
<p>用于设置小程序的状态栏、导航条、标题、窗口背景色。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;window&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;navigationBarBackgroundColor&quot;</span>: <span class="string">&quot;#ffffff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;navigationBarTextStyle&quot;</span>: <span class="string">&quot;black&quot;</span>,</span><br><span class="line">    <span class="string">&quot;navigationBarTitleText&quot;</span>: <span class="string">&quot;微信接口功能演示&quot;</span>,</span><br><span class="line">    <span class="string">&quot;backgroundColor&quot;</span>: <span class="string">&quot;#eeeeee&quot;</span>,</span><br><span class="line">    <span class="string">&quot;backgroundTextStyle&quot;</span>: <span class="string">&quot;light&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tabBar"><a href="#tabBar" class="headerlink" title="tabBar"></a>tabBar</h3><blockquote>
<p>如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;tabBar&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#333&quot;</span>,</span><br><span class="line">   <span class="string">&quot;selectedColor&quot;</span>: <span class="string">&quot;#f30&quot;</span>,</span><br><span class="line">   <span class="string">&quot;list&quot;</span>: [&#123;</span><br><span class="line">     <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">     <span class="string">&quot;text&quot;</span>: <span class="string">&quot;首页&quot;</span>,</span><br><span class="line">     <span class="string">&quot;iconPath&quot;</span>: <span class="string">&quot;assets/tabs/icon1.png&quot;</span>,</span><br><span class="line">     <span class="string">&quot;selectedIconPath&quot;</span>: <span class="string">&quot;assets/tabs/icon1.png&quot;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;pages/message/message&quot;</span>,</span><br><span class="line">     <span class="string">&quot;text&quot;</span>: <span class="string">&quot;消息&quot;</span>,</span><br><span class="line">     <span class="string">&quot;iconPath&quot;</span>: <span class="string">&quot;assets/tabs/icon1.png&quot;</span>,</span><br><span class="line">     <span class="string">&quot;selectedIconPath&quot;</span>: <span class="string">&quot;assets/tabs/icon1.png&quot;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">     <span class="string">&quot;text&quot;</span>: <span class="string">&quot;个人中心&quot;</span>,</span><br><span class="line">     <span class="string">&quot;iconPath&quot;</span>: <span class="string">&quot;assets/tabs/icon1.png&quot;</span>,</span><br><span class="line">     <span class="string">&quot;selectedIconPath&quot;</span>: <span class="string">&quot;assets/tabs/icon1.png&quot;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">     <span class="string">&quot;text&quot;</span>: <span class="string">&quot;综合&quot;</span>,</span><br><span class="line">     <span class="string">&quot;iconPath&quot;</span>: <span class="string">&quot;assets/tabs/icon1.png&quot;</span>,</span><br><span class="line">     <span class="string">&quot;selectedIconPath&quot;</span>: <span class="string">&quot;assets/tabs/icon1.png&quot;</span></span><br><span class="line">   &#125;]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190521/OCDT2PNCaB4Y.png?imageslim" alt="mark"></p>
<p><em>等等等… 不了解就看文档！</em></p>
<p><strong>注意： 所以看开发者文档很重要！</strong></p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html">点一下就可以看了，别懒！</a></p>
<h2 id="app-js-全局生命周期函数"><a href="#app-js-全局生命周期函数" class="headerlink" title="app.js 全局生命周期函数"></a>app.js 全局生命周期函数</h2><blockquote>
<p>app.js 全局生命周期函数</p>
</blockquote>
<p><em>在 app.js 文件中</em> ， 定义了一些生命周期方法 ， onLaunch，onShow，onHide，onError，以及任意开发者添加的函数或者数据（通过 this 可以访问）</p>
<p><strong>以下是各个生命周期方法作用和描述：</strong></p>
<ol>
<li><strong>onLaunch 生命周期函数</strong> –监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）</li>
<li><strong>onShow 生命周期函数</strong>–监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShow</li>
<li><strong>onHide 生命周期函数</strong>–监听小程序隐藏 当小程序从前台进入后台，会触发 onHide</li>
<li><strong>onError 错误监听函数</strong> 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息</li>
</ol>
<p>其他 Any 开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问</p>
<p><em>index.js:</em> （个人感觉 和 <strong>Vue</strong> 真的好像，如果熟悉 Vue 的话，这理解起来应该没有难度。）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//获取应用实例</span></span><br><span class="line"><span class="keyword">const</span> app = getApp();</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    motto: <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">    listarr: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）</span></span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span> (<span class="params">option</span>) </span>&#123;</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: <span class="string">&quot;https://www.baifubao.com/callback&quot;</span>,</span><br><span class="line">      success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">          listarr: res.statusCode,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注意：着重关注 onLoad 函数，因为使用最频繁！</strong></p>
<h2 id="WXML-数据绑定"><a href="#WXML-数据绑定" class="headerlink" title="WXML 数据绑定"></a>WXML 数据绑定</h2><blockquote>
<p>WXML 中的动态数据均来自对应 Page 的 data。</p>
</blockquote>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&quot;Hello World!&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190526/Dr9a1AITnQo7.png?imageslim" alt="mark"></p>
<h4 id="特别注意："><a href="#特别注意：" class="headerlink" title="特别注意："></a>特别注意：</h4><ol>
<li>花括号和引号之间不能有空格</li>
<li>不能直接写 checked=“false”，其计算结果是一个字符串，转成 boolean 类型后转为真值。</li>
</ol>
<h2 id="通过-wx-request-请求数据"><a href="#通过-wx-request-请求数据" class="headerlink" title="通过 wx.request 请求数据"></a>通过 wx.request 请求数据</h2><blockquote>
<p>通过 wx.request 请求数据</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">  url: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  data: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  header: &#123;&#125;,</span><br><span class="line">  method: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  dataType: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">  responseType: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;,</span><br><span class="line">  fail: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;&#125;,</span><br><span class="line">  complete: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190527/x00Ledvp9GT7.png?imageslim" alt="mark"></p>
<p><strong>setData</strong>：接受 <u>wx.request</u> 请求的数据，赋值给 Page 里面的 data（然后通过插值表达式渲染到页面）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//获取应用实例</span></span><br><span class="line"><span class="keyword">const</span> app = getApp();</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    motto: <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">    listarr: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span> (<span class="params">option</span>) </span>&#123;</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: <span class="string">&quot;https://www.baifubao.com/callback&quot;</span>,</span><br><span class="line">      success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">          listarr: res.statusCode,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="微信小程序里列表渲染"><a href="#微信小程序里列表渲染" class="headerlink" title="微信小程序里列表渲染"></a>微信小程序里列表渲染</h2><blockquote>
<h3 id="wx-for"><a href="#wx-for" class="headerlink" title="wx:for"></a>wx:for</h3><p>在组件上使用 <code>wx:for</code> 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。</p>
<p>默认数组的当前项的下标变量名默认为 <code>index</code>，数组当前项的变量名默认为 <code>item</code></p>
</blockquote>
<p><em>类比于 Vue：</em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example-1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span>&#123;&#123; item.message &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>微信小程序里面：</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;view wx:<span class="keyword">for</span>=<span class="string">&quot;&#123;&#123;array&#125;&#125;&quot;</span>&gt;&#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    array: [</span><br><span class="line">      &#123;</span><br><span class="line">        message: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        message: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="wx-key"><a href="#wx-key" class="headerlink" title="wx:key"></a>wx:key</h4><p>​ <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/list.html">可以参考</a></p>
<p>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/input.html">``</a> 中的输入内容，<a href="https://developers.weixin.qq.com/miniprogram/dev/component/switch.html">``</a>的选中状态），需要使用 <code>wx:key</code> 来指定列表中项目的唯一的标识符。</p>
<ol>
<li>字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。</li>
<li>保留关键字 <code>*this</code> 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：</li>
</ol>
<p>当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</p>
<p><strong>如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">switch</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;objectArray&#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;unique&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: block;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123;item.id&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">switch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;switch&quot;</span>&gt;</span>Switch<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;addToFront&quot;</span>&gt;</span>Add to the front<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">switch</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;numberArray&#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;*this&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: block;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123;item&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">switch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;addNumberToFront&quot;</span>&gt;</span>Add to the front<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    objectArray: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">unique</span>: <span class="string">&quot;unique_5&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">unique</span>: <span class="string">&quot;unique_4&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">unique</span>: <span class="string">&quot;unique_3&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">unique</span>: <span class="string">&quot;unique_2&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">unique</span>: <span class="string">&quot;unique_1&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">0</span>, <span class="attr">unique</span>: <span class="string">&quot;unique_0&quot;</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">    numberArray: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="页面相关事件处理函数"><a href="#页面相关事件处理函数" class="headerlink" title="页面相关事件处理函数"></a>页面相关事件处理函数</h2><blockquote>
<p>页面相关事件处理函数（<strong>下拉刷新</strong>，<strong>滑到底部加载更多</strong>等）</p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/ui/pull-down-refresh/wx.startPullDownRefresh.html">可以参考</a></p>
</blockquote>
<p><strong>下拉事件和触底事件</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//页面相关事件处理函数---监听用户下拉动作</span></span><br><span class="line">   onPullDownRefresh:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;下拉！&#x27;</span>)</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="comment">//页面上拉触底事件的处理函数</span></span><br><span class="line">   onReachBottom:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;上拉&#x27;</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h2><blockquote>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/ui/navigation-bar/wx.showNavigationBarLoading.html">可以参考官方文档</a></p>
<p>js 文件</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">函数 API</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">wx.showNavigationBarLoading(Object object)</td>
<td align="center">在当前页面显示导航条加载动画</td>
</tr>
<tr>
<td align="center">wx.setNavigationBarTitle(Object object)</td>
<td align="center">动态设置当前页面的标题</td>
</tr>
<tr>
<td align="center">wx.setNavigationBarColor(Object object)</td>
<td align="center">设置页面导航条颜色</td>
</tr>
<tr>
<td align="center">wx.hideNavigationBarLoading(Object object)</td>
<td align="center">在当前页面隐藏导航条加载动画</td>
</tr>
</tbody></table>
<p><img src="http://static.zxinc520.com/blog/20190603/DXIDRjESGUHv.gif" alt="mark"></p>
<h2 id="界面交互"><a href="#界面交互" class="headerlink" title="界面交互"></a>界面交互</h2><blockquote>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showToast.html">参考官方文档</a></p>
</blockquote>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.showToast(&#123;</span><br><span class="line">  title: <span class="string">&quot;成功w&quot;</span>,</span><br><span class="line">  icon: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">  duration: <span class="number">2000</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190603/fRajsw7UWlQc.gif" alt="mark"></p>
<h2 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h2><blockquote>
<p>下拉刷新( <strong>配合</strong> 页面<em>相关事件处理函数</em>—监听用户下拉动作)</p>
</blockquote>
<p><strong>index.json:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;enablePullDownRefresh&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;backgroundTextStyle&quot;</span>: <span class="string">&quot;dark&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>index.js:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//页面相关事件处理函数---监听用户下拉动作</span></span><br><span class="line"> onPullDownRefresh:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;下拉！&#x27;</span>)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190603/bHEJTM3fLLsC.gif" alt="mark"></p>
]]></content>
      <categories>
        <category>微信小程序</category>
        <category>微信小程序上篇</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序笔记下</title>
    <url>/2019/09/05/WeChatUp02/</url>
    <content><![CDATA[<h1 id="微信小程序笔记下"><a href="#微信小程序笔记下" class="headerlink" title="微信小程序笔记下"></a>微信小程序笔记下</h1><blockquote>
<p>微信小程序笔记下</p>
<p>input</p>
<p>color 属性</p>
<p>bindchange</p>
<p>wxs 页面脚本</p>
<p>微信小程序事件 <strong>冒泡 ** 和 事件</strong>传参**</p>
<p>服务号、订阅号</p>
<p>sdk</p>
</blockquote>
<h2 id="微信小程序组件"><a href="#微信小程序组件" class="headerlink" title="微信小程序组件"></a>微信小程序组件</h2><h3 id="表单组件"><a href="#表单组件" class="headerlink" title="表单组件"></a>表单组件</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><blockquote>
<p>输入框。该组件是<a href="https://developers.weixin.qq.com/miniprogram/dev/component/native-component.html">原生组件</a>，使用时请注意相关限制</p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/input.html">可以参考</a></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 输入框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&#x27;text&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;password&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&#x27;password&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;number&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&#x27;number&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;idcard&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&#x27;idcard&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;digit&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&#x27;digit&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 单选框 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">radio-group</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">radio</span>&gt;</span>单选框<span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">radio</span>&gt;</span>单选框<span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">radio-group</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 多选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">checkbox-group</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">checkbox</span>&gt;</span>多选框<span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">checkbox</span>&gt;</span>多选框<span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">checkbox</span>&gt;</span>多选框<span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">checkbox-group</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190605/iBUB5P8LKOTz.png?imageslim" alt="mark"></p>
<h3 id="改变颜色"><a href="#改变颜色" class="headerlink" title="改变颜色"></a>改变颜色</h3><blockquote>
<p><strong>color 属性</strong></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">radio-group</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">radio</span> <span class="attr">color</span>=<span class="string">&quot;#f30&quot;</span>&gt;</span>单选框<span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">radio</span>&gt;</span>单选框<span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">radio-group</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 多选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">checkbox-group</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">checkbox</span> <span class="attr">color</span>=<span class="string">&quot;#f30&quot;</span>&gt;</span>多选框<span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">checkbox</span>&gt;</span>多选框<span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">checkbox</span>&gt;</span>多选框<span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">checkbox-group</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190605/0lbNety1l8Nr.gif" alt="mark"></p>
<ul>
<li>checked：默认选中</li>
<li>disabled: 禁用</li>
</ul>
<h3 id="bindchange"><a href="#bindchange" class="headerlink" title="bindchange"></a>bindchange</h3><blockquote>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/checkbox-group.html">checkbox-group</a>中选中项发生改变时触发 change 事件，detail = {value:[选中的 checkbox 的 value 的数组]}</p>
<p><strong>单选框</strong> 和 <strong>复选框</strong> 都能用！</p>
</blockquote>
<p><strong>例如：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">radio-group</span> =<span class="string">&quot;radiobindchangefun&quot;</span> <span class="attr">data-index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">radio</span> <span class="attr">color</span>=<span class="string">&quot;#f30&quot;</span> <span class="attr">value</span>=<span class="string">&quot;nan&quot;</span>&gt;</span>单选框<span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">radio</span> <span class="attr">value</span>=<span class="string">&quot;nv&quot;</span>&gt;</span>单选框<span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">radio-group</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>index.js：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">radiobindchangefun(e)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.detail.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190605/HhwLwtgLFk7s.gif" alt="mark"></p>
<h2 id="wxs-页面脚本"><a href="#wxs-页面脚本" class="headerlink" title="wxs 页面脚本"></a>wxs 页面脚本</h2><blockquote>
<p>WXS（WeiXin Script）是小程序的一套脚本语言，结合 <code>WXML</code>，可以构建出页面的结构。</p>
<p>WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript 一致。</p>
<p><strong>用的相对不多</strong></p>
</blockquote>
<ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/01wxs-module.html">WXS 模块</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/02variate.html">变量</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/03annotation.html">注释</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/04operator.html">运算符</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/05statement.html">语句</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/06datatype.html">数据类型</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/07basiclibrary.html">基础类库</a></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">wxs</span> <span class="attr">module</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span><br><span class="line">  var sum=function(a,b)&#123; return a+b; &#125; module.exports.sum=sum</span><br><span class="line"><span class="tag">&lt;/<span class="name">wxs</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;foo.sum(1,2)&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190605/sEHFhCJgcSTT.png?imageslim" alt="mark"></p>
<h2 id="微信小程序事件冒泡和事件传参"><a href="#微信小程序事件冒泡和事件传参" class="headerlink" title="微信小程序事件冒泡和事件传参"></a>微信小程序事件冒泡和事件传参</h2><blockquote>
<p>微信小程序事件冒泡和事件传参</p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html">参考</a></p>
</blockquote>
<h3 id="事件绑定和冒泡"><a href="#事件绑定和冒泡" class="headerlink" title="事件绑定和冒泡"></a>事件绑定和冒泡</h3><p>事件绑定的写法同组件的属性，以 key、value 的形式。</p>
<ul>
<li>key 以<code>bind</code>或<code>catch</code>开头，然后跟上事件的类型，如<code>bindtap</code>、<code>catchtouchstart</code>。自基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.5.0</a> 起，在非<a href="https://developers.weixin.qq.com/miniprogram/dev/component/native-component.html">原生组件</a>中，<code>bind</code>和<code>catch</code>后可以紧跟一个冒号，其含义不变，如<code>bind:tap</code>、<code>catch:touchstart</code>。</li>
<li>value 是一个字符串，需要在对应的 Page 中定义同名的函数。不然当触发事件的时候会报错。</li>
</ul>
<p><code>bind</code>事件绑定<strong>不会阻止</strong>冒泡事件向上冒泡，<code>catch</code>事件绑定<strong>可以阻止</strong>冒泡事件向上冒泡。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;ClickFatherEvent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span> <span class="attr">catchtap</span>=<span class="string">&quot;ClickSonEvent&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190610/iYPyQKFs0uUh.gif" alt="mark"></p>
<h3 id="事件传参"><a href="#事件传参" class="headerlink" title="事件传参"></a>事件传参</h3><blockquote>
<p>自定义属性传参 ( <strong>data-index=”1”</strong> )</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;ClickFatherEvent&quot;</span> <span class="attr">data-index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span> <span class="attr">catchtap</span>=<span class="string">&quot;ClickSonEvent&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ClickFatherEvent(event)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;father&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(event.currentTarget.dataset.index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190611/QGePjx2yA28Q.gif" alt="mark"></p>
<h2 id="服务号"><a href="#服务号" class="headerlink" title="服务号"></a>服务号</h2><blockquote>
<p>服务号：为企业和组织提供更强大的业务服务与用户管理能力，主要偏向服务类交互（功能类似 12315，114，银行，提供绑定信息，服务交互的）；</p>
<p>适用人群：媒体、企业、政府或其他组织。</p>
<p>群发次数：服务号 1 个月（按自然月）内可发送 4 条群发消息。</p>
<p><a href="https://kf.qq.com/faq/120911VrYVrA150918fMZ77R.html?scene_id=kf3386">可以参考</a></p>
</blockquote>
<h2 id="订阅号"><a href="#订阅号" class="headerlink" title="订阅号"></a>订阅号</h2><blockquote>
<h1 id="什么是订阅号？"><a href="#什么是订阅号？" class="headerlink" title="什么是订阅号？"></a>什么是订阅号？</h1><p>订阅号：为媒体和个人提供一种新的信息传播方式，主要功能是在微信侧给用户传达资讯；（功能类似报纸杂志，提供新闻信息或娱乐趣事）</p>
<p>适用人群：个人、媒体、企业、政府或其他组织。</p>
<p>群发次数：订阅号（认证用户、非认证用户）1 天内可群发 1 条消息。</p>
</blockquote>
<p><strong>温馨提示：</strong></p>
<ol>
<li>如果想用公众平台简单发发消息，做宣传推广服务，建议可选择订阅号；</li>
<li>如果想用公众平台进行商品销售，建议可选择服务号，后续可认证再申请微信支付商户；</li>
</ol>
<h2 id="sdk"><a href="#sdk" class="headerlink" title="sdk"></a>sdk</h2><blockquote>
<p><a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85">软件开发工具包</a>（缩写：<strong>SDK</strong>、外语全称：<strong>Software Development Kit）</strong>一般都是一些<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88/836275">软件工程师</a>为特定的<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%8C%85/10508451">软件包</a>、<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/1471931">软件框架</a>、<a href="https://baike.baidu.com/item/%E7%A1%AC%E4%BB%B6/479446">硬件</a>平台、<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192">操作系统</a>等建立应用软件时的<a href="https://baike.baidu.com/item/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/10464557">开发工具</a>的集合。 [1]</p>
<p>软件开发工具包括广义上指<a href="https://baike.baidu.com/item/%E8%BE%85%E5%8A%A9/1045139">辅助</a>开发某一类软件的相关文档、范例和工具的<a href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88/73081">集合</a>。</p>
<p>软件开发工具包是一些被软件工程师用于为特定的软件包、软件框架、硬件平台、操作系统等创建应用软件的开发工具的集合，一般而言 SDK 即开发 <a href="https://baike.baidu.com/item/Windows">Windows</a> 平台下的应用程序所使用的 SDK。它可以简单的为某个<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/2317999">程序设计语言</a>提供<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3/10418844">应用程序接口</a> <strong>API</strong>的一些文件，但也可能包括能与某种<a href="https://baike.baidu.com/item/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/186978">嵌入式系统</a>通讯的复杂的硬件。一般的工具包括用于调试和其他用途的实用工具。SDK 还经常包括示例代码、支持性的技术注解或者其他的为基本参考资料澄清疑点的支持文档。</p>
<p>为了鼓励开发者使用其系统或者语言，许多 SDK 是<a href="https://baike.baidu.com/item/%E5%85%8D%E8%B4%B9/131326">免费</a>提供的。<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88/836275">软件工程师</a>通常从目标系统开发者那里获得软件开发包，也可以直接从互联网下载，有时也被作为<a href="https://baike.baidu.com/item/%E8%90%A5%E9%94%80%E6%89%8B%E6%AE%B5">营销手段</a>。例如，营销公司会免费提供构建 SDK 以鼓励人们使用它，从而会吸引更多人由于能免费为其编程而购买其构件。</p>
<p>SDK 可能附带了使其不能在不兼容的许可证下开发软件的许可证。例如产品供应商提供一个专有的 SDK 可能与自由软件开发抵触。<a href="https://baike.baidu.com/item/GPL">GPL</a> 能使 SDK 与专有软件开发近乎不兼容。<a href="https://baike.baidu.com/item/LGPL">LGPL</a> 下的 SDK 则没有这个问题。</p>
<p><a href="https://baike.baidu.com/item/SDK/7815680">可参考官方解释</a></p>
<p><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421141115">微信 JS-SDK 说明文档</a></p>
</blockquote>
]]></content>
      <categories>
        <category>微信小程序</category>
        <category>微信小程序下篇</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>hybrid</title>
    <url>/2019/08/29/hybrid/</url>
    <content><![CDATA[<h1 id="hybrid"><a href="#hybrid" class="headerlink" title="hybrid"></a>hybrid</h1><blockquote>
<p>本章主要介绍 hybrid 的原理和应用。hybrid 基础部分要讲解 file 协议、webview、更新上线流程；另外，通过 h5 和 hybrid 的对比，来了解两者的异同和使用场景；最后讲解前端 JS 和客户端的通讯，包括通讯原理和 JS-bridge 的代码封装。…</p>
<p>社会主流 <strong>大前端</strong> 的概念。</p>
<p><strong>知识点</strong></p>
<p>6-1 hybrid 是什么？ 为何用 hybrid ？</p>
<p>6-2 hybrid 更新上线流程</p>
<p>6-3 hybrid 和 h5 的 主要区别？</p>
<p>6-4 前端 JS 和 客户端 如何通讯？</p>
<p>The greatest test of courage on earth is to bear defeat without losing heart.</p>
<p>世界上对勇气的最大考验是忍受失败而不丧失信心。</p>
</blockquote>
<h3 id="hybrid-1"><a href="#hybrid-1" class="headerlink" title="hybrid"></a>hybrid</h3><ul>
<li>移动端占大部分流量，已经远远超过 PC</li>
<li>一线互联网公司都有自己的 App</li>
<li>这些 App 中有很大比例的前端代码 ( 不要惊讶 )</li>
<li>拿微信举例，你每天浏览微信的内容，多少是前端？</li>
</ul>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>hybrid 是什么？ 为何用 hybrid ？</li>
<li>介绍一下 hybrid 更新 和上线的流程？</li>
<li>hybrid 和 h5 的 主要区别？</li>
<li>前端 JS 和 客户端 如何通讯？</li>
</ul>
<h2 id="6-1-hybrid-是什么？-为何用-hybrid-？"><a href="#6-1-hybrid-是什么？-为何用-hybrid-？" class="headerlink" title="6-1 hybrid 是什么？ 为何用 hybrid ？"></a>6-1 hybrid 是什么？ 为何用 hybrid ？</h2><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>hybrid 文字解释</li>
<li>存在价值，为何用 hybrid ？</li>
<li>webview</li>
<li>file：//协议</li>
<li>hybrid 实现流程</li>
</ul>
<h4 id="hybrid-文字解释"><a href="#hybrid-文字解释" class="headerlink" title="hybrid 文字解释"></a>hybrid 文字解释</h4><ul>
<li>hybrid 即 “混合” ，即 前端 和客户端的混合开发</li>
<li>需前端开发人员 和 客户端开发人员配合完成</li>
<li>某些环节也可能涉及到 server 端</li>
<li>注意：不要以为自己是前端就可以不理会客户端的知识</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190829/no77eoeMXoEi.png?imageslim" alt="mark"></p>
<h4 id="hybrid-存在价值"><a href="#hybrid-存在价值" class="headerlink" title="hybrid 存在价值"></a>hybrid 存在价值</h4><ul>
<li>可以快速迭代更新【关键】（无需 app 审核，思考为何？–&gt; 前端部分能够快速更新上线）</li>
<li>体验流畅 （ 和 NA 的体验基本类似 ）</li>
<li>减少开发和沟通成本，双端公用一套代码</li>
</ul>
<h4 id="webview"><a href="#webview" class="headerlink" title="webview"></a>webview</h4><ul>
<li>是 App 中的一个组件（app 可以有 webview，也可以没有）</li>
<li>用于加载 h5 页面，即一个小型的浏览器 内核</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190829/I797MG2jf2xe.png?imageslim" alt="mark"></p>
<h4 id="file-协议"><a href="#file-协议" class="headerlink" title="file 协议"></a>file 协议</h4><ul>
<li>其实在一开始接触 html 开发，就已经使用了 file 协议</li>
<li>只不过你当时没有 “协议” “标准” 等这些概念</li>
<li>再次强调 “协议” “标准” 的重要性 ！！！</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190829/kyXpWyLb4oVR.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190829/cxJ86AeO2374.png?imageslim" alt="mark"></p>
<p><em>两者的区别：</em></p>
<ul>
<li>file 协议：本地文件，快</li>
<li>http(s) 协议：网络加载，慢</li>
</ul>
<h4 id="hybrid-具体实现"><a href="#hybrid-具体实现" class="headerlink" title="hybrid 具体实现"></a>hybrid 具体实现</h4><ul>
<li>不是所有的场景都适合使用 hybrid</li>
<li>使用 <strong>NA</strong> ：体验要求极致，变化不频繁（ 如头条的首页 ）</li>
<li>使用 <strong>hybrid</strong> ：体验要求高，变化频繁（ 如头条的新闻详情页 ）</li>
<li>使用 <strong>h5</strong> ：体验无要求，不常用（如举报、反馈等页面）</li>
</ul>
<p><strong>具体实现</strong>：</p>
<ul>
<li>前端 做好静态页面（html css js），将文件交给客户端</li>
<li>客户端拿到前端静态页面，以文件形式储存在 app 中</li>
<li>客户端 在一个 webview 中</li>
<li>使用 file 协议 加载静态页面</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190829/RIR0zOPUN22I.png?imageslim" alt="mark"></p>
<h4 id="具体实现-–-遗留问题："><a href="#具体实现-–-遗留问题：" class="headerlink" title="具体实现 – 遗留问题："></a>具体实现 – 遗留问题：</h4><ul>
<li>app 发布之后，静态文件如何实时更新？</li>
<li>静态页面如何获取内容？</li>
</ul>
<h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>hybrid 是什么？ 为何用 hybrid ？<ul>
<li>hybrid 即 “混合” ，即 前端 和客户端的混合开发</li>
<li>hybrid 存在的核心意义在于快速迭代，无需审核</li>
<li>hybrid 实现流程（图），以及 webview 和 file 协议</li>
</ul>
</li>
</ul>
<h2 id="6-2-hybrid-更新上线流程"><a href="#6-2-hybrid-更新上线流程" class="headerlink" title="6-2 hybrid 更新上线流程"></a>6-2 hybrid 更新上线流程</h2><ul>
<li>回顾 hybrid 实现流程</li>
<li>思考 （目的，实现途径）</li>
<li>更新流程</li>
</ul>
<h4 id="回顾-hybrid-实现流程"><a href="#回顾-hybrid-实现流程" class="headerlink" title="回顾 hybrid 实现流程"></a>回顾 hybrid 实现流程</h4><p><img src="http://static.zxinc520.com/blog/20190829/aeHMDopqsrCy.png?imageslim" alt="mark"></p>
<h4 id="思考-（目的，实现途径）"><a href="#思考-（目的，实现途径）" class="headerlink" title="思考 （目的，实现途径）"></a>思考 （目的，实现途径）</h4><p><img src="http://static.zxinc520.com/blog/20190829/wCDenA4EGmC8.png?imageslim" alt="mark"></p>
<ul>
<li>要替换每个客户端的静态文件</li>
<li>只能客户端来做（客户端是我们开发的）</li>
<li>客户端去 server 下载最新的静态文件</li>
<li>我们维护 server 的静态文件</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190829/H6H3arUgJB6d.png?imageslim" alt="mark"></p>
<p><em>完整流程：</em></p>
<ul>
<li>分版本，有版本号，如 201803211015</li>
<li>将静态 文件压缩成 zip 包，上传到服务器</li>
<li>客户端每次启动，都去服务端检查版本号</li>
<li>如果服务端本版本号大于客户端版本号，就去下载最新的 zip 包</li>
<li>下载完之后解压包，然后将现有的文件覆盖</li>
</ul>
<h3 id="问题解答-1"><a href="#问题解答-1" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>介绍一下 hybrid 更新 和上线的流程？<ul>
<li>掌握流程图</li>
<li>要点 1：服务端的版本和 zip 包维护</li>
<li>要点 2：更新 zip 包之前，先对比版本号</li>
<li>要点 3：zip 下载解压和覆盖</li>
</ul>
</li>
</ul>
<h2 id="6-3hybrid-和-h5-的-主要区别？"><a href="#6-3hybrid-和-h5-的-主要区别？" class="headerlink" title="6-3hybrid 和 h5 的 主要区别？"></a>6-3hybrid 和 h5 的 主要区别？</h2><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>优点</li>
<li>缺点</li>
<li>适用的场景</li>
</ul>
<h4 id="hybrid-优点"><a href="#hybrid-优点" class="headerlink" title="hybrid 优点"></a>hybrid 优点</h4><ul>
<li>体验更好，跟 NA 体验基本一致</li>
<li>可快速迭代，无需 app 审核 【关键】</li>
</ul>
<h4 id="hybrid-缺点"><a href="#hybrid-缺点" class="headerlink" title="hybrid 缺点"></a>hybrid 缺点</h4><ul>
<li>开发成本高。联调，测试，查 bug 都比较麻烦</li>
<li>运维成本高。参考此前讲过的更新上线的流程</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>hybrid ：产品的稳定功能，体验要求高，迭代频繁</li>
<li>h5：单次的运营活动（如 xx 红包）或 不常用功能（反馈、举报页面等）</li>
</ul>
<h3 id="问题解答-2"><a href="#问题解答-2" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>hybrid 和 h5 的 主要区别？<ul>
<li>优点：体验好，可快速迭代</li>
<li>缺点：开发成本高，运维成本高</li>
<li>适用的场景：hybrid 适合产品型，h5 适合 运行型</li>
</ul>
</li>
</ul>
<h2 id="6-4-前端-JS-和-客户端-如何通讯？"><a href="#6-4-前端-JS-和-客户端-如何通讯？" class="headerlink" title="6-4 前端 JS 和 客户端 如何通讯？"></a>6-4 前端 JS 和 客户端 如何通讯？</h2><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>回顾 之前遗留的问题</li>
<li>JS 和 客户端通讯的基本形式</li>
<li>schema 协议简介和使用</li>
<li>schema 使用的封装</li>
<li>内置上线</li>
</ul>
<h4 id="之前遗留的问题"><a href="#之前遗留的问题" class="headerlink" title="之前遗留的问题"></a>之前遗留的问题</h4><ul>
<li>新闻详情页适用于 hybrid，前端如何 获取新闻内容 ？<ul>
<li>不能用 ajax （http(s)协议）获取。第一： 跨域 ，第二 ：速度慢</li>
<li>客户端获取新闻内容，然后 JS 通讯拿到内容，再渲染</li>
</ul>
</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190829/MIj2ETWq9QH1.png?imageslim" alt="mark"></p>
<p><em>JS 和 客户端通讯的基本形式</em> ：</p>
<ul>
<li>JS 访问客户端能力，传递参数 和 回调函数</li>
<li>客户端 通过 回调函数 返回内容</li>
</ul>
<h4 id="schema-协议简介和使用"><a href="#schema-协议简介和使用" class="headerlink" title="schema 协议简介和使用"></a>schema 协议简介和使用</h4><ul>
<li>之前介绍了 http(s) 和 file 协议</li>
<li>schema 协议 ——前端和客户端通讯的约定</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190829/w3OphLjO8erc.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190829/QpzXgisk6E3y.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190829/RjgtefgjYzXH.png?imageslim" alt="mark"></p>
<h4 id="模拟扫一扫前后端通讯"><a href="#模拟扫一扫前后端通讯" class="headerlink" title="模拟扫一扫前后端通讯"></a>模拟扫一扫前后端通讯</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>扫一扫<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">invokeScan</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>[<span class="string">&quot;_invoke_scan_callback_&quot;</span>] = <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span><br><span class="line">          alert(result);</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span></span><br><span class="line"><span class="javascript">        iframe.style.display = <span class="string">&quot;none&quot;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// iframe.src = &#x27;weixin://dl/scan&#x27;  //重要</span></span></span><br><span class="line">        iframe.src =</span><br><span class="line"><span class="javascript">          <span class="string">&quot;weixin://dl/scan?k1=v1&amp;k2=v2&amp;k3=v3&amp;callback=_invoke_scan_callback_&quot;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span></span><br><span class="line">        body.appendChild(iframe);</span><br><span class="line"><span class="javascript">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">          body.removeChild(iframe);</span><br><span class="line"><span class="javascript">          iframe = <span class="literal">null</span>;</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        invokeScan();</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="schema-使用的封装"><a href="#schema-使用的封装" class="headerlink" title="schema 使用的封装"></a>schema 使用的封装</h4><p><img src="http://static.zxinc520.com/blog/20190829/jcvC6T5SH3Pm.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190829/fW8NCvLoYRAg.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190829/5Yhq6r9uLr7X.png?imageslim" alt="mark"></p>
<h4 id="schema-封装代码"><a href="#schema-封装代码" class="headerlink" title="schema 封装代码"></a>schema 封装代码</h4><p><em>schema 使用的封装</em> ：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span>扫一扫<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span>&gt;</span>分享<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;invoke.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//调用扫一扫</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn1&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.invoke.scan(&#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//调用分享</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn2&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.invoke.share(</span></span><br><span class="line">          &#123;</span><br><span class="line"><span class="javascript">            title: <span class="string">&quot;xxx&quot;</span>,</span></span><br><span class="line"><span class="javascript">            content: <span class="string">&quot;yyy&quot;</span>,</span></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="javascript">          <span class="function"><span class="keyword">function</span> (<span class="params">relust</span>) </span>&#123;</span></span><br><span class="line">            if (relust.error === 0) &#123;</span><br><span class="line"><span class="javascript">              alert(<span class="string">&quot;分享成功&quot;</span>);</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">              alert(relust.message);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>invoke.js</em> ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// invoke.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//调用 schema 的封装</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_invoke</span>(<span class="params">action, data, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//拼装 schema 协议</span></span><br><span class="line">    <span class="keyword">var</span> schema = <span class="string">&quot;myapp://utils/&quot;</span> + action;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拼接参数</span></span><br><span class="line">    schema += <span class="string">&quot;?a=a&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> key;</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.hasOwnProperty(key)) &#123;</span><br><span class="line">        schema += <span class="string">&quot;&amp;&quot;</span> + key + data[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理 callback</span></span><br><span class="line">    <span class="keyword">var</span> callbackName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      callbackName = callback;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      callbackName = action + <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="built_in">window</span>[callbackName] = callback;</span><br><span class="line">    &#125;</span><br><span class="line">    schema += <span class="string">&quot;callback=callbackName&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发</span></span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">    iframe.style.display = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">    iframe.src = schema; <span class="comment">//重要</span></span><br><span class="line">    <span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span><br><span class="line">    body.appendChild(iframe);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      body.removeChild(iframe);</span><br><span class="line">      iframe = <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//暴露到全局变量</span></span><br><span class="line">  <span class="built_in">window</span>.invoke = &#123;</span><br><span class="line">    share: <span class="function"><span class="keyword">function</span> (<span class="params">data, callback</span>) </span>&#123;</span><br><span class="line">      _invoke(<span class="string">&quot;share&quot;</span>, data, callback);</span><br><span class="line">    &#125;,</span><br><span class="line">    scan: <span class="function"><span class="keyword">function</span> (<span class="params">data, callback</span>) </span>&#123;</span><br><span class="line">      _invoke(<span class="string">&quot;scan&quot;</span>, data, callback);</span><br><span class="line">    &#125;,</span><br><span class="line">    login: <span class="function"><span class="keyword">function</span> (<span class="params">data, callback</span>) </span>&#123;</span><br><span class="line">      _invoke(<span class="string">&quot;login&quot;</span>, data, callback);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<h3 id="问题解答-3"><a href="#问题解答-3" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>前端 JS 和 客户端 如何通讯？<ul>
<li>通讯的基本形式：调用能力，传递参数，监听回调</li>
<li>对 schema 协议的理解和使用 （这个协议可理解为 ：定义了前端和客户端 通信的一个标准）</li>
<li>调用 schema 代码的封装</li>
<li>内置上线的好处：更快、更安全</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>混合APP</category>
      </categories>
      <tags>
        <tag>hybrid</tag>
      </tags>
  </entry>
  <entry>
    <title>异步</title>
    <url>/2019/08/14/asynchronization/</url>
    <content><![CDATA[<h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><blockquote>
<p>本章全面讲解了 JS 异步的知识点。先从<strong>原理开始</strong> ，讲解什么是 <strong>单线程</strong>、什么是 <strong>event loop</strong> ；然后讲解 jQuery 中解决 <strong>异步的 Deferred</strong> 以及 jQuery 初次展示出来的 <strong>Promise 的用法</strong>；最后再讲解 ES6 中 <strong>Promise 的用法和标准</strong> 。</p>
<p><strong>基础篇请看</strong> ：<a href="http://zxinc520.com/lcj/%225d2eeda9d797f0309cf6ab02%22">异步和单线程</a></p>
</blockquote>
<h2 id="异步-1"><a href="#异步-1" class="headerlink" title="异步"></a>异步</h2><blockquote>
<p>高级面试</p>
</blockquote>
<ul>
<li>《<a href="http://zxinc520.com/lcj/%225d2eeda9d797f0309cf6ab02%22">前端 JS 面试技巧</a>》讲到异步的基础</li>
<li>高级面试会问到更多的内容</li>
<li>如 event-loop Promise Async/Await 等</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>什么是单线程，和异步有什么关系？ <a href="http://zxinc520.com/lcj/%225d2eeda9d797f0309cf6ab02%22">参考 </a></li>
<li>什么是 event-loop？</li>
<li>是否用过 jQuery 的 Deferred</li>
<li>Promise 的基本使用和原理</li>
<li>介绍一下 async/await（ES7）（和 Promise 的区别、联系）</li>
<li>总结一下当前 JS 解决异步的方案</li>
</ul>
<h2 id="4-1-单线程和异步"><a href="#4-1-单线程和异步" class="headerlink" title="4-1 单线程和异步"></a>4-1 单线程和异步</h2><blockquote>
<p><a href="http://zxinc520.com/lcj/%225d2eeda9d797f0309cf6ab02%22">单线程和异步基础篇 </a></p>
</blockquote>
<ul>
<li>为什么是单线程？<ul>
<li>原因 - 避免 DOM 渲染冲突<ul>
<li>浏览器需要渲染 DOM</li>
<li>JS 可以修改 DOM 结构</li>
<li>JS 执行的时候，浏览器 DOM 渲染会暂停</li>
<li>两段 JS 也不能同时执行 （ 都修改 DOM 就冲突了）</li>
<li>webworker 支持多线程 ，但是不能 访问 DOM</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>单线程的解决方案</strong> ： <strong>异步</strong></p>
<p><em>暴露出的问题</em> ：</p>
<ul>
<li>问题一：没按照书写方式执行，可读性差</li>
<li>问题二：callback 中不容易模块化</li>
</ul>
<h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>什么是单线程，和异步有什么关系？<ul>
<li>单线程就是同时只做一件事，两段 JS 不能同时 执行</li>
<li>原因就是 为了避免 DOM 渲染的冲突</li>
<li>异步是一种 “无奈” 的解决方案，虽然有很多问题</li>
</ul>
</li>
</ul>
<p><strong>承上启下：</strong></p>
<ul>
<li>单线程 - 同时间只能做一件事</li>
<li>原因 - 避免 DOM 渲染冲突</li>
<li>解决方案 - 异步</li>
<li>异步的实现方式 - event loop</li>
</ul>
<h2 id="4-2-什么是-event-loop"><a href="#4-2-什么是-event-loop" class="headerlink" title="4-2 什么是 event-loop"></a>4-2 什么是 event-loop</h2><blockquote>
<p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。 <a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">再谈 Event Loop</a></p>
</blockquote>
<h3 id="文字解释"><a href="#文字解释" class="headerlink" title="文字解释"></a>文字解释</h3><blockquote>
<p>event-loop</p>
</blockquote>
<ul>
<li>事件轮询， JS 实现异步 的具体解决方案</li>
<li>同步代码，直接执行</li>
<li>异步函数先放在 异步队列 中</li>
<li>待同步函数执行完毕，轮询执行 异步队列 的函数</li>
</ul>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p><em>示例一：</em></p>
<p><img src="http://static.zxinc520.com/blog/20190813/mxsAJyrO4cLE.png?imageslim" alt="mark"></p>
<p><em>示例二：</em></p>
<p><img src="http://static.zxinc520.com/blog/20190813/kftHfWYaHL80.png?imageslim" alt="mark"></p>
<p><em>示例三：</em></p>
<p><img src="http://static.zxinc520.com/blog/20190813/j3lPm5VCfcSB.png?imageslim" alt="mark"></p>
<p><strong>上图有 2 种结果</strong>：(a 是在 ajax 请求成功时放入异步队列，所以时间不确定)</p>
<ol>
<li>d -&gt; c -&gt; a -&gt; b</li>
<li>d -&gt; c -&gt; b -&gt; a</li>
</ol>
<h3 id="问题解答-1"><a href="#问题解答-1" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>什么是 event-loop？<ul>
<li>事件轮询， JS 实现异步 的具体解决方案</li>
<li>什么是异步队列，何时被放入 异步队列</li>
<li>轮询的过程</li>
</ul>
</li>
</ul>
<h2 id="4-3-jQuery-的-Deferred"><a href="#4-3-jQuery-的-Deferred" class="headerlink" title="4-3 jQuery 的 Deferred"></a>4-3 jQuery 的 Deferred</h2><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html">jQuery 的 deferred 对象详解</a></p>
<p>jQuery 1.5.0 版本开始引入的一个新功能—-<a href="http://api.jquery.com/category/deferred-object/">deferred 对象</a>。</p>
<p>针对的读者是那些已经具备 jQuery 使用经验的开发者。如果你想了解 jQuery 的基本用法，请阅读 <a href="http://www.ruanyifeng.com/">阮一峰</a> 编写的<a href="http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html">《jQuery 设计思想》</a>和<a href="http://www.ruanyifeng.com/blog/2011/08/jquery_best_practices.html">《jQuery 最佳实践》</a>。</p>
</blockquote>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>jQuery 1.5 的变化</li>
<li>使用 jQuery Deferred</li>
<li>初步引入 Promise 概念</li>
</ul>
<p><strong>注意</strong> ：不要以为所有的网站 都是 vue 和 React 开发的</p>
<h4 id="jQuery-1-5-之前"><a href="#jQuery-1-5-之前" class="headerlink" title="jQuery 1.5 之前"></a>jQuery 1.5 之前</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = $.ajax(&#123;</span><br><span class="line">  url: <span class="string">&quot;data.json&quot;</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success1&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success2&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success3&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ajax); <span class="comment">//返回一个 XHR 对象</span></span><br></pre></td></tr></table></figure>

<h4 id="jQuery-1-5-之后"><a href="#jQuery-1-5-之后" class="headerlink" title="jQuery 1.5 之后"></a>jQuery 1.5 之后</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = $.ajax(<span class="string">&quot;data.json&quot;</span>);</span><br><span class="line">ajax</span><br><span class="line">  .done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success 1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .fail(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success 2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ajax); <span class="comment">//返回一个 deferred 对象</span></span><br></pre></td></tr></table></figure>

<h4 id="jQuery-1-5-的变化"><a href="#jQuery-1-5-的变化" class="headerlink" title="jQuery 1.5 的变化"></a>jQuery 1.5 的变化</h4><ul>
<li>无法改变 JS 异步和单线程的本质</li>
<li>只能从写法上杜绝 callback 这种形式</li>
<li>它是一种语法糖形式，但是解耦了代码</li>
<li>很好的体现：<strong>开放封闭原则</strong></li>
</ul>
<h3 id="使用-jQuery-Deferred"><a href="#使用-jQuery-Deferred" class="headerlink" title="使用 jQuery Deferred"></a>使用 jQuery Deferred</h3><blockquote>
<p>使用 jQuery Deferred</p>
<p>对比 说明</p>
</blockquote>
<p><em>未使用情况：</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给出一段非常简单的异步操作代码，使用 setTimeout 函数</span></span><br><span class="line"><span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> task = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;执行完成&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">setTimeout</span>(task, <span class="number">2000</span>);</span><br><span class="line">&#125;;</span><br><span class="line">wait();</span><br><span class="line"><span class="comment">// 新增需求：要在执行完成之后进行某些特别复杂的操作，代码可能会很多，而且分好几个步骤</span></span><br></pre></td></tr></table></figure>

<p>_使用 jQuery Deferred_：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitHandle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dtd = $.Deferred(); <span class="comment">//创建一个 Deferred 对象</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span> (<span class="params">dtd</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//要求传入一个 Deferred 对象</span></span><br><span class="line">    <span class="keyword">var</span> task = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;执行完成&quot;</span>);</span><br><span class="line">      dtd.resolve(); <span class="comment">//表示异步任务已经完成</span></span><br><span class="line">      <span class="comment">// dtd.reject()  //表示异步任务失败或出错</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">setTimeout</span>(task, <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> dtd; <span class="comment">// 要求返回 Deferred 对象</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意，这里一定要有返回值</span></span><br><span class="line">  <span class="keyword">return</span> wait(dtd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区别于promise，好像不能链式调用</span></span><br><span class="line"><span class="keyword">var</span> w = waitHandle();</span><br><span class="line">w.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;ok 1&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;err 1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">w.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;ok 2&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;error 2&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有 w.done w.fail</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>总结，dtd 的 API 可分成两类，用意不同</li>
<li>第一类：dtd.resolve dtd.reject</li>
<li>第二类：dtd.then dtd.done dtd.fail</li>
<li>这两类应该分开，否则后果很严重</li>
</ul>
<h3 id="问题解答-2"><a href="#问题解答-2" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li><p>是否用过 jQuery 的 Deferred</p>
<ul>
<li>可以 jQuery 1.5 对 ajax 的改变举例</li>
<li>说明如何简单的封装，使用 Deferred</li>
<li>说明 ES6 promise 和 Deferred 的区别</li>
</ul>
</li>
</ul>
<p><strong>想要深入理解它，就需要知道它的前世今生。</strong></p>
<h2 id="4-4-Promise"><a href="#4-4-Promise" class="headerlink" title="4-4 Promise"></a>4-4 Promise</h2><blockquote>
<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>
<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p><a href="http://es6.ruanyifeng.com/#docs/promise">ECMAScript 6 Promise 对象</a></p>
<p><strong>基础语法</strong> 请参考我的另一篇博客： <a href="http://zxinc520.com/lcj/%225cbb3bf05733fa0a66088c80%22">Promise 详细分析</a></p>
</blockquote>
<p><code>Promise</code><strong>对象有以下两个特点</strong>。</p>
<ol>
<li>对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ol>
<p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p>
<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>
<p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<p>如果某些事件不断地反复发生，一般来说，使用 <a href="https://nodejs.org/api/stream.html">Stream</a> 模式是比部署<code>Promise</code>更好的选择。</p>
<h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(img);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject();</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = src;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> src =</span><br><span class="line">  <span class="string">&quot;https://edu-image.nosdn.127.net/B34DC36428D2D51B8EF5EE2C83CE9BF2.png?imageView&amp;thumbnail=241y34&amp;quality=100&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = loadImg(src);</span><br><span class="line"></span><br><span class="line"><span class="comment">//规定 ： then 只接受一个参数，最后统一用 catch 捕获异常</span></span><br><span class="line">result</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">img</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(img.width);</span><br><span class="line">    <span class="keyword">return</span> img;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">img</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(img.height);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">ex</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 最后统一 catch</span></span><br><span class="line">    <span class="built_in">console</span>.log(ex);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Promise-all-amp-Promise-race"><a href="#Promise-all-amp-Promise-race" class="headerlink" title="Promise.all &amp; Promise.race"></a>Promise.all &amp; Promise.race</h3><blockquote>
<p><strong>Promise.all</strong> 可以将多个 Promise 实例包装成一个新的 Promise 实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被 reject 失败状态的值。</p>
<p><strong>Promse.race</strong> 就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。</p>
<p><a href="https://www.jianshu.com/p/7e60fc1be1b2">理解和使用 Promise.all 和 Promise.race</a></p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190814/LoF987DaE10r.png?imageslim" alt="mark"></p>
<p><em>演示</em> ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(img);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject();</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = src;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> src1 =</span><br><span class="line">  <span class="string">&quot;https://edu-image.nosdn.127.net/B34DC36428D2D51B8EF5EE2C83CE9BF2.png?imageView&amp;thumbnail=241y34&amp;quality=100&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> src2 = <span class="string">&quot;https://www.imooc.com/static/img/index/logo.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = loadImg(src1);</span><br><span class="line"><span class="keyword">var</span> result2 = loadImg(src2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([result1, result2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">datas</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(datas[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(datas[<span class="number">1</span>]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//谁快谁先执行</span></span><br><span class="line"><span class="built_in">Promise</span>.race([result1, result2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">datas</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(datas);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Promise.all 的执行结果</strong> ：</p>
<p><img src="http://static.zxinc520.com/blog/20190814/ITqccL9zhyE0.png?imageslim" alt="mark"></p>
<p><strong>Promise.race 的执行结果</strong> ：</p>
<p><img src="http://static.zxinc520.com/blog/20190814/PP76XFiW0S3V.png?imageslim" alt="mark"></p>
<h3 id="promise-标准"><a href="#promise-标准" class="headerlink" title="promise 标准"></a>promise 标准</h3><ul>
<li>关于 “标准” 的闲谈</li>
<li>状态变化</li>
<li>then</li>
</ul>
<h4 id="关于-“标准”-的闲谈"><a href="#关于-“标准”-的闲谈" class="headerlink" title="关于 “标准” 的闲谈"></a>关于 “标准” 的闲谈</h4><ul>
<li>任何技术推广使用都需要一套标准来支撑</li>
<li>如 html js css http 等，无规矩不成方圆</li>
<li>任何不符合标准的东西，终将会被用户抛弃</li>
<li>不要挑战标准，不要自造标准</li>
</ul>
<h4 id="状态变化"><a href="#状态变化" class="headerlink" title="状态变化"></a>状态变化</h4><ul>
<li>三种状态：pending fulfilled rejected</li>
<li>初始状态：pending</li>
<li><strong>成功</strong>：pending 变成 fulfilled ，<strong>失败</strong>：pending 变成 rejected</li>
<li>状态变化不可逆</li>
</ul>
<h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><ul>
<li><p>Promise 实例必须实现 then 这个方法</p>
</li>
<li><p>then() 必须可以接受两个函数作为参数</p>
</li>
<li><p>then() 返回的必须是一个 Promise 实例</p>
<p><img src="http://static.zxinc520.com/blog/20190814/p2zjIfnNkjIp.png?imageslim" alt="mark"></p>
</li>
</ul>
<h3 id="问题解答-3"><a href="#问题解答-3" class="headerlink" title="问题解答"></a>问题解答</h3><p><strong>问题：Promise 的基本使用和原理？</strong></p>
<ul>
<li>基本语法 （复习）</li>
<li>如何异常捕获 （ error 和 reject 都要考虑）</li>
<li>多个串联 - 链式执行的好处</li>
<li>Promise.all 和 Promise.race</li>
<li>Promise 标准 - 状态变化，then 函数</li>
</ul>
<h2 id="4-5-async-await"><a href="#4-5-async-await" class="headerlink" title="4-5 async/await"></a>4-5 async/await</h2><blockquote>
<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>
<p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>
<p><a href="http://es6.ruanyifeng.com/">ECMAScript 6 入门</a> <a href="http://es6.ruanyifeng.com/#docs/async">async 函数</a></p>
</blockquote>
<ul>
<li>then 只是将 callback 拆分了</li>
<li>async/await 是最直接的同步写法</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190815/B2MsvoDMkq7B.png?imageslim" alt="mark"></p>
<p><strong>最直接的同步写法：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> load = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">await</span> loadImg(src1);</span><br><span class="line">  <span class="built_in">console</span>.log(result1);</span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">await</span> loadImg(src2);</span><br><span class="line">  <span class="built_in">console</span>.log(result2);</span><br><span class="line">&#125;;</span><br><span class="line">load();</span><br></pre></td></tr></table></figure>

<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul>
<li>使用 await，函数必须用 async 标识</li>
<li>await 后面跟的是一个 Promise 实例</li>
<li>需要 babel-polyfill</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(img);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject();</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = src;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> src1 =</span><br><span class="line">  <span class="string">&quot;https://edu-image.nosdn.127.net/B34DC36428D2D51B8EF5EE2C83CE9BF2.png?imageView&amp;thumbnail=241y34&amp;quality=100&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> src2 = <span class="string">&quot;https://www.imooc.com/static/img/index/logo.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> load = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">await</span> loadImg(src1);</span><br><span class="line">  <span class="built_in">console</span>.log(result1);</span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">await</span> loadImg(src2);</span><br><span class="line">  <span class="built_in">console</span>.log(result2);</span><br><span class="line">&#125;;</span><br><span class="line">load();</span><br></pre></td></tr></table></figure>

<h3 id="问题解答-4"><a href="#问题解答-4" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>介绍一下 async/await（ES7）（和 Promise 的区别、联系）<ul>
<li>基本语法</li>
<li>使用了 Promise，并没有和 Promise 冲突</li>
<li>完全是同步的写法，再也没有回调函数</li>
<li>但是：改变不了 JS 单线程、异步的本质</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
        <category>JS 三座大山</category>
      </categories>
      <tags>
        <tag>JS 三座大山</tag>
        <tag>单线程</tag>
        <tag>event loop</tag>
        <tag>异步的 Deferred</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>原型</title>
    <url>/2019/08/10/NewPrototype/</url>
    <content><![CDATA[<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><blockquote>
<p>本章将结合 <strong>jQuery</strong> 和 <strong>zepto</strong> 源码来讲解原型的实际应用。通过 <strong>源码来分析</strong> jQuery 和 zepto 是如何使用原型的，以及通过它们的 <strong>插件机制</strong>，讲解 <strong>原型的扩展性</strong> 。</p>
<p>《前端 JS 面试技巧》请参考我之前的博客： <a href="http://zxinc520.com/lcj/%225d2df2cdda85353d5ca8b83f%22">前端 JS 基础面试技巧</a></p>
</blockquote>
<h3 id="关于原型"><a href="#关于原型" class="headerlink" title="关于原型"></a>关于原型</h3><ul>
<li>《前端 JS 面试技巧》已经讲解过原型的 <a href="http://zxinc520.com/lcj/%225d2df2cdda85353d5ca8b83f%22">基础知识</a></li>
<li>高级面试题，光会原型基础还不够，还要实际应用</li>
<li>zepto jquery 中如何用原型</li>
<li>顺便也算是解读了 zepto 和 jquery 的部分源码</li>
</ul>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul>
<li>说一个原型的实际应用</li>
<li>原型如何体现它的扩展性</li>
</ul>
<h2 id="原型的实际应用"><a href="#原型的实际应用" class="headerlink" title="原型的实际应用"></a>原型的实际应用</h2><blockquote>
<p>原型的实际应用</p>
</blockquote>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>jquery 和 zepto 的简单使用</li>
<li>zepto 如何使用原型</li>
<li>jquery 如何使用原型</li>
</ul>
<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;jquery test <span class="number">1</span>&lt;/p&gt;</span><br><span class="line">&lt;p&gt;jquery test <span class="number">2</span>&lt;/p&gt;</span><br><span class="line">&lt;p&gt;jquery test <span class="number">3</span>&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;div1&quot;</span>&gt;</span><br><span class="line">    &lt;p&gt;jquery test <span class="keyword">in</span> dev&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> $p = $(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">    $p.css(<span class="string">&#x27;font-size&#x27;</span>, <span class="string">&#x27;40px&#x27;</span>) <span class="comment">//css 是原型方法</span></span><br><span class="line">    alert($p.html()) 		    <span class="comment">//html 是原型方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> $div1 = $(<span class="string">&#x27;#div1&#x27;</span>)      <span class="comment">//css 是原型方法</span></span><br><span class="line">    $div1.css(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>)  <span class="comment">//html 是原型方法</span></span><br><span class="line">    alert($div1.html())</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="zepto-如何使用原型"><a href="#zepto-如何使用原型" class="headerlink" title="zepto 如何使用原型"></a>zepto 如何使用原型</h4><blockquote>
<p>源码中，这里的处理情况比较复杂。但因为本次只针对原型，因此这里就弱化了</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//空对象</span></span><br><span class="line">  <span class="keyword">var</span> zepto = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  zepto.init = <span class="function"><span class="keyword">function</span> (<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//源码中，这里的处理情况比较复杂。但因为本次只针对原型，因此这里就弱化了</span></span><br><span class="line">    <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">    <span class="keyword">var</span> dom = slice.call(<span class="built_in">document</span>.querySelectorAll(selector));</span><br><span class="line">    <span class="keyword">return</span> zepto.Z(dom, selector);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 即使用 zepto 时候的 $</span></span><br><span class="line">  <span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span> (<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zepto.init(selector);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这就是构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Z</span>(<span class="params">dom, selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i,</span><br><span class="line">      len = dom ? dom.length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) <span class="built_in">this</span>[i] = dom[i];</span><br><span class="line">    <span class="built_in">this</span>.length = len;</span><br><span class="line">    <span class="built_in">this</span>.selector = selector;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  zepto.Z = <span class="function"><span class="keyword">function</span> (<span class="params">dom, selector</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注意，出现了 new 关键字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Z(dom, selector);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  $.fn = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: zepto.Z,</span><br><span class="line">    css: function (key, value) &#123;&#125;,</span><br><span class="line">    html: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  zepto.Z.prototype = Z.prototype = $.fn;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.$ = $;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<h4 id="jquery-如何使用原型"><a href="#jquery-如何使用原型" class="headerlink" title="jquery 如何使用原型"></a>jquery 如何使用原型</h4><blockquote>
<p>简化了源码，重在讲解 jquery 如何使用原型</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简化了源码，真实源码分支很多,选取部分代码</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span> (<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//注意 new 关键字，第一步就找到了 构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义构造函数</span></span><br><span class="line">  <span class="keyword">var</span> init = (jQuery.fn.init = <span class="function"><span class="keyword">function</span> (<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">    <span class="keyword">var</span> dom = slice.call(<span class="built_in">document</span>.querySelectorAll(selector));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i,</span><br><span class="line">      len = dom ? dom.length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) <span class="built_in">this</span>[i] = dom[i];</span><br><span class="line">    <span class="built_in">this</span>.length = len;</span><br><span class="line">    <span class="built_in">this</span>.selector = selector || <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  init.prototype = jQuery.fn;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化 jQuery.fn</span></span><br><span class="line">  jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: jQuery,</span><br><span class="line"></span><br><span class="line">    //其他函数...</span><br><span class="line">    css: function (key, value) &#123;&#125;,</span><br><span class="line">    html: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义原型</span></span><br><span class="line">  init.prototype = jQuery.fn;</span><br><span class="line">  <span class="built_in">window</span>.$ = jQuery;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>描述一下 jquery 如何使用原型</li>
<li>描述一下 zepto 如何使用原型</li>
<li>再结合自己的项目经验，说一下自己开发的例子</li>
</ul>
<h2 id="如何体现原型的扩展性"><a href="#如何体现原型的扩展性" class="headerlink" title="如何体现原型的扩展性"></a>如何体现原型的扩展性</h2><blockquote>
<p>体现原型的扩展性</p>
</blockquote>
<h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>总结 zepto 和 jquery 原型的使用</li>
<li>插件机制</li>
</ul>
<h3 id="总结-zepto-和-jquery-原型的使用"><a href="#总结-zepto-和-jquery-原型的使用" class="headerlink" title="总结 zepto 和 jquery 原型的使用"></a>总结 zepto 和 jquery 原型的使用</h3><blockquote>
<p>总结 zepto 和 jquery 原型的使用</p>
<p>相关 <strong>代码实现</strong> 请看上文 ：zepto 如何使用原型 和 jquery 如何使用原型</p>
</blockquote>
<p><em>问题一：为何要把原型方法放在 $.fn ?</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化 jQuery.fn</span></span><br><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: jQuery,</span><br><span class="line"></span><br><span class="line">  //其他函数...</span><br><span class="line">  css: function (key, value) &#123;&#125;,</span><br><span class="line">  html: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义原型</span></span><br><span class="line">init.prototype = jQuery.fn;</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong> ：<u>因为要扩展插件</u> ，做一个简单的插件的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为要扩展插件，做一个简单的插件的例子</span></span><br><span class="line">$.fn.getNodeName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>[<span class="number">0</span>].nodeName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>好处</strong>：</p>
<ol>
<li>只有 $ 会暴露在 window 全局变量</li>
<li>将插件扩展统一到 $.fn.xxx 这一接口，方便使用</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>说一个原型的实际应用</p>
<ul>
<li>描述一下 jquery 如何使用 原型</li>
<li>描述一下 zepto 如何使用 原型</li>
<li>再结合自己的项目经验，说一下自己开发的例子</li>
</ul>
</li>
<li><p>原型如何体现它的扩展性</p>
<ul>
<li>说一下 jquery 和 zepto 的 插件机制</li>
<li>结合自己的开发经验，做过的基于原型的插件</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
        <category>JS 三座大山</category>
      </categories>
      <tags>
        <tag>面试全面总结</tag>
        <tag>JS 三座大山</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 语法</title>
    <url>/2019/08/04/ES6intro/</url>
    <content><![CDATA[<h1 id="ES6-语法"><a href="#ES6-语法" class="headerlink" title="ES6 语法"></a>ES6 语法</h1><blockquote>
<p>本章主要讲解工作中最常用的 ES6 语法，包括 <strong>Module Class Promise</strong> 等语法，还会介绍使用 <strong>babel webpack rollup</strong> 来搭建 ES6 编译环境。</p>
<p><a href="http://es6.ruanyifeng.com/">ECMAScript 6 入门</a></p>
</blockquote>
<h2 id="ES6-使用"><a href="#ES6-使用" class="headerlink" title="ES6 使用"></a>ES6 使用</h2><ul>
<li>开发环境已经普及使用</li>
<li>浏览器环境却支持不好（ 需要开发环境编译 ）</li>
<li>内容很多，重点了解常用语法</li>
<li>面试：开发环境的使用 + 重点语法的掌握</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>ES6 模块化如何使用，开发环境如何打包</li>
<li>Class 和 普通构造函数 有何区别 ？</li>
<li>Promise 的基本使用和原理</li>
<li>总结一下 ES6 其它常用功能</li>
</ul>
<h2 id="2-1-ES6-模块化语法"><a href="#2-1-ES6-模块化语法" class="headerlink" title="2-1 ES6 模块化语法"></a>2-1 ES6 模块化语法</h2><blockquote>
<p>ES6 模块化如何使用，开发环境如何打包</p>
</blockquote>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><strong>ES6 模块化如何使用，开发环境如何打包:</strong></p>
<ul>
<li>模块化的基本语法</li>
<li>开发环境的配置</li>
<li>关于 JS 众多 模块化标准</li>
</ul>
<h4 id="export-语法"><a href="#export-语法" class="headerlink" title="export 语法"></a>export 语法</h4><blockquote>
<p>export 语法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*util1.js*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  a: <span class="number">100</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*util2.js*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;fn1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;fn2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*index.js*/</span></span><br><span class="line"><span class="keyword">import</span> util1 <span class="keyword">from</span> <span class="string">&quot;./util1.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; fn1, fn2 &#125; <span class="keyword">from</span> <span class="string">&quot;./util2.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(util1);</span><br><span class="line">fn1();</span><br><span class="line">fn2();</span><br></pre></td></tr></table></figure>

<h4 id="开发环境-babel"><a href="#开发环境-babel" class="headerlink" title="开发环境 - babel"></a>开发环境 - babel</h4><blockquote>
<p>Babel 是一个 JavaScript 编译器。<a href="https://babeljs.io/">官网</a></p>
<p>使用技巧 可参考 <a href="http://zxinc520.com/lcj/%225cc4640d9b3032095d9e5754%22">React 学习第一天 ：webpack 中使用 Babel 配置</a></p>
<p>和 <a href="http://zxinc520.com/lcj/%225cb72a04009ae94788aa0d7f%22">Vue 第六天学习 ：webpack 中 babel 的配置</a></p>
</blockquote>
<h4 id="开发环境-webpack"><a href="#开发环境-webpack" class="headerlink" title="开发环境 - webpack"></a>开发环境 - webpack</h4><blockquote>
<p>开发环境 - webpack - <em>webpack</em> 是一个模块打包器 <a href="https://webpack.js.org/">官网</a></p>
<p>详情 可参考我的博客：<a href="http://zxinc520.com/lcj/%225cb181596d3d4a5cb52b65c9%22">Vue 第五天：webpack</a> 和 <a href="http://zxinc520.com/lcj/%225cb72a04009ae94788aa0d7f%22">Vue 第六天学习：深入 webpack</a> 以及 <a href="http://zxinc520.com/lcj/%225cc4640d9b3032095d9e5754%22">React 学习第一天：创建基本的 webpack4.x 项目 </a></p>
</blockquote>
<h4 id="rollup-js"><a href="#rollup-js" class="headerlink" title="rollup.js"></a>rollup.js</h4><blockquote>
<p>概述 (Overview) <a href="https://www.rollupjs.com/guide/zh">中文文档</a> <a href="https://rollupjs.org/guide/en/">官网</a></p>
<p>Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。Rollup 对代码模块使用新的标准化格式，这些标准都包含在 JavaScript 的 ES6 版本中，而不是以前的特殊解决方案，如 CommonJS 和 AMD。ES6 模块可以使你自由、无缝地使用你最喜爱的 library 中那些最有用独立函数，而你的项目不必携带其他未使用的代码。ES6 模块最终还是要由浏览器原生实现，但当前 Rollup 可以使你提前体验</p>
<p><strong>rollup 功能单一（极致） ，webpack 功能强大</strong></p>
</blockquote>
<h4 id="关于-JS-众多-模块化标准"><a href="#关于-JS-众多-模块化标准" class="headerlink" title="关于 JS 众多 模块化标准"></a>关于 JS 众多 模块化标准</h4><blockquote>
<p>关于 JS 众多 模块化标准</p>
<p>详情可参考我的博客：<a href="http://zxinc520.com/lcj/%225d31940b724e8113740499b3%22">开发环境： 模块化</a></p>
</blockquote>
<p><strong>发展过程</strong></p>
<ul>
<li>没有模块化</li>
<li>AMD 成为 标准，require.js （也有 CMD【<strong>用的不多</strong> 】）</li>
<li>前端打包工具，nodejs 模块化可以被使用</li>
<li>ES6 出现 ，想统一现在所有的模块化标准</li>
<li>nodejs 积极支持，浏览器尚未统一</li>
<li>你可以自造 lib，但是不要自造标准</li>
</ul>
<h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>语法：import export （注意有无 default）</li>
<li>环境：babel 编译 ES6 语法，模块化可用 webpack 和 rollup</li>
<li>扩展：说一下自己对模块化标准统一的期待</li>
</ul>
<h2 id="2-2-Class-和-普通构造函数有何区别"><a href="#2-2-Class-和-普通构造函数有何区别" class="headerlink" title="2-2 Class 和 普通构造函数有何区别"></a>2-2 Class 和 普通构造函数有何区别</h2><blockquote>
<p>Class 和 普通构造函数有何区别</p>
<p><a href="http://zxinc520.com/lcj/%225cd03896bd482e21ac46a9d4%22">我的博客：React 学习第二天：了解 class</a></p>
</blockquote>
<h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>JS 构造函数</li>
<li>Class 基本语法</li>
<li>语法糖</li>
<li>继承</li>
</ul>
<h3 id="问题解答-1"><a href="#问题解答-1" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>Class 和 普通构造函数 有何区别 ？<ul>
<li>Class 在语法上更加贴合面向对象的写法</li>
<li>Class 实现继承更加易读、易理解</li>
<li>更易于写 java 等后端语言的使用</li>
<li>本质还是语法糖， 使用 prototype</li>
</ul>
</li>
</ul>
<h2 id="2-3-Promise-的基本使用"><a href="#2-3-Promise-的基本使用" class="headerlink" title="2-3 Promise 的基本使用"></a>2-3 Promise 的基本使用</h2><h3 id="Promise-的基本使用"><a href="#Promise-的基本使用" class="headerlink" title="Promise 的基本使用"></a>Promise 的基本使用</h3><blockquote>
<p>可参考我的博客：<a href="http://zxinc520.com/lcj/%225cbb3bf05733fa0a66088c80%22">Promise 详细分析</a></p>
</blockquote>
<ul>
<li>Callback Hell</li>
<li>Promise 语法</li>
</ul>
<h4 id="Callback-Hell"><a href="#Callback-Hell" class="headerlink" title="Callback Hell"></a>Callback Hell</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">src, callback, fail</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(img);</span><br><span class="line">  &#125;;</span><br><span class="line">  img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    fail();</span><br><span class="line">  &#125;;</span><br><span class="line">  img.src = src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> src =</span><br><span class="line">  <span class="string">&quot;https://edu-image.nosdn.127.net/B34DC36428D2D51B8EF5EE2C83CE9BF2.png?imageView&amp;thumbnail=241y34&amp;quality=100&quot;</span>;</span><br><span class="line">loadImg(</span><br><span class="line">  src,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">img</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(img.width);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="Promise-语法"><a href="#Promise-语法" class="headerlink" title="Promise 语法"></a>Promise 语法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(img);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject();</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = src;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> src =</span><br><span class="line">  <span class="string">&quot;https://edu-image.nosdn.127.net/B34DC36428D2D51B8EF5EE2C83CE9BF2.png?imageView&amp;thumbnail=241y34&amp;quality=100&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = loadImg(src);</span><br><span class="line"></span><br><span class="line">result.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">img</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(img.width);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;faild&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">result.then(<span class="function"><span class="keyword">function</span> (<span class="params">img</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(img.height);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="问题解答-2"><a href="#问题解答-2" class="headerlink" title="问题解答"></a>问题解答</h3><ul>
<li>Promise 的基本使用和原理?<ul>
<li>new Promise 实例，而且要 return</li>
<li>new Promise 时要传入函数，函数有 resolve, reject 两个参数</li>
<li>成功时执行 resolve() 失败时执行 reject()</li>
<li>then 监听结果</li>
</ul>
</li>
</ul>
<h2 id="2-4-总结一下-ES6-其它常用功能"><a href="#2-4-总结一下-ES6-其它常用功能" class="headerlink" title="2-4 总结一下 ES6 其它常用功能"></a>2-4 总结一下 ES6 其它常用功能</h2><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>let/const</li>
<li>多行字符串/模板变量</li>
<li>解构赋值</li>
<li>块级作用域</li>
<li>函数默认参数</li>
<li>箭头函数</li>
</ul>
<h4 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h4><p><img src="http://static.zxinc520.com/blog/20190804/IjRCPysI3ja5.png?imageslim" alt="mark"></p>
<h4 id="多行字符串-模板变量"><a href="#多行字符串-模板变量" class="headerlink" title="多行字符串/模板变量"></a>多行字符串/模板变量</h4><p><img src="http://static.zxinc520.com/blog/20190804/cmkreCVTvB3f.png?imageslim" alt="mark"></p>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p><img src="http://static.zxinc520.com/blog/20190804/tkv3jll7XPJG.png?imageslim" alt="mark"></p>
<h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><p><img src="http://static.zxinc520.com/blog/20190804/vqFw5Cyt1Okg.png?imageslim" alt="mark"></p>
<h4 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h4><p><img src="http://static.zxinc520.com/blog/20190804/rDHBLwq6djzQ.png?imageslim" alt="mark"></p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p><img src="http://static.zxinc520.com/blog/20190804/26aXyJj3eE8M.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190804/XppPYlgRUceY.png?imageslim" alt="mark"></p>
]]></content>
      <categories>
        <category>JS</category>
        <category>ES6 语法</category>
      </categories>
      <tags>
        <tag>ES6 模块化语法</tag>
        <tag>babel</tag>
        <tag>webpack</tag>
        <tag>rollup</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>课程导论</title>
    <url>/2019/08/04/IntroductionToCourse/</url>
    <content><![CDATA[<h1 id="课程导论"><a href="#课程导论" class="headerlink" title="课程导论"></a>课程导论</h1><blockquote>
<p>课程导论：本章主要介绍课程的知识大纲，每个章节的解决顺序和主要内容。</p>
<p>1- 1 导学</p>
<p>1-2 课程重要提示</p>
<p>1-3 架构</p>
</blockquote>
<h2 id="课程概述"><a href="#课程概述" class="headerlink" title="课程概述"></a>课程概述</h2><blockquote>
<p><strong>做什么？</strong> ——讲解前端 JS 高级面试题</p>
<p><strong>哪些部分？</strong> ——高级基础，框架原理，app 混合开发</p>
<p><strong>技术？</strong> ——JS、ES6、虚拟 DOM、vueReact、hybrid</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190803/Q5w2nr68extL.png?imageslim" alt="mark"></p>
<h3 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h3><ul>
<li>高级基础</li>
<li>框架原理</li>
<li>App 混合开发</li>
<li>热爱编程</li>
</ul>
<h4 id="课程安排-高级基础"><a href="#课程安排-高级基础" class="headerlink" title="课程安排-高级基础"></a>课程安排-高级基础</h4><ul>
<li>ES6 常用语法：Class ,Module Promise 等</li>
<li>原型高级应用：结合 jQuery 和 zepto 源码</li>
<li>异步全面讲解：从原理到 jQuery 再到 Primise</li>
</ul>
<h4 id="课程安排-框架原理"><a href="#课程安排-框架原理" class="headerlink" title="课程安排-框架原理"></a>课程安排-框架原理</h4><ul>
<li>虚拟 DOM：存在价值，如何使用，diff 算法</li>
<li>vue：MVVM，vue 响应式、模板解析、渲染</li>
<li>React：组件化，JSX、VDOM，setState</li>
<li>对比：有主见，自圆其说</li>
</ul>
<h4 id="课程安排-App-混合开发"><a href="#课程安排-App-混合开发" class="headerlink" title="课程安排-App 混合开发"></a>课程安排-App 混合开发</h4><ul>
<li>hybrid：基础、和 h5 对比，上线流程</li>
<li>通讯：通讯原理，JS-Bridge 封装</li>
</ul>
<h4 id="课程安排-热爱编程"><a href="#课程安排-热爱编程" class="headerlink" title="课程安排- 热爱编程"></a>课程安排- 热爱编程</h4><ul>
<li>读书</li>
<li>博客</li>
<li>开源</li>
</ul>
<h3 id="课程收获"><a href="#课程收获" class="headerlink" title="课程收获"></a>课程收获</h3><ul>
<li>应对 JS 高级面试题</li>
<li>从深度和广度都扩充了自己的知识体系</li>
<li>学会如何高效学习</li>
<li>深入理解常用框架的实现原理和 hybrid 应用</li>
</ul>
<h3 id="学习前提"><a href="#学习前提" class="headerlink" title="学习前提"></a>学习前提</h3><ul>
<li>有 JavaScript 基础</li>
<li>用过 node.js 和 npm 开发环境</li>
<li>了解 vue 和 React （至少看过文档，做过 demo）</li>
<li>热爱前端开发，有学习的欲望</li>
</ul>
<h3 id="课程优势"><a href="#课程优势" class="headerlink" title="课程优势"></a>课程优势</h3><ul>
<li>针对高级 JS 面试中，面试官爱问 “源码” “实现”</li>
<li>介绍常用框架实现原理的视频，网上稀缺</li>
<li>会介绍 hybrid 原理和应用的视频，网上稀缺</li>
<li>全部由实际工作经验总结而来，书上看不到</li>
</ul>
]]></content>
      <categories>
        <category>混合APP</category>
      </categories>
      <tags>
        <tag>hybrid</tag>
        <tag>虚拟 DOM</tag>
        <tag>知识点概述</tag>
      </tags>
  </entry>
  <entry>
    <title>前端JS基础面试技巧下</title>
    <url>/2019/08/04/JsBasicKnowledge02/</url>
    <content><![CDATA[<h1 id="前端-JS-基础面试技巧"><a href="#前端-JS-基础面试技巧" class="headerlink" title="前端 JS 基础面试技巧"></a>前端 JS 基础面试技巧</h1><blockquote>
<p>前端 JS 基础面试技巧 – <strong>JS 基础知识下</strong></p>
<p>JS 三座大山：<strong>原型原型链</strong> 、<strong>作用域闭包</strong> 、<strong>异步和单线程</strong> 。</p>
<p>知识点：</p>
<p>3-1 异步和单线程</p>
<p>3-2 日期和 math</p>
<ul>
<li>日期</li>
<li>Math</li>
<li>数组 API</li>
<li>对象 API</li>
</ul>
</blockquote>
<h2 id="3-1-异步和单线程"><a href="#3-1-异步和单线程" class="headerlink" title="3-1 异步和单线程"></a>3-1 异步和单线程</h2><blockquote>
<p>异步和单线程</p>
<p>题目</p>
<p>知识点</p>
<p>解答</p>
</blockquote>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul>
<li>同步和异步的区别是什么？分别举一个同步和异步的例子</li>
<li>一个关于 setTimeout 的笔试题</li>
<li>前端使用异步的场景有哪些</li>
</ul>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>什么是异步（对比同步）</li>
<li>前端使用异步的场景</li>
<li>异步个单线程</li>
</ul>
<h3 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h3><blockquote>
<p>异步（Asynchronous）</p>
<p>一般而言，操作分为发出调用和得到结果两步。发出调用后一直等待，直到拿到结果（这段时间不能做任何事）为 <strong>同步</strong> ；发出调用后不等待，继续执行下一个任务，就是 <strong>异步任务</strong> 。</p>
<p><a href="https://www.jianshu.com/p/667936441cb5">参考</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">200</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">300</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    100</span></span><br><span class="line"><span class="comment">    300</span></span><br><span class="line"><span class="comment">    200</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="何时需要异步？"><a href="#何时需要异步？" class="headerlink" title="何时需要异步？"></a>何时需要异步？</h4><ul>
<li><p>在可能发生等待的情况</p>
</li>
<li><p>等待过程中不能像 alert 一样阻塞程序运行</p>
</li>
<li><p>因此，所有的 “ 等待情况” 都需要异步</p>
</li>
</ul>
<h4 id="前端使用异步的场景"><a href="#前端使用异步的场景" class="headerlink" title="前端使用异步的场景"></a>前端使用异步的场景</h4><ul>
<li><p>定时任务：<strong>setTimeout</strong>，<strong>setInterval</strong></p>
</li>
<li><p>网络请求：<strong>ajax 请求</strong>，<strong>动态</strong> &lt;**img**&gt; <strong>加载</strong></p>
</li>
<li><p><strong>事件绑定</strong></p>
</li>
</ul>
<h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><blockquote>
<p><strong>Javascript 是单线程的</strong> <a href="https://www.cnblogs.com/Mainz/p/3552717.html">参考</a></p>
<p>JS 的单线程是指一个浏览器进程中只有一个 JS 的执行线程，同一时刻内只会有一段代码在执行</p>
<p>在某个特定的时刻只有特定的代码能够被执行，并 <strong>阻塞</strong> 其它的代码。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">300</span>);</span><br></pre></td></tr></table></figure>

<p><strong>上面代码执行过程：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190717/kEQlmncCXtel.png?imageslim" alt="mark"></p>
<h4 id="重点总结"><a href="#重点总结" class="headerlink" title="重点总结"></a>重点总结</h4><ul>
<li>异步和同步的区别</li>
<li>异步和单线程的关系</li>
<li>异步在前端的引用场景</li>
</ul>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><ul>
<li><p>同步和异步的区别是什么？分别举一个同步和异步的例子</p>
<ul>
<li><p><em>同步</em> 是 <strong>阻塞模式</strong> ，<em>异步</em> 是 <strong>非阻塞模式</strong> 。</p>
<p><em>同步</em> 就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会 <strong>一直等待下去</strong> ，知道收到返回信息才继续执行下去；</p>
<p><em>异步</em> 是指进程 <strong>不需要一直等下去</strong> ，而是 <strong>继续执行下面的操作</strong>，不管其他进程的状态。当有消息返回式系统会通知进程进行处理，这样可以提高执行的效率。</p>
</li>
<li><p>alert 是 同步， setTimeout 是 异步</p>
</li>
</ul>
</li>
<li><p>一个关于 setTimeout 的笔试题</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	1</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    5</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>前端使用异步的场景有哪些<ul>
<li>定时任务：<strong>setTimeout</strong>，<strong>setInterval</strong></li>
<li>网络请求：<strong>ajax 请求</strong>，<strong>动态</strong> &lt;**img**&gt; <strong>加载</strong></li>
<li><strong>事件绑定</strong></li>
</ul>
</li>
</ul>
<h2 id="3-2-日期和-math"><a href="#3-2-日期和-math" class="headerlink" title="3-2 日期和 math"></a>3-2 日期和 math</h2><blockquote>
<p>题目</p>
<p>知识点</p>
<p>解答</p>
</blockquote>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><ul>
<li>获取 2017 -06 -10 格式的日期</li>
<li>获取 随机数，要求是长度一致 的字符串格式</li>
<li>写一个 能遍历对象 和数组 的通用 forEach 函数</li>
</ul>
<h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>日期</li>
<li>Math</li>
<li>数组 API</li>
<li>对象 API</li>
</ul>
<h4 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h4><blockquote>
<p><strong>日期对象用于处理日期和时间。</strong></p>
<p><a href="http://www.w3school.com.cn/jsref/jsref_obj_date.asp">JavaScript Date 对象 API</a></p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190717/3ijIzI0Frks1.png?imageslim" alt="mark"></p>
<h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><blockquote>
<p><strong>Math</strong> 是一个内置对象， 它具有数学常数和函数的属性和方法。不是一个函数对象。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math">Math Api</a></p>
<p>描述：与其它全局对象不同的是, <code>Math</code> 不是一个构造器. <code>Math</code> 的所有属性和方法都是静态的. 你用到的常数 pi 可以用 <code>Math.PI</code> 表示,用 <code>x</code> 作参数 Math.sin(x)调用 sin 函数. JavaScript 中的常数, 是以全精度的实数定义的.</p>
<p>Math.random() 在前端的作用：随时改变，清除缓存。</p>
</blockquote>
<h4 id="数组-API"><a href="#数组-API" class="headerlink" title="数组 API"></a>数组 API</h4><blockquote>
<p><a href="http://louiszhai.github.io/2017/04/28/array/#Array%E6%9E%84%E9%80%A0%E5%99%A8">参考</a></p>
<p>详情可以参考我的博客：<a href="http://zxinc520.com/lcj/%225d119841fd02ab26e068eb0a%22">JavaScript 数组那些事</a></p>
</blockquote>
<p><strong>面试官最常问的几个</strong> ：</p>
<ul>
<li>forEach 遍历所有元素</li>
<li>every 判断所有元素是否都符合条件</li>
<li>some 判断是否有至少一个元素符合条件</li>
<li>sort 排序</li>
<li>map 对元素重新组装，生成新数组</li>
<li>filter 过滤符合条件的元素</li>
</ul>
<h4 id="对象-API"><a href="#对象-API" class="headerlink" title="对象 API"></a>对象 API</h4><blockquote>
<p><strong>Object.prototype API</strong></p>
<p><code>Object.prototype</code> 表示对象的原型对象<br><code>Object.prototype</code> 属性的属性特征</p>
<p><a href="https://www.jianshu.com/p/2f43db2b656c">参考</a></p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190717/mOpzx9LK1xmu.png?imageslim" alt="mark"></p>
<h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><ul>
<li>获取 2019-07-17 格式的日期</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params">dt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!dt) &#123;</span><br><span class="line">    dt = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">var</span> year = dt.getFullYear();</span><br><span class="line">  <span class="keyword">var</span> month = dt.getMonth() + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> data = dt.getDate();</span><br><span class="line">  <span class="keyword">if</span> (month &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    month = <span class="string">&quot;0&quot;</span> + month;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (data &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    data = <span class="string">&quot;0&quot;</span> + data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> year + <span class="string">&quot;-&quot;</span> + month + <span class="string">&quot;-&quot;</span> + data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(formatDate(dt));</span><br><span class="line"></span><br><span class="line"><span class="comment">//  2019-07-17</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取 随机数，要求是长度一致 的字符串格式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> random = <span class="built_in">Math</span>.random();</span><br><span class="line">random = random + <span class="string">&quot;0000000000&quot;</span>;</span><br><span class="line">random = random.slice(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(random);</span><br></pre></td></tr></table></figure>

<ul>
<li>写一个 能遍历对象 和数组 的通用 forEach 函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写一个 能遍历对象 和数组 的通用 forEach 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">obj, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">    obj.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">      fn(item, index);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      fn(key, obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用  forEach 函数</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span> &#125;;</span><br><span class="line"></span><br><span class="line">forEach(arr, <span class="function"><span class="keyword">function</span> (<span class="params">index, item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index + <span class="string">&quot;---&quot;</span> + item);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">forEach(obj, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	2---1</span></span><br><span class="line"><span class="comment">    3---2</span></span><br><span class="line"><span class="comment">    x 100</span></span><br><span class="line"><span class="comment">    y 200</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
        <category>JS 三座大山</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端JS基础面试技巧上</title>
    <url>/2019/08/04/JsBasicKnowledge01/</url>
    <content><![CDATA[<h1 id="前端-JS-基础面试技巧"><a href="#前端-JS-基础面试技巧" class="headerlink" title="前端 JS 基础面试技巧"></a>前端 JS 基础面试技巧</h1><blockquote>
<p>讲解 JS 基础语法相关的面试题，分析原理以及解答方法。这一章节讲解了基础知识的第一部分：变量的类型和计算。以及 JS “三座大山” —— 原型、作用域和异步中的： 原型和原型链、作用域和闭包。</p>
<p>知识点：</p>
<p>2-1 变量类型和计算</p>
<p>2-2 原型和原型链</p>
<p>2-3 函数声明和函数表达式</p>
<p>2-4 作用域和闭包</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190715/A5zp7Ltc8RyD.png?imageslim" alt="mark"></p>
<p><strong>关于面试</strong></p>
<ul>
<li>基层工程师 - <em>基础知识</em></li>
<li>高级工程师 - <em>项目经验</em></li>
<li>架构师 - <em>解决方案</em></li>
</ul>
<h2 id="先从几道面试题入手"><a href="#先从几道面试题入手" class="headerlink" title="先从几道面试题入手"></a>先从几道面试题入手</h2><ul>
<li>JS 中使用 <strong>typeof</strong> 能得到的哪些类型？<ul>
<li>考点：<em>JS 变量类型</em></li>
</ul>
</li>
<li>何时使用 <strong>===</strong> 何时使用 **== **？<ul>
<li>考点：<em>强制类型转换</em></li>
</ul>
</li>
<li><strong>window.onload</strong> 和 <strong>DOMContentLoaded</strong> 的区别？<ul>
<li>考点：<em>浏览器的渲染过程</em></li>
</ul>
</li>
<li>用 JS 创建 10 个 a 标签，点击的时候弹出来对应的序号<ul>
<li>考点：<em>作用域</em></li>
</ul>
</li>
<li>简述如何实现一个<strong>模块加载器</strong>，实现类似 <strong>require.js</strong> 的基本功能<ul>
<li>考点：<em>JS 模块化</em></li>
</ul>
</li>
<li>实现数组的 <strong>随机排序</strong><ul>
<li>考点：<em>JS 基础算法</em></li>
</ul>
</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190715/HysLOVvbjQLN.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190715/YKiIQGW864fb.png?imageslim" alt="mark"></p>
<h1 id="知识体系"><a href="#知识体系" class="headerlink" title="知识体系"></a>知识体系</h1><blockquote>
<p>题目</p>
<p>知识点</p>
<p>解答</p>
</blockquote>
<h2 id="2-1-变量类型和计算"><a href="#2-1-变量类型和计算" class="headerlink" title="2-1 变量类型和计算"></a>2-1 变量类型和计算</h2><blockquote>
<p>2-1 变量类型和计算</p>
<p>题目</p>
<p>知识点</p>
<p>解答</p>
</blockquote>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul>
<li>JS 中使用 <strong>typeof</strong> 能得到的哪些类型？</li>
<li>何时使用 <strong>===</strong> 何时使用 **== **？</li>
<li>JS 中有哪些 <strong>内置函数</strong></li>
<li>JS 变量按照 <strong>存储方式</strong> 分为哪些类型，并描述其特点</li>
<li>如何理解 <strong>JSON</strong></li>
</ul>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>变量类型<ul>
<li>值类型 vs 引用类型</li>
<li>typeof 运算符 详解</li>
</ul>
</li>
<li>变量计算</li>
</ul>
<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><blockquote>
<p>值类型 vs 引用类型</p>
</blockquote>
<h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><blockquote>
<p><strong>值类型 (基本数据类型) 的值是按值访问的。</strong></p>
<p>基本类型的值是<strong>不可变的</strong>，基本类型的比较是它们的<strong>值的比较</strong>，基本类型的变量是存放在 <strong>栈内存（Stack）里的</strong>。</p>
<p><strong>JavaScript</strong> 数据<strong>类型</strong> 值<strong>类型</strong>(<strong>基本类型</strong>)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol (ES6 提供的新的类型)。</p>
<p>6 种基本数据类型:<strong>string</strong>、<strong>number</strong>、<strong>boolean</strong>、<strong>undefined</strong>、<strong>null</strong> 、<strong>Symbol</strong> 。</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190715/Ss70W0DDyFPT.png?imageslim" alt="mark"></p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><blockquote>
<p><strong>引用类型的值是按引用访问的。</strong></p>
<p>引用类型的值是<strong>可变的</strong>，引用类型的比较是<strong>引用的比较</strong>，引用类型的值是保存在 <strong>堆内存（Heap）中的对象（Object）</strong>。</p>
<p>特点：无限制扩展属性</p>
<p><strong>3 种</strong> 主要引用类型：对象（<strong>Object</strong>）、数组（<strong>Array</strong>）、函数（<strong>Function</strong>）</p>
<p>细分的话，有：<code>Object 类型</code>、<code>Array 类型</code>、<code>Date 类型</code>、<code>RegExp 类型</code>、<code>Function 类型</code> 等。</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190715/znhFw1Srcm3D.png?imageslim" alt="mark"></p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><blockquote>
<p><strong>值类型(基本类型) **+ **引用数据类型</strong></p>
<p><u>7 种数据类型</u>：<strong>number</strong>、<strong>string</strong>、<strong>boolean</strong>、<strong>undefined</strong>、<strong>null</strong>、<strong>Symbol</strong> 、<strong>Object (Object、Array、Function)</strong> 。</p>
</blockquote>
<h4 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h4><blockquote>
<p><strong>7</strong> 种类型：<strong>undefined</strong>、<strong>string</strong>、<strong>number</strong>、<strong>boolean</strong>、<strong>object</strong>、<strong>function</strong> 、<strong>symbol</strong>（ES6 提供的新的类型）</p>
<p>注意：typeof <strong>null</strong> // object</p>
<p>typeof 运算符 <strong>只能</strong> 区分 <strong>值类型</strong> 的 类型，对于引用类型的 <strong>对象</strong>、<strong>数组</strong> <strong>区分不出来</strong> 。</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190715/k3tYgoHSpYgy.png?imageslim" alt="mark"></p>
<h3 id="变量计算"><a href="#变量计算" class="headerlink" title="变量计算"></a>变量计算</h3><blockquote>
<p>这个主要针对值类型- 强制类型转换</p>
</blockquote>
<p><strong>4 种强制类型转换：</strong></p>
<ul>
<li>字符串拼接</li>
<li>== 运算符</li>
<li>if 语句</li>
<li>逻辑运算</li>
</ul>
<h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p><img src="http://static.zxinc520.com/blog/20190715/WBxaMX9CiLmz.png?imageslim" alt="mark"></p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="== 运算符"></a>== 运算符</h4><p><img src="http://static.zxinc520.com/blog/20190715/PTp1mF5ulTVw.png?imageslim" alt="mark"></p>
<h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><blockquote>
<p>if 语句</p>
<p><u>false 情况</u>：<strong>0</strong>、<strong>NaN</strong>、**’&lt;空字符串&gt;’<strong>、</strong>null<strong>、</strong>undefine** 、<strong>false</strong></p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190715/C387EiaoakPe.png?imageslim" alt="mark"></p>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p><img src="http://static.zxinc520.com/blog/20190715/4sGRvRvO2x65.png?imageslim" alt="mark"></p>
<h4 id="何时使用-和"><a href="#何时使用-和" class="headerlink" title="何时使用 === 和 =="></a>何时使用 === 和 ==</h4><blockquote>
<p>何时使用 === 和 ==？</p>
<p>解答：参考 jQuery 源码中推荐的写法，除了<strong>判断对象属性是否为空</strong> 和 <strong>看是否函数的参数为空 ** 的情况 ，其余的都用 **===</strong> 。</p>
<p><code>==</code> : 只进行值的比较</p>
<p><code>===</code> : 不仅进行值得比较，还要进行数据类型的比较</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190715/dfHpCgG4HQNR.png?imageslim" alt="mark"></p>
<h4 id="JS-中的内置函数"><a href="#JS-中的内置函数" class="headerlink" title="JS 中的内置函数"></a>JS 中的内置函数</h4><blockquote>
<p>JS 中的内置函数的作用</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190715/BDtLCAEhGEUX.png?imageslim" alt="mark"></p>
<h4 id="JS-按存储方式区分变量类型"><a href="#JS-按存储方式区分变量类型" class="headerlink" title="JS 按存储方式区分变量类型"></a>JS 按存储方式区分变量类型</h4><blockquote>
<p><a href="https://segmentfault.com/a/1190000006752076">参考 1</a></p>
<p><a href="https://www.cnblogs.com/leiting/p/8081413.html">参考 2</a></p>
<p>基本类型的值是不可变的</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190715/0cbg9UtuHTED.png?imageslim" alt="mark"></p>
<h4 id="如何理解-JSON"><a href="#如何理解-JSON" class="headerlink" title="如何理解 JSON"></a>如何理解 JSON</h4><blockquote>
<p>JS 内置对象，Math 也是内置对象</p>
<p>注意：JSON 既是一个 JS <strong>内置对象</strong>，也是一种 <strong>数据格式</strong>。</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190715/5bkwAGYcMzH8.png?imageslim" alt="mark"></p>
<h2 id="2-2-原型和原型链"><a href="#2-2-原型和原型链" class="headerlink" title="2-2 原型和原型链"></a>2-2 原型和原型链</h2><blockquote>
<p>2-2 原型和原型链</p>
<p>题目</p>
<p>知识点</p>
<p>解答</p>
</blockquote>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><ul>
<li>如何准确判断一个变量是 <strong>数组类型</strong></li>
<li>写一个原型链继承的例子</li>
<li>描述 new 一个对象的过程</li>
<li>zepto (或其他框架) 源码中如何使用原型链</li>
</ul>
<h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>构造函数</li>
<li>构造函数-扩展</li>
<li>原型规则和示例</li>
<li>原型链</li>
<li>instanceof</li>
</ul>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><blockquote>
<p>函数名 习惯 <strong>第一个字母大写</strong>（ 高级程序员规范）</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190715/aYlOy0sAIxjg.png?imageslim" alt="mark"></p>
<h4 id="构造函数扩展"><a href="#构造函数扩展" class="headerlink" title="构造函数扩展"></a>构造函数扩展</h4><blockquote>
<p>构造函数扩展</p>
<p>函数扩展 —- <strong>语法糖</strong></p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190715/KAiPkbgM6g8k.png?imageslim" alt="mark"></p>
<h4 id="5-条原型规则和示例"><a href="#5-条原型规则和示例" class="headerlink" title="5 条原型规则和示例"></a>5 条原型规则和示例</h4><blockquote>
<p>5 条原型规则</p>
<p><strong>原型规则</strong> 是学习 <strong>原型链</strong> 的基础</p>
</blockquote>
<p><strong>5 条原型规则 ：</strong></p>
<ol>
<li><p>所有的 <strong>引用类型</strong> (对象，数组，函数)，都具有对象特性，即可 <strong>自由扩展</strong> 属性（除了 null 以外）。</p>
</li>
<li><p>所有的 <strong>引用类型</strong> (对象，数组，函数)，都有一个<code>__proto__</code> （ <em>隐式原型</em> ）属性，属性值都是一个普通对象。</p>
<p><img src="http://static.zxinc520.com/blog/20190715/i237crTwXpRw.png?imageslim" alt="mark"></p>
</li>
<li><p>所有的函数都有一个<code>prototype</code> （ <em>显示原型</em> ）属性，属性值是一个普通对象。</p>
</li>
<li><p>所有的引用类型(对象，数组，函数)，<code>__proto__</code>属性值指向它的构造函数的<code>prototype</code>属性值。</p>
<p><img src="http://static.zxinc520.com/blog/20190715/gbOkNmykomux.png?imageslim" alt="mark"></p>
</li>
<li><p>当试图得到一个引用类型的某个属性时，如果这个对象本身没有这个属性，那么会去它的<code>__proto__</code>(即它的构造函数的<code>prototype</code>)中去找。</p>
</li>
</ol>
<p><strong>示例</strong> ：</p>
<p><img src="http://static.zxinc520.com/blog/20190715/CKA2EOYdkSQ5.png?imageslim" alt="mark"></p>
<p><strong>循环自身的属性：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190715/kAsCaFM5fgCq.png?imageslim" alt="mark"></p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><blockquote>
<p>这种搜索的轨迹,形似一条长链, 又因 prototype 在这个游戏规则中充当链接的作用,于是我们把这种实例与原型的链条称作 <strong>原型链</strong></p>
<p><a href="https://juejin.im/post/58f94c9bb123db411953691b">参考</a></p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190716/zjK7G9Pwib6K.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190716/hyX26borV0mF.png?imageslim" alt="mark"></p>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><blockquote>
<p>用于 判断 <strong>引用类型</strong> 属于哪个 构造函数的方法</p>
<p>**instanceof 运算符 ** 用于测试构造函数的 prototype 属性是否出现在对象的原型链中的任何位置</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof">参看 MDN</a></p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190716/mHVNeyIgfsSE.png?imageslim" alt="mark"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">make, model, year</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.make = make;</span><br><span class="line">  <span class="built_in">this</span>.model = model;</span><br><span class="line">  <span class="built_in">this</span>.year = year;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> auto = <span class="keyword">new</span> Car(<span class="string">&quot;Honda&quot;</span>, <span class="string">&quot;Accord&quot;</span>, <span class="number">1998</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(auto <span class="keyword">instanceof</span> Car); <span class="comment">//  true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(auto <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><ul>
<li><p>如何准确判断一个变量是 <strong>数组类型</strong></p>
<ul>
<li>arr instanceof Arrar</li>
</ul>
</li>
<li><p>写一个原型链继承的例子、</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Elem</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.elem = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Elem.prototype.html = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elem = <span class="built_in">this</span>.elem;</span><br><span class="line">  <span class="keyword">if</span> (val) &#123;</span><br><span class="line">    elem.innerHTML = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">//链式操作</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> elem.innerText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Elem.prototype.on = <span class="function"><span class="keyword">function</span> (<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elem = <span class="built_in">this</span>.elem;</span><br><span class="line">  elem.addEventListener(type, fn);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div1 = <span class="keyword">new</span> Elem(<span class="string">&quot;div1&quot;</span>);</span><br><span class="line">div1.html(<span class="string">&quot;&lt;p&gt;hello world&lt;/p&gt;&quot;</span>).on(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;clicked&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>描述 new 一个对象的过程</p>
<p><img src="http://static.zxinc520.com/blog/20190716/fEURg05c9KBT.png?imageslim" alt="mark"></p>
</li>
<li><p>zepto (或其他框架) 源码中如何使用原型链</p>
<p><img src="http://static.zxinc520.com/blog/20190716/6vDDJLlWz5AQ.png?imageslim" alt="mark"></p>
</li>
</ul>
<h2 id="2-3-函数声明和函数表达式"><a href="#2-3-函数声明和函数表达式" class="headerlink" title="2-3 函数声明和函数表达式"></a>2-3 函数声明和函数表达式</h2><blockquote>
<p>函数声明和函数表达式</p>
</blockquote>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn(); <span class="comment">//执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><blockquote>
<p>把 var 定义的变量提前：相当于：先定义 <strong>var fn</strong> — &gt; 然后执行 <strong>fn()</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn() <span class="comment">// TypeError: fn is not a function</span></span><br><span class="line"><span class="keyword">var</span> fn=<span class="function"><span class="keyword">function</span>（）</span>&#123;</span><br><span class="line">    <span class="comment">// 表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>相关的例子（函数执行的顺序）：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn(<span class="string">&quot;zhouchen&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  age = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name, age);</span><br><span class="line">  <span class="keyword">var</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output：zhouchen 20</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn(<span class="string">&quot;zhouchen&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// 参数的集合</span></span><br><span class="line">  age = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name, age);</span><br><span class="line">  <span class="keyword">var</span> age;</span><br><span class="line"></span><br><span class="line">  bar(<span class="number">100</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    &#123; &#x27;0&#x27;: &#x27;zhouchen&#x27; &#125;</span></span><br><span class="line"><span class="comment">    zhouchen 20</span></span><br><span class="line"><span class="comment">    100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-作用域和闭包"><a href="#2-4-作用域和闭包" class="headerlink" title="2-4 作用域和闭包"></a>2-4 作用域和闭包</h2><blockquote>
<p>作用域和闭包</p>
<p>题目</p>
<p>知识点</p>
<p>解答</p>
</blockquote>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><ul>
<li>说一下对变量提升的理解</li>
<li>说明 this 几种 不同的使用场景</li>
<li>创建 10 个 a 标签，点击的时候弹出来对应的序号</li>
<li>如何理解作用域</li>
<li>实际开发中闭包的应用</li>
</ul>
<h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li><p>执行上下文</p>
</li>
<li><p>this</p>
</li>
<li><p>作用域</p>
</li>
<li><p>作用域链</p>
</li>
<li><p>闭包</p>
</li>
</ul>
<h4 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h4><blockquote>
<p>执行上下文</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190716/slpXIRmFPFUC.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190716/yGYEzQ0mBi3H.png?imageslim" alt="mark"></p>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><blockquote>
<p>this 要在 <strong>执行时</strong> 才能确定值，<strong>定义时</strong> 无法确认</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190716/y7uMvda2zozx.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190716/X4ErfYyomFle.png?imageslim" alt="mark"></p>
<h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><blockquote>
<p>任何一对花括号中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。</p>
<p><strong>JS</strong> 并 <strong>不支持 块级作用域</strong>，它<strong>只支持 函数作用域</strong> ，<u>而且在一个函数中的<strong>任何位置定义的变量</strong> 在该函数中的 <strong>任何地方都是可见的</strong> 。</u></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;zhouchen&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// zhouchen</span></span><br></pre></td></tr></table></figure>

<h4 id="链式作用域"><a href="#链式作用域" class="headerlink" title="链式作用域"></a>链式作用域</h4><blockquote>
<p><strong>如何从外部读取局部变量？</strong></p>
<p>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</p>
<p>那就是在函数的内部，再定义一个函数。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(n); <span class="comment">// 999</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，函数 f2 就被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来就不行，f2 内部的局部变量，对 f1 就是不可见的。这就是 Javascript 语言特有的 “<strong>链式作用域” 结构</strong>（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><blockquote>
<p>上一节代码中的 f2 函数，就是闭包。</p>
<p>简单来说：闭包就是 <strong>能够读取其他函数内部变量的函数</strong>。</p>
<p>由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 <strong>定义在一个函数内部的函数</strong> 。</p>
<p>所以，在本质上，<u>闭包就是将函数内部和函数外部连接起来的一座桥梁</u>。</p>
<p><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">参考阮一峰的网络日志 </a></p>
</blockquote>
<h4 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h4><blockquote>
<p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
</blockquote>
<h4 id="实际开发中闭包的应用"><a href="#实际开发中闭包的应用" class="headerlink" title="实际开发中闭包的应用"></a>实际开发中闭包的应用</h4><blockquote>
<p>实际开发中闭包的应用</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190716/oAEdrQVxx55a.png?imageslim" alt="mark"></p>
<h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><ul>
<li><p>说一下对变量提升的理解</p>
<ul>
<li>变量定义</li>
<li>函数声明 （ 注意和 函数表达式 的区别）</li>
</ul>
</li>
<li><p>说明 this 几种 不同的使用场景</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_40387601/article/details/80313884">参考 1</a></li>
<li><a href="https://blog.csdn.net/sinat_32067081/article/details/53047149">参考 2</a></li>
</ul>
</li>
<li><p>创建 10 个 a 标签，点击的时候弹出来对应的序号</p>
<p><img src="http://static.zxinc520.com/blog/20190716/jpCryHpWtFmQ.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190716/JOON77hWUAPT.png?imageslim" alt="mark"></p>
</li>
<li><p>如何理解作用域</p>
<ul>
<li>自由变量</li>
<li>作用域连，即自由变量的查找</li>
<li>闭包的两个场景</li>
</ul>
</li>
<li><p>实际开发中闭包的应用</p>
<p><img src="http://static.zxinc520.com/blog/20190716/DOiHXt0yUzLP.png?imageslim" alt="mark"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
        <category>JS 三座大山</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-Web-API</title>
    <url>/2019/08/04/JS-Web-API/</url>
    <content><![CDATA[<h1 id="JS-Web-API"><a href="#JS-Web-API" class="headerlink" title="JS-Web-API"></a>JS-Web-API</h1><blockquote>
<p>前端 JS 基础面试技巧 - - <strong>JS-Web-API 上</strong></p>
<p>讲解 JS 在浏览器中具体应用的面试题。包括 <strong>DOM 操作</strong>，<strong>BOM 操作</strong> ，<strong>事件绑定</strong>，<strong>ajax</strong> 和 <strong>存储</strong> ，这些类别的题目。</p>
</blockquote>
<h2 id="从基础知识到-JS-Web-API"><a href="#从基础知识到-JS-Web-API" class="headerlink" title="从基础知识到 JS-Web-API"></a>从基础知识到 JS-Web-API</h2><blockquote>
<p>从基础知识 <strong>过渡</strong> 到 JS-Web-API</p>
</blockquote>
<ul>
<li>回顾 JS 基础知识</li>
<li>JS-Web-API</li>
<li>总结</li>
</ul>
<h3 id="回顾-JS-基础知识"><a href="#回顾-JS-基础知识" class="headerlink" title="回顾 JS 基础知识"></a>回顾 JS 基础知识</h3><blockquote>
<p>特点：表面看来并不能哟用于工作中开发代码</p>
<p>内置函数：Object，Array，Boolean，String ……</p>
<p>内置对象：Math，Json …..</p>
<p>详情请参考：<a href="http://zxinc520.com/lcj/%225d2df2cdda85353d5ca8b83f%22">原型和原型链，闭包和作用域</a> <a href="http://zxinc520.com/lcj/%225d2eeda9d797f0309cf6ab02%22">异步和单线程</a></p>
<ul>
<li>我们连在网页上弹出一句 hello world 都不能实现</li>
</ul>
</blockquote>
<p><strong>知识点</strong> ：</p>
<ul>
<li><p>变量类型和计算</p>
</li>
<li><p>原型和原型链</p>
</li>
<li><p>闭包和作用域</p>
</li>
<li><p>异步和单线程</p>
</li>
<li><p>其它（如日期，Math，各种常用 API）</p>
</li>
<li><p>JS 基础知识：<strong>ECMA 262 标准</strong></p>
</li>
<li><p>JS-Web-API ：<strong>W3C 标准</strong></p>
</li>
</ul>
<h3 id="JS-Web-API-1"><a href="#JS-Web-API-1" class="headerlink" title="JS-Web-API"></a>JS-Web-API</h3><blockquote>
<p>JS-Web-API</p>
</blockquote>
<p><strong>W3C 标准中关于 JS 的规定有</strong> ：</p>
<ul>
<li>DOM 操作</li>
<li>BOM 操作</li>
<li>事件绑定</li>
<li>ajax 请求（包括 http 协议）</li>
<li>储存</li>
</ul>
<p><strong>页面弹框 window.alert(123) ，浏览器需要做：</strong></p>
<ul>
<li>定义一个 window 全局变量 ，对象类型</li>
<li>给它定义一个 alert 属性，属性值是一个函数</li>
</ul>
<p><strong>获取元素 document.getElementById(id)，浏览器需要做：</strong></p>
<ul>
<li>定义一个 document 全局变量 ，对象类型</li>
<li>给它定义一个 getElementById 属性，属性值是一个函数</li>
</ul>
<p><strong>W3C 标准：</strong></p>
<ul>
<li>W3C 标准没有规定任何 JS 基础相关的东西</li>
<li>不管什么变量类型，原型，作用域和异步</li>
<li>只管 定义用于 浏览器中 JS 操作页面的 API 和 全局变量</li>
</ul>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><strong>常说的 JS （浏览器执行的 JS ）包含两部分：</strong></p>
<ul>
<li>JS 基础知识：<strong>ECMA 262 标准</strong></li>
<li>JS-Web-API ：<strong>W3C 标准</strong></li>
</ul>
<h2 id="5-1-BOM-节点操作"><a href="#5-1-BOM-节点操作" class="headerlink" title="5-1 BOM 节点操作"></a>5-1 BOM 节点操作</h2><blockquote>
<p>BOM 操作： <strong>Browser</strong>、<strong>Object</strong>、<strong>Model</strong> （ 浏览器对象模型 ）</p>
<p><strong>BOM 节点操作</strong> 可以理解为：浏览器把拿到的 html 代码，结构化一个 浏览器 能识别并且 js 可操作的一个模型而已 。</p>
<p>javacsript 是通过 <strong>访问 BOM</strong> （Browser Object Model）对象来 <strong>访问、控制、修改</strong> 客户端(浏览器)，由于 BOM 的 window 包含了 document，<strong>window 对象的属性和方法是直接可以使用而且被感知的</strong> ，因此可以直接使用 window 对象的 document 属性，通过 document 属性就可以访问、检索、修改 XHTML 文档内容与结构。因为 document 对象又是 DOM（Document Object Model）模型的根节点。可以说，<strong>BOM 包含了 DOM(对象)</strong> ，浏览器提供出来给予访问的是 BOM 对象，从 BOM 对象再访问到 DOM 对象，从而 js 可以操作浏览器以及浏览器读取到的文档。</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190718/LLToFChkpany.png?imageslim" alt="mark"></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul>
<li>如何检测浏览器的类型</li>
<li>拆解 url 的 各部分</li>
</ul>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>navigator</li>
<li>screen</li>
<li>location</li>
<li>history</li>
</ul>
<h4 id="navigator-amp-screen"><a href="#navigator-amp-screen" class="headerlink" title="navigator &amp; screen"></a>navigator &amp; screen</h4><blockquote>
<p>navigator &amp; screen</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190718/r3iKL9Xukvhh.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190718/HGtIQM9isqCI.png?imageslim" alt="mark"></p>
<h4 id="location-amp-history"><a href="#location-amp-history" class="headerlink" title="location &amp; history"></a>location &amp; history</h4><blockquote>
<h6 id="location-amp-history-1"><a href="#location-amp-history-1" class="headerlink" title="location &amp; history"></a>location &amp; history</h6></blockquote>
<p><img src="http://static.zxinc520.com/blog/20190718/cbYxCVkoLMQu.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190718/wBG2i12YtTmW.png?imageslim" alt="mark"></p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><ul>
<li>如何检测浏览器的类型</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190718/TfK1lJ7IAry5.png?imageslim" alt="mark"></p>
<ul>
<li>拆解 url 的 各部分</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190718/UzzCgHl1fImg.png?imageslim" alt="mark"></p>
<h2 id="5-2-DOM-节点操作"><a href="#5-2-DOM-节点操作" class="headerlink" title="5-2 DOM 节点操作"></a>5-2 DOM 节点操作</h2><blockquote>
<p><strong>DOM 操作的重点：找到节点对节点（元素/文本/属性节点）增删改查</strong></p>
<p><strong>各方法和属性之间的结合操作才会使得 DOM 文档活跃起来</strong></p>
<p><code>注意方法与属性的不同。</code> <strong>注意属性的返回值</strong></p>
<p><strong>注意 javascript 操作样式的可读可写性</strong></p>
<p><a href="https://juejin.im/post/5b16113f5188257d7a49ada7">可参考</a></p>
</blockquote>
<h3 id="DOM-节点操作："><a href="#DOM-节点操作：" class="headerlink" title="DOM 节点操作："></a>DOM 节点操作：</h3><ul>
<li>获取 DOM 节点</li>
<li>prototype</li>
<li>Attribute</li>
</ul>
<h4 id="获取-DOM-节点"><a href="#获取-DOM-节点" class="headerlink" title="获取 DOM 节点"></a>获取 DOM 节点</h4><blockquote>
<p>获取 DOM 节点</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementByClassName(<span class="string">&quot;classname&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;tag&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;#foo &gt; div.bar&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.bar&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190718/TsP71SzkfFU5.png?imageslim" alt="mark"></p>
<h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><blockquote>
<p>prototype</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190718/nehMbgtKQirx.png?imageslim" alt="mark"></p>
<h4 id="property"><a href="#property" class="headerlink" title="property"></a>property</h4><blockquote>
<p>property 只是一个 JS 对象的属性的修改</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190718/3vippb1mnJqF.png?imageslim" alt="mark"></p>
<h4 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h4><blockquote>
<p>Attribute</p>
<p>Attribute 是对 html <strong>标签属性</strong> 的修改 （获取）</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190718/B7FUAdLGXAHz.png?imageslim" alt="mark"></p>
<h3 id="DOM-结构操作"><a href="#DOM-结构操作" class="headerlink" title="DOM 结构操作"></a>DOM 结构操作</h3><blockquote>
<p>DOM 结构操作</p>
</blockquote>
<ul>
<li>新增节点</li>
<li>获取父元素</li>
<li>获取子元素</li>
<li>删除节点</li>
</ul>
<h4 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h4><blockquote>
<p>新增节点</p>
<p>移动已有 的节点</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>) p = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">  p.innerHTML = <span class="string">&#x27;&lt;h3&gt;hello world&lt;/h3&gt;&#x27;</span> div1.appendChild(p) <span class="keyword">var</span> p2 =</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.p2&#x27;</span>) div1.appendChild(p2) <span class="built_in">console</span>.log(div1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190718/e7UMDpPFqB1d.png?imageslim" alt="mark"></p>
<h4 id="获取父元素和子元素"><a href="#获取父元素和子元素" class="headerlink" title="获取父元素和子元素"></a>获取父元素和子元素</h4><blockquote>
<p>获取父元素和子元素</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;div1&quot;</span>&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;p1&quot;</span>&gt;<span class="built_in">this</span> is p1&lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;p2&quot;</span>&gt;<span class="built_in">this</span> is p2&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;div2&quot;</span>&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;p3&quot;</span>&gt;<span class="built_in">this</span> is p3&lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;p4&quot;</span>&gt;<span class="built_in">this</span> is p4&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> div1=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(div1.parentElement)</span><br><span class="line">    <span class="built_in">console</span>.log(div1.childNodes)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(div1.childNodes[<span class="number">0</span>].nodeType)  <span class="comment">//3</span></span><br><span class="line">    <span class="built_in">console</span>.log(div1.childNodes[<span class="number">1</span>].nodeType)  <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">console</span>.log(div1.childNodes[<span class="number">0</span>].nodeName)  <span class="comment">//#text</span></span><br><span class="line">    <span class="built_in">console</span>.log(div1.childNodes[<span class="number">1</span>].nodeName)  <span class="comment">// DIV</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190718/BD4IQWndiCTW.png?imageslim" alt="mark"></p>
<h4 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h4><ul>
<li><p>DOM 是哪种基本的数据结构</p>
<ul>
<li>树</li>
</ul>
</li>
<li><p>DOM 操作的常用 API 有哪些</p>
<ul>
<li>获取 DOM 节点，以及节点的 property 和 Attribute</li>
<li>获取父节点，获取子节点</li>
<li>新增节点，删除节点</li>
</ul>
</li>
<li><p>DOM 节点的 Attribute 和 property 有何区别</p>
<ul>
<li>property 只是一个 JS 对象的属性的修改</li>
<li>Attribute 是对 html 标签属性的修改</li>
</ul>
</li>
</ul>
<h4 id="重点总结"><a href="#重点总结" class="headerlink" title="重点总结"></a>重点总结</h4><ul>
<li>DOM 本质</li>
<li>DOM 节点操作</li>
<li>DOM 结构操作</li>
</ul>
<h2 id="5-3-事件绑定"><a href="#5-3-事件绑定" class="headerlink" title="5-3 事件绑定"></a>5-3 事件绑定</h2><blockquote>
<p>JavaScript 绑定事件的三种方式</p>
</blockquote>
<h3 id="JavaScript-绑定事件的三种方式："><a href="#JavaScript-绑定事件的三种方式：" class="headerlink" title="JavaScript 绑定事件的三种方式："></a>JavaScript 绑定事件的三种方式：</h3><ul>
<li>使用内联</li>
<li>使用<code>.onclick</code>的方式</li>
<li>使用事件监听<code>addEventListener</code>的方式</li>
</ul>
<h4 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(1);&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种方式就是在一个元素上面直接绑定了一个点击<code>onclick</code>事件，此事件为<a href="https://link.juejin.im/?target=https://baike.baidu.com/item/DOM/50288?fr=aladdin">DOM 0 级标准</a>。同时，这个事件的优先级是最高的。</p>
<h4 id="使用对象-事件的形式"><a href="#使用对象-事件的形式" class="headerlink" title="使用对象.事件的形式"></a>使用对象.事件的形式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;按钮&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="keyword">var</span> bt = <span class="built_in">document</span>.getElementsBytagname(<span class="string">&quot;input&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">	bt.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用这种形式也是可以给一个 DOM 元素添加上一个事件。这个也是<a href="https://link.juejin.im/?target=https://baike.baidu.com/item/DOM/50288?fr=aladdin">DOM 0 级标准</a>。</p>
<h4 id="以上的弊端"><a href="#以上的弊端" class="headerlink" title="以上的弊端"></a>以上的弊端</h4><p>以上两种方式都是存在一个弊端的，就是一个元素只能添加一个事件。第一种就不用说了，写在行内就一个属性。至于第二种，有的网友可能会说我可以再写一个，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;按钮&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> bt = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;input&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">    bt.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bt.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190718/u7dGQvDbEuTR.gif" alt="mark"></p>
<p>写是可以这么写。那么我们先来看一看这个写法的意思，这种写法的本质就是在一个对象上添加一个属性，就上面的例子，就是在<code>bt</code>这个对象上添加一个<code>onclick</code>属性。那么，如果在之后的代码中也存在<code>bt.onclcik</code>，只会吧前面的给覆盖了。所以这样的写法也只能添加一个事件。</p>
<p>那么，问题来了。我要给一个元素（DOM 对象）添加两个甚至是多个事件，使用什么呢？此时，就需要使用<code>addEventListener</code>的方式来添加事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;按钮&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="keyword">var</span> bt = <span class="built_in">document</span>.getElementsBytagname(<span class="string">&quot;input&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">	bt.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="number">1</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	bt.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="number">2</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190718/fH7NDlrt0vLr.gif" alt="mark"></p>
<p>上面的方式就可以给一个 DOM 对象绑定一个或者是多个事件。<strong>强烈推荐使用这一种绑定事件的方式</strong>。 使用<code>addEventListener</code>的方式还可以拥有第三个参数。 <a href="https://www.runoob.com/jsref/met-element-addeventlistener.html">参看</a></p>
<p><strong>三个参数</strong> ：</p>
<ol>
<li>事件类型，<strong>不需要</strong>添加上<code>on</code></li>
<li>事件函数</li>
<li>是否捕获（布尔值），默认是<code>false</code>，即不捕获，那就是冒泡。</li>
</ol>
<h3 id="捕获和冒泡"><a href="#捕获和冒泡" class="headerlink" title="捕获和冒泡"></a>捕获和冒泡</h3><h4 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h4><p><img src="http://static.zxinc520.com/blog/20190718/VLE5T5uzApOX.png?imageslim" alt="mark"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">  a</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span>&gt;</span></span><br><span class="line">    b</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">&quot;b&quot;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&quot;c&quot;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 捕获</span></span></span><br><span class="line">  a.addEventListener(</span><br><span class="line"><span class="javascript">    <span class="string">&quot;click&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="string">&quot;b-a&quot;</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="literal">true</span></span></span><br><span class="line">  );</span><br><span class="line">  b.addEventListener(</span><br><span class="line"><span class="javascript">    <span class="string">&quot;click&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="string">&quot;b-b&quot;</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="literal">true</span></span></span><br><span class="line">  );</span><br><span class="line">  c.addEventListener(</span><br><span class="line"><span class="javascript">    <span class="string">&quot;click&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="string">&quot;b-c&quot;</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="literal">true</span></span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">//运行结果：点击c时，上面的代码的执行顺序：b-a，b-b，b-c</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h4><p><img src="http://static.zxinc520.com/blog/20190718/eVyMTBdrppfb.png?imageslim" alt="mark"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;a&quot;</span>&gt;</span><br><span class="line">    a</span><br><span class="line">    &lt;div id=<span class="string">&quot;b&quot;</span>&gt;</span><br><span class="line">        b</span><br><span class="line">        &lt;div id=<span class="string">&quot;c&quot;</span>&gt;c&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> 	<span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">      <span class="comment">// 冒泡</span></span><br><span class="line">    a.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;m-a&quot;</span>)</span><br><span class="line">    &#125;,<span class="literal">false</span>)</span><br><span class="line">    b.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;m-b&quot;</span>)</span><br><span class="line">    &#125;,<span class="literal">false</span>)</span><br><span class="line">    c.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;m-c&quot;</span>)</span><br><span class="line">    &#125;,<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行结果：点击c时，上面的代码的执行顺序：m-c，m-b，m-a</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="停止传播"><a href="#停止传播" class="headerlink" title="停止传播"></a>停止传播</h4><p>使用<code>stopPropagation</code>可以阻止事件的<strong>传播</strong>。不能使用<code>return false</code> ，阻止捕获也是一样，添加之后就不会在继续往下传递了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阻止冒泡</span></span><br><span class="line">c.addEventListener(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;m-c&quot;</span>);</span><br><span class="line">    e.stopPropagation(); <span class="comment">// 此处阻止传播</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时的顺序：b-a,b-c,m-c。不会传递，后面的不会执行了</span></span><br></pre></td></tr></table></figure>

<h4 id="关于使用addEventListener"><a href="#关于使用addEventListener" class="headerlink" title="关于使用addEventListener"></a>关于使用<code>addEventListener</code></h4><p><strong>由于<code>addEventListener</code>单词太长：</strong> 所以封装一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">ele, type, fn</span>) </span>&#123;</span><br><span class="line">  ele.addEventListener(type, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    fn(e);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关于事件代理（委托）"><a href="#关于事件代理（委托）" class="headerlink" title="关于事件代理（委托）"></a>关于事件代理（委托）</h4><p>如果你要给每一个<code>li</code>标签添加一个点击事件，弹出每一个<code>li</code>的索引值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>list-1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>list-2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>list-3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>list-4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>闭包：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oLis = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oLis.length; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    addEvent(oLis[i], <span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      alert(i);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为你的<code>li</code>的个数可能发生改变，如果是这样的话，可能会出一些问题。</p>
<p>事件代理代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oBox = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line"></span><br><span class="line">addEvent(oBox, <span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> target = e.target;</span><br><span class="line">  <span class="comment">// 判断点击的是li</span></span><br><span class="line">  <span class="keyword">if</span> (target.nodeName == <span class="string">&quot;LI&quot;</span>) &#123;</span><br><span class="line">    alert(target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样也是可以的，不过此时的<code>addEvent</code>函数点击的时候就需要在<code>fn</code>里面判断点击的是哪一个标签。为了更好的使用<code>addEvent</code>，我们可以改进一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">ele, type, selector, fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果只有三个参数，那么3,4互换</span></span><br><span class="line">  <span class="keyword">if</span> (fn == <span class="literal">null</span>) &#123;</span><br><span class="line">    fn = selector;</span><br><span class="line">    selector = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ele.addEventListener(type, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target;</span><br><span class="line">    <span class="keyword">if</span> (selector) &#123;</span><br><span class="line">      <span class="comment">//  代理</span></span><br><span class="line">      target = e.target;</span><br><span class="line">      <span class="keyword">if</span> (target.matches(selector)) &#123;</span><br><span class="line">        fn.call(target.e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不代理</span></span><br><span class="line">      fn(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时点击<code>li</code>弹出 innerHTML 就可以这样实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">addEvent(oBox, <span class="string">&quot;click&quot;</span>, <span class="string">&quot;li&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.innerHTML);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><ol>
<li><strong>同时 存在捕获与冒泡时</strong> ，<strong>捕获的优先级是高于冒泡的</strong> 。</li>
<li>没有捕获的时候谁在前面先执行谁</li>
</ol>
<p>如果要取消一个使用<code>addEventListener</code>绑定的事件函数，使用<code>removeEventListener</code>可以移除事件。</p>
<h4 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h4><ul>
<li>编写一个通用的事件监听函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params">elem, type, seletor, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fn == <span class="literal">null</span>) &#123;</span><br><span class="line">    fn = selector;</span><br><span class="line">    seletor = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  elem.addEventListener(type, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target;</span><br><span class="line">    <span class="keyword">if</span> (seletor) &#123;</span><br><span class="line">      target = e.target;</span><br><span class="line">      <span class="keyword">if</span> (target.matches(seletor)) &#123;</span><br><span class="line">        fn.call(target, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fn(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>描述事件冒泡的流程</p>
<ul>
<li>DOM 树形结构</li>
<li>事件冒泡</li>
<li>阻止冒泡</li>
<li>冒泡的应用</li>
</ul>
</li>
<li><p>对于一个无线下拉加载图片的页面，如何给每个图片绑定事件</p>
<ul>
<li>使用代理</li>
<li>知道代理的两个优点</li>
</ul>
</li>
</ul>
<h4 id="重点总结-1"><a href="#重点总结-1" class="headerlink" title="重点总结"></a>重点总结</h4><ul>
<li>通用事件绑定</li>
<li>事件冒泡</li>
<li>代理</li>
</ul>
<h2 id="5-4-Ajax"><a href="#5-4-Ajax" class="headerlink" title="5-4 Ajax"></a>5-4 Ajax</h2><blockquote>
<p>题目</p>
<p>知识点</p>
<p>题目</p>
</blockquote>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><ul>
<li>手动编写一个 ajax，不依赖第三方库</li>
<li>跨域的几种实现方式</li>
</ul>
<h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>XMLHttpRequest</li>
<li>状态码说明</li>
<li>跨域</li>
</ul>
<h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h4><blockquote>
<p>使用 XMLHttpRequest (XHR)对象可以与服务器交互。您可以从 URL 获取数据，而无需让整个的页面刷新。这使得 Web 页面可以只更新页面的局部，而不影响用户的操作。XMLHttpRequest 在 <a href="https://developer.mozilla.org/en-US/docs/AJAX">Ajax</a> 编程中被大量使用</p>
<p>尽管名称如此，XMLHttpRequest 可以用于获取任何类型的数据，而不仅仅是 XML，它还支持 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">HTTP</a>以外的协议(包括文件和 ftp)。</p>
<p>如果您的通信需要从服务器接收事件或消息数据，请考虑通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource"><code>EventSource</code></a>接口使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events">server-sent events</a>。对于 full-duplex 通信， <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSockets</a> 可能是更好的选择。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">可参考</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api&quot;</span>, <span class="literal">false</span>); <span class="comment">//false 使用异步</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//这里是函数异步执行，可参考之前 JS 基础中的异步 模块</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">      alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="IE-兼容性问题"><a href="#IE-兼容性问题" class="headerlink" title="IE 兼容性问题"></a>IE 兼容性问题</h4><blockquote>
<p><a href="https://www.w3cschool.cn/mlb2er/3miu1pxk.html">有意向者可参考</a></p>
</blockquote>
<ul>
<li>IE 低版本使用 ActiveXObject，和 W3C 标准不一样</li>
<li>IE 低版本使用量非常少，很多网站都早已不支持</li>
<li>建议对 IE 低版本的兼容性：<strong>了解即可，无需深究</strong> 。</li>
<li>如果遇到对 IE 低版本要求苛刻的面试，果断放弃</li>
</ul>
<h4 id="readyState-状态码说明"><a href="#readyState-状态码说明" class="headerlink" title="readyState 状态码说明"></a>readyState 状态码说明</h4><blockquote>
<p>readyState 是 XMLHttpRequest 对象的一个属性，用来标识当前 XMLHttpRequest 对象处于什么状态。<br>readyState 总共有 5 个状态值，分别为 0~4，每个值代表了不同的含义</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>：未初始化，还没有调用 send()方法</span><br><span class="line"><span class="number">1</span>：载入，已调用send()方法，XMLHttpRequest对象开始发送请求</span><br><span class="line"><span class="number">2</span>：载入完成，send()方法执行完成，已经接收到全部的相应内容</span><br><span class="line"><span class="number">3</span>：交互，正在解析响应内容</span><br><span class="line"><span class="number">4</span>：完成，响应内容解析完成，可以在客户端调用了</span><br></pre></td></tr></table></figure>

<h4 id="status-状态码说明"><a href="#status-状态码说明" class="headerlink" title="status 状态码说明"></a>status 状态码说明</h4><blockquote>
<p>status 是 XMLHttpRequest 对象的一个属性，表示响应的 HTTP 状态码</p>
<p><a href="https://www.cnblogs.com/liu-fei-fei/p/5618782.html">详细参考</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>xx：信息响应类，表示接收到请求并且继续处理</span><br><span class="line"><span class="number">2</span>xx：处理成功响应类，表示动作被成功接收、理解和接受</span><br><span class="line"><span class="number">3</span>xx：重定向响应类，为了完成指定的动作，必须接受进一步处理</span><br><span class="line"><span class="number">4</span>xx：客户端错误，客户请求包含语法错误或者是不能正确执行</span><br><span class="line"><span class="number">5</span>xx：服务端错误，服务器不能正确执行一个正确的请求</span><br><span class="line"></span><br><span class="line"><span class="number">200</span>——交易成功</span><br><span class="line"><span class="number">404</span>——没有发现文件、查询或URl</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="5-5-跨域"><a href="#5-5-跨域" class="headerlink" title="5-5 跨域"></a>5-5 跨域</h2><blockquote>
<p><strong>定义</strong> ：跨域是指从一个域名的网页去请求另一个域名的资源。比如从<a href="http://www.baidu.com/">www.baidu.com</a> 页面去请求 <a href="http://www.google.com/">www.google.com</a> 的资源。但是一般情况下不能这么做，它是由浏览器的同源策略造成的，是浏览器对<a href="https://link.juejin.im/?target=http://lib.csdn.net/base/javascript">JavaScript</a>施加的安全限制。跨域的严格一点的定义是：只要 协议，域名，端口有任何一个的不同，就被当作是跨域</p>
<p><strong>所谓同源是指，域名，协议，端口均相同。</strong>这里说的 js 跨域是指通过 js 在不同的域之间进行数据传输或通信，比如用 ajax 向一个不同的域请求数据，或者通过 js 获取页面中不同域的框架中(iframe)的数据。</p>
<p>概念：<strong>只要协议、域名、端口有任何一个不同</strong> ，都被当作是不同的域。算作 跨域。</p>
<p><a href="https://segmentfault.com/a/1190000015597029">参考</a></p>
<p>http 默认端口：80</p>
<p>https 默认端口：443</p>
</blockquote>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>说明什么是跨域</li>
<li>JSONP</li>
<li>服务器端设置 http header</li>
</ul>
<h4 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h4><p><strong>跨域是</strong>指一个<strong>域</strong>下的文档或脚本试图去请求另一个<strong>域</strong>下的资源，这里<strong>跨域是</strong>广义的。 其实我们通常所说的<strong>跨域是</strong>狭义的，<strong>是</strong>由浏览器同源策略限制的一类请求场景。</p>
<h4 id="可以跨域的三个标签"><a href="#可以跨域的三个标签" class="headerlink" title="可以跨域的三个标签"></a>可以跨域的三个标签</h4><ul>
<li>&lt;**img src=xxx** &gt; 用于打点统计，统计网站可能是其它域</li>
<li>&lt;**link href=xxxx** &gt; 可以使用 CDN,CDN 也是其它域</li>
<li>&lt;**script src=xxx** &gt; 可以使用 CDN, 可以用于 <strong>JSONP</strong></li>
</ul>
<h4 id="跨域注意事项"><a href="#跨域注意事项" class="headerlink" title="跨域注意事项"></a>跨域注意事项</h4><ul>
<li>所有的跨域请求都必须经过信息提供方允许</li>
<li>如果未经允许即可获取，那是浏览器同源策略出现漏洞</li>
</ul>
<h3 id="JSONP-实现原理"><a href="#JSONP-实现原理" class="headerlink" title="JSONP 实现原理"></a>JSONP 实现原理</h3><blockquote>
<p>jsonp 是一种跨域通信的手段</p>
<p><a href="https://segmentfault.com/a/1190000007665361">参考 1</a> <a href="https://github.com/qianlongo/zepto-analysis/issues/4">参考 2</a></p>
</blockquote>
<p><strong>jsonp 是一种跨域通信的手段，它的原理其实很简单：</strong></p>
<ol>
<li>客户端利用<code>script</code>标签可以跨域请求资源的性质，向网页中动态插入<code>script</code>标签，来向服务端请求数据。</li>
<li>服务端会解析请求的<code>url</code>,至少拿到一个回调函数(比如<code>callback=myCallback</code>)参数,之后将数据放入其中返回给客户端。</li>
<li>当然 jsonp 不同于平常的<code>ajax</code>请求,它仅仅支持 get 类型的方式</li>
</ol>
<h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><ol>
<li><p>设定一个 script 标签</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://jsonp.js?callback=xxx&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>callback 定义了一个函数名，而远程服务端通过调用指定的函数并传入参数来实现传递参数，将<code>fn(response)</code>传递回客户端</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$callback = !<span class="keyword">empty</span>($_GET[<span class="string">&#x27;callback&#x27;</span>]) ? $_GET[<span class="string">&#x27;callback&#x27;</span>] : <span class="string">&#x27;callback&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> $callback.<span class="string">&#x27;(.json_encode($data).)&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端接收到返回的 js 脚本，开始解析和执行<code>fn(response)</code></p>
</li>
</ol>
<h4 id="服务端设置-http-header"><a href="#服务端设置-http-header" class="headerlink" title="服务端设置 http header"></a>服务端设置 http header</h4><ul>
<li>另外一个解决跨域的简洁方法，需要服务器端来做</li>
<li>但是作为交互方，我们必须知道这个方法</li>
<li>是将来解决跨域问题的一个趋势</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190718/YNGAeXPTUx6I.png?imageslim" alt="mark"></p>
<h4 id="重点总结-2"><a href="#重点总结-2" class="headerlink" title="重点总结"></a>重点总结</h4><ul>
<li>XMLHttpRequest</li>
<li>状态码说明</li>
<li>跨域</li>
</ul>
<h2 id="5-6-存储"><a href="#5-6-存储" class="headerlink" title="5-6 存储"></a>5-6 存储</h2><blockquote>
<p>题目</p>
<p>知识点</p>
<p>解答</p>
</blockquote>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><ul>
<li>请描述一下 cookie，sessionStorage 和 localStorage 的区别？</li>
</ul>
<h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>cookie</li>
<li>sessionStorage 和 localStorage</li>
</ul>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><blockquote>
<p><a href="https://juejin.im/post/5b57dba3f265da0fb018741f">可参考</a></p>
</blockquote>
<ul>
<li>本身用于客户端和服务器端通信</li>
<li>但是它有本地储存的功能，于是就被 <strong>借用</strong></li>
<li>使用 document.cookie = … 获取和修改即可</li>
</ul>
<h4 id="cookie-用于储存的缺点"><a href="#cookie-用于储存的缺点" class="headerlink" title="cookie 用于储存的缺点"></a>cookie 用于储存的缺点</h4><ul>
<li><p><strong>储存量太小</strong> ，Cookie`数量和长度的限制。每个 domain 最多只能有 20 条 cookie，每个 cookie 长度不能超过 4KB，否则会被截掉。在当今新的浏览器和客户端设备版本中，支持 8192 字节的 Cookie 大小已愈发常见。</p>
</li>
<li><p>所有 http 请求都带着，会<strong>影响获取资源的效率</strong></p>
</li>
<li><p>用户配置为禁用。有些用户禁用了浏览器或客户端设备接收 Cookie 的能力，因此限制了这一功能</p>
</li>
<li><p>由于在 HTTP 请求中的 cookie 是明文传递的，潜在的安全风险，Cookie 可能会被篡改</p>
</li>
<li><p>有些状态不可能保存在客户端</p>
</li>
<li><p>cookie 会被附加在每个 HTTP 请求中，所以无形中增加了流量</p>
</li>
<li><p>cookie 一般不可跨域使用</p>
</li>
<li><p>没有封装好的 setCookie 和 getCookie 方法，需要开发者自省封装</p>
</li>
</ul>
<h3 id="sessionStorage-和-localStorage"><a href="#sessionStorage-和-localStorage" class="headerlink" title="sessionStorage 和 localStorage"></a>sessionStorage 和 localStorage</h3><ul>
<li>HTML5 专门为储存而设计，最大容量 5M</li>
<li>API 简答易用</li>
<li>localStorage.setItem(key, value); localStorage.getItem(key, value);</li>
</ul>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><p><strong>localStorage</strong> 生命周期是永久，这意味着除非用户显示在浏览器提供的 UI 上清除 localStorage 信息，否则这些信息将永远存在。</p>
<p><strong>sessionStorage</strong> 生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过 sessionStorage 存储的数据也就被清空了。</p>
<p>不同浏览器无法共享 localStorage 或 sessionStorage 中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享 sessionStorage 的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个 iframe 标签且他们属于同源页面，那么他们之间是可以共享 sessionStorage 的。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>iOS safari 隐藏模式下</li>
<li>localStorage.getItem 会报错</li>
<li>建议 统一使用 try-catch 封装</li>
</ul>
<h3 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h3><ul>
<li>请描述一下 cookie，sessionStorage 和 localStorage 的区别？<ul>
<li>容量</li>
<li>是否携带到 ajax 中</li>
<li>API 易用性</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
        <category>JS 三座大山</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>BOM</tag>
        <tag>事件绑定</tag>
        <tag>ajax 请求</tag>
        <tag>储存</tag>
      </tags>
  </entry>
  <entry>
    <title>运行环境</title>
    <url>/2019/07/19/OperationEnvironment/</url>
    <content><![CDATA[<h1 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h1><blockquote>
<p>讲解 JS 代码在浏览器中运行的相关问题，例如 <strong>页面加载和渲染</strong>，<strong>性能优化</strong>，<strong>安全性</strong> ，这些类别的题目。</p>
<p>知识点：</p>
<p>8-1 页面加载过程</p>
<p>8-2 性能优化</p>
</blockquote>
<ul>
<li>浏览器就可以通过访问链接来得到页面内容</li>
<li>通过绘制和渲染，显示出页面的最终的样子</li>
</ul>
<h2 id="整个过程中，我们需要考虑什么问题？"><a href="#整个过程中，我们需要考虑什么问题？" class="headerlink" title="整个过程中，我们需要考虑什么问题？"></a>整个过程中，我们需要考虑什么问题？</h2><h3 id="3-个重点"><a href="#3-个重点" class="headerlink" title="3 个重点"></a>3 个重点</h3><ul>
<li>页面加载过程</li>
<li>性能优化</li>
<li>安全性</li>
</ul>
<h2 id="8-1-页面加载过程"><a href="#8-1-页面加载过程" class="headerlink" title="8-1 页面加载过程"></a>8-1 页面加载过程</h2><blockquote>
<p>题目</p>
<p>知识点</p>
<p>解答</p>
</blockquote>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul>
<li>从输入 url 到得到 html 的详细过程</li>
<li>window.onload 和 DOMContentLoaded 的区别？</li>
</ul>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>加载资源的形式</li>
<li>加载一个资源的过程</li>
<li>浏览器渲染页面的过程</li>
</ul>
<h4 id="加载资源的形式"><a href="#加载资源的形式" class="headerlink" title="加载资源的形式"></a>加载资源的形式</h4><ul>
<li>输入 url （或跳转页面）加载 html</li>
<li>url: <a href="https://www.imooc.com/">https://www.imooc.com/</a></li>
<li>加载 html 中的静态资源</li>
<li>script 标签中资源的加载: &lt;**script src=”/static/jsjquery.js”&gt;&lt;/script** &gt;</li>
</ul>
<h4 id="加载一个资源的过程"><a href="#加载一个资源的过程" class="headerlink" title="加载一个资源的过程"></a>加载一个资源的过程</h4><ol>
<li>浏览器根据 DNS 服务器得到域名的 IP 地址</li>
<li>向这个 IP 的机器发送 http 请求</li>
<li>服务器收到、处理并返回 http 请求</li>
<li>浏览器得到返回内容</li>
</ol>
<h4 id="浏览器渲染页面的过程："><a href="#浏览器渲染页面的过程：" class="headerlink" title="浏览器渲染页面的过程："></a>浏览器渲染页面的过程：</h4><p>1.根据 HTML 结构生成 DOM Tree 2.根据 CSS 生成 CSSOM 3.将 DOM 和 CSSOM 整合形成 RenderTree 4.根据 RenderTree 开始渲染和展示 5.遇到&lt;**script** &gt;时，会执行并阻止渲染。</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li><strong>为何要把 css 放在 head 中？</strong><ul>
<li>css 放在 body 标签尾部时, DOMTree 构建完成之后便开始构建 RenderTree, 并计算布局渲染网页, 等加载解析完 css 之后, 开始构建 CSSOMTree, 并和 DOMTree 重新构建 RenderTree, 重新计算布局渲染网页</li>
<li>css 放在 head 标签中时, 先加载 css, 之后解析 css 构建 CSSOMTree, 于此同时构建 DOMTree, CSSOMTree 和 DOMTree 都构建完毕之后开始构建 RenderTree, 计算布局渲染网页</li>
</ul>
</li>
</ul>
<p>对比两者, css 放在 head 标签中比 css 放在 body 标签尾部少了一次构建 RenderTree, 一次计算布局和一次渲染网页, 因此性能会更好; 并且 css 放在 body 标签尾部时会在网页中短暂出现”裸奔”的 HTML, 这不利于用户体验</p>
<hr>
<ul>
<li><p><strong>为何要把 js 放在 body 最下面？</strong> ，<u>既然 Dom 树完全生成好后才能显示“没有图片的首屏”，浏览器又必须读完全部 HTML 才能生成完整的 Dom 树，script 标签不放在 body 底部是不是也一样？</u></p>
<ul>
<li>—— JS 放在底部可以保证让浏览器优先渲染完现有的 HTML 内容，让用户先看到内容，体验好。另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。 <a href="https://segmentfault.com/a/1190000004292479">JS 一定要放在 Body 的最底部么？聊聊浏览器的渲染机制</a></li>
</ul>
</li>
</ul>
<h4 id="window-onload-和-DOMContentLoaded"><a href="#window-onload-和-DOMContentLoaded" class="headerlink" title="window.onload 和 DOMContentLoaded"></a>window.onload 和 DOMContentLoaded</h4><p><img src="http://static.zxinc520.com/blog/20190719/sSK9VYP2CSRd.png?imageslim" alt="mark"></p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><ul>
<li><p>从输入 url 到得到 html 的详细过程</p>
<ul>
<li>浏览器根据 DNS 服务器得到域名的 IP 地址</li>
<li>向这个 IP 的机器发送 http 请求</li>
<li>服务器收到、处理并返回 http 请求</li>
<li>浏览器得到返回内容</li>
</ul>
</li>
<li><p>window.onload 和 DOMContentLoaded 的区别？</p>
<ul>
<li>window.onload： 页面的全部资源加载完才会执行，包括图片、视频等</li>
<li>DOMContentLoaded： DOM 渲染完即可执行，此时图片、视频还没有加载完</li>
</ul>
</li>
</ul>
<h2 id="8-2-性能优化"><a href="#8-2-性能优化" class="headerlink" title="8-2 性能优化"></a>8-2 性能优化</h2><blockquote>
<p><a href="https://juejin.im/post/5a966bd16fb9a0635172a50a">2018 前端性能优化清单</a></p>
<p>关于 <strong>性能优化</strong> 是个大的面，这篇文章主要涉及到 <strong>前端</strong> 的几个点，如 <strong>前端性能优化</strong> 的流程、常见技术手段、工具等。</p>
<p>提及 <strong>前端性能优化</strong> ，大家应该都会想到 <strong>雅虎军规</strong>，本文会结合 <strong>雅虎军规</strong> 融入自己的了解知识，进行的总结和梳理 😜</p>
</blockquote>
<h3 id="我们先来看看-👀-雅虎军规-的-35-条-："><a href="#我们先来看看-👀-雅虎军规-的-35-条-：" class="headerlink" title="我们先来看看 👀 雅虎军规 的 35 条 ："></a>我们先来看看 👀 雅虎军规 的 35 条 ：</h3><ul>
<li>尽量减少 HTTP 请求个数——须权衡</li>
<li>使用 <strong>CDN</strong>（内容分发网络）</li>
<li>为文件头指定 Expires 或 Cache-Control ，使内容具有缓存性。</li>
<li>避免空的 src 和 href</li>
<li>使用 gzip 压缩内容</li>
<li>把 CSS 放到顶部</li>
<li>把 JS 放到底部</li>
<li>避免使用 CSS 表达式</li>
<li>将 CSS 和 JS 放到外部文件中</li>
<li>减少 DNS 查找次数</li>
<li>精简 CSS 和 JS</li>
<li>避免跳转</li>
<li>剔除重复的 JS 和 CSS</li>
<li>配置 ETags</li>
<li>使 AJAX 可缓存</li>
<li>尽早刷新输出缓冲</li>
<li>使用 GET 来完成 AJAX 请求</li>
<li>延迟加载</li>
<li>预加载</li>
<li>减少 DOM 元素个数</li>
<li>根据域名划分页面内容</li>
<li>尽量减少 iframe 的个数</li>
<li>避免 404</li>
<li>减少 Cookie 的大小</li>
<li>使用无 cookie 的域</li>
<li>减少 DOM 访问</li>
<li>开发智能事件处理程序</li>
<li>用 代替 @import</li>
<li>避免使用滤镜</li>
<li>优化图像</li>
<li>优化 CSS Spirite</li>
<li>不要在 HTML 中缩放图像——须权衡</li>
<li>favicon.ico 要小而且可缓存</li>
<li>保持单个内容小于 25K</li>
<li>打包组件成复合文本</li>
</ul>
<hr>
<ul>
<li>这本身就是一个综合性的问题</li>
<li>没有标准答案，如果要非常全面，能写一本书</li>
<li>只关注核心点，针对面试</li>
</ul>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul>
<li>多使用内存、缓存或其他方法</li>
<li>减少 CPU 计算、减少网络请求</li>
</ul>
<h3 id="从哪里入手"><a href="#从哪里入手" class="headerlink" title="从哪里入手"></a>从哪里入手</h3><ul>
<li>加载页面和静态资源</li>
<li>页面渲染</li>
</ul>
<h3 id="加载资源优化"><a href="#加载资源优化" class="headerlink" title="加载资源优化"></a>加载资源优化</h3><ul>
<li>静态资源的压缩合并</li>
<li>静态资源缓存</li>
<li>使用 CDN 让资源加载更快</li>
<li>使用 SSR 后端渲染，数据直接输出到 HTML 中</li>
</ul>
<h3 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h3><ul>
<li>CSS 放前面 ，JS 放后面</li>
<li>懒加载 （图片懒加载、下拉加载更多）</li>
<li>减少 DOM 查询 ，对 DOM 查询做缓存</li>
<li>减少 DOM 操作，多个操作尽量合并 在一起执行</li>
<li>事件节流</li>
<li>尽早执行操作 （如 DOMContentLoaded）</li>
</ul>
<h3 id="优化示例"><a href="#优化示例" class="headerlink" title="优化示例"></a>优化示例</h3><blockquote>
<p>展示几个优化示例</p>
</blockquote>
<h4 id="资源合并"><a href="#资源合并" class="headerlink" title="资源合并"></a>资源合并</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;a.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;b.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;c.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源合并</span></span><br><span class="line">&lt;script src=<span class="string">&quot;abc.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul>
<li>通过连接名字控制缓存</li>
<li>&lt;**script src=”adc_1.js”&gt;&lt;/script** &gt;</li>
<li>只有内容改变的时候，连接名称才会改变</li>
<li>&lt;**script src=”adc_2.js”&gt;&lt;/script** &gt;</li>
</ul>
<h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><blockquote>
<p>2 个在线的好用的 CDN 网站：</p>
<p><a href="https://www.bootcdn.cn/">https://www.bootcdn.cn/</a></p>
<p><a href="https://cdnjs.com/">https://cdnjs.com/</a></p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190719/wqVaD4amGTnT.png?imageslim" alt="mark"></p>
<h4 id="使用-SSR-后端渲染"><a href="#使用-SSR-后端渲染" class="headerlink" title="使用 SSR 后端渲染"></a>使用 SSR 后端渲染</h4><ul>
<li>现在 Vue React 提出了这样的概念</li>
<li>其实 jsp php asp 都属于后端渲染</li>
</ul>
<h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p><img src="http://static.zxinc520.com/blog/20190719/dNHq1Xfe0Ep5.png?imageslim" alt="mark"></p>
<h4 id="缓存-DOM-查询"><a href="#缓存-DOM-查询" class="headerlink" title="缓存 DOM 查询"></a>缓存 DOM 查询</h4><p><img src="http://static.zxinc520.com/blog/20190719/4xj98cKCzJh9.png?imageslim" alt="mark"></p>
<h4 id="合并-DOM-插入"><a href="#合并-DOM-插入" class="headerlink" title="合并 DOM 插入"></a>合并 DOM 插入</h4><p><img src="http://static.zxinc520.com/blog/20190719/S7Fvwi6QNApC.png?imageslim" alt="mark"></p>
<h4 id="事件节流"><a href="#事件节流" class="headerlink" title="事件节流"></a>事件节流</h4><p><img src="http://static.zxinc520.com/blog/20190719/vHApgiVQan6S.png?imageslim" alt="mark"></p>
<h4 id="尽早操作"><a href="#尽早操作" class="headerlink" title="尽早操作"></a>尽早操作</h4><p><img src="http://static.zxinc520.com/blog/20190719/q8SS7PiiaKI4.png?imageslim" alt="mark"></p>
]]></content>
      <categories>
        <category>JS</category>
        <category>运行环境</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>加载过程</tag>
      </tags>
  </entry>
  <entry>
    <title>开发环境</title>
    <url>/2019/07/19/DevelopmentEnvironment/</url>
    <content><![CDATA[<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><blockquote>
<p>讲解在面试过程中，面试官可能会问及的前端开发环境的问题，例如 <strong>IDE</strong> ，<strong>Git</strong> ，<strong>模块化</strong> ，<strong>打包工具</strong> ，<strong>上线流程</strong> ，这些类别的题目。</p>
<p>知识点：</p>
<p>7-1 IDE</p>
<p>7-2 Git</p>
<p>7-3 模块化</p>
<p>7-4 构建工具</p>
<p>7-5 上线和回滚</p>
</blockquote>
<h3 id="关于开发环境"><a href="#关于开发环境" class="headerlink" title="关于开发环境"></a>关于开发环境</h3><ul>
<li>面试官想通过开发环境了解面试者的经验</li>
<li>开发环境，最能体现工作产出的效率</li>
<li>会以聊天的形式为主，而不是出具体的问题</li>
</ul>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><blockquote>
<p><strong>IDE</strong> ，<strong>Git</strong> ，<strong>JS 模块化</strong> ，<strong>打包工具</strong> ，<strong>上线流程</strong> ，</p>
</blockquote>
<ul>
<li>IDE （ 写代码的效率 ）</li>
<li>git （ 代码版本管理 ，多人协作开发 ）</li>
<li>JS 模块化</li>
<li>打包工具</li>
<li>上线回滚的流程</li>
</ul>
<h2 id="7-1-IDE"><a href="#7-1-IDE" class="headerlink" title="7-1 IDE"></a>7-1 IDE</h2><ul>
<li>webstorm （ 我平常基本用的就是 <strong>webstorm</strong> ）</li>
<li>sublime</li>
<li>vscode</li>
<li>atom</li>
<li>插件 插件 插件 ！！！</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190719/MxVs8IUJKDhO.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190719/QNC5aBgIVByU.png?imageslim" alt="mark"></p>
<p><strong>注意：</strong></p>
<ul>
<li>千万不要说你使用 Dreamweaver 或者 notpad ++</li>
<li>不做 .net 也不要用 Visual Studio</li>
<li>不做 java 也不要用 eclipse</li>
</ul>
<h2 id="7-2-Git"><a href="#7-2-Git" class="headerlink" title="7-2 Git"></a>7-2 Git</h2><blockquote>
<p>Git 详细介绍：可参考的的博客：<a href="http://zxinc520.com/lcj/%225d285a027b8c9f7d8dc4f627%22">Git 篇</a></p>
</blockquote>
<ul>
<li>正式项目都需要代码版本管理</li>
<li>大型项目需要多人协作开发</li>
<li>Git 和 linux 是一个作者</li>
</ul>
<h2 id="7-3-模块化"><a href="#7-3-模块化" class="headerlink" title="7-3 模块化"></a>7-3 模块化</h2><blockquote>
<p>模块化编程就是通过组合一些<strong>相对独立可复用的模块</strong>来进行功能的实现，其最核心的两部分是<strong>定义模块</strong>和<strong>引入模块</strong>；</p>
<ul>
<li>定义模块时，每个模块内部的执行逻辑是不被外部感知的，只是导出（暴露）出部分方法和数据；</li>
<li>引入模块时，同步 / 异步去加载待引入的代码，执行并获取到其暴露的方法和数据；</li>
</ul>
<p><strong>模块化的发展情况</strong> ：无模块化–&gt;CommonJS 规范–&gt;AMD 规范–&gt;CMD 规范–&gt;ES6 模块化</p>
<p><a href="https://juejin.im/post/5b6c222a6fb9a04fde5af4ee">Javascript 模块化指北</a></p>
<p><a href="https://juejin.im/post/5b4420e7f265da0f4b7a7b27">这一次，我要弄懂 javascript 的模块化</a></p>
</blockquote>
<h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>不使用模块化的情况</li>
<li>使用模块化</li>
<li>AMD</li>
<li>CommonJS</li>
</ul>
<h4 id="无模块化"><a href="#无模块化" class="headerlink" title="无模块化"></a>无模块化</h4><p>script 标签引入 js 文件，相互罗列，但是被依赖的放在前面，否则使用就会报错。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;jquery.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=<span class="string">&quot;jquery_scroller.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=<span class="string">&quot;main.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=<span class="string">&quot;other1.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=<span class="string">&quot;other2.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=<span class="string">&quot;other3.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​ 即简单的将所有的 js 文件统统放在一起。但是这些文件的顺序还不能出错，比如 jquery 需要先引入，才能引入 jquery 插件，才能在其他的文件中使用 jquery。缺点很明显：</p>
<ul>
<li>污染全局作用域</li>
<li>维护成本高</li>
<li>依赖关系不明显</li>
</ul>
<h3 id="AMD-规范"><a href="#AMD-规范" class="headerlink" title="AMD 规范"></a>AMD 规范</h3><blockquote>
<p>异步模块定义（<strong>AMD</strong>）API 指定了一种定义模块的机制，以便可以异步加载模块及其依赖项。这特别适用于浏览器环境，其中模块的同步加载会导致性能，可用性，调试和跨域访问问题。</p>
</blockquote>
<ul>
<li>require.js <a href="https://requirejs.org/">https://requirejs.org/</a></li>
<li>全局 define 函数</li>
<li>全局 require 函数</li>
<li>依赖 JS 会自动、异步加载</li>
</ul>
<p>AMD 标准中，定义了下面三个 API：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</span><br><span class="line">define(id, [depends], callback);</span><br><span class="line"><span class="built_in">require</span>.config();</span><br></pre></td></tr></table></figure>

<p>即通过 define 来<strong>定义</strong>一个模块，然后使用 require 来<strong>加载</strong>一个模块, 使用 require.config()指定引用路径。</p>
<h4 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script</span><br><span class="line">  src=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js&quot;</span></span><br><span class="line">  data-main=<span class="string">&quot;./main.js&quot;</span></span><br><span class="line">&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><em>main.js:</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define([<span class="string">&quot;./a.js&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  a.printDate(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><em>a.js:</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define([<span class="string">&quot;./a-util.js&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">aUtil</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = &#123;</span><br><span class="line">    printDate: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(aUtil.aGetFormatDate(data));</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><em>a-util.js:</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define([<span class="string">&quot;./util.js&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">util</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> aUtil = &#123;</span><br><span class="line">    aGetFormatDate: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> util.getFormatDate(data, <span class="number">2</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> aUtil;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><em>util.js:</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> util = &#123;</span><br><span class="line">    getFormatDate: <span class="function"><span class="keyword">function</span> (<span class="params">data, type</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;2019-07-19&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;2019年6月20日&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> util;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190719/tVkLYFlEzrtH.png?imageslim" alt="mark"></p>
<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><blockquote>
<p>2009 年 ry 发布 Node.js 的第一个版本，CommonJS 作为其中最核心的特性之一，适用于服务端下的场景；历年来的考察和时间的洗礼，以及前端工程化对其的充分支持，CommonJS 被广泛运用于 Node.js 和浏览器；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Core Module</span></span><br><span class="line"><span class="keyword">const</span> cp = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>);</span><br><span class="line"><span class="comment">// Npm Module</span></span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&quot;axios&quot;</span>);</span><br><span class="line"><span class="comment">// Custom Module</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&quot;./foo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; axios &#125;;</span><br><span class="line"><span class="built_in">exports</span>.foo = foo;</span><br></pre></td></tr></table></figure>

<p><strong>规范</strong></p>
<ul>
<li>module (Object): 模块本身</li>
<li>exports (*): 模块的导出部分，即暴露出来的内容</li>
<li>require (Function): 加载模块的函数，获得目标模块的导出值（基础类型为复制，引用类型为浅拷贝），可以加载内置模块、npm 模块和自定义模块。</li>
</ul>
<p><strong>nodejs 模块化规范，现在被大量用前端，原因</strong> ：</p>
<ul>
<li>前端开发依赖的插件课库，都可以从 npm 中获取</li>
<li>构建工具的高度自动化，使得使用 npm 的成本非常低</li>
<li>CommonJS 不会异步加载 JS ，而是同步一次性加载出来</li>
</ul>
<h4 id="使用-CommonJS"><a href="#使用-CommonJS" class="headerlink" title="使用 CommonJS"></a>使用 CommonJS</h4><blockquote>
<p><strong>module</strong> (Object)、<strong>exports</strong> (*)、<strong>require</strong> (Function)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//util.ls</span></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  getFormatDate: <span class="function"><span class="keyword">function</span> (<span class="params">data, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;2019-07-19&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;2019年6月20日&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a-util.js</span></span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">&quot;util.js&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  aGetFormatDate: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> util.getFormatDate(data, <span class="number">2</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="特性总结"><a href="#特性总结" class="headerlink" title="特性总结"></a>特性总结</h4><ul>
<li>同步执行模块声明和引入逻辑，分析一些复杂的依赖引用（如循环依赖）时需注意；</li>
<li>缓存机制，性能更优，同时限制了内存占用；</li>
<li>Module 模块可供改造的灵活度高，可以实现一些定制需求（如热更新、任意文件类型模块支持）；</li>
</ul>
<h4 id="AMD-和-CommonJS-的使用场景"><a href="#AMD-和-CommonJS-的使用场景" class="headerlink" title="AMD 和 CommonJS 的使用场景"></a>AMD 和 CommonJS 的使用场景</h4><ul>
<li>需要异步加载 JS ，使用 AMD</li>
<li>使用了 npm 之后建议使用 CommonJS</li>
</ul>
<h3 id="重点总结"><a href="#重点总结" class="headerlink" title="重点总结"></a>重点总结</h3><ul>
<li>AMD</li>
<li>CommonJS</li>
<li>两者的区别</li>
</ul>
<h2 id="7-4-构建工具"><a href="#7-4-构建工具" class="headerlink" title="7-4 构建工具"></a>7-4 构建工具</h2><blockquote>
<p>我们一定会感叹前端技术发展之快，各种可以提高开发效率的新思想和框架层出不穷。但是他们都有一个共同特点：源代码无法直接运行，必须通过转换后才能正常运行。</p>
<p>比如：Grunt 、Gulp、FIS 3、<strong>Webpack</strong> …</p>
<p><a href="https://juejin.im/entry/5ae5c8c9f265da0b9f400d8e">前端构建工具发展及其比较</a></p>
<p><a href="http://zxinc520.com/lcj/%225cb181596d3d4a5cb52b65c9%22">webpack 学习可参考我的博客 </a> 和 <a href="http://zxinc520.com/lcj/%225cb72a04009ae94788aa0d7f%22">我的另一篇博客</a> 均有 涉及。</p>
</blockquote>
<p>构建工具就是做这件事，将源代码转换成可以执行的 JavaScript、CSS、HTML 代码，包括如下内容：</p>
<ul>
<li>代码转换：将 TypeScript 编译成 JavaScript、将 SCSS 编译成 CSS 等。</li>
<li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</li>
<li>代码分割：提取多个页面的公共代码，提取首屏不需要执行部分代码让其异步记在。</li>
<li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要通过构建功能将模块分类合并成一个文件。</li>
<li>自动刷新：监听本地源代码变化，自动重新构建、刷新浏览器。</li>
<li>代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</li>
<li>自动发布：更新代码后，自动构建出线上发布代码并传输给发布系统。</li>
</ul>
<p>构建其实是工程化、自动化思想在前端开发中的体现，将一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。构建为前端开发注入了更大的活力，解放了我们的生产力。</p>
<p>历史上先后出现了一系列构建工具，他们各有优缺点。由于前端工程师很熟悉 JavaScript，Node.js 又可以胜任所有构建需求，所以大多数构建工具都是用 Node.js 开发的。</p>
<h2 id="7-5-上线和回滚"><a href="#7-5-上线和回滚" class="headerlink" title="7-5 上线和回滚"></a>7-5 上线和回滚</h2><ul>
<li>不会有具体的问题，交流询问的方式</li>
</ul>
<h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>上线和回滚的基本流程</li>
<li>linux 基本命令</li>
</ul>
<h4 id="上线和回滚的基本流程"><a href="#上线和回滚的基本流程" class="headerlink" title="上线和回滚的基本流程"></a>上线和回滚的基本流程</h4><ul>
<li><p>是非常重要的开发环节</p>
</li>
<li><p>各个公司的具体流程不同</p>
</li>
<li><p>由专门的工具后者系统完成，我们无需关心细节</p>
</li>
<li><p>如果你没有参与过，面试时也要说出要点</p>
</li>
<li><p>只讲要点，具体实现无法讲解</p>
</li>
</ul>
<h3 id="上线流程要点"><a href="#上线流程要点" class="headerlink" title="上线流程要点"></a>上线流程要点</h3><ul>
<li>将测试完成的代码提交到 git 版本库的 master 分支</li>
<li>将当前服务器的代码全部打包并记录版本号，备份</li>
<li>将 master 分支的代码提交覆盖到线上服务器，生成新版本号</li>
</ul>
<h3 id="回滚的流程要点"><a href="#回滚的流程要点" class="headerlink" title="回滚的流程要点"></a>回滚的流程要点</h3><ul>
<li>将当前服务器的代码打包并记录版本号，备份</li>
<li>将备份的上一个版本号解压，覆盖到线上服务器，并生成新的版本号</li>
</ul>
<h3 id="linux-基本命令"><a href="#linux-基本命令" class="headerlink" title="linux 基本命令"></a>linux 基本命令</h3><ul>
<li>服务器使用 linux 居多，server 版，只有命令行</li>
<li>测试环境要匹配线上环境，因此也是 linux</li>
<li>经常需要登录测试机来自己配置，获取数据</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Git</tag>
        <tag>模块化</tag>
        <tag>构建工具</tag>
        <tag>上线和回滚</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 学习</title>
    <url>/2019/07/12/gitLearning/</url>
    <content><![CDATA[<h1 id="Git-学习"><a href="#Git-学习" class="headerlink" title="Git 学习"></a>Git 学习</h1><blockquote>
<p><strong>Git 学习</strong></p>
<p>Git 的优势</p>
<p>Git 与 SVN 的主要区别</p>
<p>安装 Git</p>
<p>初始化 Git 仓储/（仓库）</p>
<p>配置使用者的用户名和邮箱</p>
<p>把代码 存储到仓库中</p>
<p>Git 查看日志</p>
<p>Git 版本回退</p>
<p>Git 分支的新建与合并</p>
<p>上传至 github</p>
<p>通过 ssh 方式 上传 代码</p>
<p>push 和 pull 简写</p>
</blockquote>
<h3 id="什么是-Git？"><a href="#什么是-Git？" class="headerlink" title="什么是 Git？"></a>什么是 Git？</h3><blockquote>
<p>git – fast 版本控制</p>
<p>Git 是由“Linux 之父” <strong>Linus Torvalds</strong> 创建的。因为他发现找不到满意的方案来管理 Linux Kernel 联合开发的版本控制，就自己写了 Git。</p>
<p><a href="https://git-scm.com/">官方网站</a></p>
</blockquote>
<ul>
<li>Git 是一个<a href="https://git-scm.com/about/free-and-open-source">免费的开源</a> 分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务</li>
<li>Git <a href="https://git-scm.com/doc">易于学习</a>， <a href="https://git-scm.com/about/small-and-fast">占地面积小，具有闪电般快速的性能</a>。它超越了 Subversion，CVS，Perforce 和 ClearCase 等 SCM 工具，具有<a href="https://git-scm.com/about/branching-and-merging">廉价本地分支</a>，便捷的<a href="https://git-scm.com/about/staging-area">临时区域</a>和 <a href="https://git-scm.com/about/distributed">多个工作流程等功能</a>。</li>
</ul>
<h3 id="Git-的优势"><a href="#Git-的优势" class="headerlink" title="Git 的优势"></a>Git 的优势</h3><p>说到优势，那么自然是相对与 SVN 而言的</p>
<ol>
<li><p><strong>版本库本地化，支持离线提交，相对独立不影响协同开发。</strong>每个开发者都拥有自己的版本控制库，在自己的版本库上可以任意的执行提交代码、创建分支等行为。例如，开发者认为自己提交的代码有问题？没关系，因为版本库是自己的，回滚历史、反复提交、归并分支并不会影响到其他开发者。</p>
</li>
<li><p><strong>更少的“仓库污染”。</strong>git 对于每个工程只会产生一个.git 目录，这个工程所有的版本控制信息都在这个目录中，不会像 SVN 那样在每个目录下都产生.svn 目录。</p>
</li>
<li><p><strong>把内容按元数据方式存储，完整克隆版本库。</strong>所有版本信息位于.git 目录中，它是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签、分支、版本记录等。</p>
</li>
<li><p><strong>支持快速切换分支方便合并，比较合并性能好。</strong>在同一目录下即可切换不同的分支，方便合并，且合并文件速度比 SVN 快。</p>
</li>
<li><p><strong>分布式版本库，无单点故障，内容完整性好。</strong>内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</p>
</li>
</ol>
<h3 id="Git-与-SVN-的主要区别"><a href="#Git-与-SVN-的主要区别" class="headerlink" title="Git 与 SVN 的主要区别"></a>Git 与 SVN 的主要区别</h3><p>Git 是<strong>分布式</strong>SCM，而 SVN 是基于<strong>服务器</strong>的，也就是说每个开发者本地都有一套 git 库，每个人维护自己的版本（或者合并其他人的版本），而 SVN 是每个人写完代码后都及时的 checkin 到服务器上，进行合并。</p>
<h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><blockquote>
<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496">廖雪峰的官方网站 git 安装</a></p>
</blockquote>
<p>鼠标 <strong>右键</strong>，选中 <code>Git Bash Here</code> 在里面输入相关命令：</p>
<p><img src="http://static.zxinc520.com/blog/20190711/litoDVMJqNVb.png?imageslim" alt="mark"></p>
<h2 id="使用-Git"><a href="#使用-Git" class="headerlink" title="使用 Git"></a>使用 Git</h2><h3 id="初始化-Git-仓储-（仓库）"><a href="#初始化-Git-仓储-（仓库）" class="headerlink" title="初始化 Git 仓储/（仓库）"></a>初始化 Git 仓储/（仓库）</h3><ol>
<li><strong>新建</strong>一个文件夹</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190711/9NbV1d2Bf3H2.png?imageslim" alt="mark"></p>
<ol start="2">
<li><strong>进入</strong>文件夹，鼠标<strong>右键</strong> 选中 <code>Git Bash Here</code>，输入命令 <code>git init</code> 回车。</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190711/PApIqKpihnsJ.gif" alt="mark"></p>
<h3 id="配置使用者的用户名和邮箱"><a href="#配置使用者的用户名和邮箱" class="headerlink" title="配置使用者的用户名和邮箱"></a>配置使用者的用户名和邮箱</h3><blockquote>
<p>配置使用者的用户名和邮箱 （自报家门）,每一次备份都会把当前备份者的信息存储起来。</p>
<p><strong>配置用户名</strong> ： <code>git config --global user.name &quot;zhouchen&quot;</code></p>
<p><strong>配置邮箱</strong>： <code>git config --global user.email &quot;1583741285@qq.com&quot;</code></p>
</blockquote>
<ol>
<li><p>配置使用者的<strong>用户名</strong>：<strong>进入</strong>文件夹，鼠标<strong>右键</strong> 选中 <code>Git Bash Here</code>，</p>
<p>输入命令 <code>git config --global user.name &quot;zhouchen&quot;</code> 回车 。</p>
</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190711/FUG7gTH6S2Mh.png?imageslim" alt="mark"></p>
<ol start="2">
<li><p>同样的配置使用者的 <strong>邮箱</strong>：<strong>进入</strong>文件夹，鼠标<strong>右键</strong> 选中 <code>Git Bash Here</code>，</p>
<p>输入命令 <code>git config --global user.email &quot;1583741285@qq.com&quot;</code> 回车 。</p>
</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190711/p62Mz0UPYcY9.png?imageslim" alt="mark"></p>
<h3 id="把代码-存储到仓库中"><a href="#把代码-存储到仓库中" class="headerlink" title="把代码 存储到仓库中"></a>把代码 存储到仓库中</h3><blockquote>
<p>把代码 存储到仓库中</p>
</blockquote>
<p><strong>需求</strong>：将 readme.md 文件 存储到仓库中</p>
<p><img src="http://static.zxinc520.com/blog/20190711/KwUDn18LHU1f.png?imageslim" alt="mark"></p>
<ol>
<li><p><strong>进入</strong>文件夹，鼠标<strong>右键</strong> 选中 <code>Git Bash Here</code>，</p>
<p>输入命令 <code>git add ./readme.md</code> 回车 。</p>
</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190711/P1DnSzDuSOBO.png?imageslim" alt="mark"></p>
<ol start="2">
<li>紧接上一步，输入命令 <code>git commit -m &quot;add Introductions&quot;</code> 回车 。</li>
</ol>
<p><u>add Introductions</u>—–可以自定义，一个辅助的解释 <strong>说明</strong>。</p>
<p><img src="http://static.zxinc520.com/blog/20190711/FqHM4n7stzsF.png?imageslim" alt="mark"></p>
<h4 id="查看提交状态"><a href="#查看提交状态" class="headerlink" title="查看提交状态"></a>查看提交状态</h4><p>命令：<code>git status</code></p>
<p><img src="http://static.zxinc520.com/blog/20190711/85IXkLM5Wusf.png?imageslim" alt="mark"></p>
<h4 id="add-补充-–-添加到大门口"><a href="#add-补充-–-添加到大门口" class="headerlink" title="add 补充 – 添加到大门口"></a>add 补充 – 添加到大门口</h4><p>命令 ：<code>git add .</code></p>
<h4 id="一次性-–-放入仓库"><a href="#一次性-–-放入仓库" class="headerlink" title="一次性 – 放入仓库"></a>一次性 – 放入仓库</h4><blockquote>
<p>合并 add 和 commit 命令</p>
</blockquote>
<p>命令：<code>git commit --all -m &quot;这是一次性的操作&quot;</code></p>
<h3 id="Git-查看日志"><a href="#Git-查看日志" class="headerlink" title="Git 查看日志"></a>Git 查看日志</h3><blockquote>
<p>查看日志—-能够查看自己提交的信息</p>
<p><code>git log</code>：查看历史提交的日志</p>
<p><code>git log --oneline</code> 可以看到精简版的日志</p>
</blockquote>
<p>命令：<code>git log</code></p>
<p><img src="http://static.zxinc520.com/blog/20190711/PBubR1jYW0fX.png?imageslim" alt="mark"></p>
<p>命令：<code>git log --oneline</code></p>
<p><img src="http://static.zxinc520.com/blog/20190711/bDLltWMjdSo2.png?imageslim" alt="mark"></p>
<h3 id="Git-版本回退"><a href="#Git-版本回退" class="headerlink" title="Git 版本回退"></a>Git 版本回退</h3><blockquote>
<p>git 版本回退</p>
<p>场景：如果最后一次提交的代码有误，可以通过 git 版本回退，回到代码无误的那一个状态。</p>
</blockquote>
<h4 id="根据索引回退"><a href="#根据索引回退" class="headerlink" title="根据索引回退"></a>根据索引回退</h4><ol>
<li>使用命令 <code>git log --oneline</code>查看状态</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190711/3RDzcU0Fo8Vy.png?imageslim" alt="mark"></p>
<ol start="2">
<li>命令：<code>git reset --hard Head~0 </code> ( 向后退 <strong>0</strong> 次)</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190711/Uobb7X1EwPUd.png?imageslim" alt="mark"></p>
<ol start="3">
<li>命令：<code>git reset --hard Head~1</code> （向后退 <strong>1</strong> 次）；此时代码回退了<strong>一次</strong> 。</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190711/3lM4UYpv7mQw.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190711/rwuTTeqbAFNc.png?imageslim" alt="mark"></p>
<h4 id="通过版本号回退"><a href="#通过版本号回退" class="headerlink" title="通过版本号回退"></a>通过版本号回退</h4><blockquote>
<p>通过版本号回退</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190712/VsLjP0uf8h8D.png?imageslim" alt="mark"></p>
<p>命令：<code>git reset --hard ac97cbc </code> 回车执行</p>
<p><img src="http://static.zxinc520.com/blog/20190712/puqQzAUO57un.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190712/4b2kofXa5m3B.png?imageslim" alt="mark"></p>
<h4 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h4><blockquote>
<p>可以看到每一次切换版本记录</p>
</blockquote>
<p>命令：<code>git reflog</code> 查看总体记录</p>
<p><img src="http://static.zxinc520.com/blog/20190712/rIsddoYu54q2.png?imageslim" alt="mark"></p>
<h3 id="Git-分支的新建与合并"><a href="#Git-分支的新建与合并" class="headerlink" title="Git 分支的新建与合并"></a>Git 分支的新建与合并</h3><blockquote>
<p>git 创建分支</p>
<p>运用场景：放开发者只开发完成部分代码，想保存代码,为了能够后续继续开发，可以创建分支。</p>
</blockquote>
<p><strong>现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流程：</strong></p>
<ol>
<li>开发某个网站。</li>
<li>为实现某个新的需求，创建一个分支。</li>
<li>在这个分支上开展工作。</li>
</ol>
<p><strong>假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方式处理：</strong></p>
<ol>
<li>返回到原先已经发布到生产服务器上的分支。</li>
<li>为这次紧急修补建立一个新分支，并在其中修复问题。</li>
<li>通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。</li>
<li>切换到之前实现新需求的分支，继续工作。</li>
</ol>
<h3 id="Git-分支的新建"><a href="#Git-分支的新建" class="headerlink" title="Git 分支的新建"></a>Git 分支的新建</h3><p><strong>新建分支</strong> ：命令：<code>git branch &lt;name&gt;</code></p>
<p><img src="http://static.zxinc520.com/blog/20190712/vCIxtjnYlgsu.png?imageslim" alt="mark"></p>
<p><strong>查看分支信息</strong> ：命令：<code>git branch</code> （ <strong>绿色</strong> –&gt; 代表正处于此分支）</p>
<p><img src="http://static.zxinc520.com/blog/20190712/R3t4POgEphiO.png?imageslim" alt="mark"></p>
<p><strong>切换分支</strong> ：命令 <code>git checkout dev</code></p>
<p><img src="http://static.zxinc520.com/blog/20190712/MQQVVoNGu41k.png?imageslim" alt="mark"></p>
<h4 id="在分支中提交部分代码"><a href="#在分支中提交部分代码" class="headerlink" title="在分支中提交部分代码"></a>在分支中提交部分代码</h4><blockquote>
<p>类似于主分支 提交（一样）</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190712/gBcACkrl5Gxf.png?imageslim" alt="mark"></p>
<h3 id="Git-合并分支"><a href="#Git-合并分支" class="headerlink" title="Git 合并分支"></a>Git 合并分支</h3><blockquote>
<p>合并分支</p>
<p><strong>需求</strong>：将 dev 分支 合并到主分支（master 分支）上。</p>
</blockquote>
<ol>
<li>切换到 <strong>master</strong> 分支：命令：<code>git checkout master</code></li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190712/bKIzXXwv3Xnm.png?imageslim" alt="mark"></p>
<ol start="2">
<li>合并 dev 分支 到 master 分支上：命令：<code>git merge dev</code></li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190712/uMQR0k4u6qTT.png?imageslim" alt="mark"></p>
<ol start="3">
<li>查看自己的提交记录 命令：<code>git log --oneline</code></li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190712/gu7FKi6tGBkf.png?imageslim" alt="mark"></p>
<h3 id="上传至-github"><a href="#上传至-github" class="headerlink" title="上传至 github"></a>上传至 github</h3><blockquote>
<p><code>git push [地址] master</code></p>
<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900937935629664">参考廖雪峰的官方网站 github 篇</a></p>
<p>【地址】：例如：<a href="https://github.com/ZhChen7/Travel.git">https://github.com/ZhChen7/Travel.git</a></p>
</blockquote>
<p><strong>git push</strong> 推项目到 github：<code>git push [地址] master</code></p>
<h4 id="从-github-拉下项目"><a href="#从-github-拉下项目" class="headerlink" title="从 github 拉下项目"></a>从 github 拉下项目</h4><blockquote>
<p>github 拉下项目</p>
<p>【地址】：例如：<a href="https://github.com/ZhChen7/Travel.git">https://github.com/ZhChen7/Travel.git</a></p>
</blockquote>
<p><strong>git pull</strong> 从 github 拉下项目 ：<code>git pull [地址] master</code></p>
<p><strong>git clone</strong> 从 github 复制项目（往往在第一次使用）：<code>git clone [地址]</code></p>
<h3 id="通过-ssh-方式-上传-代码"><a href="#通过-ssh-方式-上传-代码" class="headerlink" title="通过 ssh 方式 上传 代码"></a>通过 ssh 方式 上传 代码</h3><blockquote>
<p>公钥 和 私钥 ；两者之间是有关联的。</p>
</blockquote>
<ol>
<li><p>生成 <strong>公钥</strong> 和 <strong>私钥</strong></p>
<p>命令：<code>ssh-keygen -t rsa -C &lt;邮箱&gt;</code></p>
</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190712/2GKvEKipn11B.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190712/9qHzNoUvBgy2.png?imageslim" alt="mark"></p>
<p><strong>找到生成的文件</strong> ：</p>
<p><img src="http://static.zxinc520.com/blog/20190712/DPxGphRT9AXv.png?imageslim" alt="mark"></p>
<p><strong>给自己的 github 配置 ssh</strong> ：</p>
<p><img src="http://static.zxinc520.com/blog/20190712/eK9KUtgXVIrN.png?imageslim" alt="mark"></p>
<h3 id="提交冲突"><a href="#提交冲突" class="headerlink" title="提交冲突"></a>提交冲突</h3><blockquote>
<p>先 <strong>pull</strong> 还是 先 <strong>push</strong></p>
<p>应用场景：多人共同提交时，产生提交冲突时。</p>
</blockquote>
<p><strong>解决方案</strong>：<strong>先 pull</strong> 然后 <strong>后 push</strong></p>
<h3 id="push-和-pull-简写"><a href="#push-和-pull-简写" class="headerlink" title="push 和 pull 简写"></a>push 和 pull 简写</h3><blockquote>
<p>push 和 pull 简写</p>
<p>【地址简写】：<code>git remote add &lt;变量名&gt; &lt;远程地址&gt;</code></p>
</blockquote>
<p><strong>配置远程地址</strong>（设置别名）：方便每一次不用输入很长的地址</p>
<p>命令：<code>git remote add origin git@github.com:ZhChen7/Travel.git</code></p>
<p>即：为 <code>git@github.com:ZhChen7/Travel.git</code>设置别名： **origin **</p>
<h4 id="默认关联"><a href="#默认关联" class="headerlink" title="默认关联"></a>默认关联</h4><blockquote>
<p>当我们在 push 时，加上 <strong>-u 参数</strong> ，那么在<strong>下次 push 时</strong>；只用 写 <code>git push</code> 即可上传代码。</p>
<p>（加上 <strong>-u</strong> 之后，git 会把当前分支 与 远程指定的分支 进行<strong>关联</strong>）</p>
</blockquote>
<p>下次 直接写 <code>git push</code> 相当于 写 <code>git push origin master</code> 。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>数组API</title>
    <url>/2019/06/25/DataStructure/</url>
    <content><![CDATA[<h2 id="JavaScript-数组那些事"><a href="#JavaScript-数组那些事" class="headerlink" title="JavaScript 数组那些事"></a>JavaScript 数组那些事</h2><blockquote>
<p>JavaScript 数据结构与算法 — <strong>数组</strong> 篇</p>
<p>迭代器函数</p>
<p>ECMAScript 6 和 数组 新功能</p>
</blockquote>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>数组对象的作用是：使用单独的变量名来存储一系列的值**.**</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">总的方法参考</a></p>
</blockquote>
<h3 id="数组相关操作"><a href="#数组相关操作" class="headerlink" title="数组相关操作:"></a>数组相关操作:</h3><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><ul>
<li><p>添加末尾元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.push(<span class="number">11</span>);</span><br><span class="line">arr.push(<span class="number">12</span>, <span class="number">13</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加首位元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.unshift();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><ul>
<li><p>删除末尾元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.pop();</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除首位元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.shift();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="在任意位置添加或删除元素"><a href="#在任意位置添加或删除元素" class="headerlink" title="在任意位置添加或删除元素"></a>在任意位置添加或删除元素</h4><blockquote>
<p><strong>splice()</strong> 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice">参考</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> months = [<span class="string">&quot;Jan&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;June&quot;</span>];</span><br><span class="line">months.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;Feb&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入到索引为1的位置</span></span><br><span class="line"><span class="built_in">console</span>.log(months);</span><br><span class="line"><span class="comment">// 结果: Array [&#x27;Jan&#x27;, &#x27;Feb&#x27;, &#x27;March&#x27;, &#x27;April&#x27;, &#x27;June&#x27;]</span></span><br><span class="line"></span><br><span class="line">months.splice(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;May&quot;</span>);</span><br><span class="line"><span class="comment">// 从索引为4开始 删除一个数据并添加一个 May数据</span></span><br><span class="line"><span class="built_in">console</span>.log(months);</span><br><span class="line"><span class="comment">// 结果: Array [&#x27;Jan&#x27;, &#x27;Feb&#x27;, &#x27;March&#x27;, &#x27;April&#x27;, &#x27;May&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="迭代器函数"><a href="#迭代器函数" class="headerlink" title="迭代器函数"></a>迭代器函数</h2><blockquote>
<p>处理集合中的每个项是很常见的操作。JavaScript 提供了许多迭代集合的方法，从简单的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for"><code>for</code></a>循环到<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><code>map()</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"><code>filter()</code></a>。迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of"><code>for...of</code></a>循环的行为 。</p>
</blockquote>
<h3 id="every"><a href="#every" class="headerlink" title="every:"></a>every:</h3><blockquote>
<p><code>**every()**</code> 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every">参考</a></p>
<p>描述: <code>every</code> 方法为数组中的每个元素执行一次 <code>callback</code> 函数，直到它找到一个会使 <code>callback</code> 返回 <a href="https://developer.mozilla.org/en-US/docs/Glossary/falsy">falsy</a> 的元素。如果发现了一个这样的元素，<code>every</code> 方法将会立即返回 <code>false</code>。否则，<code>callback</code> 为每一个元素返回 <code>true</code>，<code>every</code> 就会返回 <code>true</code>。<code>callback</code> 只会为那些已经被赋值的索引调用。不会为那些被删除或从未被赋值的索引调用。</p>
<p><strong>注意</strong>：若收到一个空数组，此方法在一切情况下都会返回 <code>true</code>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &gt;= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].every(isBigEnough); <span class="comment">// false</span></span><br><span class="line">[<span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">130</span>, <span class="number">44</span>].every(isBigEnough); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="some"><a href="#some" class="headerlink" title="some:"></a>some:</h3><blockquote>
<p><code>**some()**</code> 方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个 Boolean 类型的值。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some">参考</a></p>
<p><code>some()</code> 为数组中的每一个元素执行一次 <code>callback</code> 函数，直到找到一个使得 callback <strong>返回一个“真值”</strong>（即可转换为布尔值 true 的值）。如果找到了这样一个值，<code>some()</code> 将会立即返回 <code>true</code>。否则，<code>some()</code> 返回 <code>false</code>。<code>callback</code> 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。</p>
<p><code>callback</code> 被调用时传入三个参数：元素的值，元素的索引，被遍历的数组。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBelowThreshold</span>(<span class="params">currentValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> currentValue &lt; <span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array1 = [<span class="number">1</span>, <span class="number">30</span>, <span class="number">41</span>, <span class="number">29</span>, <span class="number">10</span>, <span class="number">13</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>];</span><br><span class="line">array1.some(isBelowThreshold); <span class="comment">//true</span></span><br><span class="line">array2.some(isBelowThreshold); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach:"></a>foreach:</h3><blockquote>
<p><code>**forEach()**</code> 方法对数组的每个元素执行一次提供的函数。</p>
<p><code>forEach</code> 方法按升序为数组中含有效值的每一项执行一次<code>callback</code> 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">参考</a></p>
</blockquote>
<blockquote>
<p><strong>注意：</strong> foreach 没有办法中止或者跳出 <code>forEach()</code> 循环，除了抛出一个异常。如果你需要这样，使用 <code>forEach()</code> 方法是错误的。</p>
<p>若你需要提前终止循环，你可以使用：</p>
<ul>
<li>简单循环</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of">for…of</a> 循环</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every"><code>Array.prototype.every()</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some"><code>Array.prototype.some()</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find"><code>Array.prototype.find()</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex"><code>Array.prototype.findIndex()</code></a></li>
</ul>
<p>这些数组方法可以对数组元素判断，以便确定是否需要继续遍历：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every"><code>every()</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some"><code>some()</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find"><code>find()</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex"><code>findIndex()</code></a></p>
<p>译者注：若条件允许，也可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"><code>filter()</code></a> 提前过滤出需要遍历的部分，再用 <code>forEach()</code> 处理。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"></span><br><span class="line">array1.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(element);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// expected output: &quot;a&quot;</span></span><br><span class="line"><span class="comment">// expected output: &quot;b&quot;</span></span><br><span class="line"><span class="comment">// expected output: &quot;c&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="map-和-filter-方法"><a href="#map-和-filter-方法" class="headerlink" title="map 和 filter 方法"></a>map 和 filter 方法</h3><blockquote>
<p>JavaScript 还有两个会 <strong>返回新数组</strong> 的遍历方法.</p>
</blockquote>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><blockquote>
<p><code>**map()**</code> 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">参考</a></p>
<p><code>map</code> 方法会给原数组中的每个元素都按顺序调用一次 <code>callback</code> 函数。<code>callback</code> 每次执行后的返回值（包括 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>）组合起来形成一个新数组。 <code>callback</code> 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 <code>delete</code> 删除的索引则不会被调用。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass a function to map</span></span><br><span class="line"><span class="keyword">const</span> map1 = array1.map(<span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map1);</span><br><span class="line"><span class="comment">// expected output: Array [2, 8, 18, 32]</span></span><br></pre></td></tr></table></figure>

<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><blockquote>
<p><code>**filter()**</code> 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">参考</a></p>
<p><code>filter</code> 为数组中的每个元素调用一次 <code>callback</code> 函数，并利用所有使得 <code>callback</code> 返回 true 或<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">等价于 true 的值</a>的元素创建一个新数组。<code>callback</code> 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 <code>callback</code> 测试的元素会被跳过，不会被包含在新数组中.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> words = [<span class="string">&quot;spray&quot;</span>, <span class="string">&quot;limit&quot;</span>, <span class="string">&quot;elite&quot;</span>, <span class="string">&quot;exuberant&quot;</span>, <span class="string">&quot;destruction&quot;</span>, <span class="string">&quot;present&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = words.filter(<span class="function">(<span class="params">word</span>) =&gt;</span> word.length &gt; <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上面是ES6里面的箭头函数,下面是完整版</span></span><br><span class="line"><span class="comment">* const result = words.filter(function (e) &#123;</span></span><br><span class="line"><span class="comment">    return e.length&gt;6</span></span><br><span class="line"><span class="comment">&#125;);</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce:"></a>reduce:</h3><blockquote>
<p><code>**reduce()**</code> 方法对数组中的每个元素执行一个由您提供的<strong>reducer</strong>函数(升序执行)，将其结果汇总为单个返回值。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">参考</a></p>
<p><code>reduce</code>为数组中的每一个元素依次执行<code>callback</code>函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：</p>
<ul>
<li><code>accumulator 累计器</code></li>
<li><code>currentValue 当前值</code></li>
<li><code>currentIndex 当前索引</code></li>
<li><code>array 数组</code></li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 + 2 + 3 + 4</span></span><br><span class="line"><span class="built_in">console</span>.log(array1.reduce(reducer));</span><br><span class="line"><span class="comment">// expected output: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 + 1 + 2 + 3 + 4</span></span><br><span class="line"><span class="built_in">console</span>.log(array1.reduce(reducer, <span class="number">5</span>));</span><br><span class="line"><span class="comment">// expected output: 15</span></span><br></pre></td></tr></table></figure>

<p>_假如运行下段<code>reduce()</code>代码_：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentValue,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">  array</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>_callback 被调用四次，每次调用的参数和返回值如下表_：</p>
<p><img src="http://static.zxinc520.com/blog/20190625/FxoC6IyrTRcr.png?imageslim" alt="mark"></p>
<h2 id="ECMAScript-6-和-数组-新功能"><a href="#ECMAScript-6-和-数组-新功能" class="headerlink" title="ECMAScript 6 和 数组 新功能"></a>ECMAScript 6 和 数组 新功能</h2><blockquote>
<p>ECMAScript 6 和 数组 新功能</p>
<p>这里主要介绍下 <strong>数组 ES6</strong> 新特性</p>
<p><a href="http://es6.ruanyifeng.com/#docs/iterator">Iterator 和 for…of 循环</a></p>
</blockquote>
<h3 id="for-…of-循环迭代"><a href="#for-…of-循环迭代" class="headerlink" title="for …of 循环迭代"></a>for …of 循环迭代</h3><blockquote>
<p><strong>强大的 for-of 循环</strong></p>
<p>还记得在《<a href="http://www.infoq.com/cn/articles/es6-in-depth-an-introduction">深入浅出 ES6（一）：ES6 是什么</a>》中我向你们承诺过的话么？ES6 不会破坏你已经写好的 JS 代码。目前看来，成千上万的 Web 网站依赖 for-in 循环，其中一些网站甚至将其用于数组遍历。如果想通过修正 for-in 循环增加数组遍历支持会让这一切变得更加混乱，因此，标准委员会在 ES6 中增加了一种新的循环语法来解决目前的问题。</p>
<p><a href="https://www.infoq.cn/article/es6-in-depth-iterators-and-the-for-of-loop">参考</a></p>
</blockquote>
<hr>
<h4 id="关于-for…in"><a href="#关于-for…in" class="headerlink" title="关于 for…in"></a>关于 for…in</h4><blockquote>
<p>这 <strong>绝对是一个糟糕的选择</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  <span class="comment">// 千万别这样做</span></span><br><span class="line">  <span class="built_in">console</span>.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这 <strong>绝对是一个糟糕的选择</strong>，为什么呢？</p>
<ul>
<li>在这段代码中，赋给 index 的值不是实际的数字，而是字符串“0”、“1”、“2”，此时很可能在无意之间进行字符串算数计算，例如：“2” + 1 == “21”，这给编码过程带来极大的不便。</li>
<li>作用于数组的 for-in 循环体除了遍历数组元素外，还会遍历<a href="https://developer.mozilla.org/en-US/docs/Glossary/Expando">自定义</a>属性。举个例子，如果你的数组中有一个可枚举属性 myArray.name，循环将额外执行一次，遍历到名为“name”的索引。就连数组原型链上的属性都能被访问到。</li>
<li>最让人震惊的是，在某些情况下，这段代码可能按照随机顺序遍历数组元素。</li>
<li>简而言之，for-in 是为普通对象设计的，你可以遍历得到字符串类型的键，因此不适用于数组遍历。</li>
</ul>
<hr>
<h3 id="强大的-for-of-循环"><a href="#强大的-for-of-循环" class="headerlink" title="强大的 for-of 循环"></a>强大的 for-of 循环</h3><blockquote>
<p>我们将要探究一下 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of">for-of</a> 循环的外表下隐藏着哪些强大的功能。</p>
<p><a href="https://www.infoq.cn/article/es6-in-depth-iterators-and-the-for-of-loop">参考</a></p>
</blockquote>
<p><strong>优势:</strong></p>
<ul>
<li>这是最简洁、最直接的遍历数组元素的语法</li>
<li>这个方法避开了 for-in 循环的所有缺陷</li>
<li>与 forEach() 不同的是，它可以正确响应 <strong>break</strong>、<strong>continue</strong> 和 <strong>return</strong> 语句</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-ES6-新的迭代器"><a href="#使用-ES6-新的迭代器" class="headerlink" title="使用 ES6 新的迭代器"></a>使用 ES6 新的迭代器</h2><blockquote>
<p>使用 ES6 新的迭代器</p>
<p><a href="http://es6.ruanyifeng.com/#docs/iterator">参考</a></p>
</blockquote>
<h3 id="Iterator（遍历器）的概念"><a href="#Iterator（遍历器）的概念" class="headerlink" title="Iterator（遍历器）的概念"></a>Iterator（遍历器）的概念</h3><p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>
<p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p><strong>Iterator 的作用有三个</strong>：</p>
<ul>
<li><p>一是为各种数据结构，提供一个统一的、简便的访问接口；</p>
</li>
<li><p>二是使得数据结构的成员能够按某种次序排列；</p>
</li>
<li><p>三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</p>
</li>
</ul>
<p><strong>Iterator 的遍历过程是这样的</strong> :</p>
<p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p>
<p>（2）第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</p>
<p>（3）第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</p>
<p>（4）不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</p>
<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]);</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length</span><br><span class="line">        ? &#123; <span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">        : &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个<code>makeIterator</code>函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组<code>[&#39;a&#39;, &#39;b&#39;]</code>执行这个函数，就会返回该数组的遍历器对象（即指针对象）<code>it</code>。</p>
<h3 id="默认-Iterator-接口"><a href="#默认-Iterator-接口" class="headerlink" title="默认 Iterator 接口"></a>默认 Iterator 接口</h3><blockquote>
<p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环（详见下文）。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p>
<p>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。</p>
</blockquote>
<p>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被<code>for...of</code>循环遍历。原因在于，这些数据结构原生部署了<code>Symbol.iterator</code>属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p>
<p>原生具备 Iterator 接口的数据结构如下。</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p>下面的例子是数组的<code>Symbol.iterator</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iter.next(); <span class="comment">// &#123; value: &#x27;a&#x27;, done: false &#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123; value: &#x27;b&#x27;, done: false &#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123; value: &#x27;c&#x27;, done: false &#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>arr</code>是一个数组，原生就具有遍历器接口，部署在<code>arr</code>的<code>Symbol.iterator</code>属性上面。所以，调用这个属性，就得到遍历器对象。</p>
<h3 id="数组的-entries、keys-和-values-方法"><a href="#数组的-entries、keys-和-values-方法" class="headerlink" title="数组的 entries、keys 和 values 方法"></a>数组的 entries、keys 和 values 方法</h3><blockquote>
<p>ES6 提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>方法是对 <strong>键名</strong> 的遍历、<code>values()</code>方法是对 <strong>键值</strong> 的遍历，<code>entries()</code>方法是对 <strong>键值对</strong> 的遍历。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> letter = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, &#x27;a&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="Array-from-方法"><a href="#Array-from-方法" class="headerlink" title="Array.from()方法"></a>Array.from()方法</h3><blockquote>
<p><code>Array.from()</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p>
<p><a href="http://www.waibo.wang/bible/es6/html/8/8.2.html">参考</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&quot;c&quot;</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法 ==&gt; [].slice.call(arguments)能将具有length属性的对象转成数组：</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/ae57baecc57d">你遇到过 [ ].slice.call() 吗？</a></p>
<p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的<code>arguments</code>对象。<code>Array.from()</code>方法都可以将它们转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"><span class="built_in">Array</span>.from(ps).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>querySelectorAll</code>方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用<code>forEach</code>方法。</p>
<p>只要是部署了 Iterator 接口的数据结构，<code>Array.from()</code>方法都能将其转为数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> namesSet = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]);</span><br><span class="line"><span class="built_in">Array</span>.from(namesSet); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>值得提醒的是，扩展运算符（<code>...</code>）也可以将某些数据结构转为数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> args = [...arguments];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line">[...document.querySelectorAll(<span class="string">&quot;div&quot;</span>)];</span><br></pre></td></tr></table></figure>

<p>扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换。<code>Array.from()</code>方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性。因此，任何有<code>length</code>属性的对象，都可以通过<code>Array.from()</code>方法转为数组，而此时扩展运算符就无法转换。</p>
<p>对于还没有部署该方法的浏览器，可以用<code>Array.prototype.slice</code>方法替代。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toArray = (<span class="function">() =&gt;</span></span><br><span class="line">  <span class="built_in">Array</span>.from ? <span class="built_in">Array</span>.from : <span class="function">(<span class="params">obj</span>) =&gt;</span> [].slice.call(obj))();</span><br></pre></td></tr></table></figure>

<p>Array.from()<code>方法还可以接受第二个参数，作用类似于数组的</code>map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike, <span class="function">(<span class="params">x</span>) =&gt;</span> x * x);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function">(<span class="params">x</span>) =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line">arr1 = <span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">e</span>) =&gt;</span> e * e);</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">//  [ 1, 4, 9 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="Array-of-方法"><a href="#Array-of-方法" class="headerlink" title="Array.of()方法"></a>Array.of()方法</h3><blockquote>
<p><code>Array.of()</code>方法用于将一组值，转换为数组。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>); <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>(); <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [3, 11, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[ &lt;3 empty items&gt; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Array</code>方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p>
<p><code>Array.of()</code>方法基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(); <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="literal">undefined</span>); <span class="comment">// [undefined]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>); <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<p><code>Array.of()</code>方法总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>
<p><code>Array.of()</code>方法可以用下面的代码模拟实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组实例的-fill-方法"><a href="#数组实例的-fill-方法" class="headerlink" title="数组实例的 fill()方法"></a>数组实例的 fill()方法</h3><blockquote>
<p><code>fill()</code>方法使用给定值，填充一个数组。</p>
<p><a href="http://www.waibo.wang/bible/es6/html/8/8.6.html">参考</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>].fill(<span class="number">7</span>); <span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>fill()</code>方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p>
<p><code>fill()</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line">  .fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br><span class="line">  [(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>); <span class="comment">// [ &#x27;a&#x27;, 7, 7, 7, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，<code>fill()</code>方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</p>
<h3 id="数组实例的-copyWithin-方法"><a href="#数组实例的-copyWithin-方法" class="headerlink" title="数组实例的 copyWithin()方法"></a>数组实例的 copyWithin()方法</h3><blockquote>
<p>数组实例的<code>copyWithin()</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
</blockquote>
<p><u>Array.prototype.copyWithin(target, start = 0, end = this.length)</u> ：</p>
<ul>
<li>它接受三个参数。<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul>
</li>
</ul>
<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -2相当于3号位，-1相当于4号位</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-2</span>, <span class="number">-1</span>) <span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">[].copyWithin.call(&#123;<span class="attr">length</span>: <span class="number">5</span>, <span class="number">3</span>: <span class="number">1</span>&#125;, <span class="number">0</span>, <span class="number">3</span>) <span class="comment">// &#123;0: 1, 3: 1, length: 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将2号位到数组结束，复制到0号位</span></span><br><span class="line"><span class="keyword">let</span> i32a = <span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">i32a.copyWithin(<span class="number">0</span>, <span class="number">2</span>);<span class="comment">// Int32Array [3, 4, 5, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于没有部署 TypedArray 的 copyWithin 方法的平台</span></span><br><span class="line"><span class="comment">// 需要采用下面的写法</span></span><br><span class="line">[].copyWithin.call(<span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]), <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// Int32Array [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><blockquote>
<p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>) <span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">&#x27;div&#x27;</span>)] <span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure>

<p>该运算符主要用于函数调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line">add(...numbers); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>array.push(...items)</code>和<code>add(...numbers)</code>这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p>
<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">v, w, x, y, z</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> args = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">f(<span class="number">-1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<h4 id="替代数组的-apply-方法"><a href="#替代数组的-apply-方法" class="headerlink" title="替代数组的 apply 方法"></a>替代数组的 apply 方法</h4><blockquote>
<p>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.apply(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure>

<p>下面是扩展运算符取代<code>apply</code>方法的一个实际的例子，应用<code>Math.max</code>方法，简化求出一个数组最大元素的写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用<code>Math.max</code>函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用<code>Math.max</code>了。</p>
<p>另一个例子是通过<code>push</code>函数，将一个数组添加到另一个数组的尾部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5的 写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure>

<h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><blockquote>
<p>扩展运算符的应用</p>
</blockquote>
<h4 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h4><p>扩展运算符提供了复制数组的简便写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1]; <span class="comment">// 写法一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1; <span class="comment">// 写法二</span></span><br></pre></td></tr></table></figure>

<p>上面的两种写法，<code>a2</code>都是<code>a1</code>的克隆。</p>
<h4 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h4><p>扩展运算符提供了数组合并的新写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(more)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, ...more]</span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的合并数组</span></span><br><span class="line">arr1.concat(arr2, arr3); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3] <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>扩展运算符还可以将字符串转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...<span class="string">&quot;hello&quot;</span>]; <span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure>

<p>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x\uD83D\uDE80y&#x27;</span>.length <span class="comment">// 4</span></span><br><span class="line">[...<span class="string">&#x27;x\uD83D\uDE80y&#x27;</span>].length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="数组实例的-find-和-findIndex-方法"><a href="#数组实例的-find-和-findIndex-方法" class="headerlink" title="数组实例的 find() 和 findIndex()方法"></a>数组实例的 find() 和 findIndex()方法</h3><blockquote>
<p>数组实例的<code>find()</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</p>
<p>ECMAScript6—find() 和 findIndex()方法——搜索</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// -5</span></span><br></pre></td></tr></table></figure>

<p>上面代码找出数组中第一个小于 0 的成员。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>find()</code>方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>**this</code>对象** 。</p>
<p>另外，这两个方法都可以发现<code>NaN</code>，弥补了数组的<code>indexOf()</code>方法的不足。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>]</span><br><span class="line">  .indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">  [<span class="literal">NaN</span>].findIndex(<span class="function">(<span class="params">y</span>) =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>indexOf</code>方法无法识别数组的<code>NaN</code>成员，但是<code>findIndex()</code>方法可以借助<code>Object.is</code>方法做到。</p>
<h3 id="数组实例的-includes-方法"><a href="#数组实例的-includes-方法" class="headerlink" title="数组实例的 includes()方法"></a>数组实例的 includes()方法</h3><blockquote>
<p><code>Array.prototype.includes()</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes()</code>方法类似。ES2016 引入了该方法。</p>
<p>ECMAScript7 —includes()方法 ——搜索</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  .includes(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)].includes(<span class="number">4</span>) <span class="comment">// false</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>)].includes(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>该方法的第二个参数表示搜索的起始位置，默认为<code>0</code>。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为<code>-4</code>，但数组长度为<code>3</code>），则会重置为从<code>0</code>开始。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>); <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">-1</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">  .includes(<span class="number">2</span>, <span class="number">1</span>) <span class="comment">//true</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)].includes(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>没有该方法之前，我们通常使用数组的<code>indexOf()</code>方法，检查是否包含某个值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) !== <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>indexOf()</code>方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于<code>-1</code>，表达起来不够直观。二是，它内部使用严格相等运算符（<code>===</code>）进行判断，这会导致对<code>NaN</code>的误判。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>另外，Map 和 Set 数据结构有一个<code>has</code>方法，需要注意与<code>includes()</code>区分。</p>
<ul>
<li>Map 结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li>
<li>Set 结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</li>
</ul>
<h3 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h3><blockquote>
<p>数组的空位，是指数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Array(3)</code>返回一个具有 3 个空位的数组。</p>
<p>注意，空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>]; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> [, , ,]; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。</p>
<h4 id="ES5-对空位的处理，已经很不一致了，大多数情况下会忽略空位。"><a href="#ES5-对空位的处理，已经很不一致了，大多数情况下会忽略空位。" class="headerlink" title="ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。"></a>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。</h4><ul>
<li><code>forEach()</code>,<code>filter()</code>,<code>reduce()</code>,<code>every()</code>和<code>some()</code>都会跳过空位。</li>
<li><code>map()</code>会跳过空位，但会保留这个值</li>
<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].forEach(<span class="function">(<span class="params">x,i</span>) =&gt;</span> <span class="built_in">console</span>.log(x+<span class="string">&#x27;---&#x27;</span>+i)); <span class="comment">// a---1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter方法</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// every方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x===<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce方法</span></span><br><span class="line">[<span class="number">1</span>,,<span class="number">2</span>].reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> <span class="keyword">return</span> x+y) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].some(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="ES6-则是明确将空位转为undefined。"><a href="#ES6-则是明确将空位转为undefined。" class="headerlink" title="ES6 则是明确将空位转为undefined。"></a>ES6 则是明确将空位转为<code>undefined</code>。</h4><p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="string">&quot;a&quot;</span>, , <span class="string">&quot;b&quot;</span>]); <span class="comment">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span></span><br></pre></td></tr></table></figure>

<p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...[<span class="string">&quot;a&quot;</span>, , <span class="string">&quot;b&quot;</span>]]; <span class="comment">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span></span><br></pre></td></tr></table></figure>

<p>copyWithin() 会连空位一起拷贝</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, ,].copyWithin(<span class="number">2</span>, <span class="number">0</span>); <span class="comment">// [,&quot;a&quot;,,&quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<p><code>fill()</code>会将空位视为正常的数组位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">&quot;a&quot;</span>); <span class="comment">// [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<p><code>for...of</code>循环也会遍历空位。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [, ,];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略它们。如果<strong>改成<code>map</code>方法遍历</strong>，空位是会<strong>跳过</strong>的。</p>
<p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entries()</span></span><br><span class="line">[...[,<span class="string">&#x27;a&#x27;</span>].entries()] <span class="comment">// [[0,undefined], [1,&quot;a&quot;]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// keys()</span></span><br><span class="line">[...[,<span class="string">&#x27;a&#x27;</span>].keys()] <span class="comment">// [0,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// values()</span></span><br><span class="line">[...[,<span class="string">&#x27;a&#x27;</span>].values()] <span class="comment">// [undefined,&quot;a&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find()</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].find(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// findIndex()</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="组数排序"><a href="#组数排序" class="headerlink" title="组数排序"></a>组数排序</h2><blockquote>
<p>组数排序</p>
</blockquote>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><blockquote>
<p><code>**sort()**</code> 方法用<a href="https://en.wikipedia.org/wiki/In-place_algorithm">原地算法</a>对数组的元素进行排序，并返回数组。排序算法现在是<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E7.A9.A9.E5.AE.9A.E6.80.A7">稳定的</a>。默认排序顺序是根据字符串 Unicode 码点。</p>
<p>由于它取决于具体实现，因此无法保证排序的时间和空间复杂性。</p>
<p><strong>sort()</strong> 用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的 Unicode 位点进行排序。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">参考</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> months = [<span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>];</span><br><span class="line">months.sort();</span><br><span class="line"><span class="built_in">console</span>.log(months);</span><br><span class="line"><span class="comment">// expected output: Array [&quot;Dec&quot;, &quot;Feb&quot;, &quot;Jan&quot;, &quot;March&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array1 = [<span class="number">1</span>, <span class="number">30</span>, <span class="number">4</span>, <span class="number">21</span>, <span class="number">100000</span>];</span><br><span class="line">array1.sort();</span><br><span class="line"><span class="built_in">console</span>.log(array1);</span><br><span class="line"><span class="comment">// expected output: Array [1, 100000, 21, 30, 4]</span></span><br></pre></td></tr></table></figure>

<h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><p>​ 如果没有指明 <code>compareFunction</code> ，那么元素会按照转换为的字符串的诸个字符的 Unicode 位点进行排序。例如 “Banana” 会被排列到 “cherry” 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 <code>compareFunction</code>），比较的数字会先被转换为字符串，所以在 Unicode 顺序上 “80” 要比 “9” 要靠前。</p>
<p>如果指明了 <code>compareFunction</code> ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素：</p>
<ul>
<li><p>如果 <code>compareFunction(a, b)</code> 小于 0 ，那么 a 会被排列到 b 之前；</p>
</li>
<li><p>如果 <code>compareFunction(a, b)</code> 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；</p>
</li>
<li><p>如果 <code>compareFunction(a, b)</code> 大于 0 ， b 会被排列到 a 之前。</p>
</li>
<li><p><code>compareFunction(a, b)</code> 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    <span class="comment">// 按某种排序标准进行比较, a 小于 b</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// a must be equal to b</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要比较数字而非字符串，比较函数可以简单的以 a 减 b，如下的函数将会将数组升序排列</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareNumbers</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sort</code> 方法可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a> 方便地书写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line">numbers.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(numbers);</span><br><span class="line"></span><br><span class="line">也可以写成：</span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line">numbers.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="built_in">console</span>.log(numbers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h2 id="输出数组为字符串"><a href="#输出数组为字符串" class="headerlink" title="输出数组为字符串"></a>输出数组为字符串</h2><blockquote>
<p>输出数组为字符串</p>
</blockquote>
<h3 id="toString-和-join"><a href="#toString-和-join" class="headerlink" title="toString 和 join"></a>toString 和 join</h3><blockquote>
<p>将数组转为字符串</p>
</blockquote>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><blockquote>
<p><code>**toString()**</code> 返回一个字符串，表示指定的数组及其元素。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array"><code>Array</code></a>对象覆盖了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a>的 <code>toString</code> 方法。对于数组对象，<code>toString</code> 方法连接数组并返回一个字符串，其中包含用逗号分隔的每个数组元素。</p>
<p>当一个数组被作为文本值或者进行字符串连接操作时，将会自动调用其 <code>toString</code> 方法。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;1a&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.toString()); <span class="comment">// &quot;1,2,a,1a&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><blockquote>
<p>该<code>**join()**</code>方法通过连接数组（或类<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects">数组对象</a>）中的所有元素（由逗号或指定的分隔符字符串分隔）来创建并返回新字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。</p>
<p>指定用于分隔数组的每对相邻元素的字符串。如有必要，分隔符将转换为字符串。如果省略，则数组元素用逗号（“，”）分隔。如果<code>separator</code>是空字符串，则连接所有元素，它们之间没有任何字符。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = [<span class="string">&quot;Fire&quot;</span>, <span class="string">&quot;Air&quot;</span>, <span class="string">&quot;Water&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(elements.join()); <span class="comment">//  &quot;Fire,Air,Water&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(elements.join(<span class="string">&quot;&quot;</span>)); <span class="comment">// &quot;FireAirWater&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(elements.join(<span class="string">&quot;-&quot;</span>)); <span class="comment">//  &quot;Fire-Air-Water&quot;</span></span><br></pre></td></tr></table></figure>

<p>下面的示例创建一个<code>a</code>包含三个元素的数组，然后将数组连接四次：使用默认分隔符，然后是逗号和空格，然后是加号和空字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;Wind&quot;</span>, <span class="string">&quot;Water&quot;</span>, <span class="string">&quot;Fire&quot;</span>];</span><br><span class="line">a.join(); <span class="comment">// &#x27;Wind,Water,Fire&#x27;</span></span><br><span class="line">a.join(<span class="string">&quot;, &quot;</span>); <span class="comment">// &#x27;Wind, Water, Fire&#x27;</span></span><br><span class="line">a.join(<span class="string">&quot; + &quot;</span>); <span class="comment">// &#x27;Wind + Water + Fire&#x27;</span></span><br><span class="line">a.join(<span class="string">&quot;&quot;</span>); <span class="comment">// &#x27;WindWaterFire&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>加入类似数组的对象</strong></p>
<p>以下示例<code>arguments</code>通过调用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>Function.prototype.call</code></a>on 来连接类似于 array 的对象（）<code>Array.prototype.join</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(s); <span class="comment">// &#x27;1,a,true&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//expected output: &quot;1,a,true&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>API</category>
        <category>数组API</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>数组相关操作</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统课程设计</title>
    <url>/2019/06/15/OperatingSystemCourseDesign/</url>
    <content><![CDATA[<h1 id="操作系统课程设计"><a href="#操作系统课程设计" class="headerlink" title="操作系统课程设计"></a>操作系统课程设计</h1><p><img src="http://static.zxinc520.com/blog/20190615/PaXCTq1hgEbO.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190615/HbzHoGRT91yz.png?imageslim" alt="mark"></p>
<table>
<thead>
<tr>
<th>课题</th>
<th>操作系统</th>
</tr>
</thead>
<tbody><tr>
<td>院系</td>
<td>计算机与信息工程学院</td>
</tr>
<tr>
<td>班级</td>
<td>1701</td>
</tr>
<tr>
<td>姓名</td>
<td>周琛</td>
</tr>
<tr>
<td>学号</td>
<td>2017115010124</td>
</tr>
</tbody></table>
<h2 id="实验一-处理器调度"><a href="#实验一-处理器调度" class="headerlink" title="实验一 处理器调度"></a>实验一 处理器调度</h2><h3 id="一、实习内容"><a href="#一、实习内容" class="headerlink" title="一、实习内容"></a>一、实习内容</h3><p>​ 选择一个调度算法，实现处理器调度。</p>
<h3 id="二、实习目的"><a href="#二、实习目的" class="headerlink" title="二、实习目的"></a>二、实习目的</h3><p>​ 在采用多道程序设计的系统中，往往有若干个进程同时处于就绪状态。当就绪进程个数大于处理器数时，就必须依照某种策略来决定哪些进程优先占用处理器。本实习模拟在单处理器情况下的处理器调度，帮助学生加深了解处理器调度的工作。</p>
<h3 id="三、实习题目"><a href="#三、实习题目" class="headerlink" title="三、实习题目"></a>三、实习题目</h3><p>​ 本实习有两个题，学生可选择其中的一题做实习。</p>
<p>​ 第一题：设计一个<strong>按优先数调度算法</strong>实现处理器调度的程序。</p>
<h4 id="提示"><a href="#提示" class="headerlink" title="提示:"></a>提示:</h4><ol>
<li><p>假定系统有五个进程，每一个进程用一个进程控制块 PCB 来代表，进程控制块的<strong>格式为</strong>：</p>
<p><img src="http://static.zxinc520.com/blog/20190615/BvLSkm8uRm2W.png?imageslim" alt="mark"></p>
</li>
</ol>
<p>其中，进程名——作为进程的标识，假设五个进程的进程名分别为 P1，P2，P3，P4，P5。</p>
<ul>
<li>指针——按优先数的大小把五个进程连成队列，用指针指出下一个进程的进程控制块的首地址，最后一个进程中的指针为“0”。</li>
<li>要求运行时间——假设进程需要运行的单位时间数。</li>
<li>优先数——赋予进程的优先数，调度时总是选取优先数大的进程先执行。</li>
<li>状态——可假设有两种状态，“就绪”状态和“结束”状态。五个进程的初始状态都为“就绪”，用“R”表示，当一个进程运行结束后，它的状态为“结束”，用“E”表示。</li>
</ul>
<ol start="2">
<li><p>在每次运行你所设计的处理器调度程序之前，为每个进程任意确定它的“优先数”和“要求运行时间”。</p>
</li>
<li><p>为了调度方便，把五个进程按给定的优先数从大到小连成队列。用一单元指出队首进程，用指针指出队列的连接情况。例：</p>
<p><strong>队首标志</strong></p>
</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190615/cAeym1O3lvaj.png?imageslim" alt="mark"></p>
<ol start="4">
<li>处理器调度总是选队首进程运行。采用动态改变优先数的办法，进程每运行一次优先数就减“1”。由于本实习是模拟处理器调度，所以，对被选中的进程并不实际的启动运行，而是执行：</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190615/nEAGCE9sJJqJ.png?imageslim" alt="mark"></p>
<p><strong>提醒注意的是：</strong>在实际的系统中，当一个进程被选中运行时，必须恢复进程的现场，让它占有处理器运行，直到出现等待事件或运行结束。在这里省去了这些工作。</p>
<ol start="5">
<li>进程运行一次后，若要求运行时间 ¹0，则再将它加入队列（按优先数大小插入，且置队首标志）；若要求运行时间=0，则把它的状态修改成“结束”（E），且退出队列。</li>
<li>若“就绪”状态的进程队列不为空，则重复上面（4）和（5）的步骤，直到所有进程都成为“结束”状态。</li>
<li>在所设计的程序中应有显示或打印语句，能显示或打印每次被选中进程的进程名以及运行一次后进程队列的变化。</li>
<li>为五个进程任意确定一组“优先数”和“要求运行时间”，启动所设计的处理器调度程序，显示或打印逐次被选中进程的进程名以及进程控制块的动态变化过程。</li>
</ol>
<p><strong>源代码:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt; //strcpy()</span><br><span class="line">#include&lt;stdlib.h&gt;//malloc()</span><br><span class="line"><span class="keyword">void</span> insertQuestion();</span><br><span class="line"><span class="keyword">void</span> insertNode(char ProcessName[<span class="number">5</span>],int Priority,int Time);</span><br><span class="line"><span class="keyword">void</span> view();</span><br><span class="line"><span class="keyword">void</span> arithmetic();</span><br><span class="line">typedef struct process</span><br><span class="line">&#123;</span><br><span class="line">    char ProcessName[<span class="number">5</span>];</span><br><span class="line">    int Priority;</span><br><span class="line">    int Time;</span><br><span class="line">    int processState;</span><br><span class="line">    struct process *next;</span><br><span class="line">&#125;nodelist;</span><br><span class="line"></span><br><span class="line">nodelist *pHead=NULL;<span class="comment">//存放调度的首节点地址</span></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    insertQuestion();</span><br><span class="line">    arithmetic();</span><br><span class="line">    <span class="comment">// view();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加问题</span></span><br><span class="line"><span class="keyword">void</span> insertQuestion()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> insertNode(char ProcessName[<span class="number">5</span>],int Priority,int Time);</span><br><span class="line">    char ProcessName[<span class="number">5</span>];</span><br><span class="line">    int Priority;</span><br><span class="line">    int Time;</span><br><span class="line">    int i=<span class="number">0</span>;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      scanf(<span class="string">&quot;%s %d %d&quot;</span>,ProcessName,&amp;Priority,&amp;Time);</span><br><span class="line">      insertNode(ProcessName,Priority,Time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据插入链表</span></span><br><span class="line"><span class="keyword">void</span> insertNode(char ProcessName[<span class="number">5</span>],int Priority,int Time)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//申请存储空间</span></span><br><span class="line">    nodelist *pNew=(nodelist *)malloc(sizeof(nodelist));</span><br><span class="line">    nodelist *p,*q;</span><br><span class="line">    strcpy(pNew-&gt;ProcessName,ProcessName);</span><br><span class="line">    pNew-&gt;Priority = Priority;</span><br><span class="line">    pNew-&gt;Time = Time;</span><br><span class="line">    pNew-&gt;processState=<span class="number">1</span>;</span><br><span class="line">    pNew-&gt;next=NULL;</span><br><span class="line">        <span class="keyword">if</span>(pHead==NULL) <span class="comment">//插入前链表为空，新插入的节点为头节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            pHead=pNew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=pHead;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(p-&gt;next!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                q=p-&gt;next;</span><br><span class="line">                p=q;</span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;next=pNew;</span><br><span class="line">                pNew-&gt;next=NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;next==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next=pNew;</span><br><span class="line">                p=pNew;</span><br><span class="line">                pNew-&gt;next=NULL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示链表中的数据</span></span><br><span class="line"><span class="keyword">void</span> view()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 显示所有的结果 */</span></span><br><span class="line">    nodelist *p=pHead;</span><br><span class="line">    <span class="keyword">if</span>(pHead!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    	    printf(<span class="string">&quot;进程名\t优先数\t时间\t就绪状态\n&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(p!=NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(<span class="string">&quot;%s\t&quot;</span>,p-&gt;ProcessName);</span><br><span class="line">                printf(<span class="string">&quot;%d\t&quot;</span>,p-&gt;Priority);</span><br><span class="line">                printf(<span class="string">&quot;%d\t&quot;</span>,p-&gt;Time);</span><br><span class="line">                 printf(<span class="string">&quot;%d\t&quot;</span>,p-&gt;processState);</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      printf(<span class="string">&quot;链表中啥都没有！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> arithmetic()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//相关算法实现</span></span><br><span class="line">    nodelist *p=pHead;</span><br><span class="line">    nodelist *q=pHead;</span><br><span class="line">    nodelist *m=pHead;</span><br><span class="line">    int max=p-&gt;Priority;</span><br><span class="line">    int flag=<span class="number">0</span>;</span><br><span class="line">    int i;</span><br><span class="line">    int sum=<span class="number">0</span>;</span><br><span class="line">    char firstName[<span class="number">5</span>];</span><br><span class="line">    char ReturnProcessName[<span class="number">5</span>];</span><br><span class="line">    strcpy(ReturnProcessName,p-&gt;ProcessName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pHead!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m!=<span class="number">0</span>)&#123;</span><br><span class="line">        sum+=m-&gt;Time;</span><br><span class="line">        m=m-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sum; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(p!=NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( max &lt; (p-&gt;Priority) &amp;&amp; (p-&gt;Time&gt;<span class="number">0</span>))&#123;</span><br><span class="line">                    max= p-&gt;Priority;</span><br><span class="line">                    strcpy(ReturnProcessName,p-&gt;ProcessName);</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                p=p-&gt;next;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">                      <span class="keyword">while</span>(q!=NULL)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(strcmp(q-&gt;ProcessName,ReturnProcessName) == <span class="number">0</span>)&#123;</span><br><span class="line">                            	printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                            	printf(<span class="string">&quot;被选中进程的进程名:&quot;</span>);</span><br><span class="line">                                printf(<span class="string">&quot;%s\n&quot;</span>,q-&gt;ProcessName);</span><br><span class="line">                                q-&gt;Priority--;</span><br><span class="line">                                q-&gt;Time--;</span><br><span class="line">                            &#125;</span><br><span class="line">	                              <span class="keyword">if</span> (q-&gt;Time==<span class="number">0</span>)</span><br><span class="line">					                &#123;</span><br><span class="line">					                	q-&gt;processState=<span class="number">0</span>;</span><br><span class="line">					                &#125;</span><br><span class="line">                            q=q-&gt;next;</span><br><span class="line">                        &#125;</span><br><span class="line">                    p=pHead;</span><br><span class="line">                    q=pHead;</span><br><span class="line">                    max=p-&gt;Priority;</span><br><span class="line">                    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    printf(<span class="string">&quot;运行一次后进程队列的变化:\n&quot;</span>);</span><br><span class="line">                    printf(<span class="string">&quot;----------------------------------\n&quot;</span>);</span><br><span class="line">                    view();</span><br><span class="line">                    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    strcpy(ReturnProcessName,p-&gt;ProcessName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果:</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190615/1Xn16500J847.jpg?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190615/qCGSz0Azzdif.jpg?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190615/FMiq4WyNObOV.gif" alt="mark"></p>
<h2 id="实验二-主存储器空间的分配和回收"><a href="#实验二-主存储器空间的分配和回收" class="headerlink" title="实验二 主存储器空间的分配和回收"></a>实验二 主存储器空间的分配和回收</h2><h3 id="一、实习内容-1"><a href="#一、实习内容-1" class="headerlink" title="一、实习内容"></a>一、实习内容</h3><p>​ 主存储器空间的分配和回收。</p>
<h3 id="二、实习目的-1"><a href="#二、实习目的-1" class="headerlink" title="二、实习目的"></a>二、实习目的</h3><p>​ 一个好的计算机系统不仅要有一个足够容量的、存取速度高的、稳定可靠的主存储器，而且要能合理地分配和使用这些存储空间。当用户提出申请存储器空间时，存储管理必须根据申请者的要求，按一定的策略分析主存空间的使用情况，找出足够的空闲区域分配给申请者。当作业撤离或主动归还主存资源时，则存储管理要收回作业占用的主存空间或归还部分主存空间。主存的分配和回收的实现虽与主存储器的管理方式有关的，通过本实习帮助学生理解在不同的存储管理方式下应怎样实现主存空间的分配和回收。</p>
<h3 id="三、实习题目-1"><a href="#三、实习题目-1" class="headerlink" title="三、实习题目"></a>三、实习题目</h3><p>​ 模拟在分页式管理方式下采用位示图来表示主存分配情况，实现主存空间的分配和回收。</p>
<h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><ol>
<li><p>分页式存储器把主存分成大小相等的若干块，作业的信息也按块的大小分页，作业装入主存时可把作业的信息按页分散存放在主存的空闲块中，为了说明主存中哪些块已经被占用，哪些块是尚未分配的空闲块，可用一张位示图来指出。位示图可由若干存储单元来构成，其中每一位与一个物理块对应，用 0/1 表示对应块为空闲/已占用。</p>
</li>
<li><p>假设某系统的主存被分成大小相等的 64 块，则位示图可用 8 个字节来构成，另用一单元记录当前空闲块数。如果已有第 0，1，4，5，6，9，11，13，24，31，共 10 个主存块被占用了，那么位示图情况如下：</p>
<p><img src="http://static.zxinc520.com/blog/20190615/y2yBXTmrC7SP.png?imageslim" alt="mark"></p>
</li>
<li><p>当要装入一个作业时，根据作业对主存的需要量，先查当前空闲块数是否能满足作业要求，若不能满足则输出分配不成功。若能满足，则查位示图，找出为“0”的一些位，置上占用标志“1”，从“当前空闲块数”中减去本次占用块数。</p>
</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190615/Wq5YpOTIc25K.png?imageslim" alt="mark"></p>
<p>其中，j 表示找到的是第 n 个字节，I 表示对应的是第 n 位。</p>
<p>根据分配给作业的块号，为作业建立一张<strong>页表</strong>，页表格式：</p>
<p><img src="http://static.zxinc520.com/blog/20190615/fWnQmUT7up8x.png?imageslim" alt="mark"></p>
<ol start="4">
<li><p>当一个作业执行结束，归还主存时，根据该作业的页表可以知道应归还的块号，由块号可计算出在位示图中的对应位置，把对应位的占用标志清成“0”，表示对应的块已成为空闲块。归还的块数加入到当前空闲块数中。由块号计算在位示图中的位置的公式如下：</p>
<p><img src="http://static.zxinc520.com/blog/20190615/0zJ5vnMejiNd.png?imageslim" alt="mark"></p>
</li>
<li><p>设计实现主存分配和回收的程序。假定位示图的初始状态如（2）所述，现有一信息量为 5 页的作业要装入，运行你所设计的分配程序，为作业分配主存且建立页表（格式如（3）所述）。然后假定有另一作业执行结束，它占用的块号为第 4，5，6 和 31 块，运行你所设计的回收程序，收回作业归还的主存块。</p>
</li>
</ol>
<p>要求能显示和打印分配或回收前后的位示图和当前空闲块数，对完成一次分配后还要显示或打印为作业建立的页表。</p>
<h3 id="四、实习报告"><a href="#四、实习报告" class="headerlink" title="四、实习报告"></a>四、实习报告</h3><ol>
<li>实习题目。</li>
<li>程序中使用的数据结构及符号说明。</li>
<li>流程图。</li>
<li>打印一份源程序并附上注释。</li>
<li>打印程序运行时的初值和运行结果，要求如下：</li>
</ol>
<h4 id="输出要求"><a href="#输出要求" class="headerlink" title="输出要求:"></a>输出要求:</h4><p>​ 打印位示图和当前空闲块数的初值；要求装入的作业对主存的申请量，为作业分配后的位示图、当前空闲块数和页表；作业归还的块号、回收作业所占主存后的位示图和当前空闲块数。</p>
<p><strong>源代码:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int arr[<span class="number">64</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  int n=<span class="number">0</span>;</span><br><span class="line">  int sumsheng=<span class="number">54</span>;</span><br><span class="line">  int i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">  int count=<span class="number">0</span>;</span><br><span class="line">  int indexI=<span class="number">0</span>;</span><br><span class="line">  int flag=<span class="number">0</span>;</span><br><span class="line">  int arr1[<span class="number">64</span>];</span><br><span class="line">  int finallyIndex=<span class="number">0</span>;</span><br><span class="line">  int arrindex=<span class="number">0</span>;</span><br><span class="line">  int arrindex2=<span class="number">0</span>;</span><br><span class="line">  int indexflag=<span class="number">0</span>;</span><br><span class="line">  int x[<span class="number">64</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  int ReturnNum=<span class="number">0</span>;</span><br><span class="line">  int term;</span><br><span class="line">  arr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  arr[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  arr[<span class="number">4</span>]=<span class="number">1</span>;</span><br><span class="line">  arr[<span class="number">5</span>]=<span class="number">1</span>;</span><br><span class="line">  arr[<span class="number">6</span>]=<span class="number">1</span>;</span><br><span class="line">  arr[<span class="number">9</span>]=<span class="number">1</span>;</span><br><span class="line">  arr[<span class="number">11</span>]=<span class="number">1</span>;</span><br><span class="line">  arr[<span class="number">13</span>]=<span class="number">1</span>;</span><br><span class="line">  arr[<span class="number">24</span>]=<span class="number">1</span>;</span><br><span class="line">  arr[<span class="number">31</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printf(<span class="string">&quot;装入的作业对主存的申请量:&quot;</span>);</span><br><span class="line">  scanf(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// printf(&quot;%d\n&quot;, sumsheng);</span></span><br><span class="line">printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;-------------------------------------\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;初始位示图:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (i%<span class="number">8</span>==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(<span class="string">&quot;%d &quot;</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;当前空闲块数的初值:%d\n&quot;</span>,sumsheng );</span><br><span class="line">printf(<span class="string">&quot;-------------------------------------\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">sumsheng=sumsheng-n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n&gt;sumsheng)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(<span class="string">&quot;分配不成功\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (arr[i]==<span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            indexI=i;</span><br><span class="line">            goto LOOP;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       LOOP:<span class="keyword">for</span>(i=indexI;i&lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (arr[i]==<span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            arr[i]=<span class="number">1</span>;</span><br><span class="line">            arr1[indexflag]=i;</span><br><span class="line">            indexflag++;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count==n)&#123;</span><br><span class="line">                 finallyIndex=i;</span><br><span class="line">                 goto A;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       A:printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf(<span class="string">&quot;-------------------------------------\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;为作业分配后的位示图:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (i%<span class="number">8</span>==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(<span class="string">&quot;%d &quot;</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;为作业分配后的空闲块数:%d\n&quot;</span>,sumsheng);</span><br><span class="line">printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;页表:\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;页号\t块号\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">  printf(<span class="string">&quot;%d\t%d\n&quot;</span>,i,arr1[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">&quot;-------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;-------------------------------------\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;输入作业归还的块号的数量:&quot;</span>);</span><br><span class="line">scanf(<span class="string">&quot;%d&quot;</span>,&amp;ReturnNum);</span><br><span class="line">printf(<span class="string">&quot;输入作业归还的块号:&quot;</span>);</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;ReturnNum ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d&quot;</span>,&amp;x[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ReturnNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       term=x[i];</span><br><span class="line">       arr[term]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">printf(<span class="string">&quot;回收作业所占主存后的位示图:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (i%<span class="number">8</span>==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(<span class="string">&quot;%d &quot;</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;当前空闲块数:%d\n&quot;</span>,sumsheng+ReturnNum);</span><br><span class="line">printf(<span class="string">&quot;-------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果:</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190615/oPYSHAezbqWC.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190615/5tuH6MxvT5cc.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190615/Mhg1pbnGuPwe.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190615/DePT3qGywNBk.gif" alt="mark"></p>
]]></content>
      <categories>
        <category>课程设计</category>
        <category>操作系统实训</category>
      </categories>
      <tags>
        <tag>学习实训</tag>
      </tags>
  </entry>
  <entry>
    <title>大二数据库实验</title>
    <url>/2019/06/11/Database/</url>
    <content><![CDATA[<h1 id="大二数据库实验"><a href="#大二数据库实验" class="headerlink" title="大二数据库实验"></a>大二数据库实验</h1><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><blockquote>
<p>数据库课程实验综合小实验（做一个项目实现增删改查功能）</p>
<p>大二下学期期末大作业！</p>
</blockquote>
<h3 id="技术运用："><a href="#技术运用：" class="headerlink" title="技术运用："></a>技术运用：</h3><p>​ <u>运用到的技术</u>：<strong>bootstrap</strong>+ <strong>art-template</strong> + <strong>node.js</strong> + <strong>mysql</strong></p>
<table>
<thead>
<tr>
<th>课题</th>
<th>数据库</th>
</tr>
</thead>
<tbody><tr>
<td>班级</td>
<td>1701</td>
</tr>
<tr>
<td>作者姓名</td>
<td>周琛</td>
</tr>
<tr>
<td>学号</td>
<td>2017115010124</td>
</tr>
<tr>
<td>所在院系</td>
<td>计算机信息与工程学院</td>
</tr>
<tr>
<td>学科专业名称</td>
<td>计算机科学与技术</td>
</tr>
<tr>
<td>导师及职称</td>
<td>童强</td>
</tr>
</tbody></table>
<p>​</p>
<h2 id="一、实验目的与要求"><a href="#一、实验目的与要求" class="headerlink" title="一、实验目的与要求"></a>一、实验目的与要求</h2><ol>
<li>用 node 设计一个应用程序，实现对平时实验数据库的增、删、改、查。</li>
<li>说明文档中有 node 连接数据库的关键代码说明。</li>
<li>给了一个实例代码，实现了对一张表的增删改查功能（说明文档中可以看到数据库及表的名称，和有关连接数据库和实现增删改查的关键代码）。</li>
<li>可以运行，实现对学生课程数据库的操作；</li>
</ol>
<h2 id="二-步骤操作"><a href="#二-步骤操作" class="headerlink" title="二.步骤操作"></a>二.步骤操作</h2><h4 id="1-用-node-设计一个应用程序，实现对平时实验数据库的增、删、改、查。"><a href="#1-用-node-设计一个应用程序，实现对平时实验数据库的增、删、改、查。" class="headerlink" title="1. 用 node 设计一个应用程序，实现对平时实验数据库的增、删、改、查。"></a>1. 用 node 设计一个应用程序，实现对平时实验数据库的增、删、改、查。</h4><p><strong>效果图:</strong></p>
<p>用图说话：</p>
<p><img src="http://static.zxinc520.com/blog/20190525/JWCuqSFLOqbB.png?imageslim" alt="mark"></p>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频:"></a><img src="http://static.zxinc520.com/blog/20190525/KHUkC8mo5c0L.png?imageslim" alt="mark">视频:</h3><video id="video" controls="" preload="none" poster="http://static.zxinc520.com/blog/20190613/yhdLmF30B7EP.png?imageslim">
      <source id="mp4" src="http://static.zxinc520.com/bandicam%202019-05-28%2012-50-22-208.mp4" type="video/mp4">
      </video>

<h3 id="2-说明文档中有-node-连接数据库的关键代码"><a href="#2-说明文档中有-node-连接数据库的关键代码" class="headerlink" title="2. 说明文档中有 node 连接数据库的关键代码"></a>2. 说明文档中有 node 连接数据库的关键代码</h3><blockquote>
<p>文件 : mysql.js</p>
<p><strong>作用: 连接数据库,执行数据操作、 封装、暴露方法.</strong></p>
</blockquote>
<p><strong>mysql.js</strong>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行数据操作、 封装、暴露方法</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  query: <span class="function"><span class="keyword">function</span> (<span class="params">sql, params, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建链接</span></span><br><span class="line">    <span class="keyword">const</span> connection = mysql.createConnection(&#123;</span><br><span class="line">      host: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">      user: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">      password: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">      database: <span class="string">&quot;zc&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//每次使用的时候需要创建链接，数据操作完成之后要关闭连接</span></span><br><span class="line">    connection.connect(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;数据库链接失败&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//开始数据操作</span></span><br><span class="line">      <span class="comment">//传入三个参数，第一个参数sql语句，第二个参数sql语句中需要的数据，第三个参数回调函数</span></span><br><span class="line">      connection.query(sql, params, <span class="function"><span class="keyword">function</span> (<span class="params">err, results, fields</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;数据操作失败&quot;</span>);</span><br><span class="line">          <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将查询出来的数据返回给回调函数</span></span><br><span class="line">        callback &amp;&amp; callback(results, fields);</span><br><span class="line">        <span class="comment">//results作为数据操作后的结果，fields作为数据库连接的一些字段</span></span><br><span class="line">        <span class="comment">//停止链接数据库，必须再查询语句后，要不然一调用这个方法，就直接停止链接，数据操作就会失败</span></span><br><span class="line">        connection.end(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;关闭数据库连接失败！&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-实现了对一张表的增删改查功能"><a href="#3-实现了对一张表的增删改查功能" class="headerlink" title="3.实现了对一张表的增删改查功能"></a>3.实现了对一张表的增删改查功能</h2><blockquote>
<p>给了一个实例代码，实现了对一张表的增删改查功能（说明文档中可以看到数据库及表的名称，和有关连接数据库和实现增删改查的关键代码）。</p>
</blockquote>
<h4 id="添加功能实现"><a href="#添加功能实现" class="headerlink" title="添加功能实现:"></a>添加功能实现:</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.post(<span class="string">&quot;/add&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> body = req.body;</span><br><span class="line">  <span class="built_in">console</span>.log(body);</span><br><span class="line">  <span class="keyword">let</span> addSql = <span class="string">&quot;INSERT INTO user(id,username,tel) VALUES(?,?,?)&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> addSqlParams = [body.id, body.username, body.tel];</span><br><span class="line">  db.query(addSql, addSqlParams, <span class="function"><span class="keyword">function</span> (<span class="params">result, fields</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res.status(<span class="number">200</span>).json(&#123;</span><br><span class="line">      err_code: <span class="number">0</span>,</span><br><span class="line">      message: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>效果图:</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190525/Q4p9PqfySpYr.png?imageslim" alt="mark"></p>
<h4 id="删除功能实现"><a href="#删除功能实现" class="headerlink" title="删除功能实现 :"></a>删除功能实现 :</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">&quot;/delete&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> deleteSql = <span class="string">&quot;DELETE FROM user  WHERE id = ?&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> deleteSqlParams = req.query.id;</span><br><span class="line">  db.query(deleteSql, deleteSqlParams, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">    res.redirect(<span class="number">302</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>效果图:</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190611/Gu16nhNmt2FM.png?imageslim" alt="mark"></p>
<h4 id="修改功能实现"><a href="#修改功能实现" class="headerlink" title="修改功能实现"></a>修改功能实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">&quot;/fix&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  fixsql = <span class="string">&quot;SELECT * FROM user WHERE id = ?&quot;</span>;</span><br><span class="line">  fixSqlParams = req.query.id;</span><br><span class="line">  db.query(fixsql, fixSqlParams, <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    res.render(<span class="string">&quot;fix.html&quot;</span>, &#123;</span><br><span class="line">      result: result[<span class="number">0</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&quot;/fix&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.body);</span><br><span class="line">  updatasql = <span class="string">&quot;UPDATE user SET username = ?,tel=? WHERE id = ?&quot;</span>;</span><br><span class="line">  updataSqlParams = [req.body.username, req.body.tel, req.body.id];</span><br><span class="line">  db.query(updatasql, updataSqlParams, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.status(<span class="number">200</span>).json(&#123;</span><br><span class="line">      err_code: <span class="number">0</span>,</span><br><span class="line">      message: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>效果图:</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190525/RdNGNjvSnJNF.png?imageslim" alt="mark"></p>
<h4 id="查找功能实现"><a href="#查找功能实现" class="headerlink" title="查找功能实现"></a>查找功能实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.post(<span class="string">&quot;/search&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.body);</span><br><span class="line">  arr = [];</span><br><span class="line">  db.query(<span class="string">&quot;select * from user&quot;</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params">result, fields</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">    result.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        e.id.indexOf(req.body.value) &gt;= <span class="number">0</span> ||</span><br><span class="line">        e.username.indexOf(req.body.value) &gt;= <span class="number">0</span> ||</span><br><span class="line">        e.tel.indexOf(req.body.value) &gt;= <span class="number">0</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        arr.push(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res.status(<span class="number">200</span>).json(&#123;</span><br><span class="line">      err_code: <span class="number">0</span>,</span><br><span class="line">      message: arr,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>效果图:</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190611/Ed1NKxGH1I4I.png?imageslim" alt="mark"></p>
<h2 id="4-运行程序"><a href="#4-运行程序" class="headerlink" title="4. 运行程序"></a>4. 运行程序</h2><p>相关代码源代码以上传至码云,地址为:</p>
<p><a href="https://gitee.com/zxinc/sophomore_database_experiment">源码地址</a></p>
<video id="video" controls="" preload="none" poster="http://static.zxinc520.com/blog/20190613/yhdLmF30B7EP.png?imageslim">
 <source id="mp4" src="http://static.zxinc520.com/bandicam%202019-05-28%2012-50-22-208.mp4" type="video/mp4">
  </video>
]]></content>
      <categories>
        <category>大学实训</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>大二</tag>
        <tag>数据库实训</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2019/05/13/Promise/</url>
    <content><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote>
<p>前言: Promise 是 <strong>异步编程</strong> 的一种解决方案, 相比传统的解决方案—&gt;回调函数和事件更加强大.由社区最早提出和实现,ES6 将其写进了语言标准,统一了用法,原生提供了 Promise 对象.</p>
<p>没有 Promise 之前,解决异步都是依赖回调,但执行多个具备前后顺序的异步操作时代码就会非常乱并且出现问题难调试.</p>
<p>Promise 的 <strong>本质</strong> 是要干什么的：就是单纯的为了解决 <strong>回调地狱问题</strong>，但是并不能帮我们减少代码量。</p>
</blockquote>
<h3 id="“回调地狱”是什么"><a href="#“回调地狱”是什么" class="headerlink" title="“回调地狱”是什么"></a>“回调地狱”是什么</h3><p>”回调地狱“也叫”回调金字塔“，我们平时写代码的时候 js 如果异步 回调是不可避免的<br>例如 ajax 不断的进行异步请求数据 回调方法里还要对数据进行处理，继续回调…形成回调地狱<br>这会使得我们的代码可读性变差，出现问题 不好调试 也会导致性能下降</p>
<p>而 nodejs 是一种单线程的事件驱动而且是非阻塞的 I/O 模型，而 I/O 模型，是异步的，这样 nodejs 在处理结果的时候 就需要在回调函数中执行，这样也就形成了回调地狱。</p>
<p><img src="http://static.zxinc520.com/blog/20190420/4iquo6cVxxSQ.jpg?imageslim" alt="mark"></p>
<h3 id="Promise-介绍"><a href="#Promise-介绍" class="headerlink" title="Promise 介绍"></a>Promise 介绍</h3><p>Promise 就是实现异步编程的一种解决方案，核心就是 Promise 对象。Promise 对象就像一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。它可以将异步操作以同步操作的流程表达出来，避免层层嵌套(callback)的毁掉函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p>
<p><strong>Promise 对象的两个特点</strong>：</p>
<ol>
<li><p>对象的状态不受外界影响。有三种状态：pending(进行中)、resolved(已成功)、rejected(已失败);</p>
</li>
<li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 resolved 和从 pending 变为 rejected。</p>
</li>
</ol>
<p><strong>Promise 缺点：</strong></p>
<ol>
<li>无法取消 Promise，一旦新建它就会立即执行，无法中途取消;</li>
<li>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部;</li>
<li>当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</li>
</ol>
<hr>
<h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a><strong>基本概念：</strong></h4><ol>
<li><p>Promise 是一个构造函数，既然是构造函数，那么，我们就可以 new Promise() 得到一个 Promise 的实例</p>
</li>
<li><p>在 Promise 上，有两个函数，分别叫做 <strong>resolve</strong>（成功之后的回调函数） 和 <strong>reject</strong>（失败之后的回调函数）</p>
</li>
<li><p>在 Promise 构造函数的 Prototype 属性上，有一个 <strong>.then()</strong> 方法，也就说，只要是 Promise 构造函数创建的实例，都可以访问到 .then() 方法。</p>
</li>
<li><p>Promise 表示一个 异步操作，每当我们 new 一个 Promise 的实例，这个实例，就表示一个具体的异步操作</p>
</li>
<li><p>既然 Promise 创建的实例，是一个异步操作，那么，这个 异步操作的结果，只能有两种状态：</p>
</li>
</ol>
<p>​ 5.1 <strong>状态 1</strong>： 异步执行成功了，需要在内部调用成功的回调函数（<strong>resolve</strong>），把结果返回给调用者。</p>
<p>​ 5.2 <strong>状态 2</strong>： 异步执行失败了，需要在内部调用失败的回调函数（<strong>reject</strong>），把结果返回给调用者。</p>
<p>​ 5.3 由于 Promise 的实例，是一个异步操作，所以，内部拿到 操作结果后，无法使用 return 把操作的结果返回给调用者；这时候，只能使用回调函数的形式，来把 成功 或 失败的结果，返回给调用者。</p>
<ol start="6">
<li>我们可以在 new 出来的 Promise 实例上，调用 <strong>.then() 方法</strong>，【预先】为这个 Promise 异步操作指定 成功（<strong>resolve</strong>）和 失败（<strong>reject</strong>）回调函数</li>
</ol>
<h2 id="关于-Promise-要解决回调地狱问题的说明"><a href="#关于-Promise-要解决回调地狱问题的说明" class="headerlink" title="关于 Promise 要解决回调地狱问题的说明"></a>关于 Promise 要解决回调地狱问题的说明</h2><p><strong>实验需求</strong>：你要封装一个方法，我给你一个要读取文件的路径，你这个方法帮我读取文件，并把内容返回给我。</p>
<p><em>代码实际演示：</em></p>
<p>目录结构：</p>
<p><img src="http://static.zxinc520.com/blog/20190420/djU0REH3KKbb.png?imageslim" alt="mark"></p>
<h3 id="第一步：初步实现一个读取文件的功能："><a href="#第一步：初步实现一个读取文件的功能：" class="headerlink" title="第一步：初步实现一个读取文件的功能："></a>第一步：初步实现一个读取文件的功能：</h3><p><strong>封装读取文件的方法.js</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求：你要封装一个方法，我给你一个要读取文件的路径，你这个方法帮我读取文件，并把内容返回给我</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(path.join(__dirname, <span class="string">&quot;./files/1.txt&quot;</span>), <span class="string">&quot;utf-8&quot;</span>, <span class="function">(<span class="params">err, dataStr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(dataStr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://static.zxinc520.com/blog/20190420/TR4X4SXC6m2m.png?imageslim" alt="mark"></p>
<h3 id="第二步：封装一个读取文件的方法"><a href="#第二步：封装一个读取文件的方法" class="headerlink" title="第二步：封装一个读取文件的方法"></a>第二步：封装一个读取文件的方法</h3><p><strong>封装读取文件的方法.js</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初衷 ：给定文件路径 ，返回读取到的内容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileByPath</span>(<span class="params">fpath</span>) </span>&#123;</span><br><span class="line">  fs.readFile(fpath, <span class="string">&quot;utf-8&quot;</span>, <span class="function">(<span class="params">err, dataStr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataStr;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = getFileByPath(path.join(__dirname, <span class="string">&quot;./files/1.txt&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="http://static.zxinc520.com/blog/20190420/4LrSd5ascJjT.png?imageslim" alt="mark"></p>
<h2 id="解决方案：使用回调函数"><a href="#解决方案：使用回调函数" class="headerlink" title="解决方案：使用回调函数"></a>解决方案：使用回调函数</h2><p><strong>封装读取文件的方法.js</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileByPath</span>(<span class="params">fpath, callback</span>) </span>&#123;</span><br><span class="line">  fs.readFile(fpath, <span class="string">&quot;utf-8&quot;</span>, <span class="function">(<span class="params">err, dataStr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(err);</span><br><span class="line">    &#125;</span><br><span class="line">    callback(dataStr);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFileByPath(path.join(__dirname, <span class="string">&quot;./files/1.txt&quot;</span>), <span class="function">(<span class="params">dataStr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(dataStr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://static.zxinc520.com/blog/20190420/U5MDnc8QChTb.png?imageslim" alt="mark"></p>
<h2 id="封装读取文件的方法–改进："><a href="#封装读取文件的方法–改进：" class="headerlink" title="封装读取文件的方法–改进："></a>封装读取文件的方法–改进：</h2><h4 id="callback-中，设置两个参数（err-dataStr）"><a href="#callback-中，设置两个参数（err-dataStr）" class="headerlink" title="callback 中，设置两个参数（err, dataStr）"></a>callback 中，设置两个参数（err, dataStr）</h4><p><strong>封装读取文件的方法.js</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用回调函数</span></span><br><span class="line"><span class="comment">//我们可以规定一下，callback中，有两个参数，第一个参数是失败的结果，第二个参数是成功的结果</span></span><br><span class="line"><span class="comment">//同时，我们规定了：如果成功后，返回的结果，应该位于callback 参数的第二个位置，此时，第一个位置由于没有出错，所以放一个null，如果失败了则第一个位置放置 Error对象，第二个位置放置一个 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileByPath</span>(<span class="params">fpath, callback</span>) </span>&#123;</span><br><span class="line">  fs.readFile(fpath, <span class="string">&quot;utf-8&quot;</span>, <span class="function">(<span class="params">err, dataStr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(err);</span><br><span class="line">    &#125;</span><br><span class="line">    callback(<span class="literal">null</span>, dataStr);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFileByPath(path.join(__dirname, <span class="string">&quot;./files/1.txt&quot;</span>), <span class="function">(<span class="params">err, dataStr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(err.message);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(dataStr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190420/Gi6Iffxxw1Jk.png?imageslim" alt="mark"></p>
<h2 id="封装读取文件的方法-提高版"><a href="#封装读取文件的方法-提高版" class="headerlink" title="封装读取文件的方法-提高版"></a>封装读取文件的方法-提高版</h2><h4 id="拆分成-两个-回调（getFileByPath-fpath-succCb-errCb-）"><a href="#拆分成-两个-回调（getFileByPath-fpath-succCb-errCb-）" class="headerlink" title="拆分成 两个 回调（getFileByPath (fpath, succCb, errCb)）"></a>拆分成 两个 回调（getFileByPath (fpath, succCb, errCb)）</h4><p><strong>封装读取文件的方法-提高版.js：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用两个回调---便于理解</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileByPath</span>(<span class="params">fpath, succCb, errCb</span>) </span>&#123;</span><br><span class="line">  fs.readFile(fpath, <span class="string">&quot;utf-8&quot;</span>, <span class="function">(<span class="params">err, dataStr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> errCb(err);</span><br><span class="line">    &#125;</span><br><span class="line">    succCb(dataStr);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFileByPath(</span><br><span class="line">  path.join(__dirname, <span class="string">&quot;./files/1.txt&quot;</span>),</span><br><span class="line">  (dataStr) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;成功的结果，使用成功的回调succCb: &quot;</span> + dataStr);</span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;失败的结果，使用失败的回调errCb: &quot;</span> + err.message);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>成功的结果：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190420/OfeQfiHdiJVC.png?imageslim" alt="mark"></p>
<p><strong>失败的结果：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190420/uVvrqObQxNtc.png?imageslim" alt="mark"></p>
<h2 id="回调嵌套"><a href="#回调嵌套" class="headerlink" title="回调嵌套"></a>回调嵌套</h2><h3 id="需求：先读取文件-1，在读取文件-2，最后读取文件-3"><a href="#需求：先读取文件-1，在读取文件-2，最后读取文件-3" class="headerlink" title="需求：先读取文件 1，在读取文件 2，最后读取文件 3"></a>需求：先读取文件 1，在读取文件 2，最后读取文件 3</h3><h6 id="初步实现："><a href="#初步实现：" class="headerlink" title="初步实现："></a><strong><em>初步实现：</em></strong></h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileByPath</span>(<span class="params">fpath, callback</span>) </span>&#123;</span><br><span class="line">  fs.readFile(fpath, <span class="string">&quot;utf-8&quot;</span>, <span class="function">(<span class="params">err, dataStr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(err.message);</span><br><span class="line">    &#125;</span><br><span class="line">    callback(dataStr);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调地狱</span></span><br><span class="line">getFileByPath(path.join(__dirname, <span class="string">&quot;./files/1.txt&quot;</span>), <span class="function">(<span class="params">dataStr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(dataStr);</span><br><span class="line">  getFileByPath(path.join(__dirname, <span class="string">&quot;./files/2.txt&quot;</span>), <span class="function">(<span class="params">dataStr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(dataStr);</span><br><span class="line">    getFileByPath(path.join(__dirname, <span class="string">&quot;./files/3.txt&quot;</span>), <span class="function">(<span class="params">dataStr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(dataStr);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190420/lQlQH83IcW3B.png?imageslim" alt="mark"></p>
<h3 id="使用-Promise"><a href="#使用-Promise" class="headerlink" title="使用 **Promise **:"></a>使用 **Promise **:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileByPath</span>(<span class="params">fpath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(path.join(__dirname, fpath), <span class="string">&quot;utf-8&quot;</span>, <span class="function">(<span class="params">err, dataStr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(dataStr);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFileByPath(<span class="string">&quot;./files/1.txt&quot;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="comment">//读取文件2</span></span><br><span class="line">    <span class="keyword">return</span> getFileByPath(<span class="string">&quot;./files/2.txt&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="comment">//读取文件3</span></span><br><span class="line">    <span class="keyword">return</span> getFileByPath(<span class="string">&quot;./files/3.txt&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.message);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190420/G1arCfeFpYYK.png?imageslim" alt="mark"></p>
<h2 id="Ajax-使用-then-方法高逼格请求数据"><a href="#Ajax-使用-then-方法高逼格请求数据" class="headerlink" title="Ajax 使用 then 方法高逼格请求数据"></a>Ajax 使用 then 方法高逼格请求数据</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/jquery/dist/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">&quot;#btn&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">            url: <span class="string">&quot;./data.json&quot;</span>,</span></span><br><span class="line"><span class="javascript">            type: <span class="string">&quot;get&quot;</span>,</span></span><br><span class="line"><span class="javascript">            dataType: <span class="string">&quot;json&quot;</span>,</span></span><br><span class="line"><span class="javascript">          &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(data);</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://static.zxinc520.com/blog/20190420/Raly4WtVEqEx.gif" alt="mark"></p>
]]></content>
      <categories>
        <category>JS</category>
        <category>异步解决方案</category>
      </categories>
      <tags>
        <tag>promise</tag>
        <tag>异步解决方案</tag>
        <tag>回调地狱</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统进程调度作业</title>
    <url>/2019/05/13/ProcessScheduling/</url>
    <content><![CDATA[<h1 id="操作系统进程调度作业"><a href="#操作系统进程调度作业" class="headerlink" title="操作系统进程调度作业"></a>操作系统进程调度作业</h1><blockquote>
<p>操作系统进程调度作业</p>
<p>锻炼下思维！</p>
</blockquote>
<h2 id="进程调度-1"><a href="#进程调度-1" class="headerlink" title="进程调度 1"></a>进程调度 1</h2><p><strong>问题描述</strong>：</p>
<p>​ 要求输入 3 个进程，找出最先执行的那个进程的进程名。（如果遇到优先级一样，按照输入顺序执行。），本题中，优先数数值大的表示优先级比较高。</p>
<p><strong>输入格式</strong>：</p>
<p>​ 程序要求输入 3 行，以回车符号作为分隔，每行有 3 个数据，以空格作为分隔。首先输入一个字符串（长度小于等于 10），为进程名，第 2 个数据类型为整型，表示进程的优先数，第 3 个数据类型为整型，表示进程的运行时间。</p>
<p><strong>输出格式</strong>：</p>
<p>​ 输出一个字符串，为最先执行进程的进程名。</p>
<p><em>样例输入 1：</em></p>
<p>P1 1 1</p>
<p>P2 2 2</p>
<p>P3 3 3</p>
<p>样例输出 1：</p>
<p>P3</p>
<p><em>样例输入 2：</em></p>
<p>P1 130 10</p>
<p>P2 100 100</p>
<p>P3 100 100</p>
<p>样例输出 2：</p>
<p>P2</p>
<p><strong>链表实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt; //strcpy()</span><br><span class="line">#include &lt;stdlib.h&gt;//malloc()</span><br><span class="line"><span class="keyword">void</span> insertQuestion();</span><br><span class="line"><span class="keyword">void</span> insertNode(char ProcessName[<span class="number">5</span>],int Priority,int Time);</span><br><span class="line"><span class="keyword">void</span> view();</span><br><span class="line"><span class="keyword">void</span> arithmetic();</span><br><span class="line">typedef struct process</span><br><span class="line">&#123;</span><br><span class="line">	char ProcessName[<span class="number">5</span>];</span><br><span class="line">	int Priority;</span><br><span class="line">	int Time;</span><br><span class="line">	struct process *next;</span><br><span class="line">&#125;nodelist;</span><br><span class="line"></span><br><span class="line">nodelist *pHead=NULL;<span class="comment">//存放调度的首节点地址</span></span><br><span class="line"></span><br><span class="line">int main(<span class="keyword">void</span>)&#123;</span><br><span class="line">    insertQuestion();</span><br><span class="line">    arithmetic();</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加问题</span></span><br><span class="line"><span class="keyword">void</span> insertQuestion()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> insertNode(char ProcessName[<span class="number">5</span>],int Priority,int Time);</span><br><span class="line">    char ProcessName[<span class="number">5</span>];</span><br><span class="line">	int Priority;</span><br><span class="line">	int Time;</span><br><span class="line">    int i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	  scanf(<span class="string">&quot;%s&quot;</span>,ProcessName);</span><br><span class="line">	  scanf(<span class="string">&quot;%d&quot;</span>,&amp;Priority);</span><br><span class="line">	  scanf(<span class="string">&quot;%d&quot;</span>,&amp;Time);</span><br><span class="line">	  insertNode(ProcessName,Priority,Time);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据插入链表</span></span><br><span class="line"><span class="keyword">void</span> insertNode(char ProcessName[<span class="number">5</span>],int Priority,int Time)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//申请存储空间</span></span><br><span class="line">	nodelist *pNew=(nodelist *)malloc(sizeof(nodelist));</span><br><span class="line">	nodelist *p,*q;</span><br><span class="line">	strcpy(pNew-&gt;ProcessName,ProcessName);</span><br><span class="line">	pNew-&gt;Priority = Priority;</span><br><span class="line">	pNew-&gt;Time = Time;</span><br><span class="line">	pNew-&gt;next=NULL;</span><br><span class="line">	<span class="comment">// printf(&quot;5\n&quot;);</span></span><br><span class="line">		<span class="keyword">if</span>(pHead==NULL) <span class="comment">//插入前链表为空，新插入的节点为头节点</span></span><br><span class="line">		&#123;</span><br><span class="line">			pHead=pNew;</span><br><span class="line">			<span class="comment">//p1=pHead;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p=pHead;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;next!=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span>(p-&gt;next!=<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">				q=p-&gt;next;</span><br><span class="line">			    p=q;</span><br><span class="line">				&#125;</span><br><span class="line">				p-&gt;next=pNew;</span><br><span class="line">				pNew-&gt;next=NULL;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;next==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				p-&gt;next=pNew;</span><br><span class="line">			    p=pNew;</span><br><span class="line">				pNew-&gt;next=NULL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示链表中的数据</span></span><br><span class="line"><span class="keyword">void</span> view()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 显示所有的结果 */</span></span><br><span class="line">	nodelist *p=pHead;</span><br><span class="line">	<span class="keyword">if</span>(pHead!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">			<span class="keyword">while</span>(p!=NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				printf(<span class="string">&quot;%s &quot;</span>,p-&gt;ProcessName);</span><br><span class="line">				printf(<span class="string">&quot;%d &quot;</span>,p-&gt;Priority);</span><br><span class="line">				printf(<span class="string">&quot;%d &quot;</span>,p-&gt;Time);</span><br><span class="line">				p=p-&gt;next;</span><br><span class="line">				printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  printf(<span class="string">&quot;链表中啥都没有！\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> arithmetic()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//相关算法实现</span></span><br><span class="line">	nodelist *p=pHead;</span><br><span class="line">	int max=p-&gt;Priority;</span><br><span class="line">	int flag=<span class="number">0</span>;</span><br><span class="line">	char firstName[<span class="number">5</span>];</span><br><span class="line">	char ReturnProcessName[<span class="number">5</span>];</span><br><span class="line">	strcpy(firstName,p-&gt;ProcessName);</span><br><span class="line">	<span class="keyword">if</span>(pHead!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">			<span class="keyword">while</span>(p!=NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>( max &lt; (p-&gt;Priority))&#123;</span><br><span class="line">                    max= p-&gt;Priority;</span><br><span class="line">                    strcpy(ReturnProcessName,p-&gt;ProcessName);</span><br><span class="line">					flag=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				p=p-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">		printf(<span class="string">&quot;%s\n&quot;</span>,ReturnProcessName);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		printf(<span class="string">&quot;%s\n&quot;</span>,firstName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190513/liF2w98LPKem.gif" alt="mark"></p>
<p>​ <img src="http://static.zxinc520.com/blog/20190513/XXOxTOQJ8P0H.gif" alt="mark"></p>
<h2 id="进程调度-2"><a href="#进程调度-2" class="headerlink" title="进程调度 2"></a>进程调度 2</h2><p><strong>问题描述</strong>：</p>
<p>​ 要求输入 N 个进程（0&lt;N&lt;=100），找出最后执行的那个进程的进程名。（如果遇到优先级一样，按照输入顺序执行。），本题中，优先数数值较高的优先级也较高。</p>
<p><strong>输入格式</strong>：</p>
<p>​ 程序首先要求输入一个整型值 N，接下来输入为 N 行，以回车符号作为分隔，每行有 3 个数据，以空格作为分隔。首先输入一个字符串（长度小于等于 10），该字符串为进程名。第 2 个数据类型为整型，表示进程的优先数。第 3 个数据类型为整型，表示进程的运行时间。</p>
<p><strong>输出格式：</strong></p>
<p>​ 输出一个字符串，为最后执行进程的进程名。</p>
<p><em>样例输入 1：</em></p>
<p>3</p>
<p>P1 1 1</p>
<p>P2 2 2</p>
<p>P3 3 3</p>
<p>样例输出 1：</p>
<p>P3</p>
<p><em>样例输入 2：</em></p>
<p>2</p>
<p>P1 10 10</p>
<p>P2 100 100</p>
<p>样例输出 2：</p>
<p>P2</p>
<p><strong>源代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt; //strcpy()</span><br><span class="line">#include &lt;stdlib.h&gt;//malloc()</span><br><span class="line"><span class="keyword">void</span> insertQuestion();</span><br><span class="line"><span class="keyword">void</span> insertNode(char ProcessName[<span class="number">5</span>],int Priority,int Time);</span><br><span class="line"><span class="keyword">void</span> view();</span><br><span class="line"><span class="keyword">void</span> arithmetic();</span><br><span class="line">typedef struct process</span><br><span class="line">&#123;</span><br><span class="line">	char ProcessName[<span class="number">5</span>];</span><br><span class="line">	int Priority;</span><br><span class="line">	int Time;</span><br><span class="line">	struct process *next;</span><br><span class="line">&#125;nodelist;</span><br><span class="line"></span><br><span class="line">nodelist *pHead=NULL;<span class="comment">//存放调度的首节点地址</span></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    insertQuestion();</span><br><span class="line">    arithmetic();</span><br><span class="line">    <span class="comment">// view();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加问题</span></span><br><span class="line"><span class="keyword">void</span> insertQuestion()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> insertNode(char ProcessName[<span class="number">5</span>],int Priority,int Time);</span><br><span class="line">    char ProcessName[<span class="number">5</span>];</span><br><span class="line">	int Priority;</span><br><span class="line">	int Time;</span><br><span class="line">    int i=<span class="number">0</span>;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	  scanf(<span class="string">&quot;%s %d %d&quot;</span>,ProcessName,&amp;Priority,&amp;Time);</span><br><span class="line">	  insertNode(ProcessName,Priority,Time);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据插入链表</span></span><br><span class="line"><span class="keyword">void</span> insertNode(char ProcessName[<span class="number">5</span>],int Priority,int Time)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//申请存储空间</span></span><br><span class="line">	nodelist *pNew=(nodelist *)malloc(sizeof(nodelist));</span><br><span class="line">	nodelist *p,*q;</span><br><span class="line">	strcpy(pNew-&gt;ProcessName,ProcessName);</span><br><span class="line">	pNew-&gt;Priority = Priority;</span><br><span class="line">	pNew-&gt;Time = Time;</span><br><span class="line">	pNew-&gt;next=NULL;</span><br><span class="line">	<span class="comment">// printf(&quot;5\n&quot;);</span></span><br><span class="line">		<span class="keyword">if</span>(pHead==NULL) <span class="comment">//插入前链表为空，新插入的节点为头节点</span></span><br><span class="line">		&#123;</span><br><span class="line">			pHead=pNew;</span><br><span class="line">			<span class="comment">//p1=pHead;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//将地址为pNew的节点插入到首地址为pHead的链表的尾部</span></span><br><span class="line">			<span class="comment">/*p1-&gt;next=pNew;</span></span><br><span class="line"><span class="comment">			p1=pNew;</span></span><br><span class="line"><span class="comment">			pNew-&gt;next=NULL;*/</span></span><br><span class="line">			p=pHead;</span><br><span class="line">			<span class="comment">//q=(nodelist *)malloc(sizeof(nodelist));</span></span><br><span class="line">			<span class="keyword">if</span>(p-&gt;next!=<span class="number">0</span>)     <span class="comment">//文件不为空，即pHead后面有数据</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span>(p-&gt;next!=<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">				q=p-&gt;next;</span><br><span class="line">			    p=q;</span><br><span class="line">				&#125;</span><br><span class="line">				p-&gt;next=pNew;</span><br><span class="line">				pNew-&gt;next=NULL;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;next==<span class="number">0</span>) <span class="comment">//只有头结点，即pHead后面无数据</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//将地址为pNew的节点插入到首地址为pHead的链表的尾部</span></span><br><span class="line">				p-&gt;next=pNew;</span><br><span class="line">			    p=pNew;</span><br><span class="line">				pNew-&gt;next=NULL;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示链表中的数据</span></span><br><span class="line"><span class="keyword">void</span> view()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 显示所有的结果 */</span></span><br><span class="line">	nodelist *p=pHead;</span><br><span class="line">	<span class="keyword">if</span>(pHead!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">			<span class="keyword">while</span>(p!=NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				printf(<span class="string">&quot;%s &quot;</span>,p-&gt;ProcessName);</span><br><span class="line">				printf(<span class="string">&quot;%d &quot;</span>,p-&gt;Priority);</span><br><span class="line">				printf(<span class="string">&quot;%d &quot;</span>,p-&gt;Time);</span><br><span class="line">				p=p-&gt;next;</span><br><span class="line">				printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  printf(<span class="string">&quot;链表中啥都没有！\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> arithmetic()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//相关算法实现</span></span><br><span class="line">	nodelist *p=pHead;</span><br><span class="line">	nodelist *q=pHead;</span><br><span class="line">	nodelist *m=pHead;</span><br><span class="line">	int max=p-&gt;Priority;</span><br><span class="line">	int flag=<span class="number">0</span>;</span><br><span class="line">	int i;</span><br><span class="line">	int sum=<span class="number">0</span>;</span><br><span class="line">	char firstName[<span class="number">5</span>];</span><br><span class="line">	char ReturnProcessName[<span class="number">5</span>];</span><br><span class="line">	char FinallProcessName[<span class="number">5</span>];</span><br><span class="line">	strcpy(ReturnProcessName,p-&gt;ProcessName);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pHead!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(m!=<span class="number">0</span>)&#123;</span><br><span class="line">		sum+=m-&gt;Time;</span><br><span class="line">	    m=m-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sum; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(p!=NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>( max &lt; (p-&gt;Priority) &amp;&amp; (p-&gt;Time&gt;<span class="number">0</span>))&#123;</span><br><span class="line">                    max= p-&gt;Priority;</span><br><span class="line">                    strcpy(ReturnProcessName,p-&gt;ProcessName);</span><br><span class="line">					flag=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				p=p-&gt;next;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">				  	<span class="keyword">while</span>(q!=NULL)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">if</span>(strcmp(q-&gt;ProcessName,ReturnProcessName) == <span class="number">0</span>)&#123;</span><br><span class="line">                                strcpy(FinallProcessName,q-&gt;ProcessName);</span><br><span class="line">								q-&gt;Priority--;</span><br><span class="line">								q-&gt;Time--;</span><br><span class="line">							&#125;</span><br><span class="line">							q=q-&gt;next;</span><br><span class="line">						&#125;</span><br><span class="line">					p=pHead;</span><br><span class="line">					q=pHead;</span><br><span class="line">					max=p-&gt;Priority;</span><br><span class="line">					strcpy(ReturnProcessName,p-&gt;ProcessName);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">			printf(<span class="string">&quot;%s\n&quot;</span>,FinallProcessName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190513/HbsJqnfhPfHR.gif" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190513/Ge7alyBXmauM.gif" alt="mark"></p>
<h2 id="进程调度-3"><a href="#进程调度-3" class="headerlink" title="进程调度 3"></a>进程调度 3</h2><p><strong>问题描述</strong>：</p>
<p>​ 要求输入 N 个进程（N 为正整型数，0&lt;N&lt;=25535），输出按照优先级从高到低执行的进程名字符串序列,直至结束。（如果遇到优先级一样，按照输入顺序先后执行。），本题中，优先数数值较高的进程，优先级也较高。</p>
<p><strong>输入格式</strong>：</p>
<p>​ 程序首先要求输入一个整型变量 N，接下来输入为 N 行，以回车符号作为分隔，每行有 3 个数据，以空格作为分隔。首先输入一个字符串（长度小于等于 10），该字符串为进程名。第 2 个数据类型为整型，表示进程的优先数。第 3 个数据类型为整型，表示进程的运行时间。</p>
<p><strong>输出格式</strong>：</p>
<p>​ 输出 1 行，M 个字符串，字符串之间用空格作为分隔。</p>
<p>样例输入 1：</p>
<p>3</p>
<p>P1 1 1</p>
<p>P2 2 2</p>
<p>P3 3 3</p>
<p>样例输出 1：</p>
<p>P3 P2 P3 P1 P2 P3</p>
<p>样例输入 2：</p>
<p>2</p>
<p>P1 3 3</p>
<p>P2 1 1</p>
<p>样例输出 2：</p>
<p>P1 P1 P1 P2</p>
<p>样例输入 3：</p>
<p>100</p>
<p>P0 0 1 P1 1 1 P2 2 1 P3 3 1 P4 4 1 P5 5 1 P6 6 1 P7 7 1 P8 8 1 P9 9 1 P10 10 1 P11 11 1 P12 12 1 P13 13 1 P14 14 1 P15 15 1 P16 16 1 P17 17 1 P18 18 1 P19 19 1 P20 20 1 P21 21 1 P22 22 1 P23 23 1 P24 24 1 P25 25 1 P26 26 1 P27 27 1 P28 28 1 P29 29 1 P30 30 1 P31 31 1 P32 32 1 P33 33 1 P34 34 1 P35 35 1 P36 36 1 P37 37 1 P38 38 1 P39 39 1 P40 40 1 P41 41 1 P42 42 1 P43 43 1 P44 44 1 P45 45 1 P46 46 1 P47 47 1 P48 48 1 P49 49 1 P50 50 1 P51 51 1 P52 52 1 P53 53 1 P54 54 1 P55 55 1 P56 56 1 P57 57 1 P58 58 1 P59 59 1 P60 60 1 P61 61 1 P62 62 1 P63 63 1 P64 64 1 P65 65 1 P66 66 1 P67 67 1 P68 68 1 P69 69 1 P70 70 1 P71 71 1 P72 72 1 P73 73 1 P74 74 1 P75 75 1 P76 76 1 P77 77 1 P78 78 1 P79 79 1 P80 80 1 P81 81 1 P82 82 1 P83 83 1 P84 84 1 P85 85 1 P86 86 1 P87 87 1 P88 88 1 P89 89 1 P90 90 1 P91 91 1 P92 92 1 P93 93 1 P94 94 1 P95 95 1 P96 96 1 P97 97 1 P98 98 1 P99 99 1</p>
<p>样例输出 3：</p>
<p>P100 P99 P98 P97 P96 P95 P94 P93 P92 P91 P90 P89 P88 P87 P86 P85 P84 P83 P82 P81 P80 P79 P78 P77 P76 P75 P74 P73 P72 P71 P70 P69 P68 P67 P66 P65 P64 P63 P62 P61 P60 P59 P58 P57 P56 P55 P54 P53 P52 P51 P50 P49 P48 P47 P46 P45 P44 P43 P42 P41 P40 P39 P38 P37 P36 P35 P34 P33 P32 P31 P30 P29 P28 P27 P26 P25 P24 P23 P22 P21 P20 P19 P18 P17 P16 P15 P14 P13 P12 P11 P10 P9 P8 P7 P6 P5 P4 P3 P2 P1</p>
<p><strong>源代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt; //strcpy()</span><br><span class="line">#include&lt;stdlib.h&gt;//malloc()</span><br><span class="line"><span class="keyword">void</span> insertQuestion();</span><br><span class="line"><span class="keyword">void</span> insertNode(char ProcessName[<span class="number">5</span>],int Priority,int Time);</span><br><span class="line"><span class="keyword">void</span> view();</span><br><span class="line"><span class="keyword">void</span> arithmetic();</span><br><span class="line">typedef struct process</span><br><span class="line">&#123;</span><br><span class="line">	char ProcessName[<span class="number">5</span>];</span><br><span class="line">	int Priority;</span><br><span class="line">	int Time;</span><br><span class="line">	struct process *next;</span><br><span class="line">&#125;nodelist;</span><br><span class="line"></span><br><span class="line">nodelist *pHead=NULL;<span class="comment">//存放调度的首节点地址</span></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    insertQuestion();</span><br><span class="line">    arithmetic();</span><br><span class="line">    <span class="comment">// view();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加问题</span></span><br><span class="line"><span class="keyword">void</span> insertQuestion()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> insertNode(char ProcessName[<span class="number">5</span>],int Priority,int Time);</span><br><span class="line">    char ProcessName[<span class="number">5</span>];</span><br><span class="line">	int Priority;</span><br><span class="line">	int Time;</span><br><span class="line">    int i=<span class="number">0</span>;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	  scanf(<span class="string">&quot;%s %d %d&quot;</span>,ProcessName,&amp;Priority,&amp;Time);</span><br><span class="line">	  insertNode(ProcessName,Priority,Time);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据插入链表</span></span><br><span class="line"><span class="keyword">void</span> insertNode(char ProcessName[<span class="number">5</span>],int Priority,int Time)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//申请存储空间</span></span><br><span class="line">	nodelist *pNew=(nodelist *)malloc(sizeof(nodelist));</span><br><span class="line">	nodelist *p,*q;</span><br><span class="line">	strcpy(pNew-&gt;ProcessName,ProcessName);</span><br><span class="line">	pNew-&gt;Priority = Priority;</span><br><span class="line">	pNew-&gt;Time = Time;</span><br><span class="line">	pNew-&gt;next=NULL;</span><br><span class="line">	<span class="comment">// printf(&quot;5\n&quot;);</span></span><br><span class="line">		<span class="keyword">if</span>(pHead==NULL) <span class="comment">//插入前链表为空，新插入的节点为头节点</span></span><br><span class="line">		&#123;</span><br><span class="line">			pHead=pNew;</span><br><span class="line">			<span class="comment">//p1=pHead;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//将地址为pNew的节点插入到首地址为pHead的链表的尾部</span></span><br><span class="line">			<span class="comment">/*p1-&gt;next=pNew;</span></span><br><span class="line"><span class="comment">			p1=pNew;</span></span><br><span class="line"><span class="comment">			pNew-&gt;next=NULL;*/</span></span><br><span class="line">			p=pHead;</span><br><span class="line">			<span class="comment">//q=(nodelist *)malloc(sizeof(nodelist));</span></span><br><span class="line">			<span class="keyword">if</span>(p-&gt;next!=<span class="number">0</span>)     <span class="comment">//文件不为空，即pHead后面有数据</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span>(p-&gt;next!=<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">				q=p-&gt;next;</span><br><span class="line">			    p=q;</span><br><span class="line">				&#125;</span><br><span class="line">				p-&gt;next=pNew;</span><br><span class="line">				pNew-&gt;next=NULL;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;next==<span class="number">0</span>) <span class="comment">//只有头结点，即pHead后面无数据</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//将地址为pNew的节点插入到首地址为pHead的链表的尾部</span></span><br><span class="line">				p-&gt;next=pNew;</span><br><span class="line">			    p=pNew;</span><br><span class="line">				pNew-&gt;next=NULL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示链表中的数据</span></span><br><span class="line"><span class="keyword">void</span> view()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 显示所有的结果 */</span></span><br><span class="line">	nodelist *p=pHead;</span><br><span class="line">	<span class="keyword">if</span>(pHead!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">			<span class="keyword">while</span>(p!=NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				printf(<span class="string">&quot;%s &quot;</span>,p-&gt;ProcessName);</span><br><span class="line">				printf(<span class="string">&quot;%d &quot;</span>,p-&gt;Priority);</span><br><span class="line">				printf(<span class="string">&quot;%d &quot;</span>,p-&gt;Time);</span><br><span class="line">				p=p-&gt;next;</span><br><span class="line">				printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  printf(<span class="string">&quot;链表中啥都没有！\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> arithmetic()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//相关算法实现</span></span><br><span class="line">	nodelist *p=pHead;</span><br><span class="line">	nodelist *q=pHead;</span><br><span class="line">	nodelist *m=pHead;</span><br><span class="line">	int max=p-&gt;Priority;</span><br><span class="line">	int flag=<span class="number">0</span>;</span><br><span class="line">	int i;</span><br><span class="line">	int sum=<span class="number">0</span>;</span><br><span class="line">	char firstName[<span class="number">5</span>];</span><br><span class="line">	char ReturnProcessName[<span class="number">5</span>];</span><br><span class="line">	strcpy(ReturnProcessName,p-&gt;ProcessName);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pHead!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(m!=<span class="number">0</span>)&#123;</span><br><span class="line">		sum+=m-&gt;Time;</span><br><span class="line">	    m=m-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// printf(&quot;1\n&quot;);</span></span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;,sum);</span></span><br><span class="line">    <span class="comment">// printf(&quot;2\n&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sum; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(p!=NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>( max &lt; (p-&gt;Priority) &amp;&amp; (p-&gt;Time&gt;<span class="number">0</span>))&#123;</span><br><span class="line">                    max= p-&gt;Priority;</span><br><span class="line">                    strcpy(ReturnProcessName,p-&gt;ProcessName);</span><br><span class="line">					flag=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				p=p-&gt;next;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">					<span class="comment">// printf(&quot;ReturnProcessName:%s\n&quot;, ReturnProcessName);</span></span><br><span class="line">                    <span class="comment">//printf(&quot;q-&gt;ProcessName:%s\n&quot;,q-&gt;ProcessName);</span></span><br><span class="line">                    <span class="comment">//printf(&quot;\n&quot;);</span></span><br><span class="line">				  	<span class="keyword">while</span>(q!=NULL)</span><br><span class="line">						&#123;</span><br><span class="line">							 <span class="comment">// printf(&quot;ReturnProcessName:%s\n&quot;, ReturnProcessName);</span></span><br><span class="line">      						 <span class="comment">// printf(&quot;q-&gt;ProcessName:%s\n&quot;,q-&gt;ProcessName);</span></span><br><span class="line">							<span class="keyword">if</span>(strcmp(q-&gt;ProcessName,ReturnProcessName) == <span class="number">0</span>)&#123;</span><br><span class="line">								printf(<span class="string">&quot;%s &quot;</span>,q-&gt;ProcessName);</span><br><span class="line">								q-&gt;Priority--;</span><br><span class="line">								q-&gt;Time--;</span><br><span class="line">							&#125;</span><br><span class="line">							q=q-&gt;next;</span><br><span class="line">						&#125;</span><br><span class="line">					p=pHead;</span><br><span class="line">					q=pHead;</span><br><span class="line">					max=p-&gt;Priority;</span><br><span class="line">					<span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">					<span class="comment">// view();</span></span><br><span class="line">					<span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line"></span><br><span class="line">					strcpy(ReturnProcessName,p-&gt;ProcessName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190513/fWvr6o5WnCac.gif" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190513/UBx2BDfscUbD.gif" alt="mark"></p>
<h2 id="进程调度-4：时间片轮转"><a href="#进程调度-4：时间片轮转" class="headerlink" title="进程调度 4：时间片轮转"></a>进程调度 4：时间片轮转</h2><p><strong>问题描述</strong>：</p>
<p>​ 要求输入 N 个进程（0&lt;N&lt;=100），输入时间片 M（0&lt;M〈=5），按照进程输入的顺序以时间片轮转的方法输出指定的第 K 轮（K&gt;0）执行的那个进程的进程名。</p>
<p><strong>输入格式</strong>：</p>
<p>​ 程序首先输入一个正整数 M（0&lt;M〈=5）作为时间片，下一行输入一个正整数 N（0&lt;N&lt;=100），接下来输入为 N 行，以回车符号作为分隔，每行有 2 个数据，以空格作为分隔。第一个数据是字符串（长度小于等于 10），该字符串为进程名，第 2 个数据类型为整型，表示该进程需要的运行时间。最后输入一个正整数 K，作为时间片轮转的次数（次数从 1 开始计数）。</p>
<p><strong>输出格式</strong>：</p>
<p>​ 输出一个字符串，为最后执行进程的进程名；若无进程运行，则输出“over”（不含双引号，所有字母皆为小写）。</p>
<p>样例输入 1：</p>
<p>1</p>
<p>3</p>
<p>P1 1</p>
<p>P2 2</p>
<p>P3 3</p>
<p>3</p>
<p>样例输出 1：P3</p>
<p>样例输入 2：</p>
<p>1</p>
<p>3</p>
<p>P1 1</p>
<p>P2 2</p>
<p>P3 3</p>
<p>10</p>
<p>样例输出 2：over</p>
<p>样例输入 3：</p>
<p>2</p>
<p>3</p>
<p>P1 1</p>
<p>P2 2</p>
<p>P3 3</p>
<p>4</p>
<p>样例输出 3：P3</p>
<p><em>代码展示：</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt; //strcpy()</span><br><span class="line">#include&lt;stdlib.h&gt;//malloc()</span><br><span class="line"><span class="keyword">void</span> insertQuestion();</span><br><span class="line"> <span class="keyword">void</span> insertNode(char ProcessName[<span class="number">5</span>],int Time);</span><br><span class="line"><span class="keyword">void</span> view();</span><br><span class="line"><span class="keyword">void</span> arithmetic(int M,int n,int count);</span><br><span class="line">typedef struct process</span><br><span class="line">&#123;</span><br><span class="line">    char ProcessName[<span class="number">5</span>];</span><br><span class="line">    int Priority;</span><br><span class="line">    int Time;</span><br><span class="line">    struct process *next;</span><br><span class="line">&#125;nodelist;</span><br><span class="line"></span><br><span class="line">nodelist *pHead=NULL;<span class="comment">//存放调度的首节点地址</span></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    insertQuestion();</span><br><span class="line">    <span class="comment">// view();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加问题</span></span><br><span class="line"><span class="keyword">void</span> insertQuestion()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> insertNode(char ProcessName[<span class="number">5</span>],int Time);</span><br><span class="line">	<span class="keyword">void</span> arithmetic(int M,int n,int count);</span><br><span class="line">    char ProcessName[<span class="number">5</span>];</span><br><span class="line">    int Priority;</span><br><span class="line">    int Time;</span><br><span class="line">    int i=<span class="number">0</span>;</span><br><span class="line">    int n;</span><br><span class="line">	int M;</span><br><span class="line">	int count;</span><br><span class="line">	scanf(<span class="string">&quot;%d&quot;</span>,&amp;M);</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      scanf(<span class="string">&quot;%s %d&quot;</span>,ProcessName,&amp;Time);</span><br><span class="line">      insertNode(ProcessName,Time);</span><br><span class="line">    &#125;</span><br><span class="line">	scanf(<span class="string">&quot;%d&quot;</span>,&amp;count);</span><br><span class="line">	arithmetic(M,n,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据插入链表</span></span><br><span class="line"><span class="keyword">void</span> insertNode(char ProcessName[<span class="number">5</span>],int Time)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//申请存储空间</span></span><br><span class="line">    nodelist *pNew=(nodelist *)malloc(sizeof(nodelist));</span><br><span class="line">    nodelist *p,*q;</span><br><span class="line">    strcpy(pNew-&gt;ProcessName,ProcessName);</span><br><span class="line">    pNew-&gt;Time = Time;</span><br><span class="line">    pNew-&gt;next=NULL;</span><br><span class="line">    <span class="comment">// printf(&quot;5\n&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(pHead==NULL) <span class="comment">//插入前链表为空，新插入的节点为头节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            pHead=pNew;</span><br><span class="line">            <span class="comment">//p1=pHead;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将地址为pNew的节点插入到首地址为pHead的链表的尾部</span></span><br><span class="line">            <span class="comment">/*p1-&gt;next=pNew;</span></span><br><span class="line"><span class="comment">            p1=pNew;</span></span><br><span class="line"><span class="comment">            pNew-&gt;next=NULL;*/</span></span><br><span class="line">            p=pHead;</span><br><span class="line">            <span class="comment">//q=(nodelist *)malloc(sizeof(nodelist));</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next!=<span class="number">0</span>)     <span class="comment">//文件不为空，即pHead后面有数据</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(p-&gt;next!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                q=p-&gt;next;</span><br><span class="line">                p=q;</span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;next=pNew;</span><br><span class="line">                pNew-&gt;next=NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;next==<span class="number">0</span>) <span class="comment">//只有头结点，即pHead后面无数据</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//将地址为pNew的节点插入到首地址为pHead的链表的尾部</span></span><br><span class="line">                p-&gt;next=pNew;</span><br><span class="line">                p=pNew;</span><br><span class="line">                pNew-&gt;next=NULL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示链表中的数据</span></span><br><span class="line"><span class="keyword">void</span> view()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 显示所有的结果 */</span></span><br><span class="line">    nodelist *p=pHead;</span><br><span class="line">    <span class="keyword">if</span>(pHead!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">while</span>(p!=NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(<span class="string">&quot;%s &quot;</span>,p-&gt;ProcessName);</span><br><span class="line">                printf(<span class="string">&quot;%d &quot;</span>,p-&gt;Time);</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      printf(<span class="string">&quot;链表中啥都没有！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> arithmetic(int M,int n,int count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//相关算法实现</span></span><br><span class="line">    nodelist *p=pHead;</span><br><span class="line">    int index=<span class="number">0</span>;</span><br><span class="line">    int i=<span class="number">0</span>;</span><br><span class="line">    int forcount=<span class="number">0</span>;</span><br><span class="line">    int Numcount=<span class="number">0</span>;</span><br><span class="line">    int sum=<span class="number">0</span>;</span><br><span class="line">    int flag=<span class="number">0</span>;</span><br><span class="line">    int finallyNum=<span class="number">0</span>;</span><br><span class="line">	 <span class="comment">// printf(&quot;%d %d %d\n&quot;,M,n,count);</span></span><br><span class="line">     <span class="comment">// printf(&quot;%d\n&quot;,count/n);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(count%n==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        forcount=count/n;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        forcount=count/n+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// printf(&quot;forcount:%d\n&quot;, forcount);</span></span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; forcount; i++)</span><br><span class="line">         &#123;</span><br><span class="line">                    <span class="keyword">while</span>(p!=NULL)</span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(p-&gt;Time&gt;<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                            p-&gt;Time=p-&gt;Time - M;</span><br><span class="line">                            <span class="comment">// printf(&quot;%s\n&quot;,p-&gt;ProcessName);</span></span><br><span class="line">                            <span class="comment">// view();</span></span><br><span class="line">                            <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">                            Numcount++;</span><br><span class="line">                            <span class="comment">// printf(&quot;%d\n&quot;,Numcount);</span></span><br><span class="line">                            finallyNum=Numcount;</span><br><span class="line">                            <span class="keyword">if</span> (Numcount==count)</span><br><span class="line">                            &#123;</span><br><span class="line">                              printf(<span class="string">&quot;%s\n&quot;</span>,p-&gt;ProcessName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                         p=p-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p=pHead;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="keyword">if</span>(finallyNum &lt; count)&#123;</span><br><span class="line">   printf(<span class="string">&quot;over\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190522/EE00fbgzk6Ho.gif" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190522/FAQDVGbxoawJ.gif" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190522/ddwSvMe4TwsW.gif" alt="mark"></p>
<hr>
<h2 id="存储管理-1"><a href="#存储管理-1" class="headerlink" title="存储管理 1"></a>存储管理 1</h2><p><strong>问题描述</strong>：</p>
<p>​ 现有一个 8*8 的存储器，要对其空间进行分配。（下标从 0 开始，最后一个内存块下标为 63）。现已有块号为 1、7、13、23、47、59 的几个内存块被占用。现操作系统要求申请 N 块内存空间（0&lt;N&lt;=64），当输入的块数 N 超出其剩余空闲块数的时候，输出为“false”，当输入为合理范围的时候，就输出其以行主序分配的最后一个内存空间的下标。</p>
<p><strong>输入格式：</strong></p>
<p>​ 程序要求输入一个整型数 N，表示要申请分配空间的大小。</p>
<p><strong>输出格式</strong>：</p>
<p>​ 输出为一个整型数，表示最后一个被分配空间的下标。</p>
<p>样例输入 1：</p>
<p>3</p>
<p>样例输出 1：</p>
<p>3</p>
<p>样例输入 2：</p>
<p>100</p>
<p>样例输出 2：</p>
<p>false</p>
<p>样例输入 3：</p>
<p>50</p>
<p>样例输出 3：</p>
<p>54</p>
<p>_源代码_：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int arr[<span class="number">64</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    int i=<span class="number">0</span>;</span><br><span class="line">    int n;</span><br><span class="line">    int count=<span class="number">0</span>;</span><br><span class="line">    arr[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">7</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">13</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">23</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">47</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">59</span>]=<span class="number">1</span>;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span> (n&gt;<span class="number">58</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	printf(<span class="string">&quot;false\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	 <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n+<span class="number">1</span>; i++)</span><br><span class="line">		    &#123;</span><br><span class="line">		    	<span class="keyword">if</span> (arr[i]==<span class="number">1</span>)</span><br><span class="line">		    	&#123;</span><br><span class="line">		    		count++;</span><br><span class="line">		   		&#125;</span><br><span class="line">		 	&#125;</span><br><span class="line"> 	printf(<span class="string">&quot;%d\n&quot;</span>, count+n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190522/fhJf38dsniWT.gif" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190522/G8b9fg3D0LVM.gif" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190522/cy8XL8vNxJrJ.gif" alt="mark"></p>
<h2 id="存储管理-2"><a href="#存储管理-2" class="headerlink" title="存储管理 2"></a>存储管理 2</h2><p><strong>问题描述</strong>：</p>
<p>​ 现有一个 8*8 的存储器，要对其空间进行分配。（下标从 0 开始，最后一个内存块下标为 63）。现已有块号为 2、7、13、23、37、47、59、61 的几个内存块被占用。要求输入需分配的进程数 M（0&lt;M&lt;=56），接下来输入为 M 个整型数，每个数为各个进程需占用的内存块数。当分配到某进程时，其剩余空闲块数可以分配，就输出当前进程分配的最后一个内存空间的下标。当分配到某进程时，其进程块数超出剩余空闲块数无法分配，输出为“false”（不含双引号，且为全小写）。输出的多个下标（或”false”）之间用空格隔开。</p>
<p><strong>输入格式</strong>：</p>
<p>​ 程序输入分为两行，第一行要求输入一个整型数 M，表示要所需分配空间的进程数，接下来的第二行输入 M 个整型数，每个数之间用空格隔开，表示 M 个进程每个进程占用的内存空间大小。</p>
<p><strong>输出格式：</strong></p>
<p>​ 输出为 M 组整型数（或”false”），每个整型数表示该进程最后一个被分配的内存空间的下标（或”false”），下标（或”false”）之间用空格隔开。</p>
<p>样例输入 1：</p>
<p>3</p>
<p>3 3 3</p>
<p>样例输出 1：</p>
<p>3 6 10</p>
<p>样例输入 2：</p>
<p>4</p>
<p>3 3 64 3</p>
<p>样例输出 2：</p>
<p>3 6 false 10</p>
<p><em>源代码：</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span> funsave(int n,int arr[<span class="number">64</span>],int residue);</span><br><span class="line">    int arr[<span class="number">64</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    int num[<span class="number">200</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    int inputnum;</span><br><span class="line">    int i=<span class="number">0</span>;</span><br><span class="line">    int x[<span class="number">64</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    int sumsheng=<span class="number">56</span>;</span><br><span class="line">    char thirdName[<span class="number">10</span>];</span><br><span class="line">    char str[<span class="number">10</span>];</span><br><span class="line">    int getInTStr;</span><br><span class="line">    arr[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">7</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">13</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">23</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">37</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">41</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">47</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">59</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">61</span>]=<span class="number">1</span>;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;inputnum);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inputnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d&quot;</span>,&amp;num[i]);</span><br><span class="line">        <span class="keyword">if</span> (sumsheng&gt;num[i])</span><br><span class="line">        &#123;</span><br><span class="line">           sumsheng=sumsheng-num[i];</span><br><span class="line">        &#125;</span><br><span class="line">      x[i]=sumsheng;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inputnum; i++)</span><br><span class="line">     &#123;</span><br><span class="line">      funsave(num[i],arr,x[i]);</span><br><span class="line">     &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> funsave(int n,int arr[<span class="number">64</span>],int residue)&#123;</span><br><span class="line">    int i=<span class="number">0</span>;</span><br><span class="line">    int count=<span class="number">0</span>;</span><br><span class="line">    int indexI=<span class="number">0</span>;</span><br><span class="line">    int flag=<span class="number">0</span>;</span><br><span class="line">    int arr1[<span class="number">20</span>];</span><br><span class="line">    int arr2[<span class="number">20</span>];</span><br><span class="line">    int finallyIndex=<span class="number">0</span>;</span><br><span class="line">    int arrindex=<span class="number">0</span>;</span><br><span class="line">    int arrindex2=<span class="number">0</span>;</span><br><span class="line">   <span class="comment">// printf(&quot;start n:%d\n&quot;,n);</span></span><br><span class="line">    <span class="comment">// printf(&quot;getInTStr:%d\n&quot;,getInTStr);</span></span><br><span class="line">  <span class="keyword">if</span> (n&gt;residue)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(<span class="string">&quot;false &quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (arr[<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (arr[i]==<span class="number">1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            count++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count+n; i++)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr2[arrindex2]=i;</span><br><span class="line">                arrindex2++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[i]=<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         printf(<span class="string">&quot;%d &quot;</span>, n+count<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (arr[i]==<span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            indexI=i;</span><br><span class="line">            goto LOOP;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       LOOP:<span class="keyword">for</span>(i=indexI;i&lt;indexI+n;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span> (arr[i]==<span class="number">1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            count++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = indexI; i &lt; indexI+count+n; i++)</span><br><span class="line">         &#123;</span><br><span class="line">          <span class="keyword">if</span> (arr[i]==<span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            finallyIndex=i;</span><br><span class="line">            arr1[arrindex]=i;</span><br><span class="line">          arrindex=arrindex+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">            arr[i]=<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         printf(<span class="string">&quot;%d &quot;</span>, finallyIndex);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190523/iyJhP4Rqt9KS.gif" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190523/ri4eCOgCqxI1.gif" alt="mark"></p>
<h2 id="储存管理-3"><a href="#储存管理-3" class="headerlink" title="储存管理 3"></a>储存管理 3</h2><p><strong>问题描述：</strong></p>
<p>​ 现有一个 8*8 的存储器，要对其已分配的空间进行分配及回收。（下标从 0 开始，最后一个内存块下标为 63）。现已有块号为 2、7、13、23、37、41、47、59、61 的几个内存块被占用。要求输入需分配的进程数 M（0&lt;M&lt;=55），接下来输入为 M 个整型数，每个数为各个进程需占用的内存块数。当分配到某进程时，其剩余空闲块数可以分配，就输出当前进程分配的最后一个内存空间的下标。当分配到某进程时，其进程块数超出剩余空闲块数无法分配，输出为“false”（不含双引号，且为全小写）。输出的多个下标（或”false”）之间用空格隔开。以上进程不管是否分配成功，按照输入顺序依次命名为 p1、p2、p3………pM。回收的时候输入进程名 pN，则返回进程名为 pN 的所有占用内存块号下标，如果该进程名不存在或输入的数值为不合理范围，则返回“false”。</p>
<p><strong>输入格式：</strong></p>
<p>​ 程序输入分为三行，第一行是一个整型数 M，表示要所需分配空间的进程数，第二行为 M 个整型数，每个数之间用空格隔开，表示 M 个进程每个进程占用的内存空间大小。第三行为需要回收的进程名 pN，p 为小写字母，N 为正整型数。</p>
<p><strong>输出格式：</strong></p>
<p>​ 输出为两行，第一行为一组整型数，每个整型数表示该进程最后一个被分配的内存空间的下标，下标之间用空格隔开。第二行为一组整型数，表示被回收的进程的内存块下标，多个下标之间用空格隔开。</p>
<p>样例输入 1：</p>
<p>3</p>
<p>3 3 3</p>
<p>p3</p>
<p>样例输出 1：</p>
<p>3 6 10</p>
<p>8 9 10</p>
<p>样例输入 2：</p>
<p>4</p>
<p>3 3 64 3</p>
<p>p3</p>
<p>样例输出 2：</p>
<p>3 6 false 10</p>
<p>false</p>
<p><em>源代码：</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int *funsave(int n,int arr[<span class="number">64</span>],int residue,int getInTStr,int indexflag,int num[<span class="number">64</span>]);</span><br><span class="line">    int arr[<span class="number">64</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    int num[<span class="number">200</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    int inputnum;</span><br><span class="line">    int i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    int x[<span class="number">64</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    int sumsheng=<span class="number">56</span>;</span><br><span class="line">    char thirdName[<span class="number">10</span>];</span><br><span class="line">    char str[<span class="number">10</span>];</span><br><span class="line">    int getInTStr;</span><br><span class="line">     int *p;</span><br><span class="line">     int indexflag=<span class="number">0</span>;</span><br><span class="line">    arr[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">7</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">13</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">23</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">37</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">41</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">47</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">59</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">61</span>]=<span class="number">1</span>;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;inputnum);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inputnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d&quot;</span>,&amp;num[i]);</span><br><span class="line">        <span class="keyword">if</span> (sumsheng&gt;num[i])</span><br><span class="line">        &#123;</span><br><span class="line">        	 sumsheng=sumsheng-num[i];</span><br><span class="line">        &#125;</span><br><span class="line"> 			x[i]=sumsheng;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    scanf(<span class="string">&quot;%s&quot;</span>,thirdName);</span><br><span class="line"></span><br><span class="line">    strncpy(str, thirdName+<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	getInTStr=atoi(str);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inputnum; i++)</span><br><span class="line">     &#123;</span><br><span class="line">     	p=funsave(num[i],arr,x[i],getInTStr,indexflag,num);</span><br><span class="line"></span><br><span class="line">     		indexflag=indexflag+<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// printf(&quot;sumsheng:%d\n&quot;, sumsheng);</span></span><br><span class="line">     <span class="comment">// for(i=0;i&lt;inputnum;i++)&#123;</span></span><br><span class="line">     <span class="comment">//       printf(&quot;%d &quot;,num[i]);</span></span><br><span class="line">     <span class="comment">//   &#125;</span></span><br><span class="line">       <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;inputnum;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(num[i]&gt;sumsheng&amp;&amp;getInTStr==i+<span class="number">1</span>)&#123;</span><br><span class="line">           		printf(<span class="string">&quot;false\n&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (getInTStr==<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">	       <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; num[<span class="number">0</span>]; i++ )</span><br><span class="line">		   &#123;</span><br><span class="line">		       printf(<span class="string">&quot;%d &quot;</span>, *(p + i));</span><br><span class="line">		   &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int *funsave(int n,int arr[<span class="number">64</span>],int residue,int getInTStr,int indexflag,int num[<span class="number">64</span>])&#123;</span><br><span class="line">    int i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    int count=<span class="number">0</span>;</span><br><span class="line">    int indexI=<span class="number">0</span>;</span><br><span class="line">    int flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span>  int arr1[<span class="number">64</span>][<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">static</span>  int arr2[<span class="number">20</span>];</span><br><span class="line">    int finallyIndex=<span class="number">0</span>;</span><br><span class="line">    int arrindex=<span class="number">0</span>;</span><br><span class="line">    int arrindex2=<span class="number">0</span>;</span><br><span class="line">   <span class="comment">// printf(&quot;start n:%d\n&quot;,n);</span></span><br><span class="line">    <span class="comment">// printf(&quot;getInTStr:%d\n&quot;,getInTStr);</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// for(i=0;i&lt;10;i++)&#123;</span></span><br><span class="line">    <span class="comment">// 	printf(&quot;%d &quot;, num[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">	<span class="keyword">if</span> (n&gt;residue)</span><br><span class="line">    &#123;</span><br><span class="line">    	printf(<span class="string">&quot;false &quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	 <span class="keyword">if</span> (arr[<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">    	 &#123;</span><br><span class="line">    	 	 <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		    &#123;</span><br><span class="line">		    	<span class="keyword">if</span> (arr[i]==<span class="number">1</span>)</span><br><span class="line">		    	&#123;</span><br><span class="line">		    		count++;</span><br><span class="line">		   		&#125;</span><br><span class="line">		 	&#125;</span><br><span class="line">		 	 <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count+n; i++)</span><br><span class="line">			   &#123;</span><br><span class="line">			   	  <span class="keyword">if</span> (arr[i]==<span class="number">0</span>)</span><br><span class="line">			   	  &#123;</span><br><span class="line">			   	      arr2[arrindex2]=i;</span><br><span class="line">			   	      arrindex2++;</span><br><span class="line">			   	  &#125;</span><br><span class="line">			   	  arr[i]=<span class="number">1</span>;</span><br><span class="line">			   &#125;</span><br><span class="line">			   printf(<span class="string">&quot;%d &quot;</span>, n+count<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    	 &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">    	 	&#123;</span><br><span class="line">    	 		<span class="keyword">if</span> (arr[i]==<span class="number">0</span>)</span><br><span class="line">    	 		&#123;</span><br><span class="line">    	 			indexI=i;</span><br><span class="line">    	 			goto LOOP;</span><br><span class="line">    	 		&#125;</span><br><span class="line">    	 	&#125;</span><br><span class="line"></span><br><span class="line">    	 LOOP:<span class="keyword">for</span>(i=indexI;i&lt;indexI+n;i++)&#123;</span><br><span class="line">    	 		<span class="keyword">if</span> (arr[i]==<span class="number">1</span>)</span><br><span class="line">		    	&#123;</span><br><span class="line">		    		count++;</span><br><span class="line">		   		&#125;</span><br><span class="line">    	 	&#125;</span><br><span class="line">    	 	<span class="comment">// printf(&quot;indexflag:%d\n&quot;, indexflag);</span></span><br><span class="line">    	 	<span class="keyword">for</span> (i = indexI; i &lt; indexI+count+n; i++)</span><br><span class="line">			   &#123;</span><br><span class="line">			   	<span class="keyword">if</span> (arr[i]==<span class="number">0</span>)</span><br><span class="line">			   	&#123;</span><br><span class="line">			   		finallyIndex=i;</span><br><span class="line">			   		arr1[indexflag<span class="number">-1</span>][arrindex]=i;</span><br><span class="line">					arrindex=arrindex+<span class="number">1</span>;</span><br><span class="line">			   	&#125;</span><br><span class="line">			   	  arr[i]=<span class="number">1</span>;</span><br><span class="line">			   &#125;</span><br><span class="line">			    printf(<span class="string">&quot;%d &quot;</span>, finallyIndex);</span><br><span class="line">    			&#125;</span><br><span class="line">    	 &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    	 <span class="keyword">if</span> (getInTStr==<span class="number">1</span>)</span><br><span class="line">    	 &#123;</span><br><span class="line">    	 	<span class="keyword">return</span> arr2;</span><br><span class="line">    	 &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    	 	<span class="comment">// printf(&quot;getInTStr:%d\n&quot;, getInTStr);</span></span><br><span class="line">       <span class="comment">//       printf(&quot;n:%d\n&quot;,n );</span></span><br><span class="line">       <span class="comment">//       printf(&quot;indexflag:%d\n&quot;,indexflag );</span></span><br><span class="line">    	 	<span class="comment">// for(i=0;i&lt;10;i++)</span></span><br><span class="line">			    <span class="comment">// &#123;</span></span><br><span class="line">			    <span class="comment">//     for(j=0;j&lt; 10;j++)</span></span><br><span class="line">			    <span class="comment">//     &#123;</span></span><br><span class="line">			    <span class="comment">//         printf(&quot;%d\t&quot;,arr1[i][j]);//访问i行j列的二维数组元素</span></span><br><span class="line">			    <span class="comment">//     &#125;</span></span><br><span class="line">			    <span class="comment">//     printf(&quot;\n&quot;);</span></span><br><span class="line">			    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (n&lt;=residue)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             	 <span class="keyword">if</span> (indexflag+<span class="number">1</span>&gt;=n)</span><br><span class="line">				 &#123;</span><br><span class="line">				 		printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">				        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;num[getInTStr<span class="number">-1</span>];j++)</span><br><span class="line">				        &#123;</span><br><span class="line">				        	<span class="keyword">if</span>(arr1[getInTStr<span class="number">-2</span>][j]!=<span class="number">0</span>)&#123;</span><br><span class="line"> 									printf(<span class="string">&quot;%d &quot;</span>,arr1[getInTStr<span class="number">-2</span>][j]);<span class="comment">//访问i行j列的二维数组元素</span></span><br><span class="line">				        	&#125;</span><br><span class="line"></span><br><span class="line">				        &#125;</span><br><span class="line">				 &#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    	 &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190602/famTkQ0URtAP.gif" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190602/u7GSImrnET42.gif" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190602/upFLuGwWxBsR.gif" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190602/KXkISHw5iD2s.gif" alt="mark"></p>
]]></content>
      <categories>
        <category>课程设计</category>
        <category>操作系统进程调度作业</category>
      </categories>
      <tags>
        <tag>学习实训</tag>
        <tag>进程调度</tag>
      </tags>
  </entry>
  <entry>
    <title>React 学习第三天</title>
    <url>/2019/05/12/ReactLearn03/</url>
    <content><![CDATA[<h2 id="React-第三天学习"><a href="#React-第三天学习" class="headerlink" title="React 第三天学习"></a>React 第三天学习</h2><blockquote>
<p>在 react 项目中 添加样式</p>
<p>加载外部 css 样式文件</p>
<p>css 样式作用域的问题（modules，localIdentName， local 和 global）</p>
<p>在 React 项目中 使用 bootsrtap（ 使用 sass ）</p>
<p>React 中 绑定事件</p>
<p>React 中双向绑定事件（e.target.value 和 this.refs.txt.value）</p>
<p>React 组件的生命周期</p>
<p>Dream what you want to dream; go where you want to go; be what you want to be, because you have only one life and one chance to do all the things you want to do！</p>
<p>做你想做的梦吧，去你想去的地方吧，成为你想成为的人吧，因为你只有一次生命，一个机会去做所有那些你想做的事。</p>
</blockquote>
<h2 id="在-react-项目中-添加样式"><a href="#在-react-项目中-添加样式" class="headerlink" title="在 react 项目中 添加样式"></a>在 react 项目中 添加样式</h2><h3 id="第一种方式："><a href="#第一种方式：" class="headerlink" title="第一种方式："></a>第一种方式：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h1 style=&#123;&#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">fontSize</span>: <span class="string">&quot;50px&quot;</span> &#125;&#125;&gt;这是评论列表组件&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<h4 id="第一层封装："><a href="#第一层封装：" class="headerlink" title="第一层封装："></a>第一层封装：</h4><p><strong>将样式对象抽离出来</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cmtStyle=&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>,<span class="attr">fontSize</span>:<span class="string">&#x27;30px&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">&lt;h1 style=&#123;cmtStyle&#125;&gt;这是评论列表组件&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<h4 id="第二层封装："><a href="#第二层封装：" class="headerlink" title="第二层封装："></a>第二层封装：</h4><p><strong>合并成一个大的样式对象</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> styles = &#123;</span><br><span class="line">  Item: &#123; <span class="attr">border</span>: <span class="string">&quot;1px dashed #ccc&quot;</span>, <span class="attr">margin</span>: <span class="string">&quot;10px 10px&quot;</span> &#125;,</span><br><span class="line">  user: &#123; <span class="attr">color</span>: <span class="string">&quot;#333&quot;</span> &#125;,</span><br><span class="line">  content: &#123; <span class="attr">color</span>: <span class="string">&quot;green&quot;</span>, <span class="attr">fontSize</span>: <span class="string">&quot;22px&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">CmtItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;styles.Item&#125;&gt;</span><br><span class="line">      &lt;h3 style=&#123;styles.user&#125;&gt;评论人：&#123;props.user&#125;&lt;/h3&gt;</span><br><span class="line">      &lt;p style=&#123;styles.content&#125;&gt;评论内容：&#123;props.content&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190508/ivSmbt2swrg3.png?imageslim" alt="mark"></p>
<h4 id="第三层封装"><a href="#第三层封装" class="headerlink" title="第三层封装"></a>第三层封装</h4><p><strong>抽离为单独的 样式表模块</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190508/Gg6ricXHCgO0.png?imageslim" alt="mark"></p>
<p>_CmtItem.jsx_：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react</span></span><br><span class="line"><span class="string">import styles from &#x27;</span>@/components/styles<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default function CmtItem(props) &#123;</span></span><br><span class="line"><span class="string">    return &lt;div style=&#123;styles.Item&#125;&gt;</span></span><br><span class="line"><span class="string">        &lt;h3 style=&#123;styles.user&#125;&gt;评论人：&#123;props.user&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">        &lt;p style=&#123;styles.content&#125;&gt;评论内容：&#123;props.content&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><em>styles.js</em>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  Item: &#123; <span class="attr">border</span>: <span class="string">&quot;1px dashed #ccc&quot;</span>, <span class="attr">margin</span>: <span class="string">&quot;10px 10px&quot;</span> &#125;,</span><br><span class="line">  user: &#123; <span class="attr">color</span>: <span class="string">&quot;#333&quot;</span> &#125;,</span><br><span class="line">  content: &#123; <span class="attr">color</span>: <span class="string">&quot;green&quot;</span>, <span class="attr">fontSize</span>: <span class="string">&quot;22px&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="加载外部-css-样式文件"><a href="#加载外部-css-样式文件" class="headerlink" title="加载外部 css 样式文件"></a>加载外部 css 样式文件</h2><p><em>index.js</em>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>; <span class="comment">//创建组件，虚拟DOM元素，生命周期</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>; <span class="comment">//把创建好的 组件 和 虚拟DOM 放到页面上展示的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> CmtList <span class="keyword">from</span> <span class="string">&quot;@/components/CmtList&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 ReactDOM 把虚拟 DOM 渲染到页面上</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;CmtList&gt;&lt;/CmtList&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>_CmtList.jsx_：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> CmtItem <span class="keyword">from</span> <span class="string">&#x27;@/components/CmtItem&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cmtStyle = &#123;<span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="attr">fontSize</span>: <span class="string">&#x27;30px&#x27;</span>, <span class="attr">textAlign</span>: <span class="string">&#x27;center&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">import</span> cssobj <span class="keyword">from</span> cmtList.scss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CmtList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            CommentList: [</span><br><span class="line">                &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">user</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;哈哈哈哈哈&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">user</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;打游戏&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">user</span>: <span class="string">&#x27;王五&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;唱歌，喝酒&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">id</span>: <span class="number">4</span>, <span class="attr">user</span>: <span class="string">&#x27;王麦子&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;到处happy&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">id</span>: <span class="number">5</span>, <span class="attr">user</span>: <span class="string">&#x27;周琛&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;帅的不要不要了！&#x27;</span>&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是评论列表组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;this.state.CommentList.map(item =&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">CmtItem</span> &#123;<span class="attr">...item</span>&#125; <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">CmtItem</span>&gt;</span></span></span><br><span class="line"><span class="xml">            )&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_CmtItem.jsx_：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&quot;@/components/styles&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">CmtItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;styles.Item&#125;&gt;</span><br><span class="line">      &lt;h1 style=&#123;styles.user&#125;&gt;评论人：&#123;props.user&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;评论内容：&#123;props.content&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>webpack.config.js</em>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> htmlplugin = <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  template: path.join(__dirname, <span class="string">&quot;src/index.html&quot;</span>),</span><br><span class="line">  filename: <span class="string">&quot;index.html&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    contentBase: path.join(__dirname, <span class="string">&quot;src&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [htmlplugin],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.m?js|jsx$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [</span><br><span class="line">              <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">              [</span><br><span class="line">                <span class="string">&quot;@babel/preset-react&quot;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                  pragmaFrag: <span class="string">&quot;DomFrag&quot;</span>, <span class="comment">// default is React.Fragment</span></span><br><span class="line">                  throwIfNamespace: <span class="literal">false</span>, <span class="comment">// defaults to true</span></span><br><span class="line">                &#125;,</span><br><span class="line">              ],</span><br><span class="line">            ],</span><br><span class="line">            plugins: [<span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, use: [<span class="string">&quot;style-loader,css-loader&quot;</span>] &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.jsx&quot;</span>, <span class="string">&quot;.json&quot;</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&quot;@&quot;</span>: path.join(__dirname, <span class="string">&quot;./src&quot;</span>), <span class="comment">//这样，@ 就表示 项目根目录中 的src 这一层路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="配置好相应的文件后，但是却意外的发生了错误！"><a href="#配置好相应的文件后，但是却意外的发生了错误！" class="headerlink" title="配置好相应的文件后，但是却意外的发生了错误！"></a>配置好相应的文件后，但是却意外的发生了错误！</h4><p><img src="http://static.zxinc520.com/blog/20190511/GMbDLo9GrxeD.png?imageslim" alt="mark"></p>
<p>查阅资料：参考 <a href="https://stackoverflow.com/questions/35171288/error-cannot-resolve-module-style-loader"><a href="https://stackoverflow.com/questions/35171288/error-cannot-resolve-module-style-loader">Error: Cannot resolve module ‘style-loader’</a></a></p>
<p>但是不知咋地，我瞎弄了一下，突然就好了！~</p>
<p>_结果_：</p>
<p><img src="http://static.zxinc520.com/blog/20190509/o8CRGPxVP3S2.png?imageslim" alt="mark"></p>
<h1 id="引出-css-样式作用域的问题"><a href="#引出-css-样式作用域的问题" class="headerlink" title="引出 css 样式作用域的问题"></a>引出 css 样式作用域的问题</h1><h4 id="给普通样式表加模块化"><a href="#给普通样式表加模块化" class="headerlink" title="给普通样式表加模块化"></a>给普通样式表加模块化</h4><blockquote>
<p>CSS MODULE 是一种 css in javascript 的方式，当我们把一个 css 文件 import 到一个 js 模块时，这个 css 文件会暴露一个对象，这个对象映射所有的本地和全局 css 类名</p>
</blockquote>
<p>​ <a href="https://juejin.im/entry/5826e755c4c9710054313d6e">你真的知道 css-loader 怎么用吗？</a></p>
<h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><p><strong>操作</strong>：</p>
<ul>
<li>配置 <strong><em>webpack.config.js</em></strong>: 追加参数 _modules_：表示为 普通的 css 样式表，启用模块化。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">test</span>:<span class="regexp">/\.css$/</span>,use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader?modules&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ul>
<li>css 模块化，只针对 <strong>类选择器</strong> 和 <strong>Id 选择器</strong>生效。</li>
<li>css 模块化，不会将 <strong>标签选择器</strong> 模块化。</li>
</ul>
<p><strong>使用</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cssobj <span class="keyword">from</span> cmtList.scss</span><br><span class="line"></span><br><span class="line">&lt;h1 className=&#123;cssobj.title&#125;&gt;这是评论列表组件&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190509/uBEiMLCl4Po1.png?imageslim" alt="mark"></p>
<h2 id="localIdentName"><a href="#localIdentName" class="headerlink" title="localIdentName"></a>localIdentName</h2><blockquote>
<p>通常 modules 参数还要通过 localIdentName 的配合来设置 css 的类名。在上文中我们看到没有设置 localIdentName 的 css 编译后是一串随机字符串，可读性很差，因此我们还需要对它的类名进行处理，这就用到了 localIdentName。</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190509/LmY7Up6tjWsL.png?imageslim" alt="mark"></p>
<p>使用 localIdentName 设置 css-modules 模式下 local 类名的命名。</p>
<p>_例如_：</p>
<p>【path】：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">test</span>:<span class="regexp">/\.css$/</span>,use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader?modules&amp;localIdentName=[path]&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190511/6kzRvdhhMCya.png?imageslim" alt="mark"></p>
<p>【path】【name】：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">test</span>:<span class="regexp">/\.css$/</span>,use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader?modules&amp;localIdentName=[path][name]&#x27;</span>]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190511/1fSFPLQWlGcr.png?imageslim" alt="mark"></p>
<p>【path】【name】【local】：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">test</span>:<span class="regexp">/\.css$/</span>,use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader?modules&amp;localIdentName=[path][name]-[local]&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190509/mnElXq2M49y5.png?imageslim" alt="mark"></p>
<p>【path】【name】【local】【hash】：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">test</span>:<span class="regexp">/\.css$/</span>,use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader?modules&amp;localIdentName=[path][name]-[local]-[hash]&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190511/f0mCgGRosdOV.png?imageslim" alt="mark"></p>
<h2 id="通过-local-和-global-设置类名是否被模块化"><a href="#通过-local-和-global-设置类名是否被模块化" class="headerlink" title="通过 local 和 global 设置类名是否被模块化"></a>通过 local 和 global 设置类名是否被模块化</h2><blockquote>
<p>被 <strong>:local()</strong> 包裹起来的类名，会被模块化，默认情况下，所有的类名和 ID 都被模块化了。</p>
<p>被 :global() 包裹起来的类名，不会被模块化，而会全局生效。</p>
</blockquote>
<p><strong>需求</strong>：</p>
<p><img src="http://static.zxinc520.com/blog/20190511/1nDtTim2qWpX.png?imageslim" alt="mark"></p>
<p>解决方案： <a href="https://zhuanlan.zhihu.com/p/23843710">可以参考</a></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:global(.test)</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong> ：</p>
<ul>
<li>test 类名 <em>未被模块化</em> ，而是 _全局生效_：</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190509/mxSgHjcOQL7t.png?imageslim" alt="mark"></p>
<h2 id="在-React-项目中-使用-bootsrtap"><a href="#在-React-项目中-使用-bootsrtap" class="headerlink" title="在 React 项目中 使用 bootsrtap"></a>在 React 项目中 使用 bootsrtap</h2><ol>
<li>安装 bootstrap 我一般使用 3.3.7 版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i bootstrap@3.3.7 -S</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装 相关 路径 图标 加载依赖</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i url-loader file-loader -D</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置 webpack-config-js 文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">test</span>:<span class="regexp">/\.ttf|woff|woff2|eot|svg$/</span>,use:<span class="string">&#x27;url-loader&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>导入 <strong>bootstrap 包</strong> 并且 使用 <em>bootstrap 类</em></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bootcss <span class="keyword">from</span> <span class="string">&quot;bootstrap/dist/css/bootstrap.min.css&quot;</span>;</span><br><span class="line"></span><br><span class="line">&lt;button className=&#123;[bootcss.btn, bootcss[<span class="string">&quot;btn-primary&quot;</span>]].join(<span class="string">&quot; &quot;</span>)&#125;&gt;</span><br><span class="line">  点我</span><br><span class="line">&lt;/button&gt;;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190509/AIA3b6TmGWOP.png?imageslim" alt="mark"></p>
<h3 id="升级："><a href="#升级：" class="headerlink" title="升级："></a>升级：</h3><p>问题：className={[bootcss.btn,bootcss[‘btn-primary’]].join(‘ ‘)} <strong>这样调用太麻烦了</strong></p>
<blockquote>
<p>_自己规定_：</p>
<p><strong>第三方的 样式表</strong>：(例如: bootsrtap 等 )都是以 .css 结尾，这样，我们不要为普通的 .css 启用模块化。</p>
<p><strong>自己定义样式表</strong>：都要以 .scss 或 .less 结尾，只为 .scss 或 .less 结尾的启用模块化。</p>
</blockquote>
<h3 id="使用-sass"><a href="#使用-sass" class="headerlink" title="使用 sass"></a>使用 sass</h3><blockquote>
<p>​ <a href="https://www.cnblogs.com/wangpenghui522/p/5467560.html">Sass/Scss、Less 是什么?</a></p>
</blockquote>
<ol>
<li>安装：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i sass-loader node-sass -D</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置 <em>webpack.comfig.js</em> :</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">test</span>:<span class="regexp">/\.css$/</span>,use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>]&#125;,</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">test</span>:<span class="regexp">/\.scss/</span>,use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader?modules&amp;localIdentName=[path][name]-[local]-[hash:5]&#x27;</span>,<span class="string">&#x27;sass-loader&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>导入 <strong>bootstrap 包</strong> 并且 使用 <em>bootstrap 类</em> （ <em>只用导入第三方路径即可</em> ）</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;bootstrap/dist/css/bootstrap.min.css&quot;</span>;</span><br><span class="line"></span><br><span class="line">&lt;button className=<span class="string">&quot;btn btn-danger&quot;</span>&gt;点我&lt;/button&gt;;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190511/nsjoVX1si22z.png?imageslim" alt="mark"></p>
<h2 id="React-中-绑定事件"><a href="#React-中-绑定事件" class="headerlink" title="React 中 绑定事件"></a>React 中 绑定事件</h2><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><em>BindEvent.jsx</em>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        BindEvent组件</span><br><span class="line">        &lt;hr /&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          按钮</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190511/QvadnFjsB97L.gif" alt="mark"></p>
<p>_分离_：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;BindEvent组件！&lt;/h1&gt;</span><br><span class="line">        &lt;hr /&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.myClickHandler();</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          你敢点我吗？</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myClickHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">&quot;这是myClickHandler方法！&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190511/9kb9Av4PcP9d.gif" alt="mark"></p>
<p>_传递参数_：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;BindEvent组件！&lt;/h1&gt;</span><br><span class="line">        &lt;hr /&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.myClickHandler(<span class="string">&quot;哈哈哈哈哈哈！&quot;</span>);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          你敢点我吗？</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myClickHandler = <span class="function">(<span class="params">arg1</span>) =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">&quot;这是myClickHandler方法！&quot;</span> + arg1);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190511/x9zF0YsaynFo.gif" alt="mark"></p>
<h3 id="需求：点击按钮，改变-this-state-里面的值"><a href="#需求：点击按钮，改变-this-state-里面的值" class="headerlink" title="需求：点击按钮，改变 this.state 里面的值"></a>需求：点击按钮，改变 <strong>this.state</strong> 里面的值</h3><blockquote>
<p>this.setState 方法的使用</p>
<p><strong>注意</strong>：this.setState 方法的执行是 <strong>异步</strong> 的</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190511/1TfoRzRHPm3H.png?imageslim" alt="mark"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      msg: <span class="string">&quot;周琛！&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;BindEvent组件！&lt;/h1&gt;</span><br><span class="line">        &lt;hr /&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.myClickHandler(<span class="string">&quot;哈哈哈哈哈哈！&quot;</span>, <span class="string">&quot;大傻瓜！&quot;</span>);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          你敢点我吗？</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">        &lt;h3&gt;&#123;<span class="built_in">this</span>.state.msg&#125;&lt;/h3&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myClickHandler = <span class="function">(<span class="params">arg1, arg2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// alert(&#x27;这是myClickHandler方法！&#x27;+arg1+arg2)</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      msg: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190511/AVQprOBiH0De.gif" alt="mark"></p>
<p><strong>注意</strong>：在执行 this.setState 后，又想立即拿到最新的 state 值，需要使用 this.setState({},callback)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myClickHandler = <span class="function">(<span class="params">arg1, arg2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// alert(&#x27;这是myClickHandler方法！&#x27;+arg1+arg2)</span></span><br><span class="line">  <span class="built_in">this</span>.setState(</span><br><span class="line">    &#123;</span><br><span class="line">      msg: <span class="string">&quot;张三&quot;</span> + arg1 + arg2,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.msg);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="React-中绑定文本框与-State-中的值"><a href="#React-中绑定文本框与-State-中的值" class="headerlink" title="React 中绑定文本框与 State 中的值"></a>React 中绑定文本框与 State 中的值</h2><blockquote>
<p>类似于 Vue 的双向绑定</p>
</blockquote>
<h4 id="第一种双向绑定实现方式"><a href="#第一种双向绑定实现方式" class="headerlink" title="第一种双向绑定实现方式"></a>第一种双向绑定实现方式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  type=<span class="string">&quot;text&quot;</span></span><br><span class="line">  style=&#123;&#123; <span class="attr">width</span>: <span class="string">&quot;100%&quot;</span> &#125;&#125;</span><br><span class="line">  value=&#123;<span class="built_in">this</span>.state.msg&#125;</span><br><span class="line">  onChange=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.txtChanged(e)&#125;</span><br><span class="line">/&gt;;</span><br><span class="line"></span><br><span class="line">txtChanged = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    msg: e.target.value,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190511/k4Pz5wOdvDMe.gif" alt="mark"></p>
<h3 id="使用-ref-获取-DOM-元素引用"><a href="#使用-ref-获取-DOM-元素引用" class="headerlink" title="使用 ref 获取 DOM 元素引用"></a>使用 ref 获取 DOM 元素引用</h3><blockquote>
<p>Vue 中，Vue 为页面上的元素提供了 ref 的属性，获取元素引用，则需要使用 <strong>this.$refs</strong> 引用名称</p>
<p>React 中 获取元素的引用 ：<strong>this.refs</strong></p>
</blockquote>
<p>第二种双向绑定实现方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  type=<span class="string">&quot;text&quot;</span></span><br><span class="line">  style=&#123;&#123; <span class="attr">width</span>: <span class="string">&quot;100%&quot;</span> &#125;&#125;</span><br><span class="line">  value=&#123;<span class="built_in">this</span>.state.msg&#125;</span><br><span class="line">  onChange=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.txtChanged(e)&#125;</span><br><span class="line">  ref=<span class="string">&quot;txt&quot;</span></span><br><span class="line">/&gt;;</span><br><span class="line"></span><br><span class="line">txtChanged = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    msg: <span class="built_in">this</span>.refs.txt.value,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="React-组件的生命周期"><a href="#React-组件的生命周期" class="headerlink" title="React 组件的生命周期"></a>React 组件的生命周期</h2><p><a href="https://juejin.im/post/5a062fb551882535cd4a4ce3">可以参考</a></p>
<p><img src="http://static.zxinc520.com/blog/20190512/WR2qsCelssvf.webp" alt="mark"></p>
<blockquote>
<p>如图，React 生命周期主要包括三个阶段：初始化阶段、运行中阶段和销毁阶段，在 React 不同的生命周期里，会依次触发不同的钩子函数，下面我们就来详细介绍一下 React 的生命周期函数</p>
</blockquote>
]]></content>
      <categories>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React 学习第二天</title>
    <url>/2019/05/06/ReactLearn02/</url>
    <content><![CDATA[<h1 id="React-学习第二天"><a href="#React-学习第二天" class="headerlink" title="React 学习第二天"></a>React 学习第二天</h1><blockquote>
<p>React 学习第二天</p>
<p>创建组件的方式（ function 和 class）</p>
<p>ES6 扩展运算符使用</p>
<p>抽离 jsx 组件</p>
<p>如何省略 <strong><u>jsx</u></strong> 后缀名？</p>
<p>使用@别名表示路径</p>
<p>两种创建组件方式的对比</p>
<p>评论列表案例</p>
<p>没有收拾残局的能力，就别放纵善变的情绪！！！</p>
</blockquote>
<h2 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h2><h3 id="第一种创建组件的方式"><a href="#第一种创建组件的方式" class="headerlink" title="第一种创建组件的方式"></a>第一种创建组件的方式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步：导入包</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>; <span class="comment">//创建组件，虚拟DOM元素，生命周期</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>; <span class="comment">//把创建好的 组件 和 虚拟DOM 放到页面上展示的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一个组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：使用 ReactDOM 把虚拟 DOM 渲染到页面上</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Hello&gt;&lt;/Hello&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190506/tppNOX2JwhMa.png?imageslim" alt="mark"></p>
<h4 id="接受外部传值"><a href="#接受外部传值" class="headerlink" title="接受外部传值"></a>接受外部传值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(props);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      这是一个组件---&#123;props.name&#125;---&#123;props.age&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">  name: <span class="string">&quot;大黄&quot;</span>,</span><br><span class="line">  age: <span class="string">&quot;18&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：使用 ReactDOM 把虚拟 DOM 渲染到页面上</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Hello name=&#123;dog.name&#125; age=&#123;dog.age&#125;&gt;&lt;/Hello&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190506/Ebp8WSqvYzTi.png?imageslim" alt="mark"></p>
<!--注意：不论是 Vue 还是 React，组件中的props永远都是只读的，不能被赋值！-->

<!--组件 首字母 必须为大写！-->

<h4 id="改进：使用-ES6-扩展运算符"><a href="#改进：使用-ES6-扩展运算符" class="headerlink" title="改进：使用 ES6 扩展运算符"></a>改进：使用 ES6 扩展运算符</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(props);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      这是一个组件---&#123;props.name&#125;---&#123;props.age&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">  name: <span class="string">&quot;大黄&quot;</span>,</span><br><span class="line">  age: <span class="string">&quot;18&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：使用 ReactDOM 把虚拟 DOM 渲染到页面上</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Hello &#123;...dog&#125;&gt;&lt;/Hello&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="抽离-jsx-组件"><a href="#抽离-jsx-组件" class="headerlink" title="抽离 jsx 组件"></a>抽离 jsx 组件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步：导入包</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>; <span class="comment">//创建组件，虚拟DOM元素，生命周期</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>; <span class="comment">//把创建好的 组件 和 虚拟DOM 放到页面上展示的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Hello <span class="keyword">from</span> <span class="string">&quot;./components/Hello.jsx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">  name: <span class="string">&quot;大黄&quot;</span>,</span><br><span class="line">  age: <span class="string">&quot;18&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：使用 ReactDOM 把虚拟 DOM 渲染到页面上</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Hello &#123;...dog&#125;&gt;&lt;/Hello&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190506/oiuJeOYjfvf4.png?imageslim" alt="mark"></p>
<p><strong>Hello.jsx:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(props);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      这是一个组件---&#123;props.name&#125;---&#123;props.age&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何省略-jsx-后缀名？"><a href="#如何省略-jsx-后缀名？" class="headerlink" title="如何省略 jsx 后缀名？"></a>如何省略 <strong><u>jsx</u></strong> 后缀名？</h4><p><img src="http://static.zxinc520.com/blog/20190506/Vt3JwXFKXg8w.png?imageslim" alt="mark"></p>
<p><strong>配置 webpack.config.js 文件：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [<span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.jsx&quot;</span>, <span class="string">&quot;.json&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-别名表示路径"><a href="#使用-别名表示路径" class="headerlink" title="使用@别名表示路径"></a>使用@别名表示路径</h4><p><img src="http://static.zxinc520.com/blog/20190506/1o1dm0J9gRPc.png?imageslim" alt="mark"></p>
<p><strong>配置 webpack.config.js 文件：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve:&#123;</span><br><span class="line">    extensions:[<span class="string">&#x27;.js&#x27;</span>,<span class="string">&#x27;.jsx&#x27;</span>,<span class="string">&#x27;.json&#x27;</span>],</span><br><span class="line">        alias:&#123;</span><br><span class="line">            <span class="string">&#x27;@&#x27;</span>:path.join(__dirname,<span class="string">&#x27;./src&#x27;</span>) <span class="comment">//这样，@ 就表示 项目根目录中的src 这一层路径</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种创建组件的方式"><a href="#第二种创建组件的方式" class="headerlink" title="第二种创建组件的方式"></a>第二种创建组件的方式</h3><blockquote>
<p>使用 class 关键字来创建自建</p>
<p>ES6 中 class 关键字，是实现面向对象编程的新形式（语法糖）</p>
</blockquote>
<h4 id="了解-class"><a href="#了解-class" class="headerlink" title="了解 class"></a>了解 class</h4><ol>
<li>创建一个类并提供参数</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Animate(<span class="string">&quot;大黄&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190506/S8PirbufxcXt.png?imageslim" alt="mark"></p>
<h4 id="挂载原型对象的实例方法（-function-和-class-方法对比）"><a href="#挂载原型对象的实例方法（-function-和-class-方法对比）" class="headerlink" title="挂载原型对象的实例方法（ function 和 class 方法对比）"></a>挂载原型对象的实例方法（ function 和 class 方法对比）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;这是实例方法！&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> f(<span class="string">&quot;大黄&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  show() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这是实例方法！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Animate(<span class="string">&quot;大黄&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190506/CfW0S1Lz9HP8.png?imageslim" alt="mark"></p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 function创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line">f.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;这是function创建的 f 的静态 show 方法&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">f.show();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;--------------分割线------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用class 创建对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animate</span> </span>&#123;</span><br><span class="line">  <span class="comment">//静态方法</span></span><br><span class="line">  <span class="keyword">static</span> info = <span class="string">&quot;这是class方法创建的静态方法！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Animate.info);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190506/JdrMb039jWqx.png?imageslim" alt="mark"></p>
<h4 id="extends-继承"><a href="#extends-继承" class="headerlink" title="extends 继承"></a>extends 继承</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">American</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> American(<span class="string">&quot;Jack&quot;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a1);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> Chinese(<span class="string">&quot;张三&quot;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c1);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190506/9iKF2u3HOaF1.png?imageslim" alt="mark"></p>
<h4 id="super-调用父类-constructor-可以参考"><a href="#super-调用父类-constructor-可以参考" class="headerlink" title="super 调用父类 constructor 可以参考"></a>super 调用父类 constructor <a href="https://juejin.im/post/5b3f23066fb9a04fe820cdbe">可以参考</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;大家好！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">American</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> American(<span class="string">&quot;Jack&quot;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a1);</span><br><span class="line"><span class="built_in">console</span>.log(a1.sayHello());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, IDNumber) &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age);</span><br><span class="line">    <span class="built_in">this</span>.IDNumber = IDNumber;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> Chinese(<span class="string">&quot;张三&quot;</span>, <span class="number">22</span>, <span class="string">&quot;1213123&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c1);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190506/dokRjyuJrlg5.png?imageslim" alt="mark"></p>
<h4 id="子类没有定义-constructor，会默认添加"><a href="#子类没有定义-constructor，会默认添加" class="headerlink" title="子类没有定义 constructor，会默认添加"></a>子类没有定义 constructor，会默认添加</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="built_in">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-class-关键字创建组件"><a href="#使用-class-关键字创建组件" class="headerlink" title="使用 class 关键字创建组件"></a>使用 class 关键字创建组件</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>; <span class="comment">//创建组件，虚拟DOM元素，生命周期</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>; <span class="comment">//把创建好的 组件 和 虚拟DOM 放到页面上展示的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使用class 定义组件，必须让自己的组件，继承自 React.Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">//在组件内部，必须有 render 函数，作用：渲染当前组件对应的 虚拟DOM 结构</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">//render 函数中，必须 返回合法的 JSX 虚拟DOM 结构</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是class创建组件的方式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 ReactDOM 把虚拟 DOM 渲染到页面上</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Movie&gt;&lt;/Movie&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190506/pUNFRBHpnlsL.png?imageslim" alt="mark"></p>
<h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>; <span class="comment">//创建组件，虚拟DOM元素，生命周期</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>; <span class="comment">//把创建好的 组件 和 虚拟DOM 放到页面上展示的</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">//使用class关键字创建的组件中，如果想使用外界传递过来的 props 参数，不需接受，直接通过 this.props.*** 来访问！</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        这是<span class="class"><span class="keyword">class</span>创建组件的方式--</span>&#123;<span class="built_in">this</span>.props.name&#125;--&#123;<span class="built_in">this</span>.props.age&#125;---</span><br><span class="line">        &#123;<span class="built_in">this</span>.props.hobby&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">  name: <span class="string">&quot;小黄&quot;</span>,</span><br><span class="line">  age: <span class="string">&quot;18&quot;</span>,</span><br><span class="line">  hobby: <span class="string">&quot;play games&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：使用 ReactDOM 把虚拟 DOM 渲染到页面上</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Movie &#123;...dog&#125;&gt;&lt;/Movie&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190506/3McvjLR2OU4B.png?imageslim" alt="mark"></p>
<h2 id="这两种创建组件方式的对比"><a href="#这两种创建组件方式的对比" class="headerlink" title="这两种创建组件方式的对比"></a>这两种创建组件方式的对比</h2><blockquote>
<p>注意：使用 <strong>function</strong> 创建的组件只有 props，没有自己的私有数据 和生命周期 函数</p>
<p>注意：使用 **class 关键字 **创建的组件，有自己的私有数据；</p>
</blockquote>
<ol>
<li>用 <strong>构造函数</strong> 创建出来的组件：叫做 “ <u>无状态组件</u> ”</li>
<li>用 <strong>class 关键字</strong> 创建出来的组件：叫做 “ <u>有状态组件</u> ”</li>
</ol>
<blockquote>
<p><strong>有状态组件</strong>和 <strong>无状态组件</strong> 之间的本质区别就是：有无 <strong>state 属性</strong></p>
</blockquote>
<p><a href="https://www.cnblogs.com/wonyun/p/5930333.html">可以参考</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>; <span class="comment">//创建组件，虚拟DOM元素，生命周期</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>; <span class="comment">//把创建好的 组件 和 虚拟DOM 放到页面上展示的</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      msg: <span class="string">&quot;大家好啊！我是class私有数据！&quot;</span>,</span><br><span class="line">    &#125;; <span class="comment">//相当于 Vue 里面的 data()&#123; return &#123;&#125;&#125;函数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用class关键字创建的组件中，如果想使用外界传递过来的 props 参数，不需接受，直接通过 this.props.*** 来访问！</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        这是<span class="class"><span class="keyword">class</span>创建组件的方式--</span>&#123;<span class="built_in">this</span>.props.name&#125;</span><br><span class="line">        &lt;p&gt;&#123;<span class="built_in">this</span>.state.msg&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">  name: <span class="string">&quot;小黄&quot;</span>,</span><br><span class="line">  age: <span class="string">&quot;18&quot;</span>,</span><br><span class="line">  hobby: <span class="string">&quot;play games&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第三步：使用 ReactDOM 把虚拟 DOM 渲染到页面上</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Movie &#123;...dog&#125;&gt;&lt;/Movie&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​ <img src="http://static.zxinc520.com/blog/20190506/6hl8wJm5c3p4.png?imageslim" alt="mark"></p>
<h2 id="评论列表案例"><a href="#评论列表案例" class="headerlink" title="评论列表案例"></a>评论列表案例</h2><h5 id="初步实现："><a href="#初步实现：" class="headerlink" title="初步实现："></a>初步实现：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>; <span class="comment">//创建组件，虚拟DOM元素，生命周期</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>; <span class="comment">//把创建好的 组件 和 虚拟DOM 放到页面上展示的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 function 定义 普通的无状态组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CmtItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;评论人：&#123;props.user&#125;&lt;/h3&gt;</span><br><span class="line">      &lt;p&gt;评论内容：&#123;props.content&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CmtList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      CommentList: [</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">user</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;哈哈哈哈哈&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">user</span>: <span class="string">&quot;李四&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;打游戏&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">user</span>: <span class="string">&quot;王五&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;唱歌，喝酒&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">user</span>: <span class="string">&quot;王麦子&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;到处happy&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">user</span>: <span class="string">&quot;周琛&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;帅的不要不要了！&quot;</span> &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;这是评论列表组件&lt;/h1&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.CommentList.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">          &lt;CmtItem &#123;...item&#125; key=&#123;item.id&#125;&gt;&lt;/CmtItem&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：使用 ReactDOM 把虚拟 DOM 渲染到页面上</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;CmtList&gt;&lt;/CmtList&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190506/1Ql2PHx2l6B3.png?imageslim" alt="mark"></p>
<h4 id="抽离各模块"><a href="#抽离各模块" class="headerlink" title="抽离各模块"></a>抽离各模块</h4><blockquote>
<p>便于减少一个文件的代码量，并且符合一种模块化思想</p>
</blockquote>
<p><img src="http://static.zxinc520.com/blog/20190506/57OxaxsjtBwa.png?imageslim" alt="mark"></p>
<p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span> <span class="comment">//创建组件，虚拟DOM元素，生命周期</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span> <span class="comment">//把创建好的 组件 和 虚拟DOM 放到页面上展示的</span></span><br><span class="line">·</span><br><span class="line"><span class="keyword">import</span> CmtList <span class="keyword">from</span> <span class="string">&#x27;@/components/CmtList&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：使用 ReactDOM 把虚拟 DOM 渲染到页面上</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">CmtList</span>&gt;</span><span class="tag">&lt;/<span class="name">CmtList</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>CmtList.jsx:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> CmtItem <span class="keyword">from</span> <span class="string">&quot;@/components/CmtItem&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CmtList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      CommentList: [</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">user</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;哈哈哈哈哈&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">user</span>: <span class="string">&quot;李四&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;打游戏&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">user</span>: <span class="string">&quot;王五&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;唱歌，喝酒&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">user</span>: <span class="string">&quot;王麦子&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;到处happy&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">user</span>: <span class="string">&quot;周琛&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;帅的不要不要了！&quot;</span> &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;这是评论列表组件&lt;/h1&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.CommentList.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">          &lt;CmtItem &#123;...item&#125; key=&#123;item.id&#125;&gt;&lt;/CmtItem&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CmtItem.jsx：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="comment">//使用 function 定义 普通的无状态组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">CmtItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;评论人：&#123;props.user&#125;&lt;/h3&gt;</span><br><span class="line">      &lt;p&gt;评论内容：&#123;props.content&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190506/pSXgFJCzlL44.png?imageslim" alt="mark"></p>
]]></content>
      <categories>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React 学习第一天</title>
    <url>/2019/04/27/ReactLearn01/</url>
    <content><![CDATA[<h1 id="React-学习第一天"><a href="#React-学习第一天" class="headerlink" title="React 学习第一天"></a>React 学习第一天</h1><blockquote>
<p>ReactJS 简介</p>
<p>ReactJS 的背景和原理</p>
<p>三大主流前端框架 React、Vue、Angular</p>
<p>Vue 与 React 两个框架的区别和优势对比</p>
<p>React（虚拟 DOM，DIff 算法）</p>
<p>创建基本的 webpack4.x 项目（ 并且解决了之前的一个 bug ）</p>
<p>在项目中使用 react</p>
<p>把圈子变小 把语言变干净 把成绩往上提 把故事往心里收 现在想要的三年后都会有 ！o(<em>￣ ▽ ￣</em>)ブ</p>
</blockquote>
<h2 id="1、ReactJS-简介"><a href="#1、ReactJS-简介" class="headerlink" title="1、ReactJS 简介"></a>1、ReactJS 简介</h2><p>React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西很好用，就在 2013 年 5 月开源了。由于 React 的设计思想极其独特，属于革命性创新，性能出众，代码逻辑却非常简单。所以，越来越多的人开始关注和使用，认为它可能是将来 Web 开发的主流工具。</p>
<h2 id="2、ReactJS-的背景和原理"><a href="#2、ReactJS-的背景和原理" class="headerlink" title="2、ReactJS 的背景和原理"></a>2、ReactJS 的背景和原理</h2><p>在 Web 开发中，我们总需要将变化的数据实时反应到 UI 上，这时就需要对 DOM 进行操作。而复杂或频繁的 DOM 操作通常是性能瓶颈产生的原因（如何进行高性能的复杂 DOM 操作通常是衡量一个前端开发人员技能的重要指标）。</p>
<p>React 为此引入了虚拟 DOM（Virtual DOM）的机制：在浏览器端用 Javascript 实现了一套 DOM API。基于 React 进行开发时所有的 DOM 构造都是通过虚拟 DOM 进行，每当数据变化时，React 都会重新构建整个 DOM 树，然后 React 将当前整个 DOM 树和上一次的 DOM 树进行对比，得到 DOM 结构的区别，然后仅仅将需要变化的部分进行实际的浏览器 DOM 更新。而且 React 能够批处理虚拟 DOM 的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从 A 变成 B，然后又从 B 变成 A，React 会认为 UI 不发生任何变化，而如果通过手动控制，这种逻辑通常是极其复杂的。尽管每一次都需要构造完整的虚拟 DOM 树，但是因为虚拟 DOM 是内存数据，性能是极高的，而对实际 DOM 进行操作的仅仅是 Diff 部分，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体的 DOM 元素，而只需要关心在任意一个数据状态下，整个界面是如何 Render 的。</p>
<p>如果你像在 90 年代那样写过服务器端 Render 的纯 Web 页面那么应该知道，服务器端所要做的就是根据数据 Render 出 HTML 送到浏览器端。如果这时因为用户的一个点击需要改变某个状态文字，那么也是通过刷新整个页面来完成的。服务器端并不需要知道是哪一小段 HTML 发生了变化，而只需要根据数据刷新整个页面。换句话说，任何 UI 的变化都是通过整体刷新来完成的。而 React 将这种开发模式以高性能的方式带到了前端，每做一点界面的更新，你都可以认为刷新了整个页面。至于如何进行局部更新以保证性能，则是 React 框架要完成的事情。</p>
<p>借用 Facebook 介绍 React 的视频中聊天应用的例子，当一条新的消息过来时，你的开发过程需要知道哪条数据过来了，如何将新的 DOM 结点添加到当前 DOM 树上；而基于 React 的开发思路，你永远只需要关心数据整体，两次数据之间的 UI 如何变化，则完全交给框架去做。可以看到，使用 React 大大降低了逻辑复杂性，意味着开发难度降低，可能产生 Bug 的机会也更少。</p>
<hr>
<h4 id="清楚理解两个概念："><a href="#清楚理解两个概念：" class="headerlink" title="清楚理解两个概念："></a>清楚理解两个概念：</h4><ol>
<li><p>**ibrary(库)**：小而巧的库，只提供特定的 API；优点就是 船小好调头。可以很方便的从一个库切换到另外的库；但是代码几乎不会改变。</p>
</li>
<li><p>**Framework(框架)**：大而全的是框架；框架提供了一整套的解决方案；所以，如果在项目中间，想切换到另外的框架，是比较困难的。</p>
</li>
</ol>
<h1 id="三大主流前端框架-React、Vue、Angular"><a href="#三大主流前端框架-React、Vue、Angular" class="headerlink" title="三大主流前端框架 React、Vue、Angular"></a>三大主流前端框架 React、Vue、Angular</h1><p><img src="http://static.zxinc520.com/blog/20190423/Q4Mrbn6pFhYJ.jpg?imageslim" alt="mark"></p>
<p>React（ <strong>最流行</strong> ）起源于 Facebook 的内部项目，用来架设 Instagram 的网站， 并于 2013 年 5 月开源。React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。它有以下的<strong>特性</strong>：</p>
<ol>
<li><p>声明式设计：React 采用声明范式，可以轻松描述应用。</p>
</li>
<li><p>高效：React 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互。</p>
</li>
<li><p>灵活：React 可以与已知的库或框架很好地配合。</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 速度快：在UI渲染过程中，React通过在虚拟DOM中的微操作来实现对实际DOM的局部更新。</span><br><span class="line">2. 跨浏览器兼容：虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。</span><br><span class="line">3. 模块化：为你程序编写独立的模块化UI组件，这样当某个或某些组件出现问题是，可以方便地进行隔离。</span><br><span class="line">4. 单向数据流：Flux是一个用于在JavaScript应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化。</span><br><span class="line">5. 同构、纯粹的javascript：因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。</span><br><span class="line">6.兼容性好：比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。</span><br><span class="line">缺点：</span><br><span class="line">React本身只是一个V而已，并不是一个完整的框架，所以如果是大型项目想要一套完整的框架的话，基本都需要加上ReactRouter和Flux才能写大型应用。</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190423/7hBjb1epQFoH.webp" alt="mark"></p>
<p>Vue ( <strong>目前市场上的主流</strong> ) 是尤雨溪编写的一个构建数据驱动的 Web 界面的库，准确来说不是一个框架，它聚焦在 V（view）视图层。</p>
<p>_它有以下的特性_：</p>
<ol>
<li><p>轻量级的框架</p>
</li>
<li><p>双向数据绑定</p>
</li>
<li><p>指令</p>
</li>
<li><p>插件化</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">优点：</span><br><span class="line">1. 简单：官方文档很清晰，比 Angular 简单易学。</span><br><span class="line">2. 快速：异步批处理方式更新 DOM。</span><br><span class="line">3. 组合：用解耦的、可复用的组件组合你的应用程序。</span><br><span class="line">4. 紧凑：~18kb min+gzip，且无依赖。</span><br><span class="line">5. 强大：表达式 无需声明依赖的可推导属性 (computed properties)。</span><br><span class="line">6. 对模块友好：可以通过 NPM、Bower 或 Duo 安装，不强迫你所有的代码都遵循 Angular 的各种规定，使用场景更加灵活。</span><br><span class="line">缺点：</span><br><span class="line">1. 新生儿：Vue.js是一个新的项目，没有angular那么成熟。</span><br><span class="line">2. 影响度不是很大：google了一下，有关于Vue.js多样性或者说丰富性少于其他一些有名的库。</span><br><span class="line">3. 不支持IE8</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190423/bu0preO1hhfc.webp" alt="mark"></p>
<p>Angular（ <strong>最早</strong> ）是一款优秀的前端 JS 框架，已经被用于 Google 的多款产品当中。</p>
<p>_它有以下的特性_：</p>
<ol>
<li><p>良好的应用程序结构</p>
</li>
<li><p>双向数据绑定</p>
</li>
<li><p>指令</p>
</li>
<li><p>HTML 模板</p>
</li>
<li><p>可嵌入、注入和测试</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">优点：</span><br><span class="line">1. 模板功能强大丰富，自带了极其丰富的angular指令。</span><br><span class="line">2. 是一个比较完善的前端框架，包含服务，模板，数据双向绑定，模块化，路由，过滤器，依赖注入等所有功能；</span><br><span class="line">3. 自定义指令，自定义指令后可以在项目中多次使用。</span><br><span class="line">4. ng模块化比较大胆的引入了Java的一些东西（依赖注入），能够很容易的写出可复用的代码，对于敏捷开发的团队来说非常有帮助。</span><br><span class="line">5. angularjs是互联网巨人谷歌开发，这也意味着他有一个坚实的基础和社区支持。</span><br><span class="line">缺点：</span><br><span class="line">1. angular 入门很容易 但深入后概念很多, 学习中较难理解.</span><br><span class="line">2. 文档例子非常少, 官方的文档基本只写了api, 一个例子都没有, 很多时候具体怎么用都是google来的, 或直接问misko,angular的作者.</span><br><span class="line">3. 对IE6/7 兼容不算特别好, 就是可以用jQuery自己手写代码解决一些.</span><br><span class="line">4. 指令的应用的最佳实践教程少, angular其实很灵活, 如果不看一些作者的使用原则,很容易写出 四不像的代码, 例如js中还是像jQuery的思想有很多dom操作.</span><br><span class="line">5. DI 依赖注入 如果代码压缩需要显示声明.</span><br></pre></td></tr></table></figure>

<h1 id="Vue-与-React-两个框架的区别和优势对比"><a href="#Vue-与-React-两个框架的区别和优势对比" class="headerlink" title="Vue 与 React 两个框架的区别和优势对比"></a><a href="http://caibaojian.com/vue-vs-react.html">Vue 与 React 两个框架的区别和优势对比</a></h1><blockquote>
<p>Vue 与 React 的区别： <a href="https://www.jianshu.com/p/174e8028eabd">可以参考</a></p>
</blockquote>
<p><a href="">如果你喜欢用模板搭建应用（或者有这个想法），请选择 Vue</a></p>
<p>Vue 应用的默认选项是把 markup 放在 HTML 文件中。数据绑定表达式采用的是和 Angular 相似的 mustache 语法，而指令（特殊的 HTML 属性）用来向模板添加功能。</p>
<p>相比之下，React 应用不使用模板，它要求开发者借助 JSX 在 JavaScript 中创建 DOM。</p>
<p>对于来自标准 Web 开发方式的新开发者，模板更容易理解。但是一些资深开发者也喜欢模板，因为模板可以更好的把布局和功能分割开来，还可以使用 Pug 之类的模板引擎。</p>
<p>但是使用模板的代价是不得不学习所有的 HTML 扩展语法，而渲染函数只需要会标准的 HTML 和 JavaScript。而且比起模板，渲染函数更加容易调试和<a href="https://link.jianshu.com/?t=http://lib.csdn.net/base/softwaretest">测试</a>。当然你不应该因为这方面的原因错过 Vue，因为在 Vue2.0 中提供了使用模板或者渲染函数的选项。</p>
<p><a href="">如果你喜欢简单和“能用就行”的东西，请选择 Vue</a></p>
<p>一个简单的 Vue 项目可以不需要转译直接运行在浏览器中，所以使用 Vue 可以像使用<a href="https://link.jianshu.com/?t=http://lib.csdn.net/base/jquery">jQuery</a>一样简单。当然这对于 React 来说在技术上也是可行的，但是典型的 React 代码是重度依赖于 JSX 和诸如 class 之类的 ES6 特性的。</p>
<p>Vue 的简单在程序设计的时候体现更深，让我们来比较一下两个框架是怎样处理应用数据的（也就是 state）。</p>
<p>React 中是通过比较当前 state 和前一个 state 来决定何时在 DOM 中进行重渲染以及渲染的内容，因此需要不可变（immutable）的 state。</p>
<p>Vue 中的数据是可变（mutated）的，所以同样的操作看起来更加简洁。</p>
<p>让我们来看看 Vue 中是如何进行状态管理的。当向 state 添加一个新对象的时候，Vue 将遍历其中的所有属性并且转换为 getter，setter 方法，现在 Vue 的响应系统开始保持对 state 的跟踪了，当 state 中的内容发生变化的时候就会自动重新渲染 DOM。令人称道的是，Vue 中改变 state 的状态的操作不仅更加简洁，而且它的重新渲染系统也比 React 的更快更有效率。</p>
<p>Vue 的响应系统还有有些坑的，例如：它不能检测属性的添加和删除和某些数组更改。这时候就要用到 Vue API 中的类似于 React 的 set 方法来解决。</p>
<p><a href="">如果你想要你的应用尽可能的小和快，请选择 Vue</a></p>
<p>当应用程序的状态改变时，React 和 Vue 都将构建一个虚拟 DOM 并同步到真实 DOM 中。 两者都有各自的方法优化这个过程。</p>
<p>Vue 核心开发者提供了一个 benchmark 测试，可以看出 Vue 的渲染系统比 React 的更快。测试方法是 10000 个项目的列表渲染 100 次，结果如下图。从实用的观点来看，这种 benchmark 只和边缘情况有关，大部分应用程序中不会经常进行这种操作，所以这不应该被视为一个重要的比较点。但是，页面大小是与所有项目有关的，这方面 Vue 再次领先，它目前的版本压缩后只有 25.6KB。React 要实现同样的功能，你需要 React DOM（37.4KB）和 React with Addon 库（11.4KB），共计 44.8KB，几乎是 Vue 的两倍大。双倍的体积并不能带来双倍的功能。</p>
<p><a href="">如果你打算构建一个大型应用程序，请选择 React</a></p>
<p>像文章开头那种同时用 Vue 和 React 实现的简单应用程序，可能会让一个开发者潜意识中更加倾向于 Vue。这是因为基于模板的应用程序第一眼看上去更加好理解，而且能很快跑起来。但是这些好处引入的技术债会阻碍应用扩展到更大的规模。模板容易出现很难注意到的运行时错误，同时也很难去测试，重构和分解。</p>
<p>相比之下，Javascript 模板可以组织成具有很好的分解性和干（DRY）代码的组件，干代码的可重用性和可测试性更好。Vue 也有组件系统和渲染函数，但是 React 的渲染系统可配置性更强，还有诸如浅（shallow）渲染的特性，和 React 的测试工具结合起来使用，使代码的可测试性和可维护性更好。</p>
<p>与此同时，React 的 immutable 应用状态可能写起来不够简洁，但它在大型应用中意义非凡，因为透明度和可测试性在大型项目中变得至关重要。</p>
<p><a href="">如果你想要一个同时适用于 Web 端和原生 APP 的框架，请选择 React</a></p>
<p><a href="https://link.jianshu.com/?t=http://lib.csdn.net/base/reactnative">React Native</a>是一个使用 Javascript 构建移动端原生应用程序（<a href="https://link.jianshu.com/?t=http://lib.csdn.net/base/ios">iOS</a>，<a href="https://link.jianshu.com/?t=http://lib.csdn.net/base/android">Android</a>）的库。 它与 React.js 相同，只是不使用 Web 组件，而是使用原生组件。 如果你学过 React.js，很快就能上手 React Native，反之亦然。</p>
<p>它的意义在于，开发者只需要一套知识和工具就能开发 Web 应用和移动端原生应用。如果你想同时做 Web 端开发和移动端开发，React 为你准备了一份大礼。</p>
<p>阿里的 Weex 也是一个跨平台 UI 项目，目前它以 Vue 为灵感，使用了许多相同的语法，同时计划在未来完全集成 Vue，然而集成的时间和细节还不清楚。因为 Vue 将 HTML 模板作为它设计的核心部分，并且现有特性不支持自定义渲染，因此很难看出目前的 Vue.js 的跨平台能力能像 React 和 React Native 一样强大。</p>
<p><a href="">如果你想要最大的生态系统，请选择 React</a></p>
<p>毫无疑问，React 是目前最受欢迎的前端框架。它在 NPM 上每个月的下载量超过了 250 万次，相比之下，Vue 是 22.5 万次。人气不仅仅是一个肤浅的数字，这意味着更多的文章，教程和更多 Stack Overflow 的解答，还意味有着更多的工具和插件可以在项目中使用，让开发者不再孤立无援。</p>
<p>这两个框架都是开源的，但是 React 诞生于 Facebook，有 Facebook 背书，它的开发者和 Facebook 都承诺会持续维护 React。相比之下，Vue 是独立开发者尤雨溪的作品。尤雨溪目前在全职维护 Vue，也有一些公司资助 Vue，但是规模和 Facebook 和 Google 没得比。不过请对 Vue 的团队放心，它的小规模和独立性并没有成为劣势，Vue 有着固定的发布周期，甚至更令人称道的是，Github 上 Vue 只有 54 个 open issue，3456 个 closed issue，作为对比，React 有多达 530 个 open issue，3447 个 closed issue。</p>
<h4 id="总结一下，我们发现的，Vue-的优势是："><a href="#总结一下，我们发现的，Vue-的优势是：" class="headerlink" title="总结一下，我们发现的，Vue 的优势是："></a>总结一下，我们发现的，Vue 的优势是：</h4><p>模板和渲染函数的弹性选择</p>
<p>简单的语法和项目配置</p>
<p>更快的渲染速度和更小的体积</p>
<h4 id="React-的优势是："><a href="#React-的优势是：" class="headerlink" title="React 的优势是："></a>React 的优势是：</h4><p>更适合大型应用和更好的可测试性</p>
<p>Web 端和移动端原生 APP 通吃</p>
<p>更大的生态系统，更多的支持和好用的工具</p>
<p>然而，React 和 Vue 都是很优秀的框架，它们之间的相似之处多过不同之处，并且大部分的优秀功能是相通的：</p>
<p>用虚拟 DOM 实现快速渲染</p>
<p>轻量级</p>
<p>响应式组件</p>
<p>服务端渲染</p>
<p>集成路由工具，打包工具，状态管理工具的难度低</p>
<p>优秀的支持和社区</p>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="1-虚拟-DOM（Virtual-Document-Object-Model）"><a href="#1-虚拟-DOM（Virtual-Document-Object-Model）" class="headerlink" title="1. 虚拟 DOM（Virtual Document Object Model）"></a>1. 虚拟 DOM（Virtual Document Object Model）</h3><ul>
<li>DOM 的本质什么：浏览器中的概念，用 JS 对象来表示 页面上的 元素，并提供了操作 DOM 对象的 API。</li>
<li>什么是 React 中的虚拟 DOM：是框架中的概念，是 程序员 用 JS 对象来模拟 页面上的 DOM 和 DOM 嵌套。</li>
</ul>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>先直接说一下，DOM 意思是<strong>文档对象模型（Dcoument Object Model）</strong>，它是一个结构化文本的抽象。对于 Web 开发者，这个文本是一段 HTML 代码，DOM 也就被叫做 HTML DOM。HTML 的元素在 DOM 中变成了节点。</p>
<p>所以，HTML 是一段文本，DOM 就是这段文本在内存中的表示。</p>
<blockquote>
<p>可以对比一个程序的一个进程实例。对于一个程序，可以存在多个进程，就像一段同样的 HTML 可以有多个 DOM 一样。（例：同一个页面被多个 tab 加载）。</p>
</blockquote>
<p>在 HTML DOM 中提供了遍历和修改节点的接口（API）。像<em>getElementById</em>或者<em>removeChild</em>这样的方法。我们一般使用 JavaScript 来操作 DOM，这是因为……好吧，天知道为什么。:)</p>
<p>所以，只要我们想要动态修改网页的内容的时候，我们就修改 DOM。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> item = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myLI&quot;</span>);</span><br><span class="line">item.parentNode.removeChild(item);</span><br></pre></td></tr></table></figure>

<p>所谓<em>document</em>就是根节点的抽象，而<em>getElementById</em>，<em>parentNode</em>和<em>emoveChild</em>则是 HTML DOM API 中的方法。</p>
<h2 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h2><p>首先 - 虚拟 DOM 不是 React 发明的，但是 React 用了它且免费提供。</p>
<p>虚拟 DOM 是 HTML DOM 的抽象。它是轻量的，是从浏览器特定（Browser-specific，这里意指特定的浏览器需要特定的实现）实现细节中提取出来的。由于 DOM 本身就已经是一个抽象了，所以虚拟 DOM，实际上，是一个抽象的抽象。</p>
<p>也许把虚拟 DOM 当做 React 的本地和简化版的 HTML DOM 更好。它允许 React 跳过既慢又限于特定浏览器的真实 DOM 操作，以在这个抽象世界中做自己的计算。</p>
<p>常规 DOM 和虚拟 DOM 二者并没有什么大的不同。这也是为什么 React 代码的 JSX 部分可以看起来几乎跟纯 HTML 很像的原因。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CommentBox = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&quot;commentBox&quot;</span>&gt;</span><br><span class="line">        &lt;div&gt;Hello, world! I am a CommentBox.&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在大多数情况下，当你有一段 HTML 代码且想要将其写成一个 React 组件时，你只需要做这个。</p>
<ol>
<li>在 render 方法中返回 HTML 代码；</li>
<li>将 class 属性替换成 className 属性，因为 class 在 JavaScript 中是一个保留关键字。</li>
</ol>
<p>二者之间还有一些，相当细微的区别。</p>
<ul>
<li>虚拟 DOM 的这些属性不在真实的 DOM 中出现——key，ref 和 dangerouslySetInnerHTML。<a href="https://facebook.github.io/react/docs/special-non-dom-attributes.html">查看更多</a></li>
<li>React 范的 DOM 引入了<a href="https://facebook.github.io/react/docs/dom-differences.html">一些限制</a></li>
</ul>
<h2 id="为什么需要虚拟-DOM？"><a href="#为什么需要虚拟-DOM？" class="headerlink" title="为什么需要虚拟 DOM？"></a>为什么需要虚拟 DOM？</h2><p>先介绍浏览器加载一个 HTML 文件需要做哪些事，帮助我们理解为什么我们需要虚拟 DOM。webkit 引擎的处理流程，一图胜千言：</p>
<p><img src="http://static.zxinc520.com/blog/20190425/tKU23C1t4RLN.webp" alt="mark"></p>
<p>所有浏览器的引擎工作流程都差不多，如上图大致分 5 步：创建 DOM tree –&gt; 创建 Style Rules -&gt; 构建 Render tree -&gt; 布局 Layout –&gt; 绘制 Painting</p>
<ul>
<li><p>第一步，用 HTML 分析器，分析 HTML 元素，构建一颗 DOM 树。</p>
</li>
<li><p>第二步：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表。</p>
</li>
<li><p>第三步：将上面的 DOM 树和样式表，关联起来，构建一颗 Render 树。这一过程又称为 Attachment。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer）。这些 render 对象最终会被构建成一颗 Render 树。</p>
</li>
<li><p>第四步：有了 Render 树后，浏览器开始布局，会为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标值。</p>
</li>
<li><p>第五步：Render 数有了，节点显示的位置坐标也有了，最后就是调用每个节点的 paint 方法，让它们显示出来。</p>
</li>
</ul>
<p>当你用传统的源生 api 或 jQuery 去操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。比如当你在一次操作时，需要更新 10 个 DOM 节点，理想状态是一次性构建完 DOM 树，再执行后续操作。但浏览器没这么智能，收到第一个更新 DOM 请求后，并不知道后续还有 9 次更新操作，因此会马上执行流程，最终执行 10 次流程。显然例如计算 DOM 节点的坐标值等都是白白浪费性能，可能这次计算完，紧接着的下一个 DOM 更新请求，这个节点的坐标值就变了，前面的一次计算是无用功。</p>
<p>即使计算机硬件一直在更新迭代，操作 DOM 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验。真实的 DOM 节点，哪怕一个最简单的 div 也包含着很多属性，可以打印出来直观感受一下：</p>
<p>虚拟 DOM 就是为了解决这个浏览器性能问题而被设计出来的。例如前面的例子，假如一次操作中有 10 次更新 DOM 的动作，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地的一个 js 对象中，最终将这个 js 对象一次性 attach 到 DOM 树上，通知浏览器去执行绘制工作，这样可以避免大量的无谓的计算量。</p>
<h2 id="Virtual-DOM-算法"><a href="#Virtual-DOM-算法" class="headerlink" title="Virtual DOM 算法"></a>Virtual DOM 算法</h2><p>可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作 DOM 的时候确实只变更有不同的地方。</p>
<p>这就是所谓的 Virtual DOM 算法。包括几个步骤：</p>
<ol>
<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li>
<li>把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了</li>
</ol>
<p>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。</p>
<h2 id="DIff-算法"><a href="#DIff-算法" class="headerlink" title="DIff 算法"></a>DIff 算法</h2><p>比较两棵 DOM 树的差异是 Virtual DOM 算法最核心的部分.简单的说就是新旧虚拟 dom 的比较，如果有差异就以新的为准，然后再插入的真实的 dom 中，重新渲染。、 借网络一张图片说明:</p>
<p><img src="http://static.zxinc520.com/blog/20190427/TBHlLkPiRjat.webp" alt="mark"></p>
<p><strong>比较只会在同层级进行, 不会跨层级比较。</strong><br>比较后会出现四种情况：<br>1、此节点是否被移除 -&gt; 添加新的节点<br>2、属性是否被改变 -&gt; 旧属性改为新属性<br>3、文本内容被改变-&gt; 旧内容改为新内容<br>4、节点要被整个替换 -&gt; 结构完全不相同 移除整个替换</p>
<h2 id="创建基本的-webpack4-x-项目"><a href="#创建基本的-webpack4-x-项目" class="headerlink" title="创建基本的 webpack4.x 项目"></a>创建基本的 webpack4.x 项目</h2><ol>
<li>运行 <code>npm init -y</code>快速初始化下项目</li>
<li>在项目根目录创建 <strong>src</strong> 源代码目录 和 <strong>dist</strong> 产品目录</li>
<li>在 src 目录下创建 index.html</li>
<li>使用 npm 安装 webpack，运行 <code>npm i webpack webpack-cli -D</code></li>
<li>注意：webpack4.x 提供了 约定大于配置的概念；目的是为了尽量减少 配置文件的体积。<ul>
<li>默认约定了<ul>
<li>打包的入口是 <code>src</code> -&gt;<code> index.js</code></li>
<li>打包的输出文件是 <code>dist</code> -&gt; <code>main.js</code></li>
<li>4.x 中新增的 mode 项：<u>development</u> 和 <u>production</u></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190427/N7Qiefkt9Fwn.png?imageslim" alt="mark"></p>
<p><a href="https://www.webpackjs.com/concepts/mode/">mode 介绍</a></p>
<p>​ <strong>mode</strong> 参数：（<u>development</u> 和 <u>production</u> ）：决定了 配置代码 （压缩代码体积）是否被压缩。</p>
<p><img src="http://static.zxinc520.com/blog/20190427/3EKcIY3d4kos.png?imageslim" alt="mark"></p>
<h3 id="配置-webpack-dev-server-自动打包"><a href="#配置-webpack-dev-server-自动打包" class="headerlink" title="配置 webpack-dev-server (自动打包)"></a>配置 webpack-dev-server (自动打包)</h3><blockquote>
<p><a href="https://github.com/webpack/webpack-dev-server">webpack-dev-server</a> 能够用于快速开发应用程序</p>
</blockquote>
<ol>
<li>安装：运行：<code>npm i webpack-dev-server -D</code></li>
<li>配置 <u>package.json</u></li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以在<u><em>webpack.config.js</em></u> 配置相应的 devServer（自动打开窗口，配置端口号，首页路径展示情况）</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190427/oznoq3LcPA3S.png?imageslim" alt="mark"></p>
<h3 id="配置-html-webpack-plugin"><a href="#配置-html-webpack-plugin" class="headerlink" title="配置 html-webpack-plugin"></a>配置 html-webpack-plugin</h3><blockquote>
<p><a href="https://github.com/jantimon/html-webpack-plugin"><code>HtmlWebpackPlugin</code></a>简化了 HTML 文件的创建，以便为你的 webpack 包提供服务。这对于在文件名中包含每次会随着编译而发生变化哈希的 webpack bundle 尤其有用。 你可以让插件为你生成一个 HTML 文件，使用<a href="https://lodash.com/docs#template">lodash 模板</a>提供你自己的模板，或使用你自己的<a href="https://webpack.docschina.org/loaders">loader</a>。</p>
</blockquote>
<ol>
<li>安装：运行：<code>npm i html-webpack-plugin -D</code></li>
<li>配置 <u>package.json</u></li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190427/uzkbRIjYKMqF.png?imageslim" alt="mark"></p>
<h3 id="配置-Babel"><a href="#配置-Babel" class="headerlink" title="配置 Babel"></a>配置 Babel</h3><blockquote>
<p><a href="https://babeljs.io/">Babel</a>是一个广泛使用的转码器，可以将 ES6 代码转为 ES5 代码</p>
</blockquote>
<p><a href="https://webpack.docschina.org/loaders/babel-loader/#%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3"> webpack 中使用 Babel 官方文档 </a></p>
<ol>
<li><p>安装 <code>npm install -D babel-loader @babel/core @babel/preset-env webpack</code></p>
</li>
<li><p><u>在 webpack 配置对象中，需要将 babel-loader 添加到 module 列表中，就像下面这样</u></p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="解决之前遇到的一个-BUG"><a href="#解决之前遇到的一个-BUG" class="headerlink" title="解决之前遇到的一个 BUG"></a>解决之前遇到的一个 BUG</h3><p><img src="http://static.zxinc520.com/blog/20190427/FnivOIm1VIRg.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190416/vh340CYSUk0d.png?imageslim" alt="1556355771552"></p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>安装：<code>npm i @babel/plugin-proposal-class-properties -D</code></li>
<li>配置 <code>webpack.config.js</code></li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190427/OWlsS3uCQONs.png?imageslim" alt="mark"></p>
<p><strong>运行结果</strong>：</p>
<p><img src="http://static.zxinc520.com/blog/20190427/gHK6mpqXfQca.png?imageslim" alt="mark"></p>
<h2 id="在项目中使用-react"><a href="#在项目中使用-react" class="headerlink" title="在项目中使用 react"></a>在项目中使用 react</h2><ol>
<li>运行 <code>npm i react react-dom -s</code> 安装包<ul>
<li>react：专门用于创建组件和虚拟 DOM 的，同时组件的生命周期都在这个包中</li>
<li>react-dom：专门进行 DOM 操作的，最主要的应用场景，就是 ReactDOM.render()</li>
</ul>
</li>
</ol>
<p><u>尝试写一个 react 项目</u>：</p>
<p><strong>index.js</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步：导入包</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>; <span class="comment">//创建组件，虚拟DOM元素，生命周期</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>; <span class="comment">//把创建好的 组件 和 虚拟DOM 放到页面上展示的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：创建虚拟DOM元素</span></span><br><span class="line"><span class="comment">//参数1：创建的元素的类型，字符串，表示元素的名称</span></span><br><span class="line"><span class="comment">//参数2：是一个对象或 null，表示 当前这个DOM 元素的属性</span></span><br><span class="line"><span class="comment">//参数3：子节点（包括 其它 虚拟DOM 获取 文本子节点）</span></span><br><span class="line"><span class="comment">//参数n：其它子节点</span></span><br><span class="line"><span class="keyword">const</span> myh1 = React.createElement(</span><br><span class="line">  <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;myh1&quot;</span>, <span class="attr">title</span>: <span class="string">&quot;this id h1&quot;</span> &#125;,</span><br><span class="line">  <span class="string">&quot;这是一个大大H1！&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：使用 ReactDOM 把虚拟 DOM 渲染到页面上</span></span><br><span class="line"><span class="comment">//参数一：要渲染的那个虚拟DOM元素</span></span><br><span class="line"><span class="comment">//参数二：指定页面上的DOM元素，当作容器</span></span><br><span class="line">ReactDOM.render(myh1, <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>index.html</strong>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190427/AHtHc973OThy.png?imageslim" alt="mark"></p>
<h2 id="创建-DOM-结构"><a href="#创建-DOM-结构" class="headerlink" title="创建 DOM 结构"></a>创建 DOM 结构</h2><h3 id="方式一：（-基本不用）"><a href="#方式一：（-基本不用）" class="headerlink" title="方式一：（~基本不用）"></a>方式一：（~基本不用）</h3><p><strong>index.js</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步：导入包</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>; <span class="comment">//创建组件，虚拟DOM元素，生命周期</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>; <span class="comment">//把创建好的 组件 和 虚拟DOM 放到页面上展示的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：创建虚拟DOM元素</span></span><br><span class="line"><span class="keyword">const</span> myh1 = React.createElement(</span><br><span class="line">  <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;myh1&quot;</span>, <span class="attr">title</span>: <span class="string">&quot;this id h1&quot;</span> &#125;,</span><br><span class="line">  <span class="string">&quot;这是一个大大H1！&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> mydiv = React.createElement(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;这是一个div元素&quot;</span>, myh1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：使用 ReactDOM 把虚拟 DOM 渲染到页面上</span></span><br><span class="line">ReactDOM.render(mydiv, <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="方式二：JSX-语法-（-important）"><a href="#方式二：JSX-语法-（-important）" class="headerlink" title="方式二：JSX 语法 （~ important）"></a>方式二：JSX 语法 （~ important）</h3><blockquote>
<p>JSX 语法：看起来可能有些奇怪的标签语法既不是字符串也不是 HTML。</p>
<p>JSX 语法的本质，还是在运行的时候，被转换成了 <u><strong>React.createElement 形式</strong></u>来执行的</p>
</blockquote>
<p>使用 <strong>babel</strong> 将 JSX 语法转换为 <u>React.createElement 形式</u> <a href="https://react.docschina.org/docs/introducing-jsx.html">JSX 官方详细介绍</a></p>
<p>关键包：运行 <code>npm install --save-dev @babel/preset-react</code> <a href="https://babeljs.io/docs/en/babel-preset-react">可以参考 babel 官方文档</a></p>
<p><img src="http://static.zxinc520.com/blog/20190427/NHy4KwgF4SNN.png?imageslim" alt="mark"></p>
<p>原因：<u>少写了中括号。（粗心大意了）</u>不该！！<del>~</del></p>
<p><strong>配置 <u>webpack.config.js</u></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置 @babel/preset-react</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [</span><br><span class="line">            <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">            [</span><br><span class="line">              <span class="string">&quot;@babel/preset-react&quot;</span>,</span><br><span class="line">              &#123;</span><br><span class="line">                pragmaFrag: <span class="string">&quot;DomFrag&quot;</span>, <span class="comment">// default is React.Fragment</span></span><br><span class="line">                throwIfNamespace: <span class="literal">false</span>, <span class="comment">// defaults to true</span></span><br><span class="line">              &#125;,</span><br><span class="line">            ],</span><br><span class="line">          ],</span><br><span class="line">          plugins: [<span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="在-JSX-中使用表达式：-JSX-中使用表达式"><a href="#在-JSX-中使用表达式：-JSX-中使用表达式" class="headerlink" title="在 JSX 中使用表达式： JSX 中使用表达式"></a><strong>在 JSX 中使用表达式</strong>：<a href="https://react.docschina.org/docs/introducing-jsx.html"> JSX 中使用表达式</a></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步：导入包</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>; <span class="comment">//创建组件，虚拟DOM元素，生命周期</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>; <span class="comment">//把创建好的 组件 和 虚拟DOM 放到页面上展示的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;zc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是h2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>];</span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">&quot;周琛&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：使用 ReactDOM 把虚拟 DOM 渲染到页面上</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div title=&#123;str&#125;&gt;</span><br><span class="line">    &#123;a + <span class="number">11</span>&#125;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &#123;arr&#125;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &#123;arr1.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span>;</span><br><span class="line">    &#125;)&#125;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190427/EfbH8hDEnVn0.png?imageslim" alt="mark"></p>
]]></content>
      <categories>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Mint-UI、MUI</title>
    <url>/2019/04/18/VueLearn07/</url>
    <content><![CDATA[<h1 id="Vue-第七天学习"><a href="#Vue-第七天学习" class="headerlink" title="Vue 第七天学习"></a>Vue 第七天学习</h1><blockquote>
<p>Mint-UI 学习</p>
<p>MUI</p>
</blockquote>
<h2 id="Mint-UI"><a href="#Mint-UI" class="headerlink" title="Mint-UI"></a>Mint-UI</h2><h3 id="基于-Vue-js-的移动端组件库"><a href="#基于-Vue-js-的移动端组件库" class="headerlink" title="基于 Vue.js 的移动端组件库"></a>基于 Vue.js 的移动端组件库</h3><p><strong>特性介绍：</strong><a href="http://mint-ui.github.io/#!/zh-cn">Mint-UI 官网</a></p>
<ol>
<li>Mint UI 包含丰富的 CSS 和 JS 组件，能够满足日常的移动端开发需要。通过它，可以快速构建出风格统一的页面，提升开发效率。</li>
<li>真正意义上的按需加载组件。可以只加载声明过的组件及其样式文件，无需再纠结文件体积过大。</li>
<li>考虑到移动端的性能门槛，Mint UI 采用 CSS3 处理各种动效，避免浏览器进行不必要的重绘和重排，从而使用户获得流畅顺滑的体验。</li>
<li>依托 Vue.js 高效的组件化方案，Mint UI 做到了轻量化。即使全部引入，压缩后的文件体积也仅有 ~30kb (JS + CSS) gzip。</li>
</ol>
<p><strong>安装：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 安装</span><br><span class="line"><span class="meta">#</span><span class="bash"> Vue 1.x</span></span><br><span class="line">npm install mint-ui@1 -S</span><br><span class="line"><span class="meta">#</span><span class="bash"> Vue 2.0</span></span><br><span class="line">npm install mint-ui -S</span><br></pre></td></tr></table></figure>

<p><strong>来自官网</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入全部组件</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Mint <span class="keyword">from</span> <span class="string">&quot;mint-ui&quot;</span>;</span><br><span class="line">Vue.use(Mint);</span><br><span class="line"><span class="comment">// 按需引入部分组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; Cell, Checklist &#125; <span class="keyword">from</span> <span class="string">&quot;minu-ui&quot;</span>;</span><br><span class="line">Vue.component(Cell.name, Cell);</span><br><span class="line">Vue.component(Checklist.name, Checklist);</span><br></pre></td></tr></table></figure>

<h3 id="项目演示："><a href="#项目演示：" class="headerlink" title="项目演示："></a><strong>项目演示：</strong></h3><p>项目目录：</p>
<p><img src="http://static.zxinc520.com/blog/20190418/udiBT1HHpIk4.png?imageslim" alt="mark"></p>
<p><strong>main.js:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入所以的 MintUI 组件</span></span><br><span class="line"><span class="comment">//导入 mint-ui</span></span><br><span class="line"><span class="keyword">import</span> MintUI <span class="keyword">from</span> <span class="string">&quot;mint-ui&quot;</span>; <span class="comment">//把所有的组件都导入进来</span></span><br><span class="line"><span class="comment">//这里可以 省略 node_modules 目录</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;mint-ui/lib/style.css&quot;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(MintUI); <span class="comment">//把所有的组件，注册为全局的组件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入app组件</span></span><br><span class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"><span class="comment">//导入 自定义路由模块</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./router.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function">(<span class="params">c</span>) =&gt;</span> c(app),</span><br><span class="line">  router,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>App.vue:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;这是app组件&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;mt-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;large&quot;&gt;default&lt;&#x2F;mt-button&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;account&quot;&gt;account&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;goodslist&quot;&gt;goodslist&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190418/L8Aec7UwlBhj.png?imageslim" alt="mark"></p>
<h2 id="JS-components-使用"><a href="#JS-components-使用" class="headerlink" title="JS components 使用"></a>JS components 使用</h2><h4 id="例如：使用-Toast-组件"><a href="#例如：使用-Toast-组件" class="headerlink" title="例如：使用 Toast 组件"></a>例如：使用 <strong>Toast 组件</strong></h4><p>App.vue:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;这是app组件&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;mt-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;large&quot; @click&#x3D;&quot;show&quot;&gt;default&lt;&#x2F;mt-button&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;account&quot;&gt;account&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;goodslist&quot;&gt;goodslist&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; Toast &#125; from &quot;mint-ui&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    show() &#123;</span><br><span class="line">      Toast(&#123;</span><br><span class="line">        message: &quot;Upload Complete&quot;,</span><br><span class="line">        position: &quot;middle&quot;,</span><br><span class="line">        duration: 5000,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190418/4i9Jbv1iwEGP.gif" alt="mark"></p>
<h2 id="使用-bootstrap-图标-配合-Toast-组件-使用"><a href="#使用-bootstrap-图标-配合-Toast-组件-使用" class="headerlink" title="使用 bootstrap 图标 配合 **Toast 组件 **使用"></a>使用 <strong>bootstrap 图标</strong> 配合 **Toast 组件 **使用</h2><ol>
<li>安装 bootstrap 包</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i bootstrap@3.3.7 -S</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 main.js 文件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;bootstrap/dist/css/bootstrap.min.css&quot;</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 App.vue 文件里</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190418/07pVWBGzLVEB.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190418/9NNEMXf71zIY.gif" alt="mark"></p>
<h4 id="自定义图标颜色"><a href="#自定义图标颜色" class="headerlink" title="自定义图标颜色"></a>自定义图标颜色</h4><p><img src="http://static.zxinc520.com/blog/20190418/7x5iyU8lwDzL.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190418/IX8tRWh9aU8d.gif" alt="mark"></p>
<h2 id="模拟-完成接收数据-Toast-组件消失需求"><a href="#模拟-完成接收数据-Toast-组件消失需求" class="headerlink" title="模拟 完成接收数据 Toast 组件消失需求"></a>模拟 完成接收数据 Toast 组件消失需求</h2><h3 id="需求：-1s-后-Toast-组件消失需求"><a href="#需求：-1s-后-Toast-组件消失需求" class="headerlink" title="需求： 1s 后 Toast 组件消失需求"></a>需求： 1s 后 Toast 组件消失需求</h3><p><strong>App.vue:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;这是app组件&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;mt-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;large&quot; @click&#x3D;&quot;show&quot;&gt;default&lt;&#x2F;mt-button&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;account&quot;&gt;account&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;goodslist&quot;&gt;goodslist&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; Toast &#125; from &quot;mint-ui&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      instance: null,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.getList();</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getList() &#123;</span><br><span class="line">      this.show();</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        this.instance.close();</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">    &#125;,</span><br><span class="line">    show() &#123;</span><br><span class="line">      this.instance &#x3D; Toast(&#123;</span><br><span class="line">        message: &quot;Upload Complete&quot;,</span><br><span class="line">        duration: -1,</span><br><span class="line">        position: &quot;middle&quot;,</span><br><span class="line">        duration: 5000,</span><br><span class="line">        iconClass: &quot;glyphicon glyphicon-heart&quot;,</span><br><span class="line">        className: &quot;mytoast&quot;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190418/qPQ3yPDUEMHo.gif" alt="mark"></p>
<h2 id="babel-plugin-component-插件"><a href="#babel-plugin-component-插件" class="headerlink" title="babel-plugin-component 插件"></a>babel-plugin-component 插件</h2><p><strong>作用</strong>：为了项目整体内容不过于庞大，按需加载是许多第三方的库和插件必不可少的，于是使用了官方提供的按需加载插件<a href="https://link.juejin.im/?target=https://github.com/ElementUI/babel-plugin-component">babel-plugin-component</a></p>
<h3 id="按需导入："><a href="#按需导入：" class="headerlink" title="按需导入："></a>按需导入：</h3><ol>
<li>1.安装：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install babel-plugin-component -D</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>2.修改 <strong>.babelrc</strong> 里面的 <strong>plugins</strong> ：</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [<span class="string">&quot;env&quot;</span>, <span class="string">&quot;stage-0&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;transform-runtime&quot;</span>,</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;component&quot;</span>,</span><br><span class="line">      [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;libraryName&quot;</span>: <span class="string">&quot;mint-ui&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;style&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="项目改造"><a href="#项目改造" class="headerlink" title="项目改造"></a>项目改造</h2><h4 id="按需导入"><a href="#按需导入" class="headerlink" title="按需导入"></a>按需导入</h4><p><strong>mian.js:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;mint-ui/lib/style.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按需导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">&quot;mint-ui&quot;</span>;</span><br><span class="line">Vue.component(<span class="string">&quot;mybtn&quot;</span>, Button); <span class="comment">//导入自定义的 mybtn 按钮组件</span></span><br></pre></td></tr></table></figure>

<p><strong>App.vue:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;这是app组件&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;mybtn type&#x3D;&quot;primary&quot;&gt;mybtn&lt;&#x2F;mybtn&gt;</span><br><span class="line">        &lt;router-link to&#x3D;&quot;&#x2F;account&quot;&gt;account&lt;&#x2F;router-link&gt;</span><br><span class="line">        &lt;router-link to&#x3D;&quot;&#x2F;goodslist&quot;&gt;goodslist&lt;&#x2F;router-link&gt;</span><br><span class="line">        &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;templat</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190418/Kh82KQyT57d4.png?imageslim" alt="mark"></p>
<h2 id="MUI"><a href="#MUI" class="headerlink" title="MUI"></a>MUI</h2><blockquote>
<p>注意： MUI 不同于 Mint-UI，MUI 只是开发出来的一套好用的代码片段，里面提供了配套的样式、配套的 HTML 代码段，类似于 Bootstrap； 而 Mint-UI，是真正的组件库，是使用 Vue 技术封装出来的 成套的组件，可以无缝的和 VUE 项目进行集成开发；<br>因此，从体验上来说， Mint-UI 体验更好，因为这是别人帮我们开发好的现成的 Vue 组件；<br>从体验上来说， MUI 和 Bootstrap 类似；<br>理论上，任何项目都可以使用 MUI 或 Bootstrap，但是，MInt-UI 只适用于 Vue 项目；</p>
</blockquote>
<p><strong>mui 框架：</strong>性能和体验的差距，一直是 mobile app 开发者放弃 HTML5 的首要原因。 浏览器天生的切页白屏、不忍直视的转页动画、浮动元素的抖动、无法流畅下拉刷新等问题，这些都让 HTML5 开发者倍感挫败，尤其拿到 Android 低端机运行，摔手机的心都有； 另一方面，浏览器默认控件样式又少又丑，制作一个漂亮的控件非常麻烦，也有一些制作简单的 ui 框架但性能低下。</p>
<p>mui 框架有效的解决了这些问题，这是一个可以方便开发出高性能 App 的框架，也是目前最接近原生 App 效果的框架。</p>
<p><strong>注意：</strong> MUI 并不能使用 npm 去下载，需要自己手动从 github 上，下载现成的包，自己解压出来，然后手动拷贝到项目中使用；</p>
<ol>
<li>下载 MUI 包 从 github 上</li>
</ol>
<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p><strong>在 main.js 导入 MUI 包:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./lib/dist/css/mui.min.css&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>在 App.vue 中使用（例如一个 按钮）：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;mui-btn mui-btn-royal&quot;</span>&gt;</span></span><br><span class="line">  Badge button <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;mui-badge mui-badge-royal&quot;</span>&gt;</span>999<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190418/TxVONoruT7Xq.png?imageslim" alt="mark"></p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>Mint-UI</tag>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack、webpack 后续问题</title>
    <url>/2019/04/17/VueLearn06/</url>
    <content><![CDATA[<h1 id="Vue-第六天学习"><a href="#Vue-第六天学习" class="headerlink" title="Vue 第六天学习"></a>Vue 第六天学习</h1><blockquote>
<p>file-loader（解决 webpack 打包图片路径问题，字体路径问题）</p>
<p>webpack 中 babel 的配置（处理高级的 es6 语法或者 es7 语法）</p>
<p>Vue 中的 render 函数</p>
<p>在 webpack 构建的项目中，使用 Vue 进行开发</p>
<p>export default 和 export 的使用方式</p>
<p>结合 webpack 使用 vue-router</p>
<p>组件中 style 标签 lang 属性和 scoped 属性的介绍</p>
<p>抽离路由模块</p>
<p>一个人如果不想输，就要不断学好眼前的东西，它们将来都会大有用处…</p>
</blockquote>
<h2 id="webpack-后续问题"><a href="#webpack-后续问题" class="headerlink" title="webpack 后续问题"></a>webpack 后续问题</h2><h5 id="问题：Webpack-打包图片路径问题"><a href="#问题：Webpack-打包图片路径问题" class="headerlink" title="问题：Webpack 打包图片路径问题"></a>问题：Webpack 打包图片路径问题</h5><p><img src="http://static.zxinc520.com/blog/20190415/EHGtOouC7m7W.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190415/67j7Iq3tsM4q.png?imageslim" alt="mark"></p>
<h4 id="在页面中引入图片有两种方式"><a href="#在页面中引入图片有两种方式" class="headerlink" title="在页面中引入图片有两种方式"></a>在页面中引入图片有两种方式</h4><ul>
<li>img 标签引入</li>
<li>css 引入</li>
</ul>
<h2 id="解决方案：Webpack-使用-file-loader-处理图片"><a href="#解决方案：Webpack-使用-file-loader-处理图片" class="headerlink" title="解决方案：Webpack 使用 file-loader 处理图片"></a>解决方案：Webpack 使用 file-loader 处理图片</h2><h3 id="安装：file-loader-包"><a href="#安装：file-loader-包" class="headerlink" title="安装：file-loader 包"></a>安装：<strong>file-loader</strong> 包</h3><ol>
<li>运行 <code>npm i url-loader file-loader -D</code> 来安装 <strong>file-loader</strong> 包</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190415/tFYCSVQRUkQu.png?imageslim" alt="mark"></p>
<p>​</p>
<ol start="2">
<li>配置 webpack.config.js 文件</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190415/cELvBLsveIEX.png?imageslim" alt="mark"></p>
<ol start="3">
<li>运行<code> npm run dev</code></li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190415/VVGGMT2828JL.gif" alt="mark"></p>
<h3 id="file-loader-参数"><a href="#file-loader-参数" class="headerlink" title="file-loader 参数"></a>file-loader 参数</h3><ul>
<li><p><code>limit</code> 给定的值，是图片的大小，单位是 byte，如果我们引用的 图片，<strong>大于 **给定的值，则会被转为</strong>base64 格式** 的字符串，如果，图片**小于或等于 **给定的 limit 值，则不会被转为 base64 的 字符串<br><img src="http://static.zxinc520.com/blog/20190416/XiEHyP6vdL8s.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190416/T1MukN0guNf5.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190416/FPE7T3OUKGxd.png?imageslim" alt="mark"></p>
</li>
<li><p><code>name</code> 属性 使图片路径 url 不变</p>
</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190416/wX5GMiFDX3zF.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190416/9qKydj98tyeA.png?imageslim" alt="mark"></p>
<h2 id="处理字体文件-路径问题"><a href="#处理字体文件-路径问题" class="headerlink" title="处理字体文件 路径问题"></a>处理字体文件 路径问题</h2><blockquote>
<p>使用 <strong>file-loader</strong></p>
</blockquote>
<p>问题描述：引入 bootstrap 字体图标库，但报错！</p>
<p><img src="http://static.zxinc520.com/blog/20190416/1tjFUEn3NBee.png?imageslim" alt="mark"></p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>配置 webpack.config.js</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">test</span>:<span class="regexp">/\.(ttf|eot|svg|woff|woff2)$/</span>,use:<span class="string">&#x27;url-loader&#x27;</span>&#125;,<span class="comment">//这是 处理 字体文件的 loader</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190417/K7a1le382DJs.png?imageslim" alt="mark"></p>
<ol start="2">
<li>运行 <code>npm run dev</code></li>
</ol>
<h1 id="webpack-中-babel-的配置"><a href="#webpack-中-babel-的配置" class="headerlink" title="webpack 中 babel 的配置"></a>webpack 中 babel 的配置</h1><p><a href="https://www.babeljs.cn/docs/index.html">babel 介绍 </a></p>
<p><strong>问题描述</strong>：</p>
<ol>
<li>webpack 中默认只能处理一部分 es6 语法，一些更高级的 es6 语法或者 es7 语法 webpack 处理不了，这时候就需要借助第三方 loader 帮助 webpack 处理这些语法</li>
<li>class 是 es6 中提供的语法，是用来实现 es6 中面向对象编程的方式，class 和 static 与 Java 中类似</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190416/4zFaWW0Qqco2.png?imageslim" alt="mark"></p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>通过 <strong>babel</strong> 可以将高级语法转化为低级语法</li>
<li>安装，运行两个命令，安装两套包，去安装 babel 相关的功能</li>
</ol>
<ul>
<li><strong>第一套包</strong>：<code>npm i babel-core babel-loader babel-plugin-transform-runtime -D</code></li>
<li><strong>第二套包</strong>：<code>npm i babel-preset-env babel-preset-stage-0 -D</code></li>
</ul>
<ol start="3">
<li>打开 webpack 配置文件，在 module 节点写的 rules 数组中添加一个新的匹配规则</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">test</span>:<span class="regexp">/\.js$/</span>,use:<span class="string">&#x27;babel-loader&#x27;</span>,<span class="attr">exclude</span>:<span class="regexp">/node_modules/</span>&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190416/T3zLwVwLDPgf.png?imageslim" alt="mark"></p>
<!--在配置babel的loader规则时必须把node_module目录通过exclude排除-->

<p><strong>排除 node_module 目录的原因:</strong></p>
<ul>
<li>如果排除 node_module，babel 会把 node_module 目录下的所有第三方 js 文件都打包编译，这会非常消耗 CPU，同时打包速度非常慢</li>
<li>babel 把 node_module 中的 js 文件转化完毕项目也无法正常运行</li>
</ul>
<ol start="4">
<li>在项目的根目录中新建一个叫做 <strong>.babelrc</strong> 的 babel 配置文件，这个配置文件属于 <strong>json 格式</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>:[<span class="string">&quot;env&quot;</span>,<span class="string">&quot;stage-0&quot;</span>],</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>:[<span class="string">&quot;transform-runtime&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190416/Mddz8O6ipjPl.png?imageslim" alt="mark"></p>
<p><strong>报错：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190416/6PopTItC2OrO.png?imageslim" alt="mark"></p>
<p><strong>解决方案：</strong>执行 <code>npm i babel-loader@7</code></p>
<p><img src="http://static.zxinc520.com/blog/20190416/HJupUdf1JIBA.png?imageslim" alt="mark"></p>
<p><strong>报错：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190416/dYb1bw19ID0Y.png?imageslim" alt="mark"></p>
<p><strong>啊啊啊啊~~ 崩溃！！</strong></p>
<h2 id="修改之后还是跑不起来—-醉了！！"><a href="#修改之后还是跑不起来—-醉了！！" class="headerlink" title="修改之后还是跑不起来—-醉了！！"></a>修改之后还是跑不起来—-醉了！！</h2><p><img src="http://static.zxinc520.com/blog/20190416/dK1vXd5NuoO4.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190416/sEpb3GoWOHIM.png?imageslim" alt="mark"></p>
<p><strong>报错：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190416/vh340CYSUk0d.png?imageslim" alt="mark"></p>
<h2 id="升级总结（来自百度）"><a href="#升级总结（来自百度）" class="headerlink" title="升级总结（来自百度）"></a>升级总结（<a href="https://segmentfault.com/a/1190000016458913">来自百度</a>）</h2><h4 id="babel-升级-7-X-踩坑记录"><a href="#babel-升级-7-X-踩坑记录" class="headerlink" title="-babel 升级 7.X 踩坑记录"></a>-babel 升级 7.X 踩坑记录</h4><ol>
<li>babel 包名改变，以前安装是 <code>npm i babel-*</code> 现在安装 babel 系列需要写成 <code>npm i @babel/*</code></li>
<li><code>.babelrc</code> 文件写法改变，<code>preset plugins</code> 等全部写成 <code>@babel/*</code> 的形式</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm:</span><br><span class="line">- babel-preset-env</span><br><span class="line">+ @babel/preset-env</span><br><span class="line">- babel-preset-react</span><br><span class="line">+ @babel/preset-react</span><br><span class="line">- babel-preset-stage-0</span><br><span class="line"></span><br><span class="line">.babelrc:</span><br><span class="line">- &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;, &quot;stage-0&quot;, &quot;mobx&quot;]</span><br><span class="line">+ &quot;presets&quot;: [&quot;@babel/preset-react&quot;, &quot;@babel/preset-env&quot;, &quot;mobx&quot;]</span><br></pre></td></tr></table></figure>

<p>除了上述的<code>preset</code>，我还用了<code>babel-preset-mobx</code><br>但是没找到 <code>@babel/preset-mobx</code>，从<a href="https://github.com/zwhitchcox/babel-preset-mobx/commits/master">babel-preset-mobx git 提交日志</a>上看，作者已经支持了最新的<code>babel</code>。在之后的测试中，发现<code>mobx</code>的功能也能正常使用。<br>另外，<a href="https://babeljs.io/blog/2018/07/27/removing-babels-stage-presets">stage-*已弃用</a></p>
<h2 id="使用-Vue-实例的-render-方法"><a href="#使用-Vue-实例的-render-方法" class="headerlink" title="使用 Vue 实例的 render 方法"></a>使用 Vue 实例的 render 方法</h2><blockquote>
<p>Vue 推荐使用在绝大多数情况下使用 template 来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力，这就是 <strong>render 函数</strong>，它比 template 更接近编译器。</p>
</blockquote>
<p>*基本使用**</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> login = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>login 组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&quot;,</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    render(createElement) &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> createElement(login);</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190417/El6GtYoXY4Wm.png?imageslim" alt="mark"></p>
<h2 id="在-webpack-构建的项目中，使用-Vue-进行开发"><a href="#在-webpack-构建的项目中，使用-Vue-进行开发" class="headerlink" title="在 webpack 构建的项目中，使用 Vue 进行开发"></a>在 webpack 构建的项目中，使用 Vue 进行开发</h2><ul>
<li>在普通网页中如何使用 Vue<ul>
<li>1.使用 script 标签，引入 Vue 的包</li>
<li>2.在 index 页面中，创建 一个 id 为 app div 容器</li>
<li>3.通过 new Vue 得到一个 vm 的实例</li>
</ul>
</li>
</ul>
<h2 id="重点：在-webpack-中-尝试-使用-Vue"><a href="#重点：在-webpack-中-尝试-使用-Vue" class="headerlink" title="重点：在 webpack 中 尝试 使用 Vue"></a>重点：在 webpack 中 尝试 使用 Vue</h2><ol>
<li><strong>直接导入 Vue 包</strong>：</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190417/fl74cG8ej4BE.png?imageslim" alt="mark"></p>
<p><strong>结果报错</strong>：</p>
<p><img src="http://static.zxinc520.com/blog/20190417/wte2gIV3SL5L.png?imageslim" alt="mark"></p>
<!--注意：在webpack 中 使用 `import Vue from 'vue'`导入的 Vue 构造函数，功能不完整，只提供了 **runtime-only** 的方式，并没有提供 像网页中-->

<p><img src="http://static.zxinc520.com/blog/20190417/FDsekOzOdqSz.png?imageslim" alt="mark"></p>
<h4 id="回顾-：包的-查找-规则"><a href="#回顾-：包的-查找-规则" class="headerlink" title="- 回顾 ：包的 查找 规则"></a>- 回顾 ：包的 <strong>查找</strong> 规则</h4><ol>
<li>找 项目根目录中有没有 node_modules 的文件夹</li>
<li>在 node_modules 中，根据包名，找对应的 vue 文件夹</li>
<li>在 vue 文件夹中，找 一个叫 package.json 的包配置文件</li>
<li>在 package.json 文件中，查找 一个 main 属性【mian 属性指定了这个包在被加载的时候的入口文件】</li>
</ol>
<p><strong>解决方案 1</strong>：</p>
<p><img src="http://static.zxinc520.com/blog/20190417/Q2FwTyktL3nF.png?imageslim" alt="mark"></p>
<p><strong>解决方案 2</strong>：</p>
<p><img src="http://static.zxinc520.com/blog/20190417/67SE8EyWVRmn.png?imageslim" alt="mark"></p>
<p><strong>解决方案 3（更优雅）：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190417/Cfv9yq1PVXPl.png?imageslim" alt="mark"></p>
<h2 id="定义-文件形式-vue-组件-加载到页面上"><a href="#定义-文件形式-vue-组件-加载到页面上" class="headerlink" title="定义 文件形式 vue 组件 加载到页面上"></a>定义 文件形式 vue 组件 加载到页面上</h2><p><strong>例如</strong>：</p>
<p><img src="http://static.zxinc520.com/blog/20190417/znhigwsi4kiE.png?imageslim" alt="mark"></p>
<p><strong>报错：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190417/6ag81mxVMdjN.png?imageslim" alt="mark"></p>
<p><strong>原因：</strong></p>
<ul>
<li>默认，webpack 无法打包 .vue 文件，需要安装 *<em>相关的 loader</em></li>
</ul>
<p><strong>解决方案：</strong></p>
<ol>
<li><p>安装：执行 <code>npm i vue-loader vue-template-compiler -D</code> 命令</p>
</li>
<li><p>配置 webpack.config.js 文件</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">test</span>:<span class="regexp">/\.vue$/</span>,use:<span class="string">&#x27;vue-loader&#x27;</span>&#125; 	<span class="comment">//处理 .vue后缀名的 loader</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190417/8cY6BeLLmNt2.png?imageslim" alt="mark"></p>
<p>结果：还是报错</p>
<p><img src="http://static.zxinc520.com/blog/20190417/VgCmomodVkuA.png?imageslim" alt="mark"></p>
<h4 id="原因：Vue-loader-在-15-之后的版本都是-vue-loader-的使用都是需要伴生-VueLoaderPlugin-的"><a href="#原因：Vue-loader-在-15-之后的版本都是-vue-loader-的使用都是需要伴生-VueLoaderPlugin-的" class="headerlink" title="原因：Vue-loader 在 15.*之后的版本都是 vue-loader 的使用都是需要伴生 VueLoaderPlugin 的."></a>原因：Vue-loader 在 15.*之后的版本都是 vue-loader 的使用都是需要伴生 VueLoaderPlugin 的.</h4><p>解决：在 <strong>webpack.config.js</strong> 中加入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">&quot;vue-loader/lib/plugin&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">&quot;sourcemap&quot;</span>,</span><br><span class="line">  entry: <span class="string">&quot;./js/entry.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> VueLoaderPlugin()],</span><br><span class="line">  <span class="built_in">module</span>: &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190417/4zePeemdDl56.png?imageslim" alt="mark"></p>
<p><strong>使用 render 函数 ：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190417/z60O8OR9qlLk.png?imageslim" alt="mark"><img src="http://static.zxinc520.com/blog/20190417/NG0rBbunP4N7.png?imageslim" alt="mark"></p>
<h2 id="总结梳理："><a href="#总结梳理：" class="headerlink" title="总结梳理："></a>总结梳理：</h2><h4 id="总结梳理：-webpack-中如何使用-vue"><a href="#总结梳理：-webpack-中如何使用-vue" class="headerlink" title="总结梳理： webpack 中如何使用 vue"></a>总结梳理： webpack 中如何使用 vue</h4><ol>
<li><p>安装 vue 的包： cnpm i vue -S</p>
</li>
<li><p>由于 在 webpack 中，推荐使用 .vue 这个组件模板文件定义组件，所以，需要安装 能解析这种文件的 loader ，执行命令： <code>cnpm i vue-loader vue-template-complier -D</code></p>
</li>
<li><p>在 main.js 中，导入 vue 模块 import Vue from ‘vue’</p>
</li>
<li><p>定义一个 .vue 结尾的组件，其中，组件有三部分组成： template script style</p>
</li>
<li><p>使用 import login from ‘./login.vue’ 导入这个组件</p>
</li>
<li><p>创建 vm 的实例 var vm = new Vue({ el: ‘#app’, render: c =&gt; c(login) })</p>
</li>
<li><p>在页面中创建一个 id 为 app 的 div 元素，作为我们 vm 实例要控制的区域；</p>
</li>
</ol>
<h2 id="export-default-和-export-的使用方式"><a href="#export-default-和-export-的使用方式" class="headerlink" title="export default 和 export 的使用方式"></a>export default 和 export 的使用方式</h2><p><strong>基本使用：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;这是登录组件，vue 文件定义出来的--&#123;&#123; msg &#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;哈哈哈&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    show() &#123;</span><br><span class="line">      console.log(&quot;调用了 login.vue 中的show 方法！&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190417/VJ8FVeRYb0oV.png?imageslim" alt="mark"></p>
<h2 id="export，import-，export-default-是什么？"><a href="#export，import-，export-default-是什么？" class="headerlink" title="export，import ，export default 是什么？"></a>export，import ，export default 是什么？</h2><p>ES6 模块主要有两个功能：export 和 import<br><strong>export</strong> 用于对外输出本模块（一个文件可以理解为一个模块）变量的接口<br><strong>import</strong> 用于在一个模块中加载另一个含有 export 接口的模块。<br>也就是说使用 export 命令定义了模块的对外接口以后，其他 JS 文件就可以通过 import 命令加载这个模块（文件）。这几个都是 ES6 的语法。</p>
<ul>
<li>注意：export default 向外暴露的成员，可以使用任意的变量来接受</li>
<li>注意：在一个模块中，export default 只允许向外暴露一次</li>
<li>注意：在一个模块中，可以同时使用 export 和 export default 向外暴露成员</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">在 Node中，使用 <span class="keyword">var</span> 名称= <span class="built_in">require</span>(<span class="string">&#x27;模块标识符&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports和 <span class="built_in">exports</span> 来暴露成员</span><br></pre></td></tr></table></figure>

<h2 id="export-与-export-default"><a href="#export-与-export-default" class="headerlink" title="export 与 export default"></a>export 与 export default</h2><p>上面讲的是 export 和 import，但是 <strong>export</strong> 跟 <strong>export default</strong> 有什么区别呢？如下：</p>
<ol>
<li>export 与 export default 均可用于导出常量、函数、文件、模块等</li>
<li>你可以在其它文件或模块中通过 import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用</li>
<li>在一个文件或模块中，export、import 可以有多个，export default 仅有一个，<strong>export default</strong> 只能导出<strong>一个默认模块</strong>，这个模块<strong>可以匿名</strong>（ 引入的时候可以给这个模块取任意名字，例如 “obj”，且不需要用大括号括起来。）</li>
</ol>
<p><strong>export ：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo1.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的引入方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo2.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; str, f &#125; <span class="keyword">from</span> <span class="string">&quot;demo1&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>export default</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo1.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  a: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  b: <span class="string">&quot;world&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应的引入方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo2.js</span></span><br><span class="line"><span class="keyword">import</span> obj <span class="keyword">from</span> <span class="string">&quot;demo1&quot;</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>通过 export 方式导出，在导入时要<strong>加 { }**，export default 则 **不需要</strong></li>
</ol>
<p>这样来说其实很多时候 export 与 export default 可以实现同样的目的，只是用法有些区别。注意第四条，通过 export 方式导出，在导入时要加{ }，export default 则不需要。使用 export default 命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">&quot;李四&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; name &#125;</span><br><span class="line"><span class="comment">//import &#123; name &#125; from &quot;/.a.js&quot;</span></span><br><span class="line">可以写成：</span><br><span class="line"><span class="keyword">var</span> name=<span class="string">&quot;李四&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> name</span><br><span class="line"><span class="comment">//import name from &quot;/.a.js&quot; 这里name不需要大括号</span></span><br></pre></td></tr></table></figure>

<h3 id="说明与比较：new-Vue-和-export-default-？"><a href="#说明与比较：new-Vue-和-export-default-？" class="headerlink" title="说明与比较：new Vue() 和 export default {}？"></a>说明与比较：new Vue() 和 export default {}？</h3><p>在生成、导出、导入、使用 Vue 组件的时候，像我这种新手就会常常被位于不同文件的 <code>new Vue()</code> 和 <code>export default&#123;&#125;</code> 搞得晕头转向。它们含义到底是什么，又有什么异同呢？</p>
<p>首先，Vue 是什么？ po 主的理解是 Vue 就是一个构造函数，生成的实例是一个巨大的对象，可以包含数据、模板、挂载元素、方法、生命周期钩子等选项。</p>
<p>所以渲染的时候，可以使用构造 Vue 实例的方式来渲染相应的 html 页面：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那么 export default {} 又是来干嘛的？</p>
<p>这是在复用组件的时候用到的。假设我们写了一个单页面组件 A 文件，而在另一个文件 B 里面需要用到它，那么就要用 <a href="http://es6.ruanyifeng.com/?search=%E7%9C%81%E7%95%A5&x=0&y=0#docs/module">ES6 的 import/export 语法</a> ，在文件 A 中定义输出接口 <code>export **</code>，在文件 B 中引入 <code>import **</code>，然后再生成一个 Vue 实例 <code>new Vue (**)</code>，把引入的组件用起来，这样就可以复用组件 A 去配合文件 B 生成 html 页面了。</p>
<h2 id="结合-webpack-使用-vue-router"><a href="#结合-webpack-使用-vue-router" class="headerlink" title="结合 webpack 使用 vue-router"></a>结合 webpack 使用 vue-router</h2><ol>
<li>安装 <code>npm i vue-router -S </code></li>
</ol>
<p>例：</p>
<p>目录结构：</p>
<p><img src="http://static.zxinc520.com/blog/20190417/MFFstwRsuS8S.png?imageslim" alt="mark"></p>
<p><strong>main.js：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 webpack 构建的项目中，使用Vue 进行开发</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;../node_modules/vue/dist/vue.js&quot;</span>;</span><br><span class="line"><span class="comment">//1. 导入 vue-router 包</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 手动安装</span></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入app组件</span></span><br><span class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"><span class="comment">//导入 Account 组件</span></span><br><span class="line"><span class="keyword">import</span> account <span class="keyword">from</span> <span class="string">&quot;./main/Account.vue&quot;</span>;</span><br><span class="line"><span class="comment">//导入 GoodsList 组件</span></span><br><span class="line"><span class="keyword">import</span> goodslist <span class="keyword">from</span> <span class="string">&quot;./main/GoodsList.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 创建路由对象</span></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/account&quot;</span>, <span class="attr">component</span>: account &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/goodslist&quot;</span>, <span class="attr">component</span>: goodslist &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">&quot;12322&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function">(<span class="params">c</span>) =&gt;</span> c(app),</span><br><span class="line">  router,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//注意：App 这个组件，是通过 VM 实例的 render 函数，渲染出来的，render 函数如果要渲染 组件渲染出来的组件，只能是 el ：&#x27;#app&#x27; 所指定的 元素中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Account 和 GoodsList 组件，是通过 路由匹配监听到的，所以，这两个组件，只能展示到 属于 路由的 &lt;router-view&gt;&lt;/router-view&gt; 中去</span></span><br></pre></td></tr></table></figure>

<p><strong>App.vue:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;这是app组件&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;account&quot;&gt;account&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;goodslist&quot;&gt;goodslist&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style&gt;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190417/8RslBeQhHAvx.gif" alt="mark"></p>
<h2 id="webpack-路由嵌套"><a href="#webpack-路由嵌套" class="headerlink" title="webpack-路由嵌套"></a>webpack-路由嵌套</h2><p>目录结构：</p>
<p><img src="http://static.zxinc520.com/blog/20190417/KpfhuMnyjazc.png?imageslim" alt="mark"></p>
<p><strong>main.js:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 webpack 构建的项目中，使用Vue 进行开发</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;../node_modules/vue/dist/vue.js&quot;</span>;</span><br><span class="line"><span class="comment">//1. 导入 vue-router 包</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 手动安装</span></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入app组件</span></span><br><span class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"><span class="comment">//导入 Account 组件</span></span><br><span class="line"><span class="keyword">import</span> account <span class="keyword">from</span> <span class="string">&quot;./main/Account.vue&quot;</span>;</span><br><span class="line"><span class="comment">//导入 GoodsList 组件</span></span><br><span class="line"><span class="keyword">import</span> goodslist <span class="keyword">from</span> <span class="string">&quot;./main/GoodsList.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> login <span class="keyword">from</span> <span class="string">&quot;./son/login.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> register <span class="keyword">from</span> <span class="string">&quot;./son/register.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 创建路由对象</span></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&quot;/account&quot;</span>,</span><br><span class="line">      component: account,</span><br><span class="line">      children: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;login&quot;</span>, <span class="attr">component</span>: login &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;register&quot;</span>, <span class="attr">component</span>: register &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/goodslist&quot;</span>, <span class="attr">component</span>: goodslist &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">&quot;12322&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function">(<span class="params">c</span>) =&gt;</span> c(app),</span><br><span class="line">  router,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//注意：App 这个组件，是通过 VM 实例的 render 函数，渲染出来的，render 函数如果要渲染 组件渲染出来的组件，只能是 el ：&#x27;#app&#x27; 所指定的 元素中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Account 和 GoodsList 组件，是通过 路由匹配监听到的，所以，这两个组件，只能展示到 属于 路由的 &lt;router-view&gt;&lt;/router-view&gt; 中去</span></span><br></pre></td></tr></table></figure>

<p><strong>App.vue:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;这是app组件&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;account&quot;&gt;account&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;goodslist&quot;&gt;goodslist&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Account:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;这是Account组件&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;account&#x2F;login&quot;&gt;登录&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;account&#x2F;register&quot;&gt;注册&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190417/tSeVisl10K0W.gif" alt="mark"></p>
<h2 id="组件中-style-标签-lang-属性和-scoped-属性的介绍"><a href="#组件中-style-标签-lang-属性和-scoped-属性的介绍" class="headerlink" title="组件中 style 标签 lang 属性和 scoped 属性的介绍"></a>组件中 style 标签 lang 属性和 scoped 属性的介绍</h2><p><strong>scoped：</strong>在子组件中设置 style 属性，如果不加 scoped 属性，如果是单页面程序，样式就会作用到全局中去，加了 scoped 属性以后，表示限制了该样式作用域只在该组件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;这是goods组件&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">div &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p><strong>lang 属性：</strong>普通的 style 标签只支持普通的样式,如果想启用 scss 或 less,需要为 style 设置 lang 属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;这是account组件&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line">body &#123;</span><br><span class="line">  div &#123;</span><br><span class="line">    font-style: italic;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="抽离路由模块"><a href="#抽离路由模块" class="headerlink" title="抽离路由模块"></a>抽离路由模块</h2><p>目录结构：</p>
<p><img src="http://static.zxinc520.com/blog/20190417/imC2sybXMC8G.png?imageslim" alt="mark"></p>
<p><strong>main.js:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 webpack 构建的项目中，使用Vue 进行开发</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;../node_modules/vue/dist/vue.js&quot;</span>;</span><br><span class="line"><span class="comment">//1. 导入 vue-router 包</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 手动安装</span></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入app组件</span></span><br><span class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"><span class="comment">//导入 自定义路由模块</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./router.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">&quot;12322&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function">(<span class="params">c</span>) =&gt;</span> c(app),</span><br><span class="line">  router,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//注意：App 这个组件，是通过 VM 实例的 render 函数，渲染出来的，render 函数如果要渲染 组件渲染出来的组件，只能是 el ：&#x27;#app&#x27; 所指定的 元素中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Account 和 GoodsList 组件，是通过 路由匹配监听到的，所以，这两个组件，只能展示到 属于 路由的 &lt;router-view&gt;&lt;/router-view&gt; 中去</span></span><br></pre></td></tr></table></figure>

<p><strong>router.js:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入 Account 组件</span></span><br><span class="line"><span class="keyword">import</span> account <span class="keyword">from</span> <span class="string">&quot;./main/Account.vue&quot;</span>;</span><br><span class="line"><span class="comment">//导入 GoodsList 组件</span></span><br><span class="line"><span class="keyword">import</span> goodslist <span class="keyword">from</span> <span class="string">&quot;./main/GoodsList.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> login <span class="keyword">from</span> <span class="string">&quot;./son/login.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> register <span class="keyword">from</span> <span class="string">&quot;./son/register.vue&quot;</span>;</span><br><span class="line"><span class="comment">//3. 创建路由对象</span></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&quot;/account&quot;</span>,</span><br><span class="line">      component: account,</span><br><span class="line">      children: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;login&quot;</span>, <span class="attr">component</span>: login &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;register&quot;</span>, <span class="attr">component</span>: register &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/goodslist&quot;</span>, <span class="attr">component</span>: goodslist &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>vue</tag>
        <tag>webpack 后续问题</tag>
      </tags>
  </entry>
  <entry>
    <title>监听事件、nrm、webpack</title>
    <url>/2019/04/13/VueLearn05/</url>
    <content><![CDATA[<h1 id="Vue-第五天"><a href="#Vue-第五天" class="headerlink" title="Vue 第五天"></a>Vue 第五天</h1><blockquote>
<p>监听事件（keyup ，watch ，computed ）</p>
<p>nrm （简单介绍了下）</p>
<p>webpack （很重要！很关键！很实用！重点中的重点！知识点有点多，得慢慢品味！）</p>
</blockquote>
<h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><h4 id="需求：实现名称监听案例"><a href="#需求：实现名称监听案例" class="headerlink" title="需求：实现名称监听案例"></a>需求：实现名称监听案例</h4><h4 id="1-keyup-事件监听"><a href="#1-keyup-事件监听" class="headerlink" title="1.keyup 事件监听"></a>1.keyup 事件监听</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;firstName&quot;</span> @<span class="attr">keyup</span>=<span class="string">&quot;getFullName&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;lastName&quot;</span> @<span class="attr">keyup</span>=<span class="string">&quot;getFullName&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;fullName&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      firstName: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">      lastName: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">      fullName: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      getFullName() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.fullName = <span class="built_in">this</span>.firstName + <span class="built_in">this</span>.lastName;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-使用-watch-监听-（-更常用-–-用途更广-）"><a href="#2-使用-watch-监听-（-更常用-–-用途更广-）" class="headerlink" title="2.使用 watch 监听 （ 更常用 – 用途更广 ）"></a>2.使用 watch 监听 （ 更常用 – 用途更广 ）</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;firstName&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;lastName&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;fullName&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      firstName: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">      lastName: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">      fullName: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">//使用这个 属性，可以监视 data 中指定数据的变化，然后触发这个 watch 中对应的 function 处理函数</span></span></span><br><span class="line">    watch: &#123;</span><br><span class="line">      firstName(newVal, oldVal) &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// this.fullName = this.firstName + this.lastName</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.fullName = newVal + <span class="built_in">this</span>.lastName;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      lastName(newVal, oldVal) &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// this.fullName = this.firstName + this.lastName</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.fullName = <span class="built_in">this</span>.firstName + newVal;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190412/4gxmjjUxK2At.gif" alt="mark"></p>
<ul>
<li><h5 id="watch-监听-路由-改变"><a href="#watch-监听-路由-改变" class="headerlink" title="watch 监听 路由 改变"></a>watch 监听 路由 改变</h5></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/register&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> login = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是登录子组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>&quot;,</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> register = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是注册子组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>&quot;,</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> router = <span class="keyword">new</span> VueRouter(&#123;</span></span><br><span class="line">    routes: [</span><br><span class="line">      &#123;</span><br><span class="line"><span class="javascript">        path: <span class="string">&quot;/login&quot;</span>,</span></span><br><span class="line">        component: login,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line"><span class="javascript">        path: <span class="string">&quot;/register&quot;</span>,</span></span><br><span class="line">        component: register,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line"><span class="javascript">    linkActiveClass: <span class="string">&quot;myactive&quot;</span>,</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    router,</span><br><span class="line">    watch: &#123;</span><br><span class="line"><span class="javascript">      <span class="string">&quot;$route.path&quot;</span>(newVal, oldVal) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (newVal == <span class="string">&quot;/login&quot;</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">&quot;欢迎来到登录页面&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newVal == <span class="string">&quot;/register&quot;</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">&quot;欢迎来到注册页面&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190412/6V2XPG6gVhim.gif" alt="mark"></p>
<h4 id="3-computed-监听"><a href="#3-computed-监听" class="headerlink" title="3. computed 监听"></a>3. computed 监听</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;firstName&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;lastName&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;fullName&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      firstName: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">      lastName: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">//计算属性：在引用的时候，一定不要加() 去调用，直接把它当作 普通属性去使用就好了</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//只要 计算属性，这个方法内部，所用到的 任何 data 中的数据发生了变化，就会立即重新 计算 这个属性的值</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//计算属性的求值结果，会被缓存起来，方便下次直接使用；如果 计算属性中的数据 都没有发生变化，则不会 重新对 计算属性求值</span></span></span><br><span class="line">    computed: &#123;</span><br><span class="line">      fullName() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="built_in">this</span>.lastName;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="methods-watch-computed-的区别"><a href="#methods-watch-computed-的区别" class="headerlink" title="methods,watch,computed 的区别"></a><strong>methods,watch,computed 的区别</strong></h4><ol>
<li><code>computed</code> 属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；</li>
<li><code>methods</code> 方法表示一个具体的操作，主要书写业务逻辑；</li>
<li><code>watch</code> 一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是 computed 和 methods 的结合体；</li>
</ol>
<h2 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h2><ul>
<li><p>什么是 nrm?</p>
<p><strong>nrm</strong> 是一个 <code>npm</code> 源管理器，允许你快速地在 <code>npm</code> 源间切换</p>
</li>
<li><p>安装 nrm</p>
<p>在命令行执行命令，<code>npm install -g nrm</code>，全局安装 nrm。</p>
</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190412/2eNadQOmpWKL.png?imageslim" alt="mark"></p>
<ul>
<li><p>切换</p>
<p>如果要切换到<code>taobao</code>源，执行命令<code>nrm use taobao</code>。</p>
</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190412/4BzzVOzz2ER5.png?imageslim" alt="mark"></p>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h4 id="1-在网页中会引用哪些常见的静态资源？"><a href="#1-在网页中会引用哪些常见的静态资源？" class="headerlink" title="1.在网页中会引用哪些常见的静态资源？"></a>1.在网页中会引用哪些常见的静态资源？</h4><ul>
<li>JS<ul>
<li>.js .jsx .coffee .ts（TypeScript 类 C# 语言）</li>
</ul>
</li>
<li>CSS<ul>
<li>.css .less .sass .scss</li>
</ul>
</li>
<li>Images<ul>
<li>.jpg .png .gif .bmp .svg</li>
</ul>
</li>
<li>字体文件（Fonts）<ul>
<li>.svg .ttf .eot .woff .woff2</li>
</ul>
</li>
<li>模板文件<ul>
<li>.ejs .jade .vue【这是在 webpack 中定义组件的方式，推荐这么用】</li>
</ul>
</li>
</ul>
<h4 id="2-网页中引入的静态资源多了以后有什么问题？？？"><a href="#2-网页中引入的静态资源多了以后有什么问题？？？" class="headerlink" title="2.网页中引入的静态资源多了以后有什么问题？？？"></a>2.网页中引入的静态资源多了以后有什么问题？？？</h4><ol>
<li>网页加载速度慢， 因为 我们要发起很多的二次请求；</li>
<li>要处理错综复杂的依赖关系</li>
</ol>
<h4 id="3-如何解决上述两个问题"><a href="#3-如何解决上述两个问题" class="headerlink" title="3.如何解决上述两个问题"></a>3.如何解决上述两个问题</h4><ol>
<li>合并、压缩、精灵图、图片的 Base64 编码</li>
<li>可以使用之前学过的 requireJS、也可以使用 webpack 可以解决各个包之间的复杂依赖关系；</li>
</ol>
<h4 id="4-什么是-webpack"><a href="#4-什么是-webpack" class="headerlink" title="4.什么是 webpack?"></a>4.什么是 webpack?</h4><p>webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具；</p>
<h4 id="5-如何完美实现上述的-2-种解决方案"><a href="#5-如何完美实现上述的-2-种解决方案" class="headerlink" title="5.如何完美实现上述的 2 种解决方案"></a>5.如何完美实现上述的 2 种解决方案</h4><ol>
<li>使用 <a href="https://www.gulpjs.com.cn/">Gulp</a>， 是基于 task 任务的；</li>
<li>使用 <a href="https://webpack.github.io/">Webpack</a>， 是基于整个项目进行构建的；<ul>
<li>借助于 webpack 这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。</li>
<li>根据官网的图片介绍 webpack 打包的过程</li>
<li><a href="http://webpack.github.io/">webpack 官网</a></li>
</ul>
</li>
</ol>
<h4 id="6-webpack-安装的两种方式"><a href="#6-webpack-安装的两种方式" class="headerlink" title="6.webpack 安装的两种方式"></a>6.webpack 安装的两种方式</h4><ol>
<li>运行<code>npm i webpack -g </code> 全局安装 webpack，这样就能在全局使用 webpack 的命令</li>
<li>在项目根目录中运行<code>npm i webpack --save-dev</code>安装到项目依赖中</li>
</ol>
<h2 id="webpack-小案例"><a href="#webpack-小案例" class="headerlink" title="webpack 小案例"></a>webpack 小案例</h2><p><strong>最终实现效果图：</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190413/Nhxhjre7JLIk.gif" alt="mark"></p>
<h2 id="第一阶段：用-webpack-打包-main-js-文件生成-bundle-js-文件"><a href="#第一阶段：用-webpack-打包-main-js-文件生成-bundle-js-文件" class="headerlink" title="第一阶段：用 webpack 打包 main.js 文件生成 bundle.js 文件"></a>第一阶段：用 webpack 打包 main.js 文件生成 bundle.js 文件</h2><p><strong><em>目录结构</em></strong>：</p>
<p><img src="http://static.zxinc520.com/blog/20190412/lCOHlyRXWvxs.png?imageslim" alt="mark"></p>
<p><strong>index.html</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第1个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第2个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第3个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第4个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第5个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第6个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第7个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第8个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第9个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第10个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>main.js:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js 是我们项目的JS的入口文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.导入 Jquery</span></span><br><span class="line"><span class="comment">// import *** from *** 是 ES6 中导入模块的方式</span></span><br><span class="line"><span class="comment">//由于 ES6 语法太高级了，浏览器解析不了，所以，执行会报错</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">&quot;li:odd&quot;</span>).css(&#123;</span><br><span class="line">    background: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  $(<span class="string">&quot;li:even&quot;</span>).css(&#123;</span><br><span class="line">    background: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> + <span class="string">&quot;D97634&quot;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>1.安装完相关包之后，在根目录下运行 <code>webpack .\src\main.js -o .\dist\bundle.js</code></p>
<p><img src="http://static.zxinc520.com/blog/20190412/VN1klW9vTlKk.png?imageslim" alt="mark"></p>
<p>运行结果：</p>
<p><img src="http://static.zxinc520.com/blog/20190412/cCQTanNAophR.png?imageslim" alt="mark"></p>
<h2 id="第二阶段：配置-webpack-config-js"><a href="#第二阶段：配置-webpack-config-js" class="headerlink" title="第二阶段：配置 webpack.config.js"></a>第二阶段：配置 webpack.config.js</h2><blockquote>
<p>Webpack 在执行的时候，除了在 <strong>命令行传入参数</strong>，还可以通过指定的 <strong>配置文件</strong> 来执行。默认情况下，会搜索当前目录的 <code>webpack.config.js</code> 文件，这个文件是一个 node.js 模块，返回一个 json 格式的配置信息对象，或者通过 <code>--config</code> 选项来指定配置文件。</p>
</blockquote>
<h5 id="当我们在-控制台，直接输入-webpack-命令执行的时候，webpack-做了以下几步："><a href="#当我们在-控制台，直接输入-webpack-命令执行的时候，webpack-做了以下几步：" class="headerlink" title="当我们在 控制台，直接输入 webpack 命令执行的时候，webpack 做了以下几步："></a>当我们在 控制台，直接输入 <strong>webpack</strong> 命令执行的时候，webpack 做了以下几步：</h5><ol>
<li>首先，webpack 发现，我们并没有通过命令的形式，给它指定入口和出口</li>
<li>webpack 就会去 项目的 根目录中，查找一个叫做 <code>webpack.config.js</code> 的配置文件</li>
<li>当找到配置文件后，webpack 会去解析执行这个 配置文件，当解析执行完配置文件后，就得到了 配置文件中，导出的配置对象</li>
<li>当 webpack 拿到 配置对象后，就拿到了 配置对象中，指定的 入口 和 出口，然后进行打包构建；</li>
</ol>
<p><strong>webpack.config.js</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.join(__dirname, <span class="string">&quot;./src/main.js&quot;</span>), <span class="comment">// 入口，表示，要使用 webpack 打包哪个文件</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 输出文件相关的配置</span></span><br><span class="line">    path: path.join(__dirname, <span class="string">&quot;./dist&quot;</span>), <span class="comment">// 指定 打包好的文件，输出到哪个目录中去</span></span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>, <span class="comment">// 这是指定 输出的文件的名称</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后再根目录下运行 webpack</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190412/Jtcry4FyA52b.png?imageslim" alt="mark"></p>
<h2 id="使用-webpack-dev-server-这个工具，来实现自动打包编译的功能"><a href="#使用-webpack-dev-server-这个工具，来实现自动打包编译的功能" class="headerlink" title="使用 webpack-dev-server 这个工具，来实现自动打包编译的功能"></a>使用 webpack-dev-server 这个工具，来实现自动打包编译的功能</h2><ol>
<li>运行 <code>npm i webpack-dev-server -D</code> 把这个工具安装到项目的本地开发依赖 <a href="https://blog.csdn.net/wangguoyu1996/article/details/80443861">npm install –save 和 npm install -d 的区别</a></li>
<li>安装完毕后，这个 工具的用法， 和 webpack 命令的用法，完全一样</li>
<li>由于，我们是在项目中，本地安装的 webpack-dev-server ， 所以，无法把它当作 脚本命令，在 powershell 终端中直接运行；（只有那些 安装到 全局 -g 的工具，才能在 终端中正常执行）</li>
<li>注意： webpack-dev-server 这个工具，如果想要正常运行，要求，在本地项目中，必须安装 webpack</li>
<li>webpack-dev-server 帮我们打包生成的 bundle.js 文件，并没有存放到 实际的 物理磁盘上；而是，直接托管到了 电脑的内存中，所以，我们在 项目根目录中，根本找不到 这个打包好的 bundle.js;</li>
<li>我们可以认为， webpack-dev-server 把打包好的 文件，以一种虚拟的形式，托管到了 咱们项目的 根目录中，虽然我们看不到它，但是，可以认为， 和 dist src node_modules 平级，有一个看不见的文件，叫做 bundle.js</li>
</ol>
<ul>
<li>再 package.json 文件中 配置 <code>webpack-dev-server </code></li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190413/0mEiuATRmg4V.png?imageslim" alt="mark"></p>
<ul>
<li>在根目录下运行命令：<code>npm run dev</code></li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190413/01rkpce0a7ou.png?imageslim" alt="mark"></p>
<h4 id="自动编译（保存代码即自动刷新浏览器）"><a href="#自动编译（保存代码即自动刷新浏览器）" class="headerlink" title="自动编译（保存代码即自动刷新浏览器）"></a>自动编译（保存代码即自动刷新浏览器）</h4><p><img src="http://static.zxinc520.com/blog/20190413/sEKMRkaMQOuX.png?imageslim" alt="mark"></p>
<h2 id="运行-npm-run-dev-后-自动-打开对应端口号的浏览器窗口-改端口号-显示内容"><a href="#运行-npm-run-dev-后-自动-打开对应端口号的浏览器窗口-改端口号-显示内容" class="headerlink" title="运行 npm run dev 后 自动 打开对应端口号的浏览器窗口 改端口号 显示内容"></a>运行 npm run dev 后 自动 <strong>打开对应端口号</strong>的浏览器窗口 改端口号 显示内容</h2><h3 id="方式一：配置-package-json-文件"><a href="#方式一：配置-package-json-文件" class="headerlink" title="方式一：配置 package.json 文件"></a>方式一：配置 <code>package.json</code> 文件</h3><p>优点：——-推荐，简单，直接。在开发中更常用。</p>
<p><strong>package.json:</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190413/bhRisI6Rkma4.png?imageslim" alt="mark"></p>
<h3 id="方式二：配置-webpack-config-js-文件"><a href="#方式二：配置-webpack-config-js-文件" class="headerlink" title="方式二：配置 webpack.config.js 文件"></a>方式二：配置 webpack.config.js 文件</h3><ul>
<li>相比之下 麻烦一点</li>
</ul>
<p><strong>webpack.config.js：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="comment">// 启用热更新的 第2步</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.join(__dirname, <span class="string">&quot;./src/main.js&quot;</span>), <span class="comment">// 入口，表示，要使用 webpack 打包哪个文件</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 输出文件相关的配置</span></span><br><span class="line">    path: path.join(__dirname, <span class="string">&quot;./dist&quot;</span>), <span class="comment">// 指定 打包好的文件，输出到哪个目录中去</span></span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>, <span class="comment">// 这是指定 输出的文件的名称</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    <span class="comment">//这是配置  dev-server 命令参数的第二种形式，相对来说，麻烦一点。</span></span><br><span class="line">    open: <span class="literal">true</span>, <span class="comment">//自动打开浏览器</span></span><br><span class="line">    port: <span class="number">3000</span>, <span class="comment">//设置启动时候的运行端口</span></span><br><span class="line">    contentBase: <span class="string">&quot;src&quot;</span>,</span><br><span class="line">    hot: <span class="literal">true</span>, <span class="comment">//启用热更新 第1步</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">//配置插件的节点</span></span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">// new 一个热更新的 模块对象， 这是 启用热更新的第 3 步</span></span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="使用-html-webpack-plugin-插件"><a href="#使用-html-webpack-plugin-插件" class="headerlink" title="使用 html-webpack-plugin 插件"></a>使用 html-webpack-plugin 插件</h2><blockquote>
<p>配合 <code>webpack-dev-server</code> 工具使用</p>
<p>作用：为 html 文件中引入的外部资源</p>
</blockquote>
<p><strong>这个插件的两个作用：</strong></p>
<ul>
<li>为 html 文件中引入的外部资源如<code>script</code>、<code>link</code>动态添加每次 compile 后的 hash，防止引用缓存的外部文件问题</li>
<li>可以生成创建 html 入口文件，比如单页面可以生成一个 html 文件入口，配置<strong>N</strong>个<code>html-webpack-plugin</code>可以生成<strong>N</strong>个页面入口</li>
</ul>
<p><strong>实例作用（简单来说）</strong>：</p>
<ol>
<li><p>自动在内存中根据指定页面生成一个内存的页面</p>
</li>
<li><p>自动，把打包好的 bundle.js 追加到页面中去</p>
<p><img src="http://static.zxinc520.com/blog/20190413/A77bGaRpNnBK.png?imageslim" alt="mark"></p>
</li>
</ol>
<h6 id="安装使用如下："><a href="#安装使用如下：" class="headerlink" title="安装使用如下："></a><strong>安装使用如下：</strong></h6><p>一、首先安装 html-webpack-plugin 插件</p>
<p>​ 在 cmd 中打开项目，输入 <code>npm i html-webpack-plugin -D</code></p>
<p>二、在 webpack-config.js 的 plugins 里面添加 信息，如下图</p>
<p><img src="http://static.zxinc520.com/blog/20190413/FtRgDnktWRwG.png?imageslim" alt="mark"></p>
<p>然后在 cmd 中输入 <code>npm run dev</code> ，即可以在项目文件夹下自动生成 index.html。如果报错，则表示，未安装 html-webpack-plugin 插件。</p>
<p>注：不配置任何选项的<code>html-webpack-plugin</code>插件，他会默认将 webpack 中的<code>entry</code>配置所有入口 thunk 和<code>extract-text-webpack-plugin</code>抽取的 css 样式都插入到文件指定的位置</p>
<h2 id="webpack-处理第三方文件类型的过程"><a href="#webpack-处理第三方文件类型的过程" class="headerlink" title="webpack 处理第三方文件类型的过程"></a>webpack 处理第三方文件类型的过程</h2><h4 id="需求：打包处理-css-文件"><a href="#需求：打包处理-css-文件" class="headerlink" title="需求：打包处理 css 文件"></a>需求：打包处理 css 文件</h4><p><strong>注意：</strong></p>
<ul>
<li><p>webpack, 默认只能打包处理 JS 类型的文件，无法处理 其它的非 JS 类型的文件； 如果要处理 非 JS 类型的文件，我们需要手动安装一些 合适 第三方 loader 加载器；</p>
</li>
<li><p>1.如果想要打包处理 css 文件，需要安装 <code>npm i style-loader css-loader -D</code></p>
<p><img src="http://static.zxinc520.com/blog/20190413/oqXTmYRoKMoA.png?imageslim" alt="mark"></p>
</li>
<li><p>2.打开 webpack.config.js 这个配置文件，在 里面，新增一个 配置节点，叫做 module, 它是一个对象；在 这个 module 对象身上，有个 rules 属性，这个 rules 属性是个 数组；这个数组中，存放了，所有第三方文件的 匹配和 处理规则；</p>
<p><img src="http://static.zxinc520.com/blog/20190413/Xu64lPnxIQLS.png?imageslim" alt="mark"></p>
</li>
</ul>
<p><strong>webpack 处理第三方文件类型的过程：</strong></p>
<ol>
<li>发现这个 要处理的文件不是 JS 文件，然后就去 配置文件中，查找有没有对应的第三方 loader 规则</li>
<li>如果能找到对应的规则， 就会调用 对应的 loader 处理 这种文件类型；</li>
<li>在调用 loader 的时候，是从后往前调用的；</li>
<li>当最后的一个 loader 调用完毕，会把 处理的结果，直接交给 webpack 进行 打包合并，最终输出到 bundle.js 中去</li>
</ol>
<h2 id="打包-less-文件"><a href="#打包-less-文件" class="headerlink" title="打包 less 文件"></a>打包 less 文件</h2><p><strong>第一步：安装包：</strong></p>
<ol>
<li><p>安装 <code>npm i less-loader -D</code></p>
<p><img src="http://static.zxinc520.com/blog/20190413/0bSMpt6TO1EJ.png?imageslim" alt="mark"></p>
</li>
<li><p>less-loader 内部依赖 less 包，所以安装 <code>npm i less -D</code></p>
</li>
</ol>
<p><img src="http://static.zxinc520.com/blog/20190413/5RJ7elAXllGf.png?imageslim" alt="mark"></p>
<p><strong>第二步：配置 webpack.config.js 文件</strong></p>
<p><img src="http://static.zxinc520.com/blog/20190413/qjRV20IM5XiU.png?imageslim" alt="mark"></p>
<p>第三步：根目录下 运行 <code>npm run dev</code></p>
<p><img src="http://static.zxinc520.com/blog/20190413/Nhxhjre7JLIk.gif" alt="mark"></p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>vue</tag>
        <tag>监听事件（keyup ，watch ，computed ）</tag>
        <tag>nrm</tag>
      </tags>
  </entry>
  <entry>
    <title>父子组件间通信、路由</title>
    <url>/2019/04/10/VueLearn04/</url>
    <content><![CDATA[<h2 id="Vue-第四天"><a href="#Vue-第四天" class="headerlink" title="Vue 第四天"></a>Vue 第四天</h2><blockquote>
<p>父子组件间通信</p>
<p>ref 获取 DOM 元素 和 组件</p>
<p>路由</p>
</blockquote>
<h3 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h3><h5 id="1-子组件使用父组件中的数据"><a href="#1-子组件使用父组件中的数据" class="headerlink" title="1.子组件使用父组件中的数据"></a>1.子组件使用父组件中的数据</h5><ul>
<li>初步尝试—（错误分析）</li>
</ul>
<p><img src="http://static.zxinc520.com/blogimage/20190408/mHq7etHeHLPb.png?imageslim" alt="mark"></p>
<ul>
<li>正确使用方法</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--父组件,可以在引用子组件的时候，通过 属性绑定（v-bind：） 的形式，把需要 传递给子组件 的数据，以属性绑定的形式，传递到子组件内部，供子组件使用--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">com1</span> <span class="attr">v-bind:parentmsg</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">com1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="string">&quot;123 父组件中的数据&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      com1: &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">//props中的数据，都是只读的，无法重新赋值。</span></span></span><br><span class="line"><span class="javascript">        props: [<span class="string">&quot;parentmsg&quot;</span>], <span class="comment">//把父组件传递过来的 parentmsg 属性，先在 props 数组中，先定义一下，这样才能使用这个数据</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: &quot;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是子组件---</span><span class="template-variable">&#123;&#123;<span class="name">parentmsg</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&quot;,</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190408/mUupYQNPh2hG.png?imageslim" alt="mark"></p>
<h5 id="2-子组件使用父组件中的方法"><a href="#2-子组件使用父组件中的方法" class="headerlink" title="2.子组件使用父组件中的方法"></a>2.子组件使用父组件中的方法</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">com1</span> @<span class="attr">func</span>=<span class="string">&quot;show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">com1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;tmp1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是子组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;myclick&quot;</span>&gt;</span>这是子组件的中的按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> com2 = &#123;</span></span><br><span class="line"><span class="javascript">    template: <span class="string">&quot;#tmp1&quot;</span>,</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">      myclick() &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">//  emit 英文原意：是触发，调用，发射的意思</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&quot;func&quot;</span>);</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      show() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;调用父组件身上的show方法&quot;</span>);</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      com1: com2,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190408/bmsCo9BvmEsC.gif" alt="mark"></p>
<h3 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h3><ul>
<li>设置参数（ 供子组件传递参数 ）</li>
</ul>
<p><img src="http://static.zxinc520.com/blogimage/20190408/nbHBhOYbCy7g.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blogimage/20190408/R3Te7QLYkM8o.png?imageslim" alt="mark"></p>
<ul>
<li>列举 list 数据对象 说明</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">com1</span> @<span class="attr">func</span>=<span class="string">&quot;show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">com1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;tmp1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是子组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;myclick&quot;</span>&gt;</span>这是子组件的中的按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> com2 = &#123;</span></span><br><span class="line"><span class="javascript">    template: <span class="string">&quot;#tmp1&quot;</span>,</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        list: [&#123; <span class="attr">id</span>: <span class="string">&quot;1&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;18&quot;</span> &#125;],</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      myclick() &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// emit 英文原意：是触发，调用，发射的意思</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&quot;func&quot;</span>, <span class="built_in">this</span>.list);</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      show(data) &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(data);</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      com1: com2,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190408/PgXfzpoRW7u9.png?imageslim" alt="mark"></p>
<h2 id="组件案例-发表评论"><a href="#组件案例-发表评论" class="headerlink" title="组件案例-发表评论"></a>组件案例-发表评论</h2><blockquote>
<p>发表评论案例</p>
<p>所需知识点： 父子组件传值，localStorage 本地储存</p>
</blockquote>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">comment-box</span> @<span class="attr">func</span>=<span class="string">&quot;loadlocalStorage&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">comment-box</span>&gt;</span> <span class="comment">&lt;!--评论组件调用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;list-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;badge&quot;</span>&gt;</span>&#123;&#123;item.user&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            &#123;&#123;item.content&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--评论组件模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;tmp1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;exampleInputEmail1&quot;</span>&gt;</span>user：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> 	             		                        <span class="attr">id</span>=<span class="string">&quot;exampleInputEmail1&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;user&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;exampleInputEmail2&quot;</span>&gt;</span>content：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;exampleInputEmail2&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;content&quot;</span>                <span class="attr">placeholder</span>=<span class="string">&quot;发表留言&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-bottom: 15px&quot;</span>                       @<span class="attr">click</span>=<span class="string">&quot;Postcomment&quot;</span>&gt;</span>发表</span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> commentBox = &#123;</span></span><br><span class="line"><span class="javascript">            template: <span class="string">&#x27;#tmp1&#x27;</span>,</span></span><br><span class="line">            data() &#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    user: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                    content: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                Postcomment() &#123;</span><br><span class="line"><span class="javascript">                    <span class="comment">//分析：发表评论的业务逻辑</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">//1.评论数据存到哪里去？ 存放到 localStorage 中 	 		            	                       localStorage.setItem(&#x27;cmts&#x27;,&#x27;&#x27;)</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">//2.先组织出一个最新的评论数据对象</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">//3.想办法，把 第二步中，得到的评论对象。保存到 localStorage 中</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">//   3.1 localStorage 只支持存放字符串数据，要先调用 	  JSON.stringify</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">//   3.2 在保存最新的 评论数据之前，要先从 localStorage 获取之前的评论数据  （string），转换为一个数组对象然后把最新的评论，push到这个数组</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">//   3.3 如果获取到的localStorage中 的评论字符串，为空不存在，则 可以 返回一个&#x27;[]&#x27; ,让JSON.parse 去转换</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">//   3.4 把 最新的 评论列表数组，再次调用 JSON.stringify 转换为 数组字符串，然后调用 localStorage.setItem()</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> comment = &#123;<span class="attr">id</span>: <span class="built_in">Date</span>.now(), <span class="attr">user</span>: <span class="built_in">this</span>.user, <span class="attr">content</span>: <span class="built_in">this</span>.content&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                    <span class="comment">//从 localStorage 获取所有的评论</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> list = <span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;cmts&#x27;</span>) || <span class="string">&#x27;[]&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line">                    list.unshift(comment)</span><br><span class="line"><span class="javascript">                    <span class="comment">//重新保存 最新的评论数据</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;cmts&#x27;</span>, <span class="built_in">JSON</span>.stringify(list))</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.user = <span class="built_in">this</span>.content = <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.$emit(<span class="string">&#x27;func&#x27;</span>)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="javascript">                list: [&#123;<span class="attr">id</span>: <span class="built_in">Date</span>.now(), <span class="attr">user</span>: <span class="string">&#x27;李白&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;天生我材必有用&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">                       &#123;<span class="attr">id</span>: <span class="built_in">Date</span>.now(), <span class="attr">user</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;锄禾日当午&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">                       &#123;<span class="attr">id</span>: <span class="built_in">Date</span>.now(), <span class="attr">user</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;白日依山尽&#x27;</span>&#125;]</span></span><br><span class="line">            &#125;,</span><br><span class="line">            created() &#123;</span><br><span class="line"><span class="javascript">                <span class="comment">//从本地的 localStorage 中加载评论列表</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.list = <span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;cmts&#x27;</span>) || <span class="string">&#x27;[]&#x27;</span>)</span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                loadlocalStorage() &#123;</span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.list = <span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;cmts&#x27;</span>) || <span class="string">&#x27;[]&#x27;</span>)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                commentBox: commentBox</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190409/Xoa1oQoFqxaT.gif" alt="mark"></p>
<h2 id="ref-获取-DOM-元素和组件"><a href="#ref-获取-DOM-元素和组件" class="headerlink" title="ref 获取 DOM 元素和组件"></a>ref 获取 DOM 元素和组件</h2><h4 id="ref-获取-DOM-元素"><a href="#ref-获取-DOM-元素" class="headerlink" title="ref 获取 DOM 元素"></a>ref 获取 DOM 元素</h4><ul>
<li>基本使用</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;getElement&quot;</span>&gt;</span>获取元素<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;myh3&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myh3&quot;</span>&gt;</span>今天阳光明媚<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      getElement() &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// console.log(document.getElementById(&#x27;myh3&#x27;).innerText)</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.myh3.innerText);</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190409/yp3VYrRba9dD.gif" alt="mark"></p>
<h4 id="ref-获取组件"><a href="#ref-获取组件" class="headerlink" title="ref 获取组件"></a>ref 获取组件</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;getElement&quot;</span>&gt;</span>获取元素<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;myh3&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myh3&quot;</span>&gt;</span>今天阳光明媚<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">login</span> <span class="attr">ref</span>=<span class="string">&quot;mylogin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">login</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> login = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&quot;,</span></span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        msg: <span class="string">&quot;这是子组件的数据&quot;</span>,</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      show() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;这是子组件的show方法&quot;</span>);</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      getElement() &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// console.log(document.getElementById(&#x27;myh3&#x27;).innerText)</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// console.log(this.$refs.myh3.innerText)</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.mylogin.msg);</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      login,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190409/4uo8wLRXKSxg.gif" alt="mark"></p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="什么是路由？"><a href="#什么是路由？" class="headerlink" title="什么是路由？"></a>什么是路由？</h3><p><a href="https://blog.csdn.net/deaidai/article/details/80351187">可以参考</a></p>
<blockquote>
<p>后端路由：对于普通的网站，所有的超链接都是 URL 地址，所有的 URL 地址都对应服务器上对应的资源；</p>
<p>前端路由：对于单页面应用程序来说，主要通过 URL 中的 hash(#号)来实现不同页面之间的切换，同时，hash 有一个特点：HTTP 请求中不会包含 hash 相关的内容；所以，单页面程序中的页面跳转主要用 hash 实现；</p>
<p>在单页面应用程序中，这种通过 hash 改变来切换页面的方式，称作前端路由（区别于后端路由）；URL 中的 hash（井号）</p>
</blockquote>
<p><a href="https://router.vuejs.org/installation.html#direct-download-cdn">Vue Router</a></p>
<p>​ <a href="http://www.shouce.ren/api/view/a/11771">实用小文档</a></p>
<ul>
<li>路由的基本使用</li>
<li>登陆和注册路由切换小案例：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1.安装 vue-router 路由模块--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../vue-router.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--在后面 a标签 会被 router-link 所替代--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/login&quot;</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/register&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--这是 vue-router 提供的元素，专门用来 当作占位符的，将来，路由规则，匹配到的组件，就会展示到这个 router-view 中去--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--所以：我们可以把 router-view 认为是一个 占位符--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//组件模板对象</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> login = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>登陆组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&quot;,</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> register = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>注册组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&quot;,</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">//2. 创建 一个路由对象，当 导入 vue-router 包之后，在window 全局对象中，就有了一个 路由的构造函数，叫做 VueRouter</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 在new 路由对象的时候，可以为 构造函数，传递一个配置对象</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> routerobj = <span class="keyword">new</span> VueRouter(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// routes :这个配置对象中的 route 表示 【路由匹配规则】 的意思</span></span></span><br><span class="line">    routes: [</span><br><span class="line"><span class="javascript">      <span class="comment">//路由匹配规则</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//每个路由规则，都是一个对象，这个规则对象身上，有两个必须的属性</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//属性1 是 path ，表示哪个路由链接地址；</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//属性2 是 component ，表示，如果 路由是前面匹配到的 path，则展示 component 属性对应的那个组件</span></span></span><br><span class="line"><span class="javascript">      &#123; <span class="attr">path</span>: <span class="string">&quot;/login&quot;</span>, <span class="attr">component</span>: login &#125;,</span></span><br><span class="line"><span class="javascript">      &#123; <span class="attr">path</span>: <span class="string">&quot;/register&quot;</span>, <span class="attr">component</span>: register &#125;,</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="string">&quot;sadsad&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    router: routerobj, <span class="comment">//将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件</span></span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190409/4t7CscuJJf8F.gif" alt="mark"></p>
<ul>
<li>router-link 的使用（替代 a 标签）：</li>
</ul>
<p><img src="http://static.zxinc520.com/blogimage/20190409/xwcN5dtoch9i.png?imageslim" alt="mark"></p>
<ul>
<li>首页重定向（根路径重定向）</li>
</ul>
<p><img src="http://static.zxinc520.com/blogimage/20190409/HGW7GfOFp4CR.png?imageslim" alt="mark"></p>
<ul>
<li>路由高亮效果</li>
</ul>
<p><img src="http://static.zxinc520.com/blogimage/20190409/90MOyhi4OgDj.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blogimage/20190409/tksHtocLC0RB.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blogimage/20190409/CiOF0kzonIuk.gif" alt="mark"></p>
<ul>
<li>在路由中使用 动画</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190409/Boq0wxt3SD6W.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190409/x9en06UnaelG.gif" alt="mark"></p>
<h4 id="路由规则中定义参数"><a href="#路由规则中定义参数" class="headerlink" title="路由规则中定义参数"></a>路由规则中定义参数</h4><ul>
<li>传参方式一：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/login?id=10&quot;</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/register&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//组件模板对象</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> login = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>登陆组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&quot;,</span></span></span><br><span class="line">    created() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$route);</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> register = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>注册组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&quot;,</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> routerobj = <span class="keyword">new</span> VueRouter(&#123;</span></span><br><span class="line">    routes: [</span><br><span class="line"><span class="javascript">      <span class="comment">//路由匹配规则</span></span></span><br><span class="line"><span class="javascript">      &#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">redirect</span>: <span class="string">&quot;/login&quot;</span> &#125;, <span class="comment">//这里的 redirect 和 Node 中 的redirect 完全是两回事</span></span></span><br><span class="line"><span class="javascript">      &#123; <span class="attr">path</span>: <span class="string">&quot;/login&quot;</span>, <span class="attr">component</span>: login &#125;,</span></span><br><span class="line"><span class="javascript">      &#123; <span class="attr">path</span>: <span class="string">&quot;/register&quot;</span>, <span class="attr">component</span>: register &#125;,</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="string">&quot;sadsad&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    router: routerobj, <span class="comment">//将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件</span></span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190409/fPdxBv6111Wc.png?imageslim" alt="mark"></p>
<ul>
<li>拿到参数渲染到组件上</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190409/4nCicLNRvHdI.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190409/0ljG17fNlXkA.png?imageslim" alt="mark"></p>
<p>或者：==&gt;更简洁，直观！</p>
<p><img src="http://static.zxinc520.com/blog/20190409/qBOfGm2x0N46.png?imageslim" alt="mark"></p>
<ul>
<li>传值方式二：</li>
</ul>
<p><img src="http://static.zxinc520.com/blog/20190409/XX9MBioYl1Cu.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blog/20190409/crPnx2YQN3Hl.png?imageslim" alt="mark"></p>
<h4 id="路由的嵌套"><a href="#路由的嵌套" class="headerlink" title="路由的嵌套"></a>路由的嵌套</h4><ul>
<li>children 的使用</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/account&quot;</span>&gt;</span>account<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;tmp1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是account组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/account/login&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/account/register&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> account = &#123;</span></span><br><span class="line"><span class="javascript">    template: <span class="string">&quot;#tmp1&quot;</span>,</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> login = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">h3</span>&gt;</span>login<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>&quot;,</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> register = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">h3</span>&gt;</span>register<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>&quot;,</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> router = <span class="keyword">new</span> VueRouter(&#123;</span></span><br><span class="line">    routes: [</span><br><span class="line">      &#123;</span><br><span class="line"><span class="javascript">        path: <span class="string">&quot;/account&quot;</span>,</span></span><br><span class="line">        component: account,</span><br><span class="line">        /*使用 children 属性，实现子路由，同时，子路由的 path 前面，不要带 / ，</span><br><span class="line">否则永远以根路径开始请求，这样不方便我们用户去理解URL地址*/</span><br><span class="line">        children: [</span><br><span class="line"><span class="javascript">          &#123; <span class="attr">path</span>: <span class="string">&quot;login&quot;</span>, <span class="attr">component</span>: login &#125;,</span></span><br><span class="line"><span class="javascript">          &#123; <span class="attr">path</span>: <span class="string">&quot;register&quot;</span>, <span class="attr">component</span>: register &#125;,</span></span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="string">&quot;哈哈&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    router,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190410/gPhEsa53qYkp.gif" alt="mark"></p>
<h2 id="路由-命名视图实现经典布局"><a href="#路由-命名视图实现经典布局" class="headerlink" title="路由-命名视图实现经典布局"></a>路由-命名视图实现经典布局</h2><ul>
<li>命名视图实现经典布局</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  * &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.header</span> &#123;</span></span><br><span class="line">    height: 80px;</span><br><span class="line">    background: orange;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">    display: flex;</span><br><span class="line">    height: 400px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#2b542c</span>;</span></span><br><span class="line">    flex: 2;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.main</span> &#123;</span></span><br><span class="line">    background: red;</span><br><span class="line">    flex: 8;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> header = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &#x27;<span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span>Header头部区域<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#x27;,</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> leftBox = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &#x27;<span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>leftBox区域<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#x27;,</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> mainBox = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &#x27;<span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span>mainBox区域<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#x27;,</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> router = <span class="keyword">new</span> VueRouter(&#123;</span></span><br><span class="line">    routes: [</span><br><span class="line"><span class="javascript">      <span class="comment">// &#123;path:&#x27;/&#x27;,component:header&#125;,</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// &#123;path:&#x27;/left&#x27;,component:leftBox&#125;,</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// &#123;path:&#x27;/main&#x27;,component:mainBox&#125;</span></span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="javascript">        path: <span class="string">&quot;/&quot;</span>,</span></span><br><span class="line">        components: &#123;</span><br><span class="line"><span class="javascript">          <span class="keyword">default</span>: header,</span></span><br><span class="line">          left: leftBox,</span><br><span class="line">          main: mainBox,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="string">&quot;哈啊哈&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    router,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blog/20190410/kLyVGLuGTNQU.png?imageslim" alt="mark"></p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>父子组件间通信</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title>过渡效果、组件</title>
    <url>/2019/04/02/VueLearn03/</url>
    <content><![CDATA[<h1 id="Vue-第三天"><a href="#Vue-第三天" class="headerlink" title="Vue 第三天"></a>Vue 第三天</h1><blockquote>
<p>过渡效果</p>
<p>组件</p>
</blockquote>
<h1 id="过渡效果"><a href="#过渡效果" class="headerlink" title="过渡效果"></a>过渡效果</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。<br>包括以下工具：</p>
<ol>
<li><p>在 CSS 过渡和动画中自动应用 class</p>
</li>
<li><p>可以配合使用第三方 CSS 动画库，如 Animate.css</p>
</li>
<li><p>在过渡钩子函数中使用 JavaScript 直接操作 DOM</p>
</li>
<li><p>可以配合使用第三方 JavaScript 动画库，如 <a href="https://github.com/shepherdwind/velocity.js">Velocity.js</a></p>
</li>
</ol>
<h2 id="1-使用过度类名实现动画"><a href="#1-使用过度类名实现动画" class="headerlink" title="1.使用过度类名实现动画"></a>1.使用过度类名实现动画</h2><p><strong>写个简单例子说明：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--自定义两组样式，来控制 transition 内部的元素实现动画--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  /* v-enter ：  【这是一个时间点】 是进入之前,元素的起始状态，此时还没有开始进入</span><br><span class="line">       v-leave-to：【这是一个时间点】 是动画离开之后，离开的终止状态，此时， 元素动画已经结束</span><br><span class="line">    */</span><br><span class="line"><span class="css">  <span class="selector-class">.v-enter</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.v-leave-to</span> &#123;</span></span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: translateX(80px);</span><br><span class="line">  &#125;</span><br><span class="line">  /*</span><br><span class="line">      v-enter-active: 入场动画的时间段</span><br><span class="line">      v-leave-active：离场动画的时间段</span><br><span class="line">    */</span><br><span class="line"><span class="css">  <span class="selector-class">.v-enter-active</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.v-leave-active</span> &#123;</span></span><br><span class="line">    transition: all 2s;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;flag=!flag&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--1. transition 元素，是Vue 官方提供的--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-if</span>=<span class="string">&quot;flag&quot;</span>&gt;</span>这是一个h3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      flag: <span class="literal">true</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190408/saPf7Rw6MKa5.gif" alt="mark"></p>
<p><strong>修改 v-前缀(自定义前缀)</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.my-enter</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.my-leave-to</span> &#123;</span></span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: translateY(-80px);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.my-enter-active</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.my-leave-active</span> &#123;</span></span><br><span class="line">    transition: all 2s;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;flag1=!flag1&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--1. transition 元素，是Vue 官方提供的--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;my&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h6</span> <span class="attr">v-if</span>=<span class="string">&quot;flag1&quot;</span>&gt;</span>这是一个h6<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-使用第三方类实现动画"><a href="#2-使用第三方类实现动画" class="headerlink" title="2.使用第三方类实现动画"></a>2.使用第三方类实现动画</h2><p><a href="https://daneden.github.io/animate.css/">animate.css 官网</a></p>
<p><a href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">在线 cdn</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../../animate.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;flag=!flag&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--使用 transition 元素 包裹起来--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">    <span class="attr">enter-active-class</span>=<span class="string">&quot;bounceIn&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">leave-active-class</span>=<span class="string">&quot;bounceOut&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:duration</span>=<span class="string">&quot;&#123;enter:200,leave:400&#125;&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-if</span>=<span class="string">&quot;flag&quot;</span>&gt;</span>这是一个h3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>直接使用在元素身上</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;animated infinite bounce delay-2s&quot;</span>&gt;</span>这是一个h3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-JavaScript-钩子"><a href="#3-JavaScript-钩子" class="headerlink" title="3.JavaScript 钩子"></a>3.JavaScript 钩子</h3><p><strong>html:</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:before-enter</span>=<span class="string">&quot;beforeEnter&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enter</span>=<span class="string">&quot;enter&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:after-enter</span>=<span class="string">&quot;afterEnter&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enter-cancelled</span>=<span class="string">&quot;enterCancelled&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:before-leave</span>=<span class="string">&quot;beforeLeave&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:leave</span>=<span class="string">&quot;leave&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:after-leave</span>=<span class="string">&quot;afterLeave&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:leave-cancelled</span>=<span class="string">&quot;leaveCancelled&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// 进入中</span></span><br><span class="line">  beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 此回调函数是可选项的设置</span></span><br><span class="line">  <span class="comment">// 与 CSS 结合时使用</span></span><br><span class="line">  enter: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</span><br><span class="line">      done()</span><br><span class="line">  &#125;,</span><br><span class="line">  afterEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  enterCancelled: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 离开时</span></span><br><span class="line">  beforeLeave: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 此回调函数是可选项的设置</span></span><br><span class="line">  <span class="comment">// 与 CSS 结合时使用</span></span><br><span class="line">  leave: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</span><br><span class="line">    done()</span><br><span class="line">  &#125;,</span><br><span class="line">  afterLeave: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// leaveCancelled 只用于 v-show 中</span></span><br><span class="line">  leaveCancelled: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="案例：小球动画"><a href="#案例：小球动画" class="headerlink" title="案例：小球动画"></a>案例：小球动画</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;flag = !flag&quot;</span>&gt;</span>加入购物车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--使用 transition 元素把 小球包裹起来--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:before-enter</span>=<span class="string">&quot;beforeEnter&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:enter</span>=<span class="string">&quot;enter&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:after-enter</span>=<span class="string">&quot;afterEnter&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;flag&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ball&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      flag: <span class="literal">false</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">//注意：动画钩子函数的第一个参数 el ，表示 要执行动画的那个 DOM 元素，是个原生的JS 对象</span></span></span><br><span class="line">      beforeEnter(el) &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">//beforeEnter : 表示动画入场之前，此时，动画尚未开始，可以在 beforeEnter中，设置元素开始动画之前的起始样式</span></span></span><br><span class="line"><span class="javascript">        el.style.transform = <span class="string">&quot;translate(0,0)&quot;</span>;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      enter(el, done) &#123;</span><br><span class="line">        el.offsetWidth;</span><br><span class="line"><span class="javascript">        <span class="comment">//这句话，没有实际的作用，但是，如果不写，出不来动画效果</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//可以认为  el.offsetWidth 会强制动画刷新</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// enter 表示动画 开始之后的样式，这里，可以设置小球完成动画之后的,结束状态</span></span></span><br><span class="line"><span class="javascript">        el.style.transform = <span class="string">&quot;translate(150px,150px)&quot;</span>;</span></span><br><span class="line"><span class="javascript">        el.style.transition = <span class="string">&quot;all 2s&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//这里的done， 起始就是 afterEnter 这个函数。也就是说：done 是afterEnter函数的引用</span></span></span><br><span class="line">        done();</span><br><span class="line">      &#125;,</span><br><span class="line">      afterEnter(el) &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">//动画完成之后，会调用 afterEnter()</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.flag = !<span class="built_in">this</span>.flag;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190408/KnduLdOBz0cI.gif" alt="mark"></p>
<h2 id="列表过渡"><a href="#列表过渡" class="headerlink" title="列表过渡"></a>列表过渡</h2><p>_目前为止，关于过渡我们已经讲到_：</p>
<ul>
<li>单个节点</li>
<li>一次渲染多个节点</li>
</ul>
<p>那么怎么同时渲染整个列表，比如使用 <code>v-for</code> ？在这种场景中，使用<code>&lt;transition-group&gt;</code> 组件。在我们深入例子之前，先了解关于这个组件的几个特点：</p>
<ul>
<li>不同于 <code>&lt;transition&gt;</code>， 它会以一个真实元素呈现：默认为一个 <code>&lt;span&gt;</code>。你也可以通过 <code>tag</code> 特性更换为其他元素。</li>
<li>元素 <strong>一定需要</strong> 指定唯一的 <code>**key</code> 特性值**</li>
</ul>
<p>举例说明：</p>
<h4 id="列表添加动画"><a href="#列表添加动画" class="headerlink" title="列表添加动画"></a>列表添加动画</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.v-enter</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.v-leave-to</span> &#123;</span></span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: translateY(80px);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="selector-class">.v-enter-active</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.v-leave-active</span> &#123;</span></span><br><span class="line">    transition: all 2s;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在实现列表过度的时候，如果需要过度的元素，是通过 v-for 循环渲染出来的，不能使用transition 包裹，需要使用transitionGroup--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果要为 v-for 循环创建的元素设置动画，必须为每一个元素 设置 :key 属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition-group</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123;item.id&#125;&#125;--- &#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;id&quot;</span>&gt;</span>id:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;id&quot;</span> <span class="attr">id</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      list: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: 1,</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 2,</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;李四&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 3,</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;王五&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 4,</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;赵二&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 5,</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;王八&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line"><span class="javascript">      id: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">      name: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      add() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.list.push(&#123; <span class="attr">id</span>: <span class="built_in">this</span>.id, <span class="attr">name</span>: <span class="built_in">this</span>.name &#125;);</span></span><br><span class="line"><span class="javascript">        (<span class="built_in">this</span>.id = <span class="string">&quot;&quot;</span>), (<span class="built_in">this</span>.name = <span class="string">&quot;&quot;</span>);</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190408/BniWO4XoExQy.gif" alt="mark"></p>
<h4 id="删除动画"><a href="#删除动画" class="headerlink" title="删除动画"></a>删除动画</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.v-enter</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.v-leave-to</span> &#123;</span></span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: translateY(80px);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.v-enter-active</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.v-leave-active</span> &#123;</span></span><br><span class="line">    transition: all 2s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="comment">/*下面的 .v-move和 .v-leave-active 配合使用，能够实现列表后续的元素，渐渐飘上来的效果*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.v-move</span> &#123;</span></span><br><span class="line">    transition: all 3s ease;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.v-leave-active</span> &#123;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition-group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,i) in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;del(i)&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123;item.id&#125;&#125;---&#123;&#123;item.name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190408/vkbO2TDtKy2q.gif" alt="mark"></p>
<h4 id="实现入场时候的效果（-appear-属性）"><a href="#实现入场时候的效果（-appear-属性）" class="headerlink" title="实现入场时候的效果（ appear 属性）"></a>实现入场时候的效果（ appear 属性）</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--给 transition-group 添加 appear 属性，实现入场时候的效果--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">appear</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,i) in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;del(i)&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123;item.id&#125;&#125;---&#123;&#123;item.name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190408/yEodBeN1cCdm.gif" alt="mark"></p>
<h4 id="解决-ul-标签下-span-包裹问题"><a href="#解决-ul-标签下-span-包裹问题" class="headerlink" title="解决 ul 标签下 span 包裹问题"></a>解决 ul 标签下 span 包裹问题</h4><p><img src="http://static.zxinc520.com/blogimage/20190402/vn2iYgGzCqCz.png?imageslim" alt="mark"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>去掉 ul 标签，并给 transition-group 标签加 tag=”ul” 。</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">appear</span> <span class="attr">tag</span>=<span class="string">&quot;ul&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,i) in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;del(i)&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;item.id&#125;&#125;---&#123;&#123;item.name&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h3 id="什么是组件？"><a href="#什么是组件？" class="headerlink" title="什么是组件？"></a>什么是组件？</h3><blockquote>
<p>组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。</p>
<p>组件的出现，就是为了拆分 Vue 实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可</p>
</blockquote>
<h2 id="组件化和模块化的不同："><a href="#组件化和模块化的不同：" class="headerlink" title="组件化和模块化的不同："></a>组件化和模块化的不同：</h2><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><blockquote>
<p>​ 就是**”基础库”<strong>或者</strong>“基础组件”，**意思是把代码重复的部分提炼出一个个组件供给功能使用。</p>
<p>​ 使用：Dialog，各种自定义的 UI 控件、能在项目或者不同项目重复应用的代码等等。</p>
<p>​ 目的：复用，解耦。</p>
<p>​ 依赖：组件之间低依赖，比较独立。</p>
<p>​ 架构定位：纵向分层（位于架构底层，被其他层所依赖）。</p>
</blockquote>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><blockquote>
<p>​ 就是**”业务框架”<strong>或者</strong>“业务模块”**，也可以理解为“框架”，意思是把功能进行划分，将同一类型的代码整合在一起，所以模块的功能相对复杂，但都同属于一个业务。</p>
<p>​ 使用：按照项目功能需求划分成不同类型的业务框架（例如：注册、登录、外卖、直播…..）</p>
<p>​ 目的：隔离/封装 （高内聚）。</p>
<p>​ 依赖：模块之间有依赖的关系，可通过路由器进行模块之间的耦合问题。</p>
<p>​ 架构定位：横向分块（位于架构业务框架层）。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​ 其实组件相当于<strong>库</strong>，把一些能在<strong>项目里或者不同类型项目中</strong>可复用的代码进行工具性的封装。</p>
<p>​ 而模块相应于<strong>业务逻辑模块</strong>，把<strong>同一类型项目里</strong>的功能逻辑进行进行需求性的封装。</p>
<h2 id="创建组件实例："><a href="#创建组件实例：" class="headerlink" title="创建组件实例："></a>创建组件实例：</h2><blockquote>
<p>注意：不论是哪种方式创建出来的组件，组件的 template 属性指向的模板内容必须有且只能有唯 一的一个根元素</p>
</blockquote>
<h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><h4 id="创建组件的方式-1"><a href="#创建组件的方式-1" class="headerlink" title="创建组件的方式 1"></a>创建组件的方式 1</h4><p><strong>实例：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-com1</span>&gt;</span><span class="tag">&lt;/<span class="name">my-com1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//1.1 使用 Vue.extend 来创建全局的Vue组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> com1 = Vue.extend(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是使用 Vue.extend 创建的组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>&quot;,</span></span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">//1.2 使用  Vue.component(&#x27;组件的名称&#x27;，创建出来的组件模板对象)</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">//如果 使用  Vue.component定义全局组件的时候，组件名称使用了 驼峰命名，则在引用组件的时候，需要把大写的驼峰改为小写的字母，两个单词之间，使用 - 链接</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">//如果不使用驼峰，则直接拿名称来使用</span></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&quot;myCom1&quot;</span>, com1);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190402/AE4CTF8EzGix.png?imageslim" alt="mark"></p>
<h4 id="简化："><a href="#简化：" class="headerlink" title="简化："></a>简化：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">&quot;myCom1&quot;</span>,</span><br><span class="line">  Vue.extend(&#123;</span><br><span class="line">    template: <span class="string">&quot;&lt;h3&gt;这是使用 Vue.extend 创建的组件&lt;/h3&gt;&quot;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="创建组件的方式-2"><a href="#创建组件的方式-2" class="headerlink" title="创建组件的方式 2"></a>创建组件的方式 2</h4><p><strong>实例</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-com2</span>&gt;</span><span class="tag">&lt;/<span class="name">my-com2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&quot;myCom2&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//注意：不论是哪种方式创建出来的组件，组件的 template 属性指向的模板内容必须有且只能有唯一的一个根元素</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是直接使用 Vue.component 创建出来的组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>&quot;,</span></span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190402/EiTu5Mwl5jpJ.png?imageslim" alt="mark"></p>
<h4 id="创建组件的方式-3"><a href="#创建组件的方式-3" class="headerlink" title="创建组件的方式 3"></a>创建组件的方式 3</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-com3</span>&gt;</span><span class="tag">&lt;/<span class="name">my-com3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在 被控制的 #app 外面，使用 template 元素，定义组件的 HTML 模板结构--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;tmp1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">      这是通过 template 元素，在外部定义的组件结构，这个方式，有代码的智能提示和</span><br><span class="line">      高亮</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>好用不错哦！<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&quot;myCom3&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    template: <span class="string">&quot;#tmp1&quot;</span>,</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190402/V6vcm4TQjGh1.png?imageslim" alt="mark"></p>
<h3 id="私有组件"><a href="#私有组件" class="headerlink" title="私有组件"></a>私有组件</h3><p><strong>自定义一个私有组件</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">login</span>&gt;</span><span class="tag">&lt;/<span class="name">login</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">//定义实例内部私有组件</span></span></span><br><span class="line">      login: &#123;</span><br><span class="line"><span class="handlebars"><span class="xml">        template: &quot;<span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是定义实例内部私有组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>&quot;,</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190402/oA5piSDptycq.png?imageslim" alt="mark"><strong>同理而言：或者这样处理</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">login</span>&gt;</span><span class="tag">&lt;/<span class="name">login</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在 被控制的 #app 外面，使用 template 元素，定义组件的 HTML 模板结构--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;tmp2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是定义实例内部私有组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">//定义实例内部私有组件</span></span></span><br><span class="line">      login: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&quot;#tmp2&quot;</span>,</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="组件中的-data-和-methods"><a href="#组件中的-data-和-methods" class="headerlink" title="组件中的 data 和 methods"></a>组件中的 data 和 methods</h2><blockquote>
<ol>
<li><p>组件可以有自己的 data 数据</p>
</li>
<li><p>组件的 data 和 实例的 data 有点不一样，实例中的 data 可以为一个对象，但组件的 data 必须为一个方法</p>
</li>
<li><p>组件中的 data 除了为一个方法之外，这个方法内部，还必须返回一个对象才行</p>
</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;myCom1&quot;</span>, &#123;</span><br><span class="line">  template: <span class="string">&quot;&lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt;&quot;</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">&quot;这是组件中定义的数据&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190402/IbE2L3d6S5x8.png?imageslim" alt="mark"></p>
<h2 id="组件切换"><a href="#组件切换" class="headerlink" title="组件切换"></a>组件切换</h2><h4 id="v-if-和-v-else-（-2-个组件之间切换-）"><a href="#v-if-和-v-else-（-2-个组件之间切换-）" class="headerlink" title="v-if 和 v-else （ 2 个组件之间切换 ）"></a>v-if 和 v-else （ 2 个组件之间切换 ）</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;flag=true&quot;</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;flag=false&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">login</span> <span class="attr">v-if</span>=<span class="string">&quot;flag&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">login</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">register</span> <span class="attr">v-else</span>=<span class="string">&quot;flag&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">register</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190402/wjg1VesuOq1U.png?imageslim" alt="mark"></p>
<h4 id="component-is-实现多个组件之间的切换"><a href="#component-is-实现多个组件之间的切换" class="headerlink" title="component :is 实现多个组件之间的切换"></a>component :is 实现多个组件之间的切换</h4><blockquote>
<!--Vue 提供了 component ，来展示对应名称的组件-->

<!--component 是一个占位符，:is 属性,可以用来指定展示的组件的名称-->
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;comName=&#x27;login&#x27;&quot;</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;comName=&#x27;register&#x27;&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--Vue 提供了 component ，来展示对应名称的组件--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--component 是一个占位符，:is 属性,可以用来指定展示的组件的名称--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&quot;login&quot;</span>, &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">msg</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span>&quot;,</span></span></span><br><span class="line"><span class="javascript">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        msg: <span class="string">&quot;这是登陆&quot;</span>,</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&quot;register&quot;</span>, &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">msg</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span>&quot;,</span></span></span><br><span class="line"><span class="javascript">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        msg: <span class="string">&quot;这是注册&quot;</span>,</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      comName: <span class="string">&quot;login&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190402/lhRHsBxN0qN2.png?imageslim" alt="mark"></p>
<!--总结：当前学习了几个 Vue 提供的标签了-->

<!-- component, template, transition , transitionGroup -->

<h4 id="多个组件切换动画"><a href="#多个组件切换动画" class="headerlink" title="多个组件切换动画"></a>多个组件切换动画</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.v-enter</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.v-leave-to</span> &#123;</span></span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: translateX(80px);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="selector-class">.v-enter-active</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.v-leave-active</span> &#123;</span></span><br><span class="line">    transition: all 2s;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;comName=&#x27;login&#x27;&quot;</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;comName=&#x27;register&#x27;&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--通过 mode 属性，设置组件切换时候的 模式--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">mode</span>=<span class="string">&quot;out-in&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190408/Th9ksgrvutDI.gif" alt="mark"></p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>过渡效果</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>过滤器、按键修饰符、指令、生命周期</title>
    <url>/2019/03/28/VueLearn02/</url>
    <content><![CDATA[<h1 id="Vue-第二天"><a href="#Vue-第二天" class="headerlink" title="Vue 第二天"></a>Vue 第二天</h1><blockquote>
<p>以做案例逐渐深入学习</p>
<p>打好基础很重要！</p>
<p><em>believe in yourself</em></p>
</blockquote>
<h2 id="品牌列表案例"><a href="#品牌列表案例" class="headerlink" title="品牌列表案例"></a>品牌列表案例</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel panel-primary&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-heading&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-title&quot;</span>&gt;</span>添加品牌<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-body form-inline&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;id&quot;</span>&gt;</span>id: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;id&quot;</span> <span class="attr">id</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>name: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn  btn-primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table table-bordered table-hover table-striped&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>ctime<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Operation<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.id&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.ctime&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;del(item.id)&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      id: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">      name: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line">      list: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: 1,</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;奔驰&quot;</span>,</span></span><br><span class="line"><span class="javascript">          ctime: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 2,</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;宝马&quot;</span>,</span></span><br><span class="line"><span class="javascript">          ctime: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span></span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      add() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> car = &#123; <span class="attr">id</span>: <span class="built_in">this</span>.id, <span class="attr">name</span>: <span class="built_in">this</span>.name, <span class="attr">ctime</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.list.push(car);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.name = <span class="built_in">this</span>.id = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      del(id) &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> index = <span class="built_in">this</span>.list.findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span></span><br><span class="line">          if (item.id == id) &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.list.splice(index, <span class="number">1</span>);</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190328/IdnBfABbITPK.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blogimage/20190328/62jdzeY5BOrT.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blogimage/20190328/bSDUCjvTlY6Y.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blogimage/20190328/qNRshJrorrew.png?imageslim" alt="mark"></p>
<h3 id="增加搜索功能"><a href="#增加搜索功能" class="headerlink" title="增加搜索功能"></a>增加搜索功能</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">&quot;item in search(keywords)&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.id&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.ctime&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;del(item.id)&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">      search(keywords)&#123;<span class="comment">//根据关键字进行数据的搜索</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> newList=[]</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.list.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span></span><br><span class="line">              if(item.name.indexOf(keywords)!= -1)&#123;</span><br><span class="line">                  newList.push(item)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> newList</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方法二-使用-filter"><a href="#方法二-使用-filter" class="headerlink" title="方法二 (使用 filter)"></a>方法二 (使用 filter)</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">      search(keywords)&#123;<span class="comment">//根据关键字进行数据的搜索</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> newList = []</span></span><br><span class="line"><span class="javascript">              <span class="comment">//注意 ：foreach some filter findIndex 这些都属于数组的新方法</span></span></span><br><span class="line"><span class="javascript">              <span class="comment">//都会对数组中的每一项，进行遍历，执行相关的操作</span></span></span><br><span class="line"><span class="javascript">              <span class="comment">//注意：Es6中，为字符串提供了一个新方法 ，叫做String.prototype.includes(&#x27;要包含的字符串，如果包含返回true&#x27;)</span></span></span><br><span class="line"><span class="javascript">          newList = <span class="built_in">this</span>.list.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">              <span class="comment">// if(item.name.indexOf(keywords)!= -1)</span></span></span><br><span class="line">              if (item.name.includes(keywords)) &#123;</span><br><span class="line"><span class="javascript">                  <span class="keyword">return</span> item</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> newList</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190328/mtKxnpNYuRqG.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blogimage/20190328/m5EeSUQtLPF8.png?imageslim" alt="mark"></p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><p><strong>过滤器的定义语法</strong>：<u>Vue.filter(‘过滤器的名称’,function(){})</u></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//过滤器中的function，第一个参数，已经被规定死了，永远都是 过滤器 管道符前面 传递过来的数据</span></span><br><span class="line">Vue.filter(<span class="string">&quot;过滤器的名称&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data + <span class="string">&quot;123&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>写一个例子</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>&#123;&#123; msg | msgFormat&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//定义一个Vue 全局的过滤器 名字叫做 msgFormat</span></span></span><br><span class="line"><span class="javascript">  Vue.filter(<span class="string">&quot;msgFormat&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//字符串 replace方法，第一个参数，除了可以写一个 字符串之外，还可以定义一个正则表达式</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// return msg.replace(&#x27;拼尽全力&#x27;,&#x27;开心快乐&#x27;)</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> msg.replace(<span class="regexp">/拼尽全力/g</span>, <span class="string">&quot;开心快乐&quot;</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="string">&quot;人活着就要拼尽全力！拼尽全力，拼尽全力，拼尽全力！&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190328/E2cejpC39vcl.png?imageslim" alt="mark"></p>
<h4 id="使用过滤器时（传参数）"><a href="#使用过滤器时（传参数）" class="headerlink" title="使用过滤器时（传参数）"></a>使用过滤器时（传参数）</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>&#123;&#123; msg | msgFormat(&#x27;开心快乐&#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//定义一个Vue 全局的过滤器 名字叫做 msgFormat</span></span></span><br><span class="line"><span class="javascript">  Vue.filter(<span class="string">&quot;msgFormat&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg, arg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//字符串 replace方法，第一个参数，除了可以写一个 字符串之外，还可以定义一个正则</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// return msg.replace(&#x27;拼尽全力&#x27;,&#x27;开心快乐&#x27;)</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> msg.replace(<span class="regexp">/拼尽全力/g</span>, arg);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="string">&quot;人活着就要拼尽全力！拼尽全力，拼尽全力，拼尽全力！&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用过滤器时（传多个参数）"><a href="#使用过滤器时（传多个参数）" class="headerlink" title="使用过滤器时（传多个参数）"></a>使用过滤器时（传多个参数）</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>&#123;&#123; msg | msgFormat(&#x27;开心快乐&#x27;,&#x27;123&#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//定义一个Vue 全局的过滤器 名字叫做 msgFormat</span></span></span><br><span class="line"><span class="javascript">  Vue.filter(<span class="string">&quot;msgFormat&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg, arg, arg2</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//字符串 replace方法，第一个参数，除了可以写一个 字符串之外，还可以定义一个正则</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// return msg.replace(&#x27;拼尽全力&#x27;,&#x27;开心快乐&#x27;)</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> msg.replace(<span class="regexp">/拼尽全力/g</span>, arg + arg2);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="string">&quot;人活着就要拼尽全力！拼尽全力，拼尽全力，拼尽全力！&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190328/fhuGqD3vbBl5.png?imageslim" alt="mark"></p>
<h4 id="使用过滤器时（多次调用）"><a href="#使用过滤器时（多次调用）" class="headerlink" title="使用过滤器时（多次调用）"></a>使用过滤器时（多次调用）</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>&#123;&#123; msg | msgFormat(&#x27;开心快乐&#x27;,&#x27;123&#x27;) | test&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//定义一个Vue 全局的过滤器 名字叫做 msgFormat</span></span></span><br><span class="line"><span class="javascript">  Vue.filter(<span class="string">&quot;msgFormat&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg, arg, arg2</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//字符串 replace方法，第一个参数，除了可以写一个 字符串之外，还可以定义一个正则</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// return msg.replace(&#x27;拼尽全力&#x27;,&#x27;开心快乐&#x27;)</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> msg.replace(<span class="regexp">/拼尽全力/g</span>, arg + arg2);</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  Vue.filter(<span class="string">&quot;test&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> msg + <span class="string">&quot;test&quot;</span>;</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="string">&quot;人活着就要拼尽全力！拼尽全力，拼尽全力，拼尽全力！&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190328/1l2JyRlfFVKL.png?imageslim" alt="mark"></p>
<h2 id="修改品牌列表案例，进行时间的格式化"><a href="#修改品牌列表案例，进行时间的格式化" class="headerlink" title="修改品牌列表案例，进行时间的格式化"></a>修改品牌列表案例，进行时间的格式化</h2><h3 id="关键代码："><a href="#关键代码：" class="headerlink" title="关键代码："></a>关键代码：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.ctime | dataFormat&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//全局的过滤器,进行时间的格式化</span></span></span><br><span class="line"><span class="javascript">  Vue.filter(<span class="string">&quot;dataFormat&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//根据给定的时间字符串,得到特定的时间</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(data);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> y = dt.getFullYear();</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> m = dt.getMonth() + <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> d = dt.getDate();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// return y + &#x27;-&#x27; + m + &#x27;-&#x27; + d</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span>`</span>;</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190328/or9QSA0r1Adn.png?imageslim" alt="mark"></p>
<h4 id="功能改进"><a href="#功能改进" class="headerlink" title="功能改进"></a>功能改进</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.ctime | dataFormat(&#x27;&#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//全局的过滤器,进行时间的格式化</span></span></span><br><span class="line"><span class="javascript">  Vue.filter(<span class="string">&quot;dataFormat&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data, pattern</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//根据给定的时间字符串,得到特定的时间</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(data);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> y = dt.getFullYear();</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> m = dt.getMonth() + <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> d = dt.getDate();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// return y + &#x27;-&#x27; + m + &#x27;-&#x27; + d</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (pattern &amp;&amp; pattern.toLowerCase() === <span class="string">&quot;yyyy-mm-dd&quot;</span>) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span>`</span>;</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> hh = dt.getHours();</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> mm = dt.getMinutes();</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> ss = dt.getSeconds();</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190328/ow9K3Omz64dG.png?imageslim" alt="mark"></p>
<h3 id="局部过滤器"><a href="#局部过滤器" class="headerlink" title="局部过滤器"></a>局部过滤器</h3><blockquote>
<!--定义一个私有的过滤器（局部）-->
</blockquote>
<p>过滤器调用的时候，采用的是<strong>就近原则</strong>，<u>如果私有过滤器和全局过滤器名称一致了</u>，这时候<strong>优先调用私有过滤器</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app1&quot;</span>&gt;</span>&#123;&#123;msg | dataFormat&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app2&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm1 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app1&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    filters: &#123;</span><br><span class="line"><span class="javascript">      dataFormat: <span class="function"><span class="keyword">function</span> (<span class="params">data, pattern</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(data);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> y = dt.getFullYear();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> m = dt.getMonth() + <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> d = dt.getDate();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (pattern &amp;&amp; pattern.toLowerCase() === <span class="string">&quot;yyyy-mm-dd&quot;</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span>`</span>;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> hh = dt.getHours();</span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> mm = dt.getMinutes();</span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> ss = dt.getSeconds();</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm2 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app2&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190328/AfDdXTwFOveq.png?imageslim" alt="mark"></p>
<h3 id="时间补-0-的情况（如：2019-03-29-21-48-20）"><a href="#时间补-0-的情况（如：2019-03-29-21-48-20）" class="headerlink" title="时间补 0 的情况（如：2019-03-29 21:48:20）"></a>时间补 0 的情况（如：2019-03-29 21:48:20）</h3><h4 id="padStart-的运用"><a href="#padStart-的运用" class="headerlink" title="padStart()的运用"></a>padStart()的运用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = (dt.getMonth() + <span class="number">1</span>).toString().padStart(<span class="number">2</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> d = dt.getDate().toString().padStart(<span class="number">2</span>, <span class="string">&quot;0&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><h4 id="按回车键添加数据（不用按添加按钮）"><a href="#按回车键添加数据（不用按添加按钮）" class="headerlink" title="按回车键添加数据（不用按添加按钮）"></a>按回车键添加数据（不用按添加按钮）</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;name&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keyup.enter</span>=<span class="string">&quot;add&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn  btn-primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义全局按键修饰符"><a href="#自定义全局按键修饰符" class="headerlink" title="自定义全局按键修饰符"></a>自定义全局按键修饰符</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;name&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keyup.f2</span>=<span class="string">&quot;add&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//自定义全局按键修饰符</span></span></span><br><span class="line">  Vue.config.keyCodes.f2 = 113;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190329/2DmzaiYUgToA.gif" alt="mark"></p>
<h2 id="自定义全局（私有）的指令"><a href="#自定义全局（私有）的指令" class="headerlink" title="自定义全局（私有）的指令"></a>自定义全局（私有）的指令</h2><h3 id="自定义全局指令"><a href="#自定义全局指令" class="headerlink" title="自定义全局指令"></a>自定义全局指令</h3><h4 id="自定义一个自动获取焦点的指令（v-focus）"><a href="#自定义一个自动获取焦点的指令（v-focus）" class="headerlink" title="自定义一个自动获取焦点的指令（v-focus）"></a>自定义一个自动获取焦点的指令（v-focus）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数一：指令的名称，在定义的时候，指令的名称前面，不需要加 v- 前缀，</span></span><br><span class="line"><span class="comment">//在调用的时候，必须 在指令名称前 加上 v- 前缀来调用</span></span><br><span class="line"><span class="comment">//参数二：是一个对象，在这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段执行相关的操作</span></span><br><span class="line">Vue.directive(<span class="string">&quot;focus&quot;</span>, &#123;</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//每当指令绑定到元素上的时候，会立即执行这个 bind 函数，只执行一次</span></span><br><span class="line">    <span class="comment">//注意：在每个函数中，第一个参数永远是el，表示被绑定了指令的那个元素，这个el 参数，是一个元素的JS对象</span></span><br><span class="line">    <span class="comment">//在元素 刚绑定指令的时候，还没有插入到 DOM 中去，这时候，调用 focus 方法没有作用</span></span><br><span class="line">    <span class="comment">//因为，一个元素，只有插入 DOM 之后，才能获取焦点</span></span><br><span class="line">    <span class="comment">// el.focus()</span></span><br><span class="line">  &#125;,</span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数                                  【触发一次】</span></span><br><span class="line">    el.focus();</span><br><span class="line">    <span class="comment">//和JS行为有关的操作，最好在 inserted 中去执行，防止 JS 行为不生效</span></span><br><span class="line">  &#125;,</span><br><span class="line">  updated: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//当vNode更新的时候，会执行 updated，可能会触发多次</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：<a href="https://www.cnblogs.com/ftxc/p/8086008.html">参考文档</a></p>
<ul>
<li><p>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>
</li>
<li><p>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p>
</li>
<li><p>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</p>
</li>
<li><p>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p>
</li>
<li><p>unbind：只调用一次，指令与元素解绑时调用。</p>
</li>
<li><p>指令钩子函数会被传入以下参数：</p>
<ul>
<li>el：指令所绑定的元素，可以用来直接操作 DOM 。</li>
<li>binding：一个对象，包含以下属性：<br>name：指令名，不包括 v- 前缀。<br>value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。<br>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。<br>expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。<br>arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。<br>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。<br>vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。<br>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li>
</ul>
</li>
</ul>
<p><img src="http://static.zxinc520.com/blogimage/20190329/QfOUnkjKHsEA.png?imageslim" alt="mark"></p>
<h4 id="自定义一个-设置字体颜色的-指令（v-color）"><a href="#自定义一个-设置字体颜色的-指令（v-color）" class="headerlink" title="自定义一个 设置字体颜色的 指令（v-color）"></a>自定义一个 设置字体颜色的 指令（v-color）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//样式，只要通过指令绑定了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联的样式</span></span><br><span class="line"><span class="comment">//将来元素肯定会显示到页面中去，这时候，浏览器的渲染引擎必然会解析样式，应用给这个元素</span></span><br><span class="line">bind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    el.style.color = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    <span class="comment">//和样式相关的操作，一般都可以在 bind 执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="自定义一个-设置字体颜色的-指令-传参数"><a href="#自定义一个-设置字体颜色的-指令-传参数" class="headerlink" title="自定义一个 设置字体颜色的 指令 ( 传参数 )"></a>自定义一个 设置字体颜色的 指令 ( 传参数 )</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;search&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">&quot;keywords&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-color</span>=<span class="string">&quot;&#x27;blue&#x27;&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-focus</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  Vue.directive(<span class="string">&quot;color&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    bind: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span></span><br><span class="line">      el.style.color = binding.value;</span><br><span class="line"><span class="javascript">      <span class="comment">//对比 value 和 expression</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(binding.value);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(binding.expression);</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190329/mnJeqSiyTLNO.png?imageslim" alt="mark"></p>
<h3 id="自定义私有指令"><a href="#自定义私有指令" class="headerlink" title="自定义私有指令"></a>自定义私有指令</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&quot;#app1&quot;</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">  directives: &#123;</span><br><span class="line">    <span class="comment">//自定义私有指令</span></span><br><span class="line">    fontweight: &#123;</span><br><span class="line">      bind: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">        el.style.fontWeight = binding.value;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="函数简写"><a href="#函数简写" class="headerlink" title="函数简写"></a>函数简写</h4><p>大多数情况下，我们可能想在 <code>bind</code> 和 <code>update</code> 钩子上做重复动作，并且不想关心其它的钩子函数。可以这样写:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">&quot;color-swatch&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">  el.style.backgroundColor = binding.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>例如：自定义一个字体大小的指令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">directives: &#123; <span class="comment">//自定义私有指令</span></span><br><span class="line">        <span class="string">&#x27;fontsize&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123; <span class="comment">//这个 function 等同于 把代码写到 bind 和 	update 中去</span></span><br><span class="line">            el.style.fontSize = <span class="built_in">parseInt</span>(binding.value)+ <span class="string">&#x27;px&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vue-实例的生命周期"><a href="#Vue-实例的生命周期" class="headerlink" title="Vue 实例的生命周期"></a>Vue 实例的生命周期</h2><ol>
<li>生命周期钩子 = 生命周期函数 = 生命周期事件</li>
<li>举例说明：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;msg=&#x27;no&#x27;&quot;</span>&gt;</span>修改msg<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;h3&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="string">&quot;ok&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      show() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;执行了show方法&quot;</span>);</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">//这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(this.msg) //undefined</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.show()           //TypeError: this.show is not a function</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 注意：在beforeCreate 生命周期函数执行的时候，data和methods 中的数据未被初始化</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">//这是我们遇到的第二个生命周期函数</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(this.msg) //ok</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.show()  //执行了show方法</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//在 created中，data 和 methods 都已经被初始化好了！</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//如果要调用 methods 中的方法，或者操作 data中的数据，最早，只能在 created 中操作</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeMount() &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">//这是我们遇到的第三个生命周期函数，表示模板已经在内存中编辑完成了，但是尚未把 模板渲染到 页面中</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">&quot;h3&quot;</span>).innerText); <span class="comment">// &#123;&#123;msg&#125;&#125;</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">//这是我们遇到的第四个生命周期函数，表示内存中的模板，已经真实的挂载到页面中去，用户可以看到渲染好的页面</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">&quot;h3&quot;</span>).innerText); <span class="comment">// ok</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//注意：mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示,实例已经被完全创建好了，</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 此时，如果没有其它操作，这个实例，就静静的 躺在内存中，一动不动。</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">//接下来是运行中的两个事件</span></span></span><br><span class="line">    beforeUpdate() &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">//这时候表示，我们的界面还没有被更新 【数据被更新了吗？数据肯定被更新了】</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(document.getElementById(&#x27;h3&#x27;).innerText) //没有输出任何东西</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="javascript">        <span class="string">&quot;界面上元素的内容：&quot;</span> + <span class="built_in">document</span>.getElementById(<span class="string">&quot;h3&quot;</span>).innerText</span></span><br><span class="line"><span class="javascript">      ); <span class="comment">//界面上元素的内容：ok</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;data中 msg 数据是：&quot;</span> + <span class="built_in">this</span>.msg); <span class="comment">//data中 msg 数据是：no</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//得出结论：当执行 beforeUpdate 的时候，页面中显示的数据还是旧的，此时 data 数据是最新的，页面尚未和最新的数据 保持同步</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    updated() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="javascript">        <span class="string">&quot;界面上元素的内容：&quot;</span> + <span class="built_in">document</span>.getElementById(<span class="string">&quot;h3&quot;</span>).innerText</span></span><br><span class="line"><span class="javascript">      ); <span class="comment">//界面上元素的内容：no</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;data中 msg 数据是：&quot;</span> + <span class="built_in">this</span>.msg); <span class="comment">//data中 msg 数据是：no</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190330/4A8AYanLcI7i.png?imageslim" alt="mark"></p>
<h2 id="Vue-resource-实现-get，post，jsonp-请求"><a href="#Vue-resource-实现-get，post，jsonp-请求" class="headerlink" title="Vue-resource 实现 get，post，jsonp 请求"></a>Vue-resource 实现 get，post，jsonp 请求</h2><!--除了Vue-resource之外，还可以使用 `axios` 的第三方包实现数据的请求-->

<p><a href="http://www.cnblogs.com/both-eyes/p/10122243.html"> Vue-resource 和 axios 的区别</a></p>
<p><strong>Vue-resource 的基本使用</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../vue-resource-1.3.4.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;getInfo&quot;</span>&gt;</span>get请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="string">&quot;这是一句话！&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      getInfo() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$http.get(<span class="string">&quot;../../data.json&quot;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(result);</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190330/sND0YtQhlkeL.png?imageslim" alt="mark"></p>
<ul>
<li>get，post，jsonp 请求</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;getInfo&quot;</span>&gt;</span>get请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;postInfo&quot;</span>&gt;</span>post请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;jsonpInfo&quot;</span>&gt;</span>jsonp请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="string">&quot;这是一句话！&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      getInfo() &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">//发起 get 请求</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$http.get(<span class="string">&quot;../../data.json&quot;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">//通过 result.body 拿到服务器返回的成功的数据</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(result.body);</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      postInfo() &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">//发起 post  请求</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$http.post(<span class="string">&quot;../../data.json&quot;</span>, &#123;&#125;, &#123;&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">//通过 result.body 拿到服务器返回的成功的数据</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(result.body);</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      jsonpInfo() &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">//发起 jsonp 请求</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$http.jsonp(<span class="string">&quot;../../data.json&quot;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">//通过 result.body 拿到服务器返回的成功的数据</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(result.body);</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>过滤器</tag>
        <tag>按键修饰符</tag>
        <tag>指令</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>创建实例、基础指令、跑马灯、修饰符、样式、key, v-model</title>
    <url>/2019/03/23/VueLearn01/</url>
    <content><![CDATA[<h1 id="Vue-第一天"><a href="#Vue-第一天" class="headerlink" title="Vue 第一天"></a>Vue 第一天</h1><blockquote>
<p>这是我第 5 遍学习 Vue 了（可能是因为感觉自己达不到游刃有余的感觉吧，也可能是以前学的不系统，要学就得学扎实了。）</p>
</blockquote>
<h2 id="创建一个实例"><a href="#创建一个实例" class="headerlink" title="创建一个实例"></a>创建一个实例</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      title: <span class="string">&quot;欢迎学习Vue！&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h4 id="v-cloak-（-能够解决-插值表达式闪烁问题-）"><a href="#v-cloak-（-能够解决-插值表达式闪烁问题-）" class="headerlink" title="v-cloak （ 能够解决 插值表达式闪烁问题 ）"></a>v-cloak （ 能够解决 插值表达式闪烁问题 ）</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-attr">[v-cloak]</span> &#123;</span></span><br><span class="line">    display: none;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-text-功能与插值表达式相同，优点：没有闪烁问题-，缺点：会覆盖元素中原本的内容"><a href="#v-text-功能与插值表达式相同，优点：没有闪烁问题-，缺点：会覆盖元素中原本的内容" class="headerlink" title="v-text ( 功能与插值表达式相同，优点：没有闪烁问题 ，缺点：会覆盖元素中原本的内容)"></a>v-text ( 功能与插值表达式相同，优点：没有闪烁问题 ，缺点：会覆盖元素中原本的内容)</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">&quot;“title”&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-html-能够解析文本里面的-HTML-标签"><a href="#v-html-能够解析文本里面的-HTML-标签" class="headerlink" title="v-html (能够解析文本里面的 HTML 标签)"></a>v-html (能够解析文本里面的 HTML 标签)</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-bind（-用于绑定属性的指令-）-简写形式"><a href="#v-bind（-用于绑定属性的指令-）-简写形式" class="headerlink" title="v-bind（ 用于绑定属性的指令 ）(简写形式 : )"></a>v-bind（ 用于绑定属性的指令 ）(简写形式 : )</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;mytitle&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> <span class="attr">:title</span>=<span class="string">&quot;mytitle&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-on-绑定事件-（简写形式-）"><a href="#v-on-绑定事件-（简写形式-）" class="headerlink" title="v-on ( 绑定事件 ) （简写形式 @ ）"></a>v-on ( 绑定事件 ) （简写形式 @ ）</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;alert(&#x27;hello&#x27;)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;alert(&#x27;hello&#x27;)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h4 id="跑马灯"><a href="#跑马灯" class="headerlink" title="跑马灯"></a>跑马灯</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;开始&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;start&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;停止&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;stop&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="string">&quot;猥琐发育，别浪~~~~&quot;</span>,</span></span><br><span class="line"><span class="javascript">      timer: <span class="literal">null</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      start() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="built_in">this</span>.timer != <span class="literal">null</span>) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> start = <span class="built_in">this</span>.msg.substring(<span class="number">0</span>, <span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> end = <span class="built_in">this</span>.msg.substring(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.msg = end + start;</span></span><br><span class="line">        &#125;, 200);</span><br><span class="line">      &#125;,</span><br><span class="line">      stop() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.timer = <span class="literal">null</span>;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190322/KCTsr3d2g1EG.png?imageslim" alt="mark"></p>
<h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><h4 id="stop-阻止冒泡"><a href="#stop-阻止冒泡" class="headerlink" title="stop ( 阻止冒泡 )"></a>stop ( 阻止冒泡 )</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;DivClick&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击&quot;</span> @<span class="attr">click.stop</span>=<span class="string">&quot;BtnClick&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      DivClick() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;触发了inner点击事件&quot;</span>);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      BtnClick() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;触发了按钮点击事件&quot;</span>);</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190322/NjmXomRJ4g4P.png?imageslim" alt="mark"></p>
<h4 id="prevent-阻止默认行为"><a href="#prevent-阻止默认行为" class="headerlink" title="prevent ( 阻止默认行为 )"></a>prevent ( 阻止默认行为 )</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;linkClick&quot;</span>&gt;</span>去百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190322/DPTRjEbdvTuS.png?imageslim" alt="mark"></p>
<h4 id="capture-（捕获触发事件机制）（从外向里-）"><a href="#capture-（捕获触发事件机制）（从外向里-）" class="headerlink" title="capture （捕获触发事件机制）（从外向里 ）"></a>capture （捕获触发事件机制）（从外向里 ）</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span> @<span class="attr">click.capture</span>=<span class="string">&quot;DivClick&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;BtnClick&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190322/SmpSkg4nCGn0.png?imageslim" alt="mark"></p>
<h4 id="self-只有点击当前元素才能触发事件"><a href="#self-只有点击当前元素才能触发事件" class="headerlink" title="self ( 只有点击当前元素才能触发事件)"></a>self ( 只有点击当前元素才能触发事件)</h4><!--.self 只会阻止自己身上冒泡行为的触发，并不会真正阻止 冒泡行为-->

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span> @<span class="attr">click.self</span>=<span class="string">&quot;DivClick&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;BtnClick&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190322/3pybyy00aAn9.png?imageslim" alt="mark"></p>
<h4 id="once-（只触发一次事件）"><a href="#once-（只触发一次事件）" class="headerlink" title="once （只触发一次事件）"></a>once （只触发一次事件）</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> @<span class="attr">click.prevent.once</span>=<span class="string">&quot;linkClick&quot;</span>&gt;</span>去百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><!-- v-bind 只能实现单向绑定，从 M 自动绑定到 V ，无法实现数据的双向绑定-->

<!--使用 ：v-model 可以实现 表单元素 和 Model 中数据的双向数据绑定-->

<!--注意 ：v-model 只能运用到 表单元素中-->

<!--input(radio,text,address,email...) select checkbox textarea-->

<h3 id="案例（计算器）"><a href="#案例（计算器）" class="headerlink" title="案例（计算器）"></a>案例（计算器）</h3><h6 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><strong>代码：</strong></h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;n1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;opt&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;+&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;-&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;*&quot;</span>&gt;</span>*<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;/&quot;</span>&gt;</span>/<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;n2&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;=&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;result&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      n1: 0,</span><br><span class="line">      n2: 0,</span><br><span class="line">      result: 0,</span><br><span class="line"><span class="javascript">      opt: <span class="string">&quot;+&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      btnClick() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">switch</span> (<span class="built_in">this</span>.opt) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.result = <span class="built_in">parseInt</span>(<span class="built_in">this</span>.n1) + <span class="built_in">parseInt</span>(<span class="built_in">this</span>.n2);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.result = <span class="built_in">parseInt</span>(<span class="built_in">this</span>.n1) - <span class="built_in">parseInt</span>(<span class="built_in">this</span>.n2);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.result = <span class="built_in">parseInt</span>(<span class="built_in">this</span>.n1) * <span class="built_in">parseInt</span>(<span class="built_in">this</span>.n2);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.result = <span class="built_in">parseInt</span>(<span class="built_in">this</span>.n1) / <span class="built_in">parseInt</span>(<span class="built_in">this</span>.n2);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">break</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="代码优化（投机取巧，正式开发中尽量少用）"><a href="#代码优化（投机取巧，正式开发中尽量少用）" class="headerlink" title="代码优化（投机取巧，正式开发中尽量少用）"></a>代码优化（投机取巧，正式开发中尽量少用）</h4><blockquote>
<p>（使用 eval，eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码）</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      n1: 0,</span><br><span class="line">      n2: 0,</span><br><span class="line">      result: 0,</span><br><span class="line"><span class="javascript">      opt: <span class="string">&quot;+&quot;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      btnClick() &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// switch (this.opt) &#123;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//     case &#x27;+&#x27;:</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//         this.result = parseInt(this.n1) + parseInt(this.n2)</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//         break</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//     case &#x27;-&#x27;:</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//         this.result = parseInt(this.n1) - parseInt(this.n2)</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//         break</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//     case &#x27;*&#x27;:</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//         this.result = parseInt(this.n1) * parseInt(this.n2)</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//         break</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//     case &#x27;/&#x27;:</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//         this.result = parseInt(this.n1) / parseInt(this.n2)</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//         break</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> codeStr = <span class="string">&quot;parseInt(this.n1)&quot;</span> + <span class="built_in">this</span>.opt + <span class="string">&quot;parseInt(this.n2)&quot;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.result = <span class="built_in">eval</span>(codeStr);</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190323/xYFJRqe4Ivuf.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blogimage/20190323/ju1GHCX1FzMc.png?imageslim" alt="mark"></p>
<h2 id="Vue-中使用样式"><a href="#Vue-中使用样式" class="headerlink" title="Vue 中使用样式"></a>Vue 中使用样式</h2><h3 id="使用-class-样式"><a href="#使用-class-样式" class="headerlink" title="使用 class 样式"></a>使用 class 样式</h3><h4 id="第一种方式：直接传递一个数组"><a href="#第一种方式：直接传递一个数组" class="headerlink" title="第一种方式：直接传递一个数组"></a>第一种方式：直接传递一个数组</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.red</span> &#123;</span></span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="selector-class">.thin</span> &#123;</span></span><br><span class="line">    font-weight: 200;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="selector-class">.italic</span> &#123;</span></span><br><span class="line">    font-style: italic;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;red&#x27;,&#x27;thin&#x27;,&#x27;italic&#x27;]&quot;</span>&gt;</span>这是h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="在数组中使用三元表达式"><a href="#在数组中使用三元表达式" class="headerlink" title="在数组中使用三元表达式"></a>在数组中使用三元表达式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;red&#x27;,&#x27;thin&#x27;,flag?&#x27;italic&#x27;:&#x27;&#x27;]&quot;</span>&gt;</span>这是h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      flag: <span class="literal">true</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>或者：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;red&#x27;,&#x27;thin&#x27;,&#123;&#x27;italic&#x27;:flag&#125;]&quot;</span>&gt;</span>这是h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>直接使用对象（true 和 false 可用变量来代替）</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;red:true,thin:true,italic:false&#125;&quot;</span>&gt;</span>这是h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>data 里面定义</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">&quot;classObj&quot;</span>&gt;</span>这是h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      classObj: &#123; <span class="attr">red</span>: <span class="literal">true</span>, <span class="attr">thin</span>: <span class="literal">true</span>, <span class="attr">italic</span>: <span class="literal">true</span> &#125;,</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用内联样式"><a href="#使用内联样式" class="headerlink" title="使用内联样式"></a>使用内联样式</h3><p>直接使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;color:&#x27;red&#x27;,&#x27;font-weight&#x27;:200&#125;&quot;</span>&gt;</span>这是h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>data 里面调用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:style</span>=<span class="string">&quot;styleObj&quot;</span>&gt;</span>这是h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      styleObj: &#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>, <span class="string">&quot;font-weight&quot;</span>: <span class="number">200</span> &#125;,</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运用数组</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:style</span>=<span class="string">&quot;[styleObj1,styleObj2]&quot;</span>&gt;</span>这是h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      styleObj1: &#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>, <span class="string">&quot;font-weight&quot;</span>: <span class="number">200</span> &#125;,</span></span><br><span class="line"><span class="javascript">      styleObj2: &#123; <span class="string">&quot;font-style&quot;</span>: <span class="string">&quot;italic&quot;</span> &#125;,</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Vue-指令之-V-for-和-key-属性"><a href="#Vue-指令之-V-for-和-key-属性" class="headerlink" title="Vue 指令之 V-for 和 key 属性"></a>Vue 指令之 V-for 和 key 属性</h2><!--v-for使用的过程中一般要加上 key 属性，保证数据的唯一性-->

<h4 id="v-for-简单实用"><a href="#v-for-简单实用" class="headerlink" title="v-for 简单实用"></a>v-for 简单实用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      list: [1, 2, 3, 4, 5, 6],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190323/CUbor8Fl39AJ.png?imageslim" alt="mark"></p>
<h4 id="索引值："><a href="#索引值：" class="headerlink" title="索引值："></a>索引值：</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in list&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;---&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190323/eChPoVycrqGB.png?imageslim" alt="mark"></p>
<h4 id="循环对象数组"><a href="#循环对象数组" class="headerlink" title="循环对象数组"></a>循环对象数组</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in list&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123;item.id&#125;&#125;---&#123;&#123;item.name&#125;&#125;---&#123;&#123;index&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      list: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: 1,</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 2,</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;李四&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 3,</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;王五&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 4,</span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;隔壁老王&quot;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190323/UBp33b7hpd6L.png?imageslim" alt="mark"></p>
<h4 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(val,key,index) in user&quot;</span>&gt;</span>&#123;&#123;key&#125;&#125;--&#123;&#123;val&#125;&#125;---&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      user: &#123;</span><br><span class="line">        id: 1,</span><br><span class="line"><span class="javascript">        name: <span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line"><span class="javascript">        hobby: <span class="string">&quot;打篮球&quot;</span>,</span></span><br><span class="line"><span class="javascript">        sex: <span class="string">&quot;男&quot;</span>,</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190323/7z0KTgVSTrnT.png?imageslim" alt="mark"></p>
<h4 id="迭代数字"><a href="#迭代数字" class="headerlink" title="迭代数字"></a>迭代数字</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;count in 5&quot;</span>&gt;</span>这是第 &#123;&#123;count&#125;&#125; 次循环<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190323/pkTWMsrKq3K5.png?imageslim" alt="mark"></p>
<h2 id="Vue-指令之-v-if-和-v-show"><a href="#Vue-指令之-v-if-和-v-show" class="headerlink" title="Vue 指令之 v-if 和 v-show"></a>Vue 指令之 v-if 和 v-show</h2><p><strong>基本使用</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-if</span>=<span class="string">&quot;flag&quot;</span>&gt;</span>这是v-if控制的元素<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-show</span>=<span class="string">&quot;flag&quot;</span>&gt;</span>这是v-show控制的元素<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;flag=!flag&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      flag: <span class="literal">true</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://static.zxinc520.com/blogimage/20190323/RvJkAeqmP7pU.png?imageslim" alt="mark"></p>
<p><img src="http://static.zxinc520.com/blogimage/20190323/Pt5eFpvu4dpd.png?imageslim" alt="mark"></p>
<!-- v-if 有较高的切换性能消耗-->

<!-- v-show 有较高的初始渲染消耗-->

<!-- 如果元素涉及频繁的切换，最好不要使用 v-if-->

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p><a href="https://blog.csdn.net/qq_42329594/article/details/81380665">MVC 和 MVVM 的区别</a></p>
</li>
<li><p>学习了 Vue 中最基本的代码结构</p>
</li>
<li><p>基本指令</p>
</li>
<li><p>事件修饰符</p>
</li>
<li><p>v-for 要会使用 key 属性</p>
</li>
<li><p>v-model 只能应用于表单元素</p>
</li>
</ol>
]]></content>
      <categories>
        <category>框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>跑马灯</tag>
      </tags>
  </entry>
  <entry>
    <title>适配技巧和组件化思想</title>
    <url>/2019/03/19/AdaptiveSkill/</url>
    <content><![CDATA[<h2 id="你一定要会的适配技巧和组件化思想"><a href="#你一定要会的适配技巧和组件化思想" class="headerlink" title="你一定要会的适配技巧和组件化思想"></a>你一定要会的适配技巧和组件化思想</h2><blockquote>
<p>rem：利用它能实现强大的屏幕适配布局</p>
<p>less：Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。(代表的有 less，Sass，stylus)</p>
<p>模板引擎：art-template（实现组件化，代码不复用，提高开发效率）(当然还有很多其它好用的模板引擎，但原理上基本一样。)</p>
</blockquote>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>本文将介绍以 rem（结合流式布局）+less（为代表）的适配方式</li>
<li>模板引擎上以将以 art-template 举例说明。（模板引擎 ==&gt; 这里特指用于 Web 开发的模板引擎,是为了使<a href="https://baike.baidu.com/item/%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2">用户界面</a>与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的<a href="https://baike.baidu.com/item/HTML">HTML</a>文档。）</li>
</ul>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>为什么 <strong>rem+less</strong> 会产生？</p>
<ul>
<li><p><strong>rem</strong> ：<u>rem 是相对长度单位，相对于根元素 font-size 计算值的倍数（通俗来讲，相对于 html 字体大小）</u></p>
<p>这种需求主要产生在移动端，因为随着科学水平的发展，手机产业发展非常迅速，作为一个前端工作者，大量的手机页面需要我们去书写，而现在市面上的手机大小不一（分辨率各不相同），一种适配所有手机的页面开发模式需求应由而生。（px 为一种固定的像素单位，不太适合需求），之后<strong>流式布局，响应式布局</strong>等随之产生，rem 的作用也逐渐凸显出来。</p>
</li>
</ul>
<h4 id="如何使用-rem-less-呢？"><a href="#如何使用-rem-less-呢？" class="headerlink" title="如何使用 rem+less 呢？"></a>如何使用 rem+less 呢？</h4><p>===&gt;新建个 less 目录，在里面做如下操作：</p>
<p>1.新建 variable.less（名字随便都可以，反正这是一个表示变量的 less 文件）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@charset <span class="string">&quot;utf-8&quot;</span>;</span><br><span class="line"><span class="comment">//适配主流设备</span></span><br><span class="line">@adapterDeviceList:<span class="number">750</span>px,<span class="number">720</span>px,<span class="number">640</span>px,<span class="number">540</span>px,<span class="number">529</span>px,<span class="number">480</span>px,<span class="number">434</span>px,<span class="number">414</span>px,<span class="number">400</span>px,<span class="number">384</span>px,<span class="number">375</span>px,<span class="number">360</span>px,<span class="number">320</span>px;</span><br><span class="line"><span class="comment">//设计稿尺寸</span></span><br><span class="line">@psdwidth:<span class="number">529</span>px;  <span class="comment">//就是你参考的设计稿的尺寸</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    预设基准值</span></span><br><span class="line"><span class="comment">    我习惯设100px，这样感觉用起来比较方便。比如：32px可以写作32rem/@baseFontSize</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">@baseFontSize:<span class="number">100</span>px;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设备种类数量</span></span><br><span class="line">@len:length(@adapterDeviceList);</span><br></pre></td></tr></table></figure>

<p>2.新建 mixins.less（这是一个表示函数的 less 文件）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这类似一个循环（定义一个函数），只是less没有跟js差不多的for循环啥滴，所以只能通过这种方式来实现一个循环。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">.adapterMixin(@index) when (@index &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  @media (min-width: extract(@adapterDeviceList,@index))&#123;</span><br><span class="line">    html&#123;</span><br><span class="line">      font-size: @baseFontSize/@psdwidth* extract(@adapterDeviceList,@index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  .adapterMixin(@index - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.新建 adapter.less（调用函数）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.adapterMixin(@len);</span><br></pre></td></tr></table></figure>

<p>4.新建 index.less (主入口)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@charset <span class="string">&quot;utf-8&quot;</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">&#x27;variable&#x27;</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">&quot;mixins&quot;</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">&quot;adapter&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>5.在网页中引用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/less&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/less/index.less&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdnjs.cloudflare.com/ajax/libs/less.js/3.9.0/less.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="http://lesscss.org/">less 官网</a></p>
<p>说明：在网页中直接引用 less 文件是不行的，一定要加一个 less.min.js 来解析 less 文件，这样浏览器才能认识。</p>
<p>在完成上述操作后，你已基本完成 <strong>rem+less</strong>的适配方式。接下来在 less 文件中 （像素单位 px 将可以用 rem/@baseFontSize 来代替），你的页面将适配所有大小的容器。</p>
<h2 id="组件化思想"><a href="#组件化思想" class="headerlink" title="组件化思想"></a>组件化思想</h2><h4 id="需求分析："><a href="#需求分析：" class="headerlink" title="需求分析："></a>需求分析：</h4><blockquote>
<p>随着要写大量的页面，页面的重复，冗杂等问题相应而出。为了解决这种重复的问题，组件化思想出来了。</p>
</blockquote>
<h4 id="什么是组件化"><a href="#什么是组件化" class="headerlink" title="什么是组件化"></a>什么是组件化</h4><p>组件化并不是前端所特有的，一些其他的语言或者桌面程序等，都具有组件化的先例。确切的说，只要有 UI 层的展示，就必定有可以组件化的地方。简单来说，组件就是将一段 UI 样式和其对应的功能作为独立的整体去看待，无论这个整体放在哪里去使用，它都具有一样的功能和样式，从而实现复用，这种整体化的细想就是组件化。不难看出，组件化设计就是为了增加复用性，灵活性，提高系统设计，从而提高开发效率。</p>
<ul>
<li>css 实现代码分离（组件化思想）：可以用 less，Sass，stylus。<a href="http://lesscss.org/">less 官网</a></li>
<li>html 实现代码分离（组件化思想）：可以用模板引擎—-如 <a href="https://aui.github.io/art-template/docs/">art-template</a> 等…</li>
</ul>
<blockquote>
<p>art-template 是一个简约、超快的模板引擎。它采用作用域预声明的技术来优化模板渲染速度，从而获得接近 JavaScript 极限的运行性能，并且同时支持 NodeJS 和浏览器。</p>
<ol>
<li>拥有接近 JavaScript 渲染极限的的性能</li>
<li>调试友好：语法、运行时错误日志精确到模板所在行；支持在模板文件上打断点（Webpack Loader）</li>
<li>支持 Express、Koa、Webpack</li>
<li>支持模板继承与子模板</li>
<li>浏览器版本仅 6KB 大小</li>
</ol>
</blockquote>
<p>详情介绍： <a href="https://aui.github.io/art-template/zh-cn/docs/index.html">art-template 官网</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>1.适配技巧和组件化思想是你必不可少的技能</li>
<li>2.组件化思想将是未来主流方向（React、Vue、Angular 三大前端主流框架）</li>
<li>3.多做项目===&gt;体会这种组件化开发思想和适配方案。</li>
</ol>
]]></content>
      <categories>
        <category>适配技巧</category>
      </categories>
      <tags>
        <tag>rem</tag>
        <tag>less</tag>
        <tag>art-template</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 mongodb 取出时是 UTC 时间问题</title>
    <url>/2019/03/18/resolveUTCtime/</url>
    <content><![CDATA[<h1 id="解决-mongodb-取出时是-UTC-时间问题。"><a href="#解决-mongodb-取出时是-UTC-时间问题。" class="headerlink" title="解决 mongodb 取出时是 UTC 时间问题。"></a>解决 mongodb 取出时是 UTC 时间问题。</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h4 id="问题：将一个时间类型数据保存到-mongodb-数据库中，在数据库中时间还是正常的时间，如："><a href="#问题：将一个时间类型数据保存到-mongodb-数据库中，在数据库中时间还是正常的时间，如：" class="headerlink" title="问题：将一个时间类型数据保存到 mongodb 数据库中，在数据库中时间还是正常的时间，如："></a>问题：将一个时间类型数据保存到 mongodb 数据库中，在数据库中时间还是正常的时间，如：</h4><p><img src="http://static.zxinc520.com/blogimage/20190318/n3ekfX3CcF0P.png?imageslim" alt="mark"></p>
<p><strong>但是后台拿出来的时候却是这样的（node.js）</strong></p>
<p><img src="http://static.zxinc520.com/blogimage/20190318/3KOdujSN2DnV.png?imageslim" alt="mark"></p>
<p><em>解决方案：</em></p>
<p>网上查阅了很多资料，可我没找到一个解决方案（可能我比较傻吧），我只有自己想解决方案。</p>
<h1 id="我的解决步骤："><a href="#我的解决步骤：" class="headerlink" title="我的解决步骤："></a>我的解决步骤：</h1><h4 id="1-将-UTC-时间转换为-data-类型时间"><a href="#1-将-UTC-时间转换为-data-类型时间" class="headerlink" title="1.将 UTC 时间转换为 data 类型时间"></a>1.将 UTC 时间转换为 data 类型时间</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*publish在这里是一个数组，数组里面的每一项都是一个对象。 </span></span><br><span class="line"><span class="comment">  比如：publish[0].publishDate = 2019-03-15T08:44:07.842Z</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*遍历publish数组*/</span></span><br><span class="line">publish.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(e.publishDate).toLocaleString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="http://static.zxinc520.com/blogimage/20190318/okqlTlNhFEPQ.png?imageslim" alt="mark"></p>
<p>瞬间特别开心，以为解决了，谁知？（哎！）</p>
<h4 id="2-我开始将转变后的时间赋给原对象："><a href="#2-我开始将转变后的时间赋给原对象：" class="headerlink" title="2.我开始将转变后的时间赋给原对象："></a>2.我开始将转变后的时间赋给原对象：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*遍历publish数组*/</span></span><br><span class="line">publish.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.publishDate = <span class="keyword">new</span> <span class="built_in">Date</span>(e.publishDate).toLocaleString();</span><br><span class="line">  <span class="built_in">console</span>.log(e.publishDate);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="http://static.zxinc520.com/blogimage/20190318/woBo6Xdm0nCl.png?imageslim" alt="mark"></p>
<p>我百思不得其解，我也不知道为什么会这样，我想不可能啊！</p>
<p>于是：我想方设法查明其中的原有，最终我发现了一个问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> publish[<span class="number">0</span>].publishDate); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>(publish[<span class="number">0</span>].publishDate).toLocaleString()); <span class="comment">//string</span></span><br></pre></td></tr></table></figure>

<p>原来是<strong>类型不一样</strong>，怪不得不能直接赋值，<u>我何不把它们转换成一样的类型，然后进行赋值呢，于是，我有进行了下面的操作：</u></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">publish.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.publishDate = <span class="built_in">JSON</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>(e.publishDate).toLocaleString());</span><br><span class="line">  <span class="built_in">console</span>.log(e.publishDate);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但结果报错了：</p>
<p><img src="http://static.zxinc520.com/blogimage/20190318/RQVh7hC91D61.png?imageslim" alt="mark"></p>
<h2 id="3-在我无限困惑的时候：我终于想到了一种可行的解决方案-gt"><a href="#3-在我无限困惑的时候：我终于想到了一种可行的解决方案-gt" class="headerlink" title="3.在我无限困惑的时候：我终于想到了一种可行的解决方案===&gt;"></a>3.在我无限困惑的时候：我终于想到了一种可行的解决方案===&gt;</h2><h4 id="我给-publish-新加了一个属性值："><a href="#我给-publish-新加了一个属性值：" class="headerlink" title="我给 publish 新加了一个属性值："></a>我给 publish 新加了一个属性值：</h4><p><img src="http://static.zxinc520.com/blogimage/20190318/F7Dap7RvsP1D.png?imageslim" alt="mark"></p>
<p><strong>然后在代码中</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">publish.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.UTCtodata = <span class="keyword">new</span> <span class="built_in">Date</span>(e.publishDate).toLocaleString();</span><br><span class="line">  <span class="built_in">console</span>.log(e.UTCtodata);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="http://static.zxinc520.com/blogimage/20190318/OetS9laujbDI.png?imageslim" alt="mark"></p>
<h4 id="渲染到页面："><a href="#渲染到页面：" class="headerlink" title="渲染到页面："></a>渲染到页面：</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;list_time_submit&quot;</span>&gt;</span>&#123;&#123;publish[i].UTCtodata&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>页面效果：</strong></p>
<p><img src="http://static.zxinc520.com/blogimage/20190318/4vr3aw5u3e55.png?imageslim" alt="mark"></p>
<p>这就是我解决 mongodb 取出时间是 UTC 时间的解决办法，如果你们有特别好，特别简单的处理办法，可一定要告诉我哦！</p>
]]></content>
      <categories>
        <category>node</category>
        <category>UTC</category>
      </categories>
      <tags>
        <tag>UTC时间问题</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我的博客</title>
    <url>/2019/03/18/AboutMyBlog/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Hey, password is required here.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="3c29160916ef210fe63e9ef58477b8ee5c53aff7dc3804bb11fc2c91020cb165">4559430e68db4919e30bc8ca159918898d0ac8b981a0393da4b3d76eb26833c40e76e8558f538800455d786144b39366dda3203e455713609eb2c11c701672a2d99a5b53ad6a03a0adf8eb46d3d4e064672e3959ff6566674615fb3152749c85b43c870a6c9e5b414278789d655a3eeea77d287305ed1758501456e60282d4784b500fe4ff6e0b22ef3f1312a4e3ea9e4c2650872c5b3ad6b8b51645cf84ba21bf9257e91b2e97c6c2eab25c43f88aa2ad58e22e7150d77087f5748bb4bfcb6bb6e032ae84ab40a429c084ba8f97c1c26471882e0cbb1414500eb1469445dbb91eb70cf996390ce30f21f81698f0c1d477ddddcef0ea54fb43e6dadc960a9c541853bee54fd04ca2062ec5271ad7adeef406837d76b0fc7c050cb346baa6e4a9812b493db47a20f9fb9909488e66d1d879eefaf8edc512c9e933d79e550ccf86f3926db3ba5c4c9c4bdb599297b5adeaa56e7115e864926f1e0b6fe1ad4678bb86095daef3f9f403c816985ce33d5d15a4e3c26bfbb85989034409c4a6889ac060bef116e6e617b76f3fe40271012deaffcede25c3348bb69b8eb2a300258065417f078a0be5a6fdd1da6b8911c81b71d15acbf5ea4609c04f7891ff48e0edc71e8a7a98ce1d1e1d49dbb4844da7819cde461e8887281cbc9faf2269a2dcb9286695ad242b9a154f854999c9d50486f78f6a8abb803b08ed1669b46018ca4919b264188747421c29a330b0c70eec3b2f55971dcc372cbaf194ed7702a5e99dfdea6b7439745cceb8154261fd6c17412b71a70d16705e5d501d251a801dc7567d4caf135a77a490328cb78b00b6cb7de83fc75636c4fd24c5fe6ed4a6cef93ee8dc1103552e5ef336a29f8c8908e0231e59ac3fb7ae45fda9e2a2019372e330522c95490a893111e4e8c76bdfcce8ffe3024344b7798fbd6a9e7ee2798a33244489119bd88dc35b2396ddb568d66e2a648032d98a0a8d455fa28f1fc5c1053ea7da5df7549e33d8e953424c673b2e9a1636495cdce10f46ce4eb5528c00e1ac699f2770fba5b996b9a5351913aed75ede16692d67f19fc2ce105f494cfc44dddad03665cbb5beb070763d9b4c01b9ef0224f91422f19e445ec567cb2b7e108e3a94f55bfe86354231ea2865e8b219cfba46b3973e652db54e5d563e6b8b56264e52289570b8ccb2281642d2254e09d5db2707d97ee8de0acd1f815a555044efc8f1e7415f5183b97f165563ac09166181839325c432eb7974d289cb90ae598803f4966fe17b4012b4422b33e988c98a9712c396250a192629040dd1d99cc95df4fffc5d522c908146dfa82859b9ab78d2b5cf2349a835a9d6139f9b15385c5e8e6fb6fe0c7a987b4b5808323603f033b278781c229ab652383e066abac9fb1756a28de7de1dc43b423eddc4aac752fae837c4c8eabf85801f5d1a4fad44e0c6c0a9be05b274e7cfec7e56865dcaaf75523880ec7c91985950b7952b8d6a67f6a3c0b4d3831dab4b1b56ed0ce5084c989d4ee5adb002d8571fad308bf96a2cc97c49bd969198355e12f1817e24c3a6cc6d8376cf8c35ff9744d84cf4f702a0493cc400f07ba9ec30a55269ed525ece402fa667e116b8c212eccbfc05450540da4cb8d7f39f5c46789d2f4b8d97b3b4aa1af0b048df6d694188f805d66f26eb1430f31fea472d751f7f57b956ef21767c34e97f5fa5c9cecd580e5f187396dcdd120be9e209ddd6ba6e065775221390d428e4a45340b0f23a1093aabc207e79a109795b23ee3c217f9722d178cbac47b5f9629514f1ab9a4b3ff18d91c0490075308cf4ee04971e0fb7a04c9f685683b8b29e4d41a9b92bcc9440970e4157d100d762eb14e7558457b068152ad837bddc8d7ab8e6a5f6000da2f4a4afd5892b3513edc4a320b1d360afae3a19e02afd0f9efd32951bada9d5388989bf7935e626b7b82d4ca6418ccb1eb0c847b68cd77534b5b58eb9353a4697622bfdadac680ecc3aff7e349aa1f9e2e005c742b1f6ea259fbab8a51b5e5fea7953d6214341bf063dd58922510d5ba3c9bade94e6d1a27939cc779b3d5a6745177b37b780168f8bc2c9093ad068da67fac47df1298510a3c8f626f9b174188577e8eec40db026d44a393491d08b61120d0dee4f428f04e39be55162907dc5432141bc6b6040e1298cdae12351eb68226049c4ecd32baf5ce62107c4bb0caf276ff7e64a42346d019086daa8301112cb9472a657d2937e0616b74214e71181a8d5f7fa2b6e05401a398ba67a184766a4866a15d47916a8df13f613ee36ff92fb8e6ed13ccbc7227e62060110a00106b8e55240209739efb958149d25b00fa2b0397272dda51ac3ca20c4dc1a655781a5b7dbc9492fe364c6327f225bb866b2640011a1e9b87cd22861aa3c109cd6c0c30bb4f42db9749e5f5f05018a843e79fa7a5be1422e145f35fe2e0e461902b085f2ba5ed7383f00d194ae192749bcf1a1c4c0e7c5706f2979a3c3fc1bf1f9fe252c474bfe041a2996fc7b6087df61670900f0400624be7046daeba493f07ec9b5aa3165a8237dfd609b0b5344fab150fec380d70cf54c52bf9e3e370a1401888e45e92b7327d775a9b1908852c393f7de2f050c742425acab4a81da8866d938c92f2075004a81d8b8667a7563e213e80d4cbdc2e223e4bbcded3346f28a4d505c2883b7c4cda0f6511494f85df10822f209ddbeb61cb494689376b3ce0fe4766e9e81b7874da25986d8af6e92d5b7bd802723a9bca1ff8a880214d8039c2348b0ba12411ab649c0054a7fa90749bc0fa10b811d08f1ac406ab47520d64ebe58f46a9e06197960c94590db5ac62d581705bffef6d225b73974b1bee2b721c0ec72679aea8561402c10563dd4ecd41172c2a324c724b85bd761258e44ab29434cb4c26187c2230168c8ed715b22466a4a9eb24c3ea8bf8ac86c684abdef2a20338c1632d2ec1c95141fce45be0d68a6c16f28029ac4e7e2e3a65eb19e0eee1f536ccd68ca1a116f10dcfb794303e50be18fe05eb06f5b7c75046d14d3b1f56962a6ea481d0f16ae553e011c93b8e4ddd6b8e23b07a96c82f1b838317ca0b748de587cdd3fe5d5e0cbc82f035086e21a25922691471d3154ddafd9b3faee18e66ea42558730201d04b6668843ea250b8e9c46fd74ab37ed552306a579cd022c2f6f30caf8c52c080f558eb2aaf2308d1d3448d0a45eb7807146bf343ee2ea82b24025a51a9a14cba0c0fb9669f15cfd1a50998357a6f8a0394aa01cd23f0e62c1648d9dde347215f1fe8de151932db25bf8435c9f33b1aef8d08b4d6d16b254577528f0094b8a585d83868d2cf98e100b2b36000bde5f7365916ae54515f66780b98884e0a75c4521258d6289257e501eed3cbf67fe16cae2cfeb1d65fb7bac7469ee82acdfff8a0780bd417ff878afa40375e4c390ef5b555adbf409756d7e9854a4f897ca086a3435b21bd452e361c55f49c0fa7a1c9c08935bae7c5e891e88aba47166dff992fb4791b12cdea95b10848c4cb130f0ccf6322e94cdee3a794d5ac91bf3b9e93801ef69f6c7c33f1e0d1859fe9a6aa7b00f8a3ee7a01f6798b9499e2c13a0f32c72178da927a27149f82a270b90686468c4df3207030c246e3af4da9d51058f5e1b4a2dc240f5d10b9a443e2e220341b088b4163d8e779fbc8d0e8496af5c26653170f9e29bb4ebbeb8e6b6a8f0df05db857b61533010fd813d06ded5cdf80b0a381d999ee66684221a28d6ef1ab79af033ad5dee2161ef03343437632a75b8254946df960428b0c5140221597edc5e23310b01bb10184d0132847c4a70d326f74677e51329dd398f8a567b499ab0732b03e5172b38cc803d27607fcb8a3e1f3f099e98a90d323edcb179064465295ce33561e8207968ca496b83fbcb6572682b1b95c0dd81a7e8c681e213867d79c7ef9ff24bbf985ca3810ef820f4ab8381993cbaaa4d9dbdccec9385f2a3b2032d0bbe62242595ace5447095bdb67aac2ec6d135d4ebb492487ab1b0f35636e35d4a7000b4c7c072bbfadeecdb06b585cae9785107c1831f67f227b2d6ddc3b40e0f6ea100f0d86c6d40eec22f6ec8af81f7494c951eecafd06d2b6e4f2ac3ae9a1551d4339c16c4369604a5ed31a8d130f5db6e19e5fd37728e22d1dc9b3b228e3d326c4852495094a4d18a1afa7ddc6720883dad0dae8fc8dbadbcbca96198208c00fe63cd09658c6345f457f81f4ce644202365f9df62d1ac5ac1dce893441ea33cc73de4de364378bd26ad01f3e74a0da9a2421d10838a6ae9d462214c77e5b92f14e3943246113635c33b5194997e59aa1bd179554d80f36372daabc0fb8b35fa978ac47befb2899a648cbb177599fb3d15e2854f658da49a3f0b5e43a46db6a2a51c843b2df2a5eaa83db830703e2e0b94267e828bfe2751101b30ece16d4a5483ef7ee235f8674b757b3259081c143f73eca029cfe46c950a9aa49e2208f1ec916f0295afcd7e8b77719984514efe3cdc7dad68a49393522426bba390507705aabc49d76c9645c879bcb58c11fa45b69c11e8896fdb668724e6ca636642504d7507af86802b183f9152e4f49a03bbb65d958056ba91e7c824f89c3a1094bb6a9d857408b9b25df80803648fbdca2ba05d649ded83542e03a6823fcf700dffb48af0a440f784a5b38dd69f08840dddc8454f2b43bab0a1a6c7dc0da29c0071d319ef8dad829d3ad2a2c46f399db938537b4f8a2dccb3a7d44252c392fa855ce280625b0d761311c9fa42952a359df2ee93a263929a46d19cf1be42b7a1b4728c693682a77d7adb5934239f600845a8edc3d0d676c1e30ec2b8a472d1e00dfa382a40801ff7c4da932a2493617a9d8e8bce471db5a662062bfac6311be43f3db6ea186f4072d371945110c1393a2232d1c9e53ad7db64d94685a061e76299bf23e6e86cfdf8add0c2613be1b60d6f61304fa1f3e93d167b67dc3a6ae4896f0f6baaf3de7ff1cdf47c25a4831f6bccda44561d8eb51df72b84b93fe201fe89d6b138b5c2c4a33bba5f192129d5c07a94f393c9a7eb118bc641086877af6c287cca5d940b40f4c5eaf21342bf1c058eb6d8be7365d59e7c646b2ccd3577f5987f1c907aa800465ef8368803becd71cf14f01517ecd9521ee4220ceddc40b8647cb4b8f888dc2579e1c32ff78aeca23bce546ab212715f559138ee7e42cdbf9574ff0ed2e21a04b74dc60aa7505fe17a9fe97eef376f3768470cfb780d4d19361a20342cbef8edfa831bdf49ded709e17878210d4f58e5e91f34f10a9b57361b85ec2a0042bbe2aa88c77924e056d5a07d0bc6046e5077e71fc6d624b386567f0b5c4bd85863c82c25119aee42c7b396d19fe8efbb9c4ec4fe1a2ddf237db2afa51820fa550cc53e881442deea7fd13c176873943a7b398236df4478fecbd6b7dc9314397baee98c14e68329af08d7def811fa79e4c0b03d45d683b22ab2013955b8337a83a4dd7334b4389c117dcdc5acac3ea047b46677ba30c29f51cff8389964a56ec9fb67c709414004f03bb55705249cbc613084c2ad0d04dd7a30ed7143a5b2e519060213be7e228b2d7700e335e74dc27a36e9b8883fdf33feb8a0bd8f76c9f1b949cbce08c578d534408c13d66c348f93045893a702853e926e0c5b611de39eeee956f7e19cda939227a44562a143aae55cc52d725d09e60bbf9a3afbf2bb791c3fd0641de836c78e70262bee9be37d66c7188b1f91b1c2c016b3d12ef1eeaf827b8419878f2339c59d2e0213882fad4b2ab3c43e07cae7c95fc341db7d2a9513c46f06cc76b21ecfbb2de6b99672b7f12c62f0bcdaf99859bd496cc5da375a15df62055bcf22745c1ff69557b1146c1ea99a480b13133b9ae55e3cf4867c48e806d89540070b47ec8206ec362c22a44e409a087f39e3d6337d54d0425881f3959c3d3aa6549efe53d8af44eb71a1db1c1f81d6f09dc955c0d0b405d18cfcdb9cd9a5364639ed429f3bb04a52d65581611229562abbe1088a2950509a7d602f7e6628286d027513fa9a5b09dfe9bf8a94131c14faf267ac047dacbfbbd05ed51c7f19e53694789290ccaeba02989417ce6bcfb65db61ddae9428d2f61f1a5759b9108315df8359bd795277ce3c6a1bd4fa6ff35d209362a429776a17292e31f8e2e0aa88f839cef8ef9cc6e2568e3dd544d1abbf4379667c7b055ee92d7cd9cce5be1bf0f70965f5acdeb475179d0d9ab8ec7f9d572f9f3a8fdac47fc84c3098bbb5a21c4fb1344060c25e463f955e5792641113d77b6ff3997960ec110658c67d638b5c462ffec9d63279c279d82c13c66c71efa6bb5a86ad275e425faa6e346b8bf2623c6b651a022d068cea8198db2e03a352fa447fa9ee567bb7e7179e446afbf1b6fb384c0b5b1d98f7ba4a27dacb9c96dbb305af0378faa552a6de21702a9fb81ef12d8fe8313f3e4fba3ea0832ef289d8821ccdf630c55714214c1abab8233f0fd098c13fb0d860da311439631cbfbb0b95cac89dc0da715a77c051334d514812cb54eb4efea29b2cbf41b42543ca6316091ebf3beddfa56028330f55303e22a1b86966ea47d3182bcbbd240a80808b25050e97d136ce9238ac298668f52a230d3825470ba66bd82a88cb0c43c16bff3055ef996e55c5af8e81a039e8f1627ba5e8b32841e3b12269b85c4bc63f0400d0234827583983b9ed5a628db9c652aed062c2b9870afce77d3570f1cb76553dddc0f1cef0fd381e62d842462187b048b12a3e4f102d44cc11f6d27f88fbdf768e68337ce00e7288f611a090dc7e4faebd37b6144432a31c24bb061aa6170be56107c30fd6f7d1a31b1111436ef05c569e97aff0d7a12d9ee9d50b95451a94ca8c3e2f565c877e15f18a4c92c28ddcf0f2758e340fea3526f3aec94e2ebb5cef71b8d24832cac8f169ff68b987b212063ab2c6a175670eb05449b84a6f8c8d326776c7fbf3f4233e801dad0b8ad135bc4b306a9c0d4ba9c3d0fe1f26e327b2f9b721a0089e418f142e7289ea87b74e0439d1960d3bdf1336aa5728b4b66428109cbbdd5e2ac1aa61b3a84f551bb2a77cc9862013221da1cdeb63835d21457d3fe99e0cf8e294b2cb421ef4fa6a254ba7486bbb2294bc3b530e668f6b976a79a26654fa7721fd4b60f850cfeb8a4550e85b0c1264e3417328237e865ea82e231c506c101f326d3c148f0fb8afa455313d23f825bdf0d01e6ee97764ddac175e422929c3e2efafedab29e0d22574bece06c6b3238ced769042ab8ffea5236862beb7b7df50e5b4c06c0adfc912958c81426f594e632fa2595ef4605cc3a75bae57d7aaf450f15f016eebe7c044a749ff97c0cbbdc2516285576b42578787e20329977c91960962ac2b75ee5bc99345d33edf35ef23ade1a74becde0e9e830d6d89c4e5abd6b0504c7d245c734ee70b6a38839c3b4d2889b490bfe95f582fe6e9a31c7ec71ee508e6c28e64556e65a45b7cc9b9d5c41e0ddf676cff5b572df581099c097358d148a4ce180bc4dbc5e048718c4707fdc6e3208c07795174e379362cfc98f1a0306353c5b839c767367a17f275c7207c6525c204f7348c43bf6d4508c158a3b3f7f3c496ce5a00cea1f4f6bc37e884d9990a8af358918aea1864448b121047282697f8a38e3c86c6f635f9ad099f9b7b1d52f0eb8badee59a3a353c05e2a37d9f5c19337d5fcbe13cc21ed3a9f5d6b67cb4907bcdff0b5c1053a4c8a4844d3a8afe917cace5baed1df73b1d07432fd5191065604b387a0a4d9070440172fcb26b2397e5fbd7872ea6dde1244a4cc50741bdb8c15d4e9ffd49e34e8827334146a62bddb86146080c237b2f0c83e0602fca6e734ad57a192698fc531e5ce804a05a19ff3e0bfb9857a132e8003f3b3fef00c40e26b9c10e7cf36843be7b2b45a288d20627fdfb7e6aa50d9fb7c38fa6d9461ab28df5202cdfba6bf77ce40362f85f0c0ae5209c2ad478fa8caf60137954feb9fed5165f4e12cf9b584d95e14a716561e516b7f97706b28721083e8a2be8070b8e49daceceaa241787e18aeea432c46f37c26967fcf10b50ef00f6fb894177cd6b50fa189d4f8f0012fee3d2a8e1a99ca74dbbd7cd44db1a874f32239c9137b8211e812b4d70be7544069ff39ba46f0d3815b063c6684051d5cd18bb76b68c16ae8ae587153414de3727ca2d0cf71de65f505f028b86ef80dfe1eb77b79249439b9c39708dda4603f03250c5c9ff440f1da1dfc08d2bb3f19377e5459b9be447db704de52c27cf29d20a2abae93499ea64a713dc2cb88af804d4f343874e5d24247911dbc036aa6a99d795af17d88f9237bc559a46bcd2d02a02bb87d1c85a93f431a8c1fdc5c14e06dc9fce6add87eb4efffba98b1837297d962bd865ac5ad11912283f8cb22a81ae60a7a94567151bf52ef9546a6fa0ee08d5f4ad944065663b59a81f8f4417fd4fd145fc4f1a0bf32e1f8eb63637a78621f91f2cab24b29528c37c00149685418356f2ca48e6844117ad2088531e8de33f74c199e5e257b06b6a1fabfb8d0ff7bd47c9e29bf86a0dd0a392ce57f50a3d8952d6aec7d84b686d9d5336552cc11a687fcfd9aa33ce833d342e76967ac14fa2619e5a481300ce00fe8951d6dd27c780a44c63f4a3dfe55c6d6feb1edb689302fc5583482a3012570c1eda4dced10b073a81159aad1c8a23e3e136bf00cc1cfd082ee8220ae74d0d926365f1d896a93beff215bcdb8303aa581b2396402e9c89516a8fededb410ba7fb6f5ef2ae4293aa03de24b5b50b7c773eda569bcbfaf70264109483b9e9a35eb991c92b493ff614c0ec2c2af95d168177e3d0309c0f4c67057fe901ddcd49d9ac96a214afed732509968af734d74748338b5584b03eb672c4007c4c61cca82e34a99a0fc8c2ba21cd0336967a2414b1793ddbbdd6f37fae9e67abfdb33e367547a73a3c74a5ed007e551fa0c723853a4dca495e3d06a7cfc15b653e62e099e13f2ad72f620a431856ac2b3fbc3737e015fcd99960e3502e28df22e9d483cbfc1d1fc1f8854bfc335533e6405b0a14ddcbe70674f04151375bfa298b22b0f174dcfdd47cfe7ea4b3c902983d5a970bbb15ec97a734b2dcb0a90cc2bfbd0c78d14a87565bfdd3db5fc015fba90d294e3237f2ce93411af57037ff070810e828fb0eb18ee59ac560c4fb581a0619bdcb049a2f40b460241c96008019bc2f72dbd229bd9c0e5f3318015f07745ab142ae655a50325733430b1961f3360258591a1b38dfcc95a18e0278636007f0c361ebbada3bd173baa18ee99a93ef21168b682ac70ad4378bf88a3b8f1466f53d49985cc80f0724703810bd7cc4627fcc3252a0ab521a4a6e92547f7420d26d4cb2dac54dffeb27184b07ee055230acff05ea0715422f6531308feccd7c8c6969aa0c68803202f7e7b062288647341f89ca0f67981d88c700d7476b1a21a13eb7fc2ef86eef0a6843de02312830d1481c1baca3984bbcf81ff12878fc8026d7000e30d1c5a7bc6f7af86ad4da54f4b3354becbe05fe9cb57a692f670a6a66a902c0dd7770242f6a499306c577a0389f31ccd61882840c261c70bcd0bf22d39354cda5f8f1083e23fe3d34068db8368654cc62f6750024448807c0bb2ddc60a9bad28b9ef077666bd3b573bf0f1a743d931553a3a4b28705e5d8704f3afc09a0d9b427662e56d8b0d33f544eeb610466fda5f5adee0b7936ea0825dd52b629d383aef00b175f0d5ec234895371f75e6ed31da1d3a3e3fad6a046596fd2ee646040b01962a05ee7b317ef02de392282151e618df91eeefcc7a183a7b9c4577c8eca7d3d6918035364fd89d7a345ae5c52a99a90e70982ddf95e4ab1dfe49b7a61c9dc97f8d2dfb1cec38a61eebf7b968720021474cb33774e3c3d892ed1eb9d4cea284fd51fcba4e9d1dc15f69d20bf62b4fe4e7e134674ef486846bd2676a5f948227a210349abcde86cf5a5b1274f26853c4d32aa7a993ba2bc8e4f073916b4ca0211ed1d37fd38fe2db7b9e2ade8dc79c81e375c8bd715c88dae979423e5c0f57f93463b5153f512ea7f717ea165a699e9b7f4de590b7b1d51bbc72dc84d448fbd6605a64107dcfc55367af780aa77c28ba55e331621c51582e74c01a9d98e2c4cac585bd9b179b05ce1480e6dfa9690d9d6e70a7ad76d6360993ca5e8fa3653041519f2f5d88a3b8e83b4dec3d4f85a7b258adef8c29cf2b1b5de63fd580871a558c8af6cb85cfc05987194ee7a519e86b9c36609d4e870a152b2602c6e661fdc0dffe8207321fbc76fb7151eaf30020c5e6d4e9ab205a60f0b223313f699b31cd42a836a9313ed04f16cfda3767596f2f7f7b29fc18ee40e0bce9cce05be0b2417bdea5ca1ccf741aa42058d912e9549b9a9f75c79fc4a2a55e725ab9274de032f194cda05aab97b8a0acbfaef84d78bdb38155fe7d6ca1ec08b7c79659bb4bf9af8fff86126d8f888e3e20f3a98c6bb12991ef484701c4b17c76d480a4755538803832e468d982bd6d3093345be4bbcf0d7443f4e971ac766e79c6d722a0a8daeab525a8b86cc69be21e66d01eae5a8fb7bb4203fa4d4b167ecb0d27c16bf46bcc8e75e1a17a5ab3d75db39cd87e2a30f4bb4d183bda37930b8d5d1f6a66a89fe45945cd0ed5757b0f4a2be002f5295d8902ed7d1ac6f60992aabb5c382229ec1b267cdac39f400408409d69ab7d685fdb95845e3b733ca796fa6d57120da226cd27f151a186e0244d98ce2dae6bb4042bc8eacf3d35daa7e3e9ffc6ac789dab39051f0f81f81f7d10faeb1bfb190aa0e87b1318fc8087895b3c5bbcefb06a83c806b3ab5ff2930d229af10c67d8f18e1198d7ec71032c42376bfae170b2ee7d0bb52d7a231b160610416a02c3a792b0c0b6ea4c45535657b762ebe655901613809f38386f93e217c502da075e3370eb15e8acbe7d210e1cbadeeea341d3abb7aa642fb8c4218d47cb2df372254413064767157000cb3296c3063799f4f405650df264664ec0ec91a0204c0a52646ca4e201378012d6b00f1c6993abe661193607706834f1c2378494ec7353fdbdf4887383617f04a0f6fe65b018206f578f969b40ab2fe231ced4b42321f05843e50a7535146c1942ddf7026502f71321220fa755a21dd3dc1011851863536c5cdee00b46c356148149a3b1b5f128caa32fe029f1ccfe371dedf54d17d4c3b9a87857340764c5886fcfd7c5cf82102787e93cd526e27776573ba3249ab2dcb4af2f0d2ca0450e6c14d4ab2c06dd3568c227e76bf59f3652da32d7854810ccd709d91fe23a56b9793418a27aec807447e6ef3a9604837ceccb47615405b0300a109fd0015d85bf9cad13168753a4f75f523e0fe489ed7e4d6aed069ae9ca2d2036479d71b0ae3c5cf39ba4c694b8785a83374e877fc72c1d8917b74671f8aac4bf4e2e21b8dcee59badce1bb7c9eceeb6afe4b0acf0a121d12c1b8826ab4a5389281ebcbbe54690c229f44dd5c79e72216726a67d8c1338849d38a485d9bf3af0e0f56a1b943104671e2915a9f32e63c862ba295d8b8789869d594f7d56fe211135ccadbca6a3aaafab7ba8a0b9c66fc0de6f38ce542db518a6aad4fbcb1b83e35f8976d1a7678c4d53fc524d15dce24bc6ab4c98e46837f8ef3a2ad183b171f508cb9d2513731b369d6d3433c88381f2f8f05f974a23f052bb0a9d295f3760aab287971d436d26695eac8b1dbd65959f2efc79643a3cf726d469f3e5e836ed2eed90104d92f77a6a77d4d2cfbb046616d5a7b5427c8e4b065d4f17d5433d7dbe1161bcc8e43cbcc3ea88f953c9cbbb433c5fb5e63492b35b306e5ec6cf5222eadf0a8336e58c5ba4e51afdc8eb0a3895776c813b9b3838c000fc6b5aa793e5fdc2d9113e1bc957fc98f56e24cc937f359817b532c025155380d2b1d67a810e5cb9e38719a230b016c27d3e5ad7df7c5b641a713f1ee6e4a96d4871688eda930938604e77e89cb380d283e319cef28c3fb5ff9f61f703ddb72d3f98b7bcb3f27489c04f3baf9a3af0bda18ff841cb165c183823526daed3697af648c6156cdb916b2ee3c8ac83b067bdde04637fb5699841543798ab953fbd32cad2af4fc3724f15ab9456f0d6356ad62626d8d6a371faef23cfbb08899ccc1af715da46cb9ed79d4c3e3610b9e4c6178818e3cb1155eff40ab0f1e7e6aaf64419c9dcd3b270a2cedd513219ceefad7caa7ce69f51f9739e43e61f9693f384b5728ccddeb368912f607b424b094795d1e436cb833cdea4137f272ceccc4ce5e8fa6ed307538304c67da8d7bb3b6ec5a6dea47a9ec8ce0e56df302c8cfc0da5048a98e524c1bf6449d438ccabd76b47154777634e911c150aaf4f4e558a7cb6d1a495056077d6f63d9d4e7ade4dfbbb207ffcfe47b358fd75859e9ad19597ae02d81e550b88ad03bcf477a182aba6341030b7364d2b156b63de6a12a0817c12521f9562b75ac45f9c647277ce35cd8867916ee68c29381abb4b1208d6fcccac915d30b9c2228e5e489dd83e6f1d898e0b27bce44499fcb4d0ad8f2205ffa37c68d7580a529f1bfda4106861ed12a1b23c7df990422e3b3f0b36a0b1d04d6f0af02dd47c3fd9f38a3f9cdd94386c07e31956c969391ff258435aedef331b4f3c24faf36e789c2960764da79c34246cacd71a2a126738d05b87b874b145d08acea5bbb4bb6ff4f3dde7026df6779811aee0fc4e61cdd48313452aae13f35236c68f0f2c19d0a8f674c53a0b249c4e5c25f1161df57fb8b91199d51e74982b8f034f482bf27f0ee31ec487bde3a09d6a1f8aca17b2921d10f78a88b0442dce96e3ee8550e75f5d6550fcd83d39b296ecdae457ba94ce4bebac4c36211c4b49d1a06313bfb9e7993949d4b085a6b916e31e49734b31dfe01913ccb613f4dfb02435dcd9df23d4dfe46104a42b69dad111edff39d128e47390c141d1d55eda1ab4a773a3d5eb1a5c0b93851cc63a193d92f7c5a7fba80c2e89c26b13e54d56b83928d7519f662052177ed2957eb54da52b3ccd8be0cc6f51e2909f50d9207651fe9ef1fd1391f201dd0cb756fd03ba87f5da9fd8f53fa807aed8a1a7299c236dfbf9f8442f9fc90a628e3be58d6a851d62d27e293ef9fe51a10519f28892e167e89d3abc10d6179dd0d5b81916bb2c1c8604d2ac7910cdae687c8571c911109ae74cbba58b77d719450d23a9c43e145277e530be47d5c0e4282923621f8d23e084c61a3fea6325325edc1e28f9a35937a9693aea9f0b60a2810c67887edee2a35257c434344039b65a852af7726114e3b0acaacd1fea10678be4320b80c3e43b91fbe4a42deef85cc347e105047b7083649ce1e01657fc4f52275d7dc28b15c039d9374adb4f2886615fe397219c74101b4f633481660334c776eda89e5e155ed40bfcf9c516b5abd9454c196696e3303a28a420e41d86d9951ae6411ceea5e04bb91b42c732b2a647551125bdf41eec5e5aeed8da1e88ebd69cc00425f3c55f69707e2c35ae71859491da5a815aeb9295097670f7bff72c1aa953df87b5ba55eb98818ac2abd41bbd571cbcd3b904b4de2d5e93d2717bb5bf036acbf8297f56db935a92057a0447e2e11279463b2655664aaa24c9677837050cb1ab173c4b23a75fb9188a8c9d1b05d0ec019065e2f118190906e628a2b80227ccd9dad18e448bea934af86d51f04d38ca0c574eddcc593c01d73fbc0a6e98ee0fc3e2b938eba450da70e2daf808f02d703f531818ec25fa9016fe50d802a5d230bf128a62ee25fd1a4423d575a1bb281bb0920dba4ad0f14243df1d3a360b18c7cd0b8c83e438606f6b3421a8efc64cfcd4285ffe960f71362d1c3e6556b1fc1406ca4d6c7eda0ef23485ab66e4382f8ed798a6436618584ac05bfd1355d152fc6f00b064540ff32cac012b8559ad7899100d1db6577eeb0ab8edbc5d3c6fc5f28bc0653b73b8aed844467e70dc17fd3e041e1a0fb92fca38274af45e3aff155dd88d0e08bf8b9e0c243999ce4ebc9038183a01971e8c8dd9b725dcccc3d130eb2df8f4601f6c60fda8fa1f60468714d1c0d5b036272fd7bfb4511ec388eafde0d57c1c5c8199d29f1f9081ef927b0177038a8fa5fa18c754db9c2d0503728a947780592aec07a11a7286fdee6ee2df62056320b1f99161b80b3ad47a9cdfb64a08e56f1a05d7d72501e37423156119f8df841ebb246eaaf1fc300df778f5e9d8a581de615808d2144c13520510325ce40bc27a1a188c87bffc5febeace522a305d6acce3f5b8363ebcb371717f9ad140ba7ba6fdb6658f062afb992263f674a2bcfcba5e588ab7d681a9087a89109d3ad2ff756aae288536c74ebb9ee1f9fb5b2aaee798bd7b68bae8e54b9d882b541445fadf5e0aba13603817dbfb4bfc437409d0af52c67db40cc8e47ad79a9619fc6db6836784b43721eddd6343243f44d9751a5485d4f2593e20169aec4c3650e3943d95facfec07085ecfbf719d261bb73d09ad59eb10dd2dc20613da7b787a84bfa1fceb24a181ffc23804df296e37f5b215f99958093197da24a8dd3df888722164311d25e9368b762538f9954dca8bc9b3a60352f0e7a3d8e138547bcb446ccadeaa4b0b1e6b694cf203680b5bc2be68fd6b68a182ac64f686aa1efdb337e775f8923fcf64e9de3546e030dfaa1f27fd46f9b25dbf283c057e9b4c176a16ecccb3397b059a33924bcbc3f761ab6a2eaaf0db784fe0226360d3015b6473cb86b8b9fb6fb0e4c2153976b4405d1817b01949404de06e39b42ae4cea9e5a402d057a0531d03f58a799fa7f3c5894194329d24fe54fa6ff5883151bc0348ca0a66ad4b5a68f0d4143112c1f3b6c0f1ec58da75b6f7de12063b8bb0f66f76318a50ff42d6047d49f0ec66d88fbf76650db9b71557297fa41c837caca0d4747cf2c469cdf7ef19195330798811fa449401bd92527be42e95e613df9648c4d4f7e44d5a842532f575976020450a5d78041932146d35ad6813d94b879fd65e1d49fd9ae0950fe6a291ba9d8cc95285329b44fa06f2b40aeb1a4ccb5744327aed8441b26a6c472285043c69ff05187ce95604f1656ccee1943dfcc7cfee66c3ace6322ef1fbc435a2f3f12ee3b0a35f5da716bb737a399569e4d727dc9a2b12ed706c5c6201d00f351d42652d050732efa28bda158a93555f7182e2a543359ca78a0dd8bfd5dc0ffed10325ca77d67299a1daa88b1a87dd0d6f0d3475b57e477a27bb262ecc65f98f72b8e8220a9d0e1bf8e0e55bc2f8185c8401aaac8c70aa9d259995d135711bc69de1f84eb172fe97d28b084ead820176f971205181636367dcd0f9ed389f43ada8e4bea32d825bd221c0a7da5411b6ca0f6894712e5d51e8665ea01ac9aa06ce752739735c31d675b6e819d40afabd0a37b673b86e46be671186bed0aace844220e8188ce57028c4c03b5e14f6999b3e33f615383ed89c095d7437494e75593a5f1dac4c33a946852d7d3ab7897320442a153bd1b87fbf6c61ce70b8a73e5ada6d070f04847c327652e0a591b889f562160c4e441a688bfeac7a49e1f0543d1fe876be2c2b4d22c9b8f9f90dfecb09333decc054fe2c5ae04913c5dd536c5e00a2f3f4578524f691966b8243c4878b35249498acb15571f6b9619053f33f00951909eb1c5643aa7959b00c89ec71bfc779c95ffaf802234b4ee472417cc9a3d20bb4c5bd157f3fa0253094f43a4f173608e2ce4e316ce8eb06f69003772842ec8365b7bc05b6498ec5b6d35dc360ddea794f5faf74c203d2b6077525f323f272ba142555947f050a60dfe049092523f6c574d000b2bc32370c76204f6d91f459cc32e3c23141e385249ad570a6115fa7db46bf05ed533e00d185c3b1d28fadd3498cd0e49640b93045f2a97dd6006f40a07d797a83fafbe31b49fa18b2409b124c5d3619a71e6e3c7014d780feb70ca9f35453735c5bfc2f78c715f263cf8693e77c7312089e52fbe89d43cd0c24fd308f28a7ce5a8708d5aa3729f389da77cfcb75028cb5585def165704138de802e87ca74ec2cd0b8a5aa14ac7de5eb805770ffc55e7a5d5d6758859acaf88ed400f555e02b811dc1f083a08e10bfda5c83ce6943b56d72f03978de27489edf6311299455173b7c7c4f1565c6e95a071c21afa020b5dcd29bad1c298daf936ff71feb462b561d336a30f014a1037a5d58bc750ff38bc5a2b7311478851fc4ad9111676d86105f488b1296175d3c211788a1061199cd7292c4045042d832a38dda604f731df0dc0bad23dedc5e44f2e2ee9b22adf28cee3143e156e1a9718d4bc151cd46a31735f5326e5533cc2c6b8d1c6acf5bae98f15f59c1b47b935a2baf553a57480688fd2ba75fa940897d258975ac3da38961aa4d62bd20cc31c8ce772a0652ff222e99f93c238784e8f7359a843bcda01ea3ab0ba92260f55d8d867505af003910a620ee8478b3fde90a9cbc28e615fe1bef234f6f0de7d4ffd903eb39b005ffdfb5e3c5acce1f3b7a7cf62a853c7d4f733b9b02f8c98dd3b74c23cb6a5daf587ebdf09a960c20385ccca6d13fe41993a43e48bcc95b414bdcc4a2a169daa41829c5812f9ac6fae4efec7adafdeae4d9d8495f853c27315493f5a43241e3e3b00bf7129e08fdc530c788e10b752434c08837123470ee06ab98b7f2e4569383603752279a460c969618fa5b93c889412617647d90442760cfd3203579977e7c25d4be48947742f3129f552dd2df3d1e5f3cbabbd7ffd006ecb1498fc4e2b0674462d1900d26ac77a62d206f2ab9f9b5261c5fbbce385d026a5483ad66580bce727093b2df1478ea0be9a43eae1a8f3112d4b715e95e518842bd67e1b5d1c184d9ce4e2aefa9803cac584980ef088283fa2c6055fd99ad291394efca66c3bd7038ae0f0baf5718c92e7f86492100a6bff3b9b97f96acc6da585609f2dce9c820275449f3884ce890c8ab9bf9901294de7113e52d48833cea91aa2b23e258a22b5e82e0776d7db2b62675fd7ecae0c76bafdac5c1fda048cca0ef33f5c5d16bb8baa3e4e6bd391a5b6b0cf9b908609f360190561238b4f6ab8f9d800421af365393a1f391eda2e86a0781796d884ed659827ce589835af3a8cbb4e9037fe3d3b7f62f4945905b6e0b57c5e02e87da15bd3014579263083019ddf33bdb950903a6341519354eff86ce07e141cf61e378bcf05c379def2b61631ca91ba0f96c05aaf08ec9ba6eb9de0a20eea5f876a5536a3268a127ea0761ee9f49ce1d89ca25c6382463fcf0b761d701fa1ad546f112150c5765c084570a7ea9447b329829d074b56a74ca05df1b4b0bb5b8a86515af1692c4aaf3069b9a03245eb9733e11285651a30fd022a40f23c284a6298e27a15096725cb9a6fcde22449ec7f7a06335c2c4b24af91ae866cadcf0ff0594a2cf15734d77e0da1c4bbe00256416caa90320e828b1a169bccdeeccd0e68822298de17e162f1c25f583d5d198365852fb73906cf6719eca18ca0f9ea8dfdbf1c71cd45316122d5b0389256fe48638a85e6ddfe336a13962a46ee64add40a33dacdac65b84b640408df1496f9a736458ebb3ec35f52bb73d1d004564d8363083c83814b733ce7eb9f2cc166ea0588a777bb7455abf91c582d9097597eb6c5fa851f482c575c3541ce45dc42b1d2b4aeabb0c880dc92c75172c304c0179c7f20b17901133d28459d24733efc6dbcc417eeee7931bd69a5f04ea147b840f693cbb5765719e13043bb14caacdd9d706a99f280db3dcc4806477f7fe5df013409a924ac6fa3c1df6a3a167e63577f8eb0851e3c851ec1c89e2f8e16a19dead598c9e067c61bdc58735706801d8eadd14c044f13787e4da494bca9b8b526104d9d460bca0be8f55cd92653a582fe9c1efa78ef8d18e378a262a4931228a45b022a154d93df1617d0fbca7d2ff04468024dc83a590d3e8c63400583d334ad8b6fc711935facc2cf31ba52a2ac42081e5e96c3479db2467e02a0ffdb9779bb7785d37f58d71df7d337551e201cc3b86bd776034c02e1ab3f50ce0272aca77a6ef651e4f2451d80057517e2b2afa70ecb1e5c66eb92f07168cd95dfc6c6a2a8af50f7cc6b144afabde380f26d9b8ca91d6fbd68e85d3da3b2198281ad3700aab441e22f0b3aa5dc57184516a41d8fb178f88cd21485c85ec847e71e0af8aa3bf40c9b509ff64e4f748d88cdc7a2159b19459f1474e89dace66b945480d5995442906c6bb6507075062b464d05616c89951ca32677733cf938cfd6ab77905f27e91506f44bc77d528c8b90d23540a5c261ac0081695e33a260f48b5a6fb41903e1ab7ede5ad745f2a4991aac2f4b1c9905bf587283e3f984c753b9cb92188956e019fb3b95ab72112d728ed75362e7bb335d73773e206ad8b4034d81b517bbc1663717598a4dce7c90d0ef0755ed6ca40dfa09909e23ca3b4f39247fb3789e48cfda5cf81efb95a1378e3f0d62bd780d1a916b0c1b710f1aefc0e6d3f74fb66e2604e05fd824928fd41080bccf368d023aaf3559460c298395db6ae577aed2aa40cf5bc431672fe8979c9ff8a7e2e4f5b1039b67b2373654b7b024bb6b2f78e5daf996b835c94b4a5d9c871b380abfc05c2a21e0dc13d54f063370fbcf599151c571a4d96040389851deedf922c2b668b85512b4bd65c7ca9ba28f049f2dd44c3cec70c827815368d1b24ce13d60998326ff2b0c2c4ec2f630122c6bc076328490515b4f63e95abc16fc94f41dfd49975b956e9008dd58ce8cac64b0e1e1661ff00a5460f151d688dabfead2e1711cd6eb955675d255a6af0531568ed8ffd6a99e9f25809a10a6840b693c9b64b6a12fd37e4829c803e20611b9f69be8db05d27a59305d00fd1677ed465d576e3ea3c29ba425e732aae1700582bde96a4be17847a193a4926ab16683c1ee12870743750fae548567dab0512a9719e268b69e74ced02c873179aa9ac9642455a78f01d51041e63e1df3759f926d37a5b5d24840fc41e6f53fa9ab2b6d080d2f6508396ca711abf3f16459968b8640a21659e2108401dd41f686327b00ccfb964781d799ca6ecc2357540379ac5a08c8f470ac723666d2a5262885bbaa2c70e090ac20170f075ca2c843bb789bc1b367f43ea3a19efc87cbb45d22fe3ad3af950c0249ac13e49283321bbf5857764ec7cd08e8322973216c964d7b30f7d229014073e310370a60708077cef664c1c87bf595540f36408bb4da2084bbeb181d955be89891268ac0dfcdc8655ea1a0bfaa8d37db9fe5679a27ee69f951693b50e9ea87c1fb9c2b3cd03ffc9860009a12a54b7ea5a54aee6446346321e0e0ca7cf2cd8053bbdbdc022e0ef68e4dcfad5d246f4dc69aa8b7d1f43b1cc058f3a34e8f730e2a5117eff7d0458d60b1b8e10beeae5ae79f1e417ca09f838bace59650981d9e6bd503ec09628f08c476ce1a7ed303dffdfeb954990c3090bf6077c78622b1f13ecd9d8075b0bac441d247f26e24cb47ae57c5866ca92c1302ef8bd9ac6438c5fc0b85f078c9b68ff4eeb800e82c3ea0990b94dc39597443ca13bf559d7845e64ab1feb99a01dc0d99ea710e04af233fb8ece5ba6431765df0abbafccbfd5ed5496a3989efcf9fa67ae732cbd802c3225534d662fb1792e6d2c5e77afd295bee449d2af9d96527507cde13a0b5e7471fdc479ce62898e08ff5950cec9fd807e9ccfa08c941023adf05cdb0f4a50bd8368288de4cb9536b201d08ca8b601a7125b5da0d018d92724d2afe91248bc05382a28b552ffa6753308e5c0e1cbc93c63a5ce3c3ba62a15f4b3b92e4adcf4207cd0915906edca5dd50d2a909817ed640860c4e3ced925ce9e37bcb0660337a3643174efa08cf2d95977b94c841ae58f134ca99da2e3db617b0727b5a97cebd8fd6120cf0cdf2e6072cee5541ab455a8ed8b65b8668bcfdf22ab87585da980e07eee21555bc06f5d2fcc02c2714e57cbd2b9cc7ae5ca0b6d9724a14609b5367e7a5a20590ca75651f3af28ec18c2806f81b01137b7ff6fc7d59940583f6f3c0ab0c8bfe91286f06f392a9591668ebfaac838b99c6b156589758d6170412c1da5fae75573fd2a7bf6b4892d27c3cf18aa168d9b15dcaf379f7227aa419e70f3a25a9e34ac6cdb869e22e47e832ee4379e6a09e9e4598bc1038d7b250a2a5d5d7e4bfa75336581a11fb399ae145b29d8ed5d4e239422f7d062ef5e82fc9f31aebfe6c4a216bf78bfcb52414097a357b21bcbd3985fe029ae58bd8464e611570630079d325e3e115532a7997c2a9393602e6a3a5aa946648b524ff8f5fe7b4302948b664a07fafbf63f6e66cd8e88ee6b5a84966f4f8db96a9acd03c177db92082c0e00586c5730ec1fca864f56d991135848bead9f1839c44b0b66cdeb3faeb2813c80c9256affbee0272c77e614918533c911714f9a275ba87b2e311ab79c0d6b79c246c70934ae570c15321f869f12f1bf1b752bc47318f8dc88a451cd948f4c98530f798966af7563e30990a9a4153c7099ef4593f8cfa6df5fcb97e6d62447e687cb75f19f906bdd5089564aca083961a12c251e0edb8aa60529940c259e722e7aaf8e905890b696a8ba8bfb2aeed849d9b08bb6b42e59bfe1957e0f64fa6c65a32d091049f71c7f4b60109c1d9e1002ff6ecd95f03d2404281f5c152573de9f29c386c3aff3442706ecb140fba6c528f436b5cf69fc3912be48e645509b78b5e704d6bbc52580d6ce5db9e2f903631ed39be5b02543b7fdeb0da4a7435a632b43e6d98bac27e185b91268dd0b094bed5c99a6482d10d32b7324115929add390cd36e3b838f3d7f94ecd712a9af8e0ce1fe3dd26ab27c5b8affdba453b36c8f8ef95f8889738bd02e44ab2cea238faf205a9edb1d4403e25c03e6ca838ff3d1ad8a5bde94694a93bcb6389d8a3ec4b327e4c7f903d481856d35467853e57f31c5cb19a81d29078451efb9599b9b0cefab2e11e217e05a27f1a29ab4824899cd14015472c7c6c335112360f9464d1642e95331e9e9c8f3d2f9f77c0f78273dd3970bf514f9744052695a7262fb41b3f5d11030583036b757404dcd362f02038eca727018a3092de539c1171b76fc7e354340044ac349d23b693b6586203007860d139fe313134aa83e0d52c65b6253822340bdbe6b5f1349545b43e150e3fa8a1dc5fd49f98fd5051f1b7b138848a82035b102cfa9245037e6d683f92c357772b6d3cdc45be9557c74638d1b6bb05f9061393e69d9d5d1b244eb0fa46d7efbf3c08947f6b6441d60a1b63652ac8b6a9b375ccdb030388509ef196c427bbba26d2deddae862f0e335968eaa0a421838ce1e78d62da55dd2e440551467c9dcb63b58c230cf5aab8f4c2dbd75d9b3260f58b66d94ab964e2a4885d6dc1a2a8ada8d9b5c4289c8e8b2b87a152811d832e1d8dc70d2d596724c835c8d5d8c5582914bc4fb099ead15ce04957235c40bf89ee7eea58bc0768fe29ba9b9654bd5b439ca76f9f39ce8ac89c21b979b687e00632651ab07259c2b5deb0f18b0ef1024e76b11558433282e46948166477c80f0b3bb05a648a0c08325504a1c0abf5d19ff36d12220c09d75de03cb02dee194c40ccc235424fe6e85befe2486841388c55a28edc7d662296e97bc23cba7fdf6b67780c850b7ce065e29a2268641f806c82f151dbd82da845460f8b4f5f2bac43963570313213f8647f69af6d788e7a12b1caf02cf1afd361a758ed8b1e1b5fab33beb0fab9a14b070b382f556ca72d9066384ed7004b557cdb3fd529859d20075af5e854d753f0feddd2a7b11871bbc9deb8bb8c14eaeaae86f6005c3d3430ce1c48ea73cac56246bdd388464bfaedb30ed34ce91fc05b6b773b2b8db5d14a329bf7256955664d894cc1954ee07a8d83bdb2ec6ee1a16529020e0e4d7dfd37e5f991f73a3d79c2eaba4dd6bf6da8e64c75a483a66f394ff4faed141845664180ab768275ba1f53b60c49dbe501850ec5aafff9d3d0fb17969d184e411d2d957b9b6801bb247d44fcf0d16a1d62aa2d032af8224973df454b2946608bc9e50d2befb473ef69cfbdace1511076b6b05de850dd1244bdec1298f9cf5cc9cadcb739c861154a3cbe4755fccdef7aa99fba46c6e98f7328da5f86630756b2e96d07b0ae819385f277ba142efc5988f45aab825a6c2760457c23a9d212d8214e546d752025cf61589565096169b1b391637be53c8c59e1dda953d829784bd719d46c83353236c77166f572ee539f26e0fc60f23b727bd5a8895f3778b6e8a81cb22072cb3d071799931e2c6b2711a8bf18609c32a0221182736b23bd5f8da4fbe4fbcb939555eecc2f0c35a9677e99b1d5e135fa5e1a64a84ae77588640583fc919f60e65855b085ca1afbb878556252ceb7f16e35d2964067f8081e5b9fd4671990f00818d16a0cb6329a935647856f27a52689916d3f97ce04e57c77cbbf6e34f8e6c4ce8bf7dcf523ac1ce2a52c02d2bfc1bb76214d2aa8caefa134b54921655e2fe4b73d592d5a8734bcba84f777b7749ae0b21dbedcbabe265ecddf09043b45e1701c68648496c46a8deb16c9e8fa364689b6400b25921ac1a57a9f46e96e2173097356afe04f55dbc97737ae417744ad0cf9ae37110b42605ae8ce7db409f112ab34aef763b28493a222dcd9b8db601adf5b9b6548afa672c6686804716784071230f9b925ba84447ef519bbe9a9ef39ad93da63359688849b6e71b96e341926111b4fc29eff2a4c859af03b734542fc8836f0876e39bffedb49818b8756b145ea165169e0fa92f8b8ff2cd644e30e28d8c8f6691669db82f3012804f58665cb06e042bc09762de2c0c40b9df82b994f4debb3574207008694897d8e78e0940b7eef84e8fb941834413d8d2e08cdcfa61d561ffaf4b247c6659b88147a42d0818017508cebaaf2558936e75c17c159a5756c172171892466e46edaf89b5afca2d85cbcec83800d9c5655701d1d65e3e8b8105c24d111d0ced0679eb12da9b7e5107c84bceb8c416e72da6dc348a7027448f2b632afb39b2ed40a413be94929f24787f1d53c437ac1f2ea078d147e832e6e09df8fee12ae4039eaf4c05bb6d6a1ef9e1cc6a48f11fef298455ccb1ca7fe653a30f57140ad147c675c46b7c934a4303bdeaea3ac133a5069a1197606a73e0576e6180dd24d3e2f3794682ba5291fa5c5258259a2078685c0146a26da01a64403fb36cb028ff46c011ffb4d17678ad532ef218a0277ce60f1fc4041399a5cc7e583cf28aadc01c48b2757ba8b046e9a9665abbabd6ec90950c70c49289af0038b3a56a146bfd9c4f4760a9ba8bf0071137cb5d7c1b8a80d5e1626f6c5bd2d29e7631c9467853b1e59240e660feccc069e09ebdb6749a3a023488b911aeacc6ffbe04a59657555501a188122e3b502403a9b50b7b2b56729d36e01f6cba00f72d311667c3b134f3087a70bebe34c74dfefb4e5dbc64277a165d06b09eece05ea54386c6142081720e032e1acaf34f2fc000b52c06ef4ffa43509d005884d82447d90a04220953854ef5371fd12110d2d16b29e1d7aece583b19fb9231f037d225b9986924e06bba59fdcd04cb04998ddb23ddf1b7586aadb096d760fb3c70dfcce2d882d1e8773d1417698ecd644fd83c3864597ab07e9193f3d998d64d14e60ba6cb15bd62a451d284a08f89de84a48ce354dc80f0fdc11ad5f9d8d01dad77e4be8a9d2ba791173dd4fb1316bb89da034e0d21cb40e4481410dbf03f0b0bec16b657043e9462fd43cb85b94d6a50cf4348c2b54d8078c3c40227d1d3cddcf536a6ed85d59a7eea362d3be184298df5f5c8f2d92d0761cb81ef68385afcd853b18b064c52311773920e9fb5aa140364fef1735b07dfea5594093d1e0f9ba7bd3294525355a3e0d9fb8ca9395b073d82865c3ee3d833961254494409b31adfa37dca73d2ac237640952157b2666c707fb03ffb6db778473e1bed5215c5e9ff47a271f877abe1f61a485c12dbb83ab65a63dbb9c8e10b2fe7849ff76134681e02777701afe15777b6ae089cbc179126236c2253297d4a0e03a5b8fc519ca8c99d7159bc56ae698ba99e1471a44eb81f7fb9011f1868ecfdf9cf253de02100346e29cda6ce2e219b440870e6c4cc4beb14ce72aace98ed7a7e2fc5d8fec3a07d7406ebed472ce85554932978336797d88598cc3d7c85d5e824647e5b99c15c55a2512861ac5916397978f219c4ff7e2156dae35edec751527ae01455bc7ed9ee3300124672927b88ded9375b28b700011f937582ae8050a93ab0b2b4cd3b0469b56f958d3fb939a0aaf9103337ca5b3b299db9660440bfd9ab01db3984cdfa2cf827b5c6b455ec92a27d42198b6623c16f550cfb26c4c5be284fead70827bd0220978bc41823e295025478c87dbe4fe2b7f6a91a788ec23ca85ce2dee2a3ac02b191928c0c2c41b2ee98fd60349881eaab478d97cdbc17d5c92c5c5251c98bf082961e42d023b322e7369ecf8d46feefba412c22827907607daa75e8c8f3d94dd76f6a9fc2fbff52fe239c060af6022322ca2a3147c136faef7fd6e80febf4254745dd4775066c02725663bf3504ddb86e872d6c85debaed4933bf46ecd7ee04a655e38d56966a79b38e7ef377a26656353524abcc44c3050a4a0e08311b977ceb0dfced6464e2a3593ea000db609640ff2a8eaeff9cb39ce365ad9a85413417b633f4b3e4e863774fb665e8b88938666626025da541a0ce3c5786c5eee8cbb6bf8898460d9fb88c23c538ed5a8ee656fa6b5b4b6b9cd9cdcd1164ef4d042f8dcdaefb533b1edb5cb0dd5604d4a508c9d089b95a3aacd0bd3bbe7f1d4c271142f248f45712b7e2215ac581ee05b5075068ed553739a5de975fb4ccdff3239cac7acc3825a30883acbdd4cc12819e2bc14dd3a4d7d9e1677e87e03e660d4a6252217843280ce38de2b9ce93d1515d30c1c0a62f2ed495a8c31b3cdf150844a78d1bc2e874047e7d71df4846f92a0d18b79ac1d1bf8d4abd2e7a3bf99a253bf6cc76dbd91e88d27f708c8dab11efdcf95b6e30752a447458580f68d5c6669e78f0738c7d3ccebe008baf8c6995715da2f67091d6e903c02d5853fc66ec3e1d298831ea089c4b0d202bb3346b6d17d020ebc10e953c9657f50605491768ebc07efcfb88f6e8902bd73da483516c7a6a223b8e9db7ee7eae40f160dabbd64fd3ac9333d2116bca5d45471d7ee4838c819326e06538af1448c2fa93c8e3fac4d0575ad84724c9ab3a00689f12569781686bda6865364fafee1a83791f9d80c388b61ace08ef1ea663eca44bbbe46bc2a87ab098ccbcc08607ed0cc2f0d68c26e65f2a5ae9ad419b985d809b559d3fdb97584676d25a9754a7df7b8c4f875043f8d6e343c2f023f9b241991dedb68576ddd5ac8a7a747b6bd2d32a1d1f2ec0261669fa4a0f151113231a4636739c228ff33f76b6f6638532c7049d187cfeb6198eef423d51cc0683bb31a8fb42ee29f420e5f351bf2b4b5da1606116152dcf6d2bf6342414d8eea35b02b3bbe6d26162bee19db63160c9c7cae01073b0506fae44b6ebe439587a2e1e252b0e0a77b80f56bba1bc20391f306a2c213f714f8b9eb062d941a11b292e52b56849190e18ecdde0f6ae1fea1d14daf1c9515cdd537450b2f79428f832dbd87a672378f693dc659fada16269d2455ebc7b4fa6ed804a75ab777e5cfa789c5c63cbfb1255a7f23a0fe1be0e90032278af0f262d6be87a94309bc56a065c4b656075a5199bb10fe4084aaaee30725552d5e49bd831e32b6d5cd5f3e0749374886d64121d9c8e3e7beb5e3ddbfbfbd226f85e4ed2fdebee101e207be2795f8b093c13f568222f47daf4c217cc5660d19b2e8d3f39f7eceb263f95d6e1ea5edd5c1f506013d6f7e60e6c90ccf28466a7b78d81da9b009628a4c88124742c25e03c67d3ecf03ee87a4ae82279cf09df06891debfa0a9ab5a0e13fc9084f2d5b0b75e6a689b733b188f53f799062883a7f3378311397ac0fb4c22201d113e1f00af50c27082bb7a7fd0dd4ae9f89e7d6a19f2b0ef65e3909bcc2165ac597f1432731949d0bdeac87cf6ec50d944964169045cfd2f5188b91943561f970ce388c036d29db50353f55ad5713974384c17f094f4ccbd9cebe706c4bc2574fda55e7a2a9d2a3fec4efc290e22bf5e4ac9f2e5d804072b59638e56b3f21f8faf1d9bad16f38290f27de71a06bb6bac797605c69c7f3fff8f66085c4ebeb6baf6de882d18a4bfe4881648213a8897cd7b55069a8726136a393411dd04ac6c962cf17386703a32d39a9e9bfb3604206edfb023618b6a533c2d23c8e29f5dc3c8036a27490cf8c2290ec121c77b872a4e7bd217657903df813abf46cc6c1e8e40b10f6a6e0553a60d9fc702a1518a447cc5cedd01b4ef4ffc1438a1c8dde6d7a1983d79b46b13d5df87143133f7ce865a9c343b3e460219a26c855cbe84deb88c9131ce338a8c048a2d10ecc387a809325db5f09843fefd701123a707e85c9f5f04ce304547c29e8d8998cce7ffe95d78b6dbfb689381ed1b8fa98ea14fd66959aab3d63ac126d764cda86f4025b01dcb00b5ef6aac6464ece996be28a36cd8e5046b64fb1786542cc09c021833c8c3f025c1ae925c44fd3acaca976120cd69f13c1fe365e1054c9e588188597a4534037f466e8d6d0c6001ac82a49525c6c910b149d6515aeed7525df3aa0fa327e9825a6f4d234bd80dbb342720998579753889852848a2fb550645064df58a36a0be4ddfad80f536e0350af41a1a2db7acf89792d03a86275839501161dc9180a471b65a053a66b5bc644404cf920f70103a300c2b9702b47e2e8885c57629b3993697512885243262b7c42a3816964635c252ef25896cf55cce66aedc95d31d3a4a61e947b6d57d259373337d5fcc9e34238e94c06f814986980e13557dbd0e58b9b9a39807aafa82094b33ca7378b1a94cf8ba9fb289905249a9e0e40b8afd73bace56e86bb8a2d0e5c4adef7daad8b04e113617df83479487895de63f9a87cbedb71da6cd56183ff4cf7bda6e270f55f27307371d7a41c927ebee83a2060870ef9e52a910bc8a7f11605cac3b9731d029e477f4fe12fb5e30cc7408b2d54cdca2b85ddea85a93c92323d5be039edb044086dd81acf51862aa2fe06df9c450ff338f9dab1e7363d3a6bfc92caa08835bb4bbffb22f3e184f286fc8830613ce440b4c8d023f5e92c3adf01415f890746be70aefd24c18d85708a4b6bc20f3592a5db09058a05ca051bed64fe69b8c0c6b0fcc4259fe007392b818398c2f9076e3de899e8bf1205b253e339711687d94a9d999063388e43520dc57e07dcd61b2d7397fe1a319d19fea03e98fcb73e998403596292b4846fb58a3b9936e543cdeb1a5ae9abab2f7699c8b8b300f4326eb3ae954634614ecd7ebb9fc05cb340d8634536765d01c94b52b1a3e0986c0e0d2834d8df02af9e9d252a10918f1aa5a161a8c3e8048aa0407d09d3178c2102a0f77977dacd384bf13e649ce2b00b7d568fac63f2fb2d5abe5bc3754b9bb5352c964ee88f5ceb8d02bae2826b6acbafd93874e406b1f00e341bc2eb87771821a50a6656344faf44ef227dce57758aa8281b5a8783299875947256fe367e059114a0fdb6d053b7063569c3d757dd8efe6e29ad883919908ddff22ccae950c3c36b272d38d2b5f8ae3ae0db7a7e3e14e6a2ab3be1895b2f8cb5a3e0ce4b18a00cae6000df0251be7ca7f7b5bd69db146b70bfaaddc63f0b570e58ace3acdec3aff94d6ed00bf31d950db1f01c05ea6ed0edc5bcef08982cef1ad43d8d8d9c7145cdfb0896c122803422d9245a65ed024c8383229952bbfbbb65f337129440afdad08b6d5f2747b65b5c965f4096030d4565253265cbd432e3e009fea9667255cf42daac1e282bc626759d2dcf240a137c5781dd88a8d87535cbe95d766ebfc6aeb0904c07b29cedd661cb03e1113f65ac5a8610cb38dab1524c8a3c7d0fb6ab649eed95ed9b620faf5c2f37df3461dc220f8f8c4689178530b1ff907fc69806726c8ca4982092e054c772c4f5f8a5c2c3dd7aae5f1eb378d1c4db78cf584c712052dc0b5f9c7cac5b796c8c424d2eca6855fd5ffe46a991270909fabf1d5e58599ddf6b393e31c545e6cb25f68db6856f41cba1218f7ce2d2a620792db28bd95c2a4b70f61c1a9e657abb613b3c8e902ea1ce61b5882d2adaeca89c0fa56b1db2d16ff8eae5d3cd576182fb8d5f8e9807cb729fd7fae47701d19b2bac3ab54895c74ed13f83ea0e0bc129342bdb2eae6653498458ca25df159fdad8d98c5a5f43125c2291a806d9240c8e6172d868e080d6750515ba9d4042b46d21cba86570fc502b9021ba9e653b8ff3504c753f1d9ea25716741a0d5680a176c70a4872a7ac311dec7bf6f5ad0be79ced4c1195606f9bc78487f662a4b1113c84477d36d3718bdc1947bfe33f31dd970914b503010009865031f06619ab527e78b0018acbcdeff0b6fe2c2972a6b65f7407a5b470270c73b4eb21327737a1846b2af9537f1fbcc754042a5d9a71069edeff7f60cbc091b8869923ddd4b498ae17a89cc0710f052136e5efae21448bd2d8017445fb098de1cf73f2ab8baa798d2849e3ebd21748a1d8c64515d4bfbb64c7231a2be54beddba6bddbe2d846bc90d4f2fcd35dad2c621c74a337b1fccac6ec1b1f284f7714ea0bc537d630b75ea677460de91153c1a8a20f29675edaddb2e51f93a2f21ea0bf8b9c2443288b4f50b2603f518d360544d156a12ecb608eb148874040c7e357ca67fdd855964111642e565282ea5ed48146a83480dff49754a14f97d3b9067507d6abb07166c3514b760da0e98364258234d2d2c9ea0f0119031eaf7295b81fcc299dfa5ea30004cc60533f6ab3c45f72ebe88673f4e052284b0e3ecdbc69570d6337cde4dfdff345244e2f0bd6018f8947fd047f23ac44eb37a1ac5fd8fde7fe01b87bc182c5ebd9e6839b3dfd53185328c0840a3d0a8fb08c04f6c7f2bbb59a55eb220f48be63f2894b5fdcad9fc217b70035eda4374ee5f35ebe14fd5a8641d11026612ec04ab80c2d8d06db3ef30af1b79ddfe0b67838dcd2767ef18d9988b4a599adb615b3ac9bbca14393f6c55ab550f3abfc562ffacf00482481a57059a19a0ed3ed291db641592ebd0ab5c4665e6553c2bd4d84a3888f893b2111bb953674fc059e174ed55958244cebb1bfb602cba950c327e518078134f460535b227b30fffe0338dd4465e7d12eb5f8fff015fcde16930a3195bd9e3f32a3601cdd9eebe3d46d9163e5ced01d1eb8dfc2b35c5c6cf41ac397e689365c13c0368ae603b8d09ec9f9c0882353d6cade8ba4ca5bb57b0dd0115792a14e689a0eed08d08b82f92248ff1a2cf43aa91db8b488d960de0475e41de4cdae796f7769f389f2aab402e4569294583ae368843608ee5965b0982b0063e41d35583e4729f4a0ecf353fc026eeb3b1cec16cbf406596660b1f245d71e2b82967a24601dc989892566d12c36cc36e445163ee5c1f07b95ec254b717aabc5d07960337d88814918d930df3a8b7ca5fab10b4260af7fb97c995ff7210ce99fd6fec958e00b60bc1b735d11cceed245095352bf9f441b267c5bac32534a68bb718f6d63c82aad4eff9617d47b3510edbe2108be9d87b1feded1ba3e669fcb178d11ba4d79980381114579cb6d4ec8121dd0e313f16caad0e076317a05df935c8b072c0c056c3bce9d9f30e817950f73f0583e1cc04125708f5cde34d0661ee99547741911d9f314d22bc189a25ac2c0229c95721f92dbd6de3c1d6a08c275dc5c93a40ce4106094cc11d01f3cad5f6897a7c3e55f3c8277def3096464f734a5d45fc9d7e343bdfec15ac34d18b802b6f7615bbb55a96b7a958eda0588e0f2a98201c67fa1d27d702cc2fc7b9ce94f6a754c4ba8935cc73abe227d12fabf63a578461ba46b2c364ffb8bf82c8ae8d1b2316c1fa5d85ffa4da1f74da239131964a4fe7e9213170451f44c4a73f8ec72042269af9abaa8b994cd86236d92ef765bcbb3f409730f9c39ab98e049cba6f4a7ac690fc9fb57f4e2c5211c05ecd965e84ca8e72144d0fb81a925e47ab61441769540abcb4c07a6007ee6e53e9aa5575d092f49781a3956936e610483f9d14dbf9a55d35ed5f25e4aa399e92861f82c87e0dedb1299dfaad12cf04b71a1cf3fa02ca495b5b7e22e5fe3d736e2248d4acab99e36545005191c86f1b4e05692c89fc1af8a108704a0e71c7ba6c2363b16ed7ce27da9d8aa6333abdb2c47b3c76a99f81ee654f2798aa8888bebdd1e0987409390ae83a721f5b1c7d0584b985710c5077d0b02a1f96e00c25a34112976fe28480891b4cff7eea2a2879507af259798eff2ee2dd57d99ac2b367f0f0a85335d1d6fe23ea767ff4174222f2a25d2464e828b8ff3d37490820518656216bccd168d37420ec4b6fa71bc6edc9c69155e4c709cd4a66f0a9c4af540e77ec8a20191ccc38465521e191991e24df4186e8ae3bf696f00e9036e84476b6c89a57461b3ddbe344a3c546f615d2c6855e11d37e235def33b725dbba179cb295a7671d79fd52fb1ce50ec5062c3f59b071297488268be781e09115cec3689520fa90767b80862be9b7e9335d60519b882396dc957473def450ea19d97cf37c8c0051af3c16ae70d58c691f1ed6fcabc05033f0eb6d5abf35081ea451ee798ebfc68f7ea3b0fc7999751d86ccf92a0d9977dae333c4d527f3fb1d14b4a139bbb1a8368a0efc8d9b6c2ba61fb4625ccd767cdb2f0ebe111b374943b0b7b0163b63a7a6e2fcbe7471fc0264f39ccae4b34e566922b91dba6929e17efcf249cef3834b1dcc9dfa187ea17a0b9d3debb22e1385a3bf6bf5868cd16fed4507d362c07dd59bce502d5f24063cd54ba7d6d52f160b7e95ec5ee7ebe239fb59999ca9bcad4e19ad3359c4551bbcd0c4479a3ca00315855907026d7be9078220b5c5dce343c66d75c4d4df6a86e3ac86949624ae755968115c3970eac63fa03b17e491d3a9c42fb03802a13ed000e5a06c0ead11eae91b0eabd1922b0196754199c368bcf7e126c165d6638557fb2c3d9eaedbee78234aa19db0bc1f9268b6eb881efaa61abd27783d306253b2e1a867dca7e77e3b8d58aa3d72e8aeb55c6e035ae57d2588f8ccad546c8f44a0e3da42e47fda6169db96e1d95bd0231501c7ec82ed6cd414857dc5785fcc068a0e5d993d4fe08e0ece97246f0de5e1c2e616963a87ab5442a22bf4aa2f97b3df0330ddf04fdb4ca1ca3de7e64e30831f0659ca55ea0c31f0ea97eb4c3d162b268936a180096d08ef0f00be9b9d0bf8cbdd70df13c86d307913cba7f3b92f8d87abd931160d8ef316ed202d4972e1331e3512b3470ac29a573b85aa575330c995f71b4b7e4608d3f302b09fc5e507bdc55997f7a4ffe281259e3821b15c1731abc7134be00669e2aa614e8653a479eebfe2482514316b64f03dfd17c8ac945c9181b9281a678e89406bf35b13ee1fc3f94cecde703336050ee0c4f64ecefbbe9f9a1cf6bb4440b8a3472ff09f6f06333ee6b825eaa396b43c662d20128a662a39bd77d23f74e91ed7e9f45a416ac04a06888b3d4c21844185e4fd5841063bd0640a0178adb5e933353ed62b4f6640d753435531c857e2513359bd65938afef104b577c08a43191a5e0e67418780a4e70f31110c4b7638eddb87fabf5aaed204076f619674694b9622fa636a195e8abce3226758509d225a27167f09af9f0d987e66a83e2232dd453012c62096ca7217262372d6a99c78ae86215889445b65d24ce102d6d9265027f13bf0c467dc5b461774ca0b1a156d52684f7325b3a6cb8a34c6bcdcc542c672112ace57f7b06e2e76eba857957e5068839a996498f1eda03742523977bbb5c1cae6a0eb842308740b80ee71bcbf7e542527bba6e04a792ae87fce20d3be244297f6db57a50991e0a4a55fbbb4074f3104283cd4f283e9cf0814eb11301d315276a694293c01d948021c032d087e1e28b1c425515e5a0226d9e2ca9762e60d1298a4a97311bbdc943e26c1fe7fa45ffc3575f95592055ad328aa374bd1a972f30b525d099f92de02521650b039082db7eacaf46ea5fdc60c5e36f4839c221e2cf90be513791344f4e1994f92e58adabc374717a9d563696781e95e7fce598f8fc66e1aebf97a759c32eb3ca93cad9417bc2d532c74f33d84f7a37dbbb0bd56b118865d9be72b87ff5935b8cf244a25d17e1a974a5b46befa16de34cfd5e85d0e29650e548a8d86474a2147e800c3c5ea7152d363d2a55900d2a413db48d8e39dff26c9e37ca8f2011c4033b57d7c4cacfb08872fcdd217fa732c7511239162564cfd9e09c41e24b80280028fd696a4146fda7405ba1c12411767278b172b797b1b7159df53ebcfa74671c0a2c5ced8797bfa4334515fb99966668ff68262b35e154a3779d8a64bb4f9061821bc2dd7c33eb451faa2e95b31e4ba114d9b96ed77ee25dea20fd5a3ffc67195851e2181a9954757d59616c0fc16a11392792ff355893a4384e8b1528cdb3fcd9bf0cfe55bf124e7bfb9995c0c15e7070d61ef47ddfa9383bb74fe48d4252e99b619bc30d4f1b4fc61715b9b88e55cd4d47427b9e361b427ccb3ecbc65613a7e67e79e81a3b2a23a1d549f5c00d0b8276e925b05c0924d6e773ece3ff03e73d658d32a183216d82f418f7a5b853416448d30e414375553162f227592edc0ce97fa7cd914818d129b276dfbecd1a125b4b2c0b70c0a7c35a06feee2798da9bd53dd9ecb48dcc404cd6d8201e47d349c5e2bd2bba4f059502163788892361a9f2d859b547aa69b0c7f37fea5e49d74154d3ac9e6360467718213ba6da75b95bf63ff501959f851a7dbf5286c3618af52f8b75ed50dcde6eacc746123be8bac0fb0f9eaf099f09eb8393625c7e6878fd28e73420ce10c19c22e48c979abecafd3610fcfd6336a4c11611307d88e73138b61d319dadeb2adf0982584c019c32455bd96dcf9f33f7738f86abe404465b6f8bdb3390d9c5064c0b33839d6369bbcb660b10bb6364fab53e064b16d79cc36fe7709011215e5ee507871898840e6715fb9b212296629d3b11f0d642ad9c386b5e59d0deff63a8095d3a1e2b7196c9a12930163a2c440b90f746c04a1e6686fbf8b5f7ffcf2deb15f4148744696b969c4dca5081979308a1cb07ff9253fb80ce04b61846102dfc0d1b42d3464b7adab86306be57e30c9e7c6f7badd1b4b550e7a3ab9a46522fa4e35c2acac49ad7b8ce002396bdd7fe26a5d69d77c92a3bb9eaba4af4b84232c1b518a56f3697b405247a520dbea4007aa93f05b3e85969582be46917631b8ff61373325fff87345c54afc8703454c1120207b8e2a98298d7cb0d5951826d94ebd851eafb59d6327265dbaa95fe2026554eeff66466f031dd02091e1548184e51804555eb1119f96053d69705f30a890ff9e6f560a23e965b04ba984f51e567fcc37e2f9c07108c23554d9212c860f945ee2e043d62705ebdb1fe8e0f21c35c71454897d33a78174949b5c2014fceb334c466e9b3e5f9494fe67db45b195131fe6c702d88d2357917a86e8d5c79fead4217f543c1283349916c1a85cd42d93c98f3a673569a9d5a982d6faa4ba8066fa3aa113a1672c6ba845bafb19e462f9e1447a30868792d5bd12c22b3b43dce6a796d17efa187c8a5ad0401c803db7e1e8627f47935062c6587c8a0231d23c16b6e73e4e87c2f563c429fb3889b774f8f0c43435a6634d657c46b66d34749f2b8dd4e599a8dc58402a93d2b95561969bde15ba239cebfca1a7bae3b4b7d49c1087e2068ef7c619ea0934d927d9991bff762f5210538a690fb40d2bcb708a78ef7ccb2f4762edbab9520b5dd137171cc8aa063a9ee7865e061f4572eaa6542e295aa6521661429836aecedbae84dc79d15e30aa046c4572ab3b1b0675951b85fde3fba741fd36da662b83fd7e119b02135b52a7d25501a80276d4ce4d58ae01a3899be0b3d1b2b25ff0e232b63f9b38c33d580e8d164c94306447c0f06731c0e6db282e0782d545610b75547e6413db7ba7d147f65ebd63e4424ba6e625657db521f49ccb2f115dc2dd10b04d0e066e7572634cc212aaca30264b3c0b3d22fdd3f83ead713a715ee95af476b6ad22320f0b19589d12916f97b87e58438f89a7c9158c32c04ef683e6f4d125d16993a381bbfdf4ffd8ce66275acd6b1f70a0d1e2a9977cf2c86fdf6ba7e45f01ebdb2a24252dc464560041191d4b689367f583770660e8ec8c647ea64d1a0bf4bb9aa9c32c6fced7d35bd980d22a41db7882552c356051afb0c3834fc60438ac0dc610608876d18f1ea4ecbbaca18d44433413b55c9b9675d1b09e8326c24e2d30a880222310b36cd9c16e9951e87d1793ba387ee96148e1d60bc89c272cc82fbd2ac550e92b8a5244679c32faaa8807c7fd3768e2e83f0c0d70bb18d3b1c0a401f7e580577c6211da5e37644eb40ca203a7ae20d178451b0f30a8a02b360c03871efb7e6eb9d72a0ab0d85aa2e63119f47a53cd8bc9e4a09cef7678b183f631a9af6703483c79dd917199694b00c3670ee125514c394a4eaa0f7cab932e013c26bfdd788d1b1064970003e74b8f56401227b6e5195c98dc604b1972ebd3f1a2a3717467181e67b995b57c568e9c0d8386345180b7a044c63184c65e91c404472b1007bb5e04f31302af42ec28dea66cabeab76b869f84cf4c636d88a45f635d6e69607ce155de367171282d74d735c49fb5d307d8d7086535e35fe72150b34f1758d015dcd771b7c38ceb9838f29db54eb41c1830fa64c3aa4bea200fe6247629d22178494525507863f0fa982950a6ba0ec909acc699c9a7636dfce873a7bf0ad3c1592ac6db2e29c2d21a983421ae8ff0e473ffd421177ba2598a9a9bf77c060d2091487010b48ff4801f22e067841e9152cbfa47bbe0b430eafebea04b0eaf418419ebdeb596e38f568e8b2ef95038e35e94ec4b053fd5e61f4315db034272e5a34111e3b679dbbbe5232814e0faf2bde82e2ed92c7390f93b37cbcdb8ff1f3016c62d0bcf04b923113d832a71b7140c64efcfab35eba034c06ac3d80fcfa9b0776b293abb9415c1fb761060a207895c8b7a1f81cc2dc9c30e6fe44abef41e3f71069b453dc7d9d3aa883874a25992736d295d5814b815fe94d0801d278595a351de2284f663dbb53ab07ccc1a0e9dcd2f6c3a2f19b73e690e4fdcde25cf12ac3f778da3dfbb50536b72a076f51f1af24823784dc30cfe00f6f4988708f17d820af16948ede9c46c7d28f65fa237058b1dee472e8f18c49771961a7c9d2657a4c5699a58744155eec9ca2feef111896a1893203405ea7f81364482ea393a4299312569da9e5d0b5c18a285a920d6d4a033a278322a7f292533c63894b5b72f4f4100ee8dfc40ad4a60bae2e6eaa3bedade3f1eb542deb29b569f499febe8979ae9485cabecc9dea57951189e38dbc4639f44c7a9a30313a5af7e655c6ef329f2ced616a29d4d603dccb9ec1fffb3b5ebbc6b2b11d7ba0f8c25f3d2df6b6dabbaf3abfdbed79e94f1ea4c29a11ed3880977cdc4d7935a3f345844cfd4ab55eb14f5fe50bf50dd0696da0a19eebb6e35934f9e286dd251e53b263ffbedbe0093c49471c3362b727d2885ffd2c97c04fa9b880e2dc44ca08871c29bbd456ebbaf227754b307e9ec67cdf30ba9de20e3113af8c6c3d8d88b6983a542b56ab71268e69b212213b93436d5282704f422e60492ac3273e432e00ad4aa2b37760b0429abf04b6586e2bc06c8b1ec05fd6e99ee7d6209a7f5ce4050e9f4af7bbca8bed1e359431a115fca9130e73fd54e35afb452aa6a1779b73b7f96f076b7a33ca644f285e2bfc1f83e86b729c676aa9a2a077d127d29d89b556c3657b34a425346881b0005dfad6d233c74611adc4766d40bff3e48bc52ae1e2756eed89bb981c2d29898cd7ddcaa68c6a7883db3be1f947cc5ae4ce60ab8129c1a6298549161b38a2ec2953e7de97e0c78ef38ce2ee844184f02d731713716b937734f57788baf76f2feee6753f105c91cca2418b7bad4fc779495ddac18f2d03532914149b594d367ceea1c22ac829d73ffa32740bd7a1b6ac4eaef80e235cc665c9aa396de9139d521ba514e59e8845342d6ec5413e8d202f41888df9a12a372e8737cf41195affacbd5c2d3f8c323d33b5d2ca97b46fbccf7dd5a1be28578dd9f287e2312d430a4c746d08ccd7f781999549258b6b69fdc27bc22b3e5c99501733d3d538e8aecc2c1514460b4116720828d90c26ecc5fb6c25d88c47477c40a79472f760f29fe19863746169a73c87bb9b91fe29e8c9dc8c2776a123468dc9868d22e8da83b30b4bb216dd8fee5370438bccba245bbc8e9febef3e21d010922c227fc484d68fe1a079d43bbd60556f2071073d004832960599e7a1a92a2aabd0a17677b56f51c3978994e5e6d0f7ae5378fec8204bcdca8cdd744485fd4ed9004f4f1fa1e2e2959b063434711fcccdd1734c0c9781151a32e8967ebf9a5ca94d05eeb12a2f1e59f38f7e432a6b29444b18249af6c1fde9b91848f667385ce5acd9ee61f5e2643db2b3c468afb4e553a7c7292789d120418ac1b9b05bd3844e6f99923493fa3c99568316135d59b719baa8d4943cba60b81d730d419f31b226cb3162c6f6d6f0a83a2ad43f2544d490558c98fca1127a4c27caae20613251a1e1b7ff1f4068797067e0b79e240e110bf84a8ea6bdf076197c0e91aced7a2c547b00a7bc8c4f382b5cc963b652a398a7f65d9010c52971e7f4c706abfc427714dcf56bc506f59812f4d6b2196ad5a2d19fa47332ec3154775049b13450abd23462425636b056348d9352b808511c9dc1c9a0ee395a0bcc1797475b2bdb67ec508948c4c268898a67c062d49eb13dcd1a4f4b806e91a64dea06e279dd93b4819ba1c3c827f087f0b336d705a03b8d2a59510cd165a1b57618c1f46682953830f1b7ef8465bbbcb51b092724f0bf1db72ce830e3dcdabf2d4d1a006f9131b53ae89d0d753eacfebf0bdf4864f2905d0ce43d4bb530cdaffba8f5b6b75e0de0efc37a36ca732c76d23a877cc40494d3bc9478739da717ff8a59f100ca5b7561cfbaea46a2524b863193e5a967cc3a4d8d968b8175a660f6b15d378ea3326ea132dcf812f21c59497082281555f05aa6667d01b418f9d79d9ac28cda9d116215dcc7ee4e7e8c902f7cebe4987a1e65df6e7cbaba6548861733254db4a68fa875c44e9f4a1e608dc614b3a47e21bddb0586585b2ad4922f1a878b942ea2c3a79c5b2dd0b6dda0842a2c60c95a0e876ecb0fd486daaf2b8bbfca8af50c5701d16e7f29307c32aad4468325bc49dccc1033c4977b5973923f7dd8cf53a507d781df5d38963678643e37653a548ecbda4d4b91f7292987bbe2dd4eeb13dc564f9bd2bf9c252c27e94236a7dbe92861fdd3b6d6d98fa2b7c8f52a2cd8c5937cd1cf97ba58bc1d032908a1d0ae14d295930b48cdbddeb643423b69dd98ff3ed34c3f5071041a7a9de4bc0a1b36c7ac611a954b3d8001ecbb614017b67b41a4d88a76cb1c98a4b5241bf246868ec90cb8cb60669337fcc52e0a1caa1f7b5f1cd5b9d823bcf3e8afcd1ff55b9f572e65ab0004ca03e45a60c637b51c16ddcdeef8c96f0e33cede42fbbde8d50c8a5bbdd15d197d408829e88d67f34f9e4f913696f91c4066bee1d97a9d92ea857ff1dc981156388f2a50bf4b35943b637feed67f193c3981f0e26a8baee8b067f2a710da67c1d5b2994f4957f0057879a85c871af1612fea688988a56e558ce9d0a76686334539894e6de95e681a23cfc42d8ed2f4f19d3adb6ae9143a798ff699b8dc84d268f202b80f5dc25d454177302a1d1e54c90e20e3c841c8118f06b17de8952bde5089a1a2456b33951200440076de298f656524ec180444c0c5bef987e05361e3eb14b33db58fbbb3fcd02f5e4a456a514aecb2650eaaec7ba8f0bf4c0d3d1ee300ab0baedfa9881b5efb7c78f64c77b1955facda7a2448b8e0be07f2b6e835f4a6df45788093a79293c62088bd305c003f4d11cd5204d9010c1070061a116fa71901f0eda2f2a57a162d1187e2bc799ff52e73ef03f077214bb3ab9583cadf6346842c459f648030a113e2d2d43e5e73a6f1c2c7ed45ae25be27597b07ac276121fc03257b06651bacf660dab6ffa85013dcdf425021c51ee7e0df8df2d68a7f36e574a9ff0bac1a91fc422a7e1148ee7ed628d916dcbb5ee7c77796fa406ef8accdfcd2beae102c1c1f656600563159c6395762b95e27bee3a5c2939cf4162ed3e979318c9daba36ddacf9d296373932bd014510f05ea7b066bd66a3f1ee208ed0fbe77cde43ee67d14450fa62f26338352e56808202e8effde09273470ce03f7b900979cc6af5b38df6012df0fc9273ae1ef5d204f22f28136847cf7f2c9fbba1e0836898ad7b35a702c7d3f280ac4cba69339436b90934fac95a34db8ddcefac2684093d132b48f9a92c9b3bdbd231a76795730f6120b50612c6410b8da7af91762705e5ff876e4f86c0f41b854974151fe7776bc1d615044a2e38a0aaaee042aa3d6540ad440fe8d9bd207b09c718c5950079b98849b63fd8b015859f023a5dd46ae1433018375139326fa940061f2f1e6f122b3beafdf8f757cec26103dae2a999469303db6006ddd2a84d27a95cc843504f7636f4eb8cb69fc264b3b38b75a844455d2155bd90be533fb5c2d635e19e90b60a51a0863985238c35cf94c822d62a1b1a10859d3c9983b2a7be3aa26c38c86a71f9c21db7fa8610b316aa8d2008330b11f9d35a6ccdaa7700df6d27d2d3b550c9a4bd3be8d252ab42f03bdfd0c7427e33d3b1c7e21f89161ff55d0601b4b11462a00f4f8b81107a07726bc67bd06aba7f25430e62f8b0a96c5cc5ab14e1ad82466de86a45906e683d15e466c0510a86f3beb974039b89409321135f8a5480614cda36d1f8012d37c0d144d6a27d87f99a7b474577ca232778946c4f6dc9e740010caa99f138859fc0d9f7ee8c231f618b39c6f86c6c1f0571504a1d133f8dbdcdb81b99992645b5423264713e09bcd51549c2adc7c8ec442ed7e8b1cea42024feea12fc448b9cdffd501d2ffca2b28d4b7550d296c399283eff9a6083ab2435fe0aecb48bae546e3f551d1b21e4948e868c3a075ef68de9fadd483f7be2222eaba2b68684517ffa217bf77dabdd8126faa48d950b4ac891789bb36fb3069a58ff6d60530dc57eacb3a1c960ef60aca42668644bb5d6256e5872ab373d56afceed8381fb3a68b4ec0a42f2e027db0c6eb58e65dbc4e1e8331442502baa88d40acf2b0a62214ee8d5f1f46a6fa7cf45335afb641b1219e00555d6a4547bfe60bdb294b60b840f451de6c6ca5c16de1a8d6033c5ed7b91fc170f564fa4f5765f40e4ca4840c4787be5c99783455a1199c8794bdb02c7eff53560cbbce91b40d793a683a368a8f3b2d3b987e15822fa28a34ce549debe4b21adac24c39bd6f1cbffd5d695caf4885fdfee41d93f3dc0152d0004b1664d96bded5908e27cd8a370baf20254428e239a85ba615225ac47b08a32262c49add8a1c1ae2e9989c1af5a1455e40407eb25f35d19cce30f131c954b7cb01f01aba789093e5f0a478670b7bd973931eeb201438513ff76b2f1635fcf1ded1e7d6825552efe4628da89e90cf66d05c6aee32f6bfdd72d402d93eb2e84f03c4aae4b0045ad15dffa7fcb7f47a530ea9acb0aa20a909e940f54f61517fa61a163b2dc4081d902ec76e43b9a45e517c7e8b23faa30f6db0517e56e20adf126c135b546e5c728b2d285a4ce810c196dbd4fd593f264f200abe7c2960586613160c9730d0089051eae05bc5c4109fd45fb26fc31aa4d973d4ed2ba3d4da3d16f410dde93b355187e5f76b0bf27b49eb545182d993517e11f81c1075099185aaa77c066d4aecae066476f909f53c0323d966a95cbfb15418c4a7d70a3756392a04503be5c06114bcffa7a435f1272dfcd18841a2baa0f91cc6f71567dbc50eb616872af430f4b85b7ce73d3049fbbce2887822c9ff58c31137e73b713d42e90b39cdb63766517899d48071d5e3af9ca16ce506cc70433f4fdf9cf5cd07c9388cfb94062b8fea070038392243238df53aa63c75188653fd5592a1b1126c050db6175588a4b6d36cda553e5f2a686f0ae12c0f054e85ae8fe246314d70741b472952a8f8d3bf4b228c35c9c84f883a42d0a5df3632fddc7c8d48dfa00b91ae50f7afb49010c2adf406875e8f3bf20095a72d8ca93c7fccff8e71cba10d463dde404e9f4197d16ed9c5026c36e0412a03b25c25710df8a33fdc8c948fda5abee0c1c994bc63abc2df3c474a221484cb19eb1b93f4bf948a70674a62f2fee4fa071af56a6b0a6fed75defdaf4d7baa193ad1097735a81a4833c86d3a6bd4a27fefeb927bacdc499a4b0ddb1375cb838f0e883c67c6f2b5e76ea63ea65b29f0a0c886e9530597cba348268dc08fb744236aa910a25895979b8c5adb226b83a8059182a7e7e446ae5ee6304e0f8b436288db1cfeb358982373ecbdb966a1359fe5b6b22d1a1581d813eb0deffdcb635512509686ffb6d04eea05b196c7ed1138f7d8570875c90c106a5ea30491e96806588b44e504f466dea9b50a1d4fa78686298f9a8206c30dce2485c9a4da5fdea1a78d4a61c9c229ae85dbad6fefb862bce3418fb81337533c0e83451134ff10cd028784995374e6036724b2cb9d54c58ecc1b14136ac4ffe7bab4d8cc67c54edfd3870945c05777daf930d7770641154447dcbf18d02e8e12cce037788f5a8d780c7a153b9995d0af7fc733a6f2d9bc0ea4ecb78e35fc486228ec4379c130b9d1bf12416e00cd1fe569de7a8cbd4061754530700ca90b9e07071eb13251d6641c8f4c06629d1baa0ea05c9574fa5c2ede8e21aa94d46e3f7aa06f20f92ce9e0e39bc45644af6a860c899e862d818ec9902a864daaf0c814bb6f975066354a54c819ee3a12c06101beaf87286a32edac70884bad9f952b9bc668233584df052a5db4c307466dc74a5024389cb210cc527479091ab208aec2f8a57783765fd545fdc9de4f8704d57dc272cde5a76ae6d27445e1f73f7ce18c4bd5ad9e34583eafa3bc417ccbb32246c8bb172ce44c1bd143431c5798d94d67849ac045a0567126bf09845bd9a231376907ab8b34a56679c8253dab9fcc443a7509a22d9acdd39040df15d1d801e5616d40c4844bf185c9d56b95d4538b02dd4895efe56ad8ea24bf3d94cc3a7b0e5691384fc6a82c34072ff367f89266bc1328e11543402ee60da01f1be0656d3bdd8490fb1a2f582e46af9b50d5ec4e67ee8ab5b0453bab4ef0d777de05ff0caa4ffd97704c656824e0f62a354711526fc38ec27441d644f217f0540c5f71ba43518fa6d6afef744ad95c0f9694d1fd1b2dbc422d475d9ac6b27789a8ef1e130585d57639705e32498351933106d12274ef932eeaf7f0703ee5c58ef75919712b902a63f6a961a3744e6b8db1ded61f127646d34775418c4d97163a17462738bac3b53c6ca5271b4b5e1c3ec3cfca9fed3070e8fa09e99b2dac2ec048c2967c89946574f14de1b92effb5cb67211a69f48f68c3f6a2b38de4cc7ccfe30e19abd19dd70957b33d08a331b0cd1453eb66d3c5284aec1d3b243a8537f0bbe6b977335998ecca3e39ef731498ac74927db3a9c28c55bedfa6f6f694fd2bf1ee3d5d3532ea9c97399186e87c94e9d33ac83417ed7863e0be4aa7b9ac83cef340020f563cf2de1d96d23d19f88d12354a42dfb36d4c73c1c453454d0dddc8c6eaa3de6fa9561239a674727f5afb97eeb294e9ca418c14fe4ff2e518bcae0c42c80b4588e18304bc15486c1fe00ce7cef1c39a118ea098cfc91adc96666a0f5bc66d34a687ce75f6b97f8de35986b6dabf2e6e782fe1a50d8c66351da885dc59559ce6f0166ac6efb3e2dba85a49f8fdb8a3516a5cf4e3a53765f0470f654e1430df6cea2e41800d59682db5b7f36668a65f96d68759e9add11fdecbc186ca7b4deae4eaef72194a7e925bf380fd0e6aa962af355f728e668e920dd1762eb5649b00ad29c9144b13d800507e9611339e483742e9d13b147236757d79096f48ce55f22203b2129ef9f0a6248f8ea990ea89f34748b78fe35507a47e6274d03146599db444d457dc2ed889ac5bb89e5e4db12e84ffc2f3ee515dc5b020021fe5b1adf2288c8f34609b5687f91b09977756f9b939053ea2346a07fcd6969e5f8ba44b8e4ee86706d6d13e7d999098484338adaaa453d40a258aa5f8249ba27ca9a7624a33d61056756fc938a69aa5220e16dbc3795059aa01e4e3c4fa3f65e4191b91d01d0dacf6598b93a5124a66216293b1b4fab166f565872d7962a84e7d89538c918e77774abbbc445eb4741fb703b6ba92d2980c6593ca6bef48128b54ce9769a3dc9772a21a9bcaa56e853a3b33af919833f8055df51b48da8fc49876789a246136485864437d3b8428cf41ba3939d9015d116fbfa5137929043dccf5b0a08294ec1f104780955712537ba4f86164b49aa48fb81ebf3682ab3a09b60840020a9bfc20d2811e1fca57d0929900d9e3574a97166ab765875da72a6f268bf08d22ad7356ae83a4d03fb324d1a0a7eaf6306b576a55ce30731c11edf43347e280f03805bf41c8ecb2dc2d0af0169d99bdbca25096798f0351c000cca564b8b005dbad5bc205ff2bd11c86a6062d29d62b7af3ef66ceed9921db4720454e935ee9e287e8364163316b026bb0718bbd6691f2699ab11d164d3fc7764331a232c0cb2429c73cb3e89ecb00e0aeb9cc97934b9bc0c1f121db2767205b7c0ef511061388188b568620e0e7eed1106444d62cb7e35e741fc416b562c94b5c34bd2b4fe97cb7f55adb4815f709ee9980b8882f680dd46e8df3d8f5bfa7a12ac0c9737e8f1ca6aa9a217e4b58778bb8e829e4bb5af54c053c926922d692c044606e53f29519e933800d5cea9c54d7de7e3fc36ff9b1d697507244f6dad442fafeec00c4c718f724376e9d956b070b1d9f4b65b384eca625a7ba4c8d321127fac3f36012ceb837ffead4ed4a2dbfd5b89c48d45c4fb8f96e7d02362da6d482f5fdd40b192cc8d5d1142dbdfecc6c4d4d85ece207decc5fcf102cb69100a2dcd15df8de6bd04416641746dacd66acef1d255c6f7d640b696a3894918625135291bc1468b438358a161f18259b4c9e3edff9057ff650ed4541feec5b62511ca0a5559fea7b639ebb5a94747127359ccb1704291c905873d28c6172f1800f30bf4cf8de7886a2f324c37b12a58db1a034ab60eb544c2b54a7431b2b63a1045aa5b7cbcf9d874f7fbceebf4856f8e41f64d35f26a9ced88720904245875df5a1f3d58720fbd0e956fb471817eb65a503f760d5e02179c1a7b083f72cec8c68a104d5b015a5f61e27c1311b6e61adb3194189b791ccbec58b3c3fd1a3e0f872ffa9ae8fda13929e4e4ea74074f64fba33a8520b666a814b23ef846e6a261043d62fd097271ebe0277bb87fbe309d3f062be55bd693f86efd1590cf6b0ba23cb317f82965703d40af9da90565eab45775b8553c454bcc4bddd062e406cbf67f7b74147cb5949b8d5edd0a0732870f0947401d12e7131663493bb00e92d5c9cd9439283eb01c38bd6d6129e6b789871f6f8bcccdaa21dd9c381dbe59841d9c5b399b365a51ad3bc50e91347a0d8b01547d39a6507a44daa74ff8f5f6571976c63300bb7b659be5e6ca609d323eb3e690905f0dc5a47ca38f6d17fb09afc7eee35666ff2d5d32dda404ec30c59aea630c2e1d8eb9a68d6a1d1a031452c0e123828a981c54886567aa59adfa49b2c6fc819cff5c69581cdc669d65677ca1b72c2122057efb56962cf575e974aafd7aed1bcaa00d1e13e4c961cda76ec5e0bd5f25ff15cd028499c3f1beec6d732b4c586dd6ddd837ce700cb9788c57d891a1febc01664c81fa10245893be60d603af4b329974a8687cf556deb6738a7f6b6a2f6ee38b0a2f36199f965a4f9badf745397b360c477a9a7b104d25ae604748c733bc8b7d05cc0b8316ccc4c2e8881709e27b53961c02f25ce7c5ba1edf0894ff5b49c29b62dacdb756134614a0417f645268be6944d3e5dd2701b843d77577e601f91de5b35b17df1b62a957aeaa43dd985d7f90b46e05553245bda623cc7c1f2e718ebf896342f0befded7c276d86102d292b9d17568043a6e340ba63c36d68b9376117e444815850b94cfa92cc2b9d1af877a247c8d6066f4180bca7ae5aaff9fe62f491c35f3a54b3214532ecfc07d74e0db372af71aef75da344b71a8e42e284042dfbaa56cc159f0069ff05d987c1ca2699c0b491fcc87d66e979998248db3d2ae3bfacdc43b77f6d01c32304af9951a5e94b2fc9449f552ae77c279accf479d646f17dd32ed899b2a2a19b27c5d7fdbe13b165082706db0cb348e88609309c5c47572646749e255432ac4cb920db424ae2cefb5bca6a9c08f44f70b728899deed1d716d2de65e7bc3ce6670aa0e910616e16c615358b14346b96538f271439b3ec622fa55e373331b7c430453a4b7917376ed758ffe7e82b1b6fb42ae4c0c5f38fb0631fe98beb2b9432b4de677d9c4029fd4e0c97d9b75097156a0560c8fc3ac8ed8fc49ec8891584486e111dddd327135bbd7d867f3390829dcba333c3d1564effc85108188f8fc87599e8ea989870b9324865ddd83576f3c884ce7f5766bf9379c96db98ffdb44cd9a83fd3c66256c1ba8641d30c65ae28ee9f961d2283a5111b9128afed59f4a82e4fb93ccd83f71c8d980141a18d36b42568ddd4270269b6d4040f1eb70ddcb56287a18a64744db0e036ead4e616bafb90b7369cf214e56c17718d27dea501c66c80d8f7a5bdbb306da37df3b8f501997282f4407cb244eda146f32d6e99dc4dae5ff7f93320f37aee57ebdba193fee6f309d621c8dcba675d51dde713975c191b248dd80ce1ae40534737988443b5605a747b784069bf345f22bb1acc6e65ec9dc56ef3c10b3851e312bdf2fe35143608b70c32b7cee0022d68137721aabba9ddc90ffa2723f82e628bcd0a38d53275268f8d092f7586c405c9e8b77c63c39294ef355a78e2aba1a3562c6e6f44680eb95021ad718bd86131b5939d932561d15c87af06f226e3b06b62d6f0d1777f7c708cc891a96db0c904d04d4cf2df0455183a89aec1043e23bd17cb54d76e79bf0e711bec94e13cbcc1491076781a3671425df1ddf1ce2467ee2495241e2d46f14f19c0f67c16b1dcb5b404479ec39a90b109d9354180cc4abfea665e31f0a6d7bc5496d4e5d1a0d35e81dfa486e87c35c922346730bcbc961c2db61d88d2c3059b4a5aac3cccc6d684db24f89c4c45cc44a16915948c58179103e4c015744186899234d1a7cb6658017df29fc28b3db1184b71035f53cbefd10dca141ad7aac78e7af4fd485c93da36ba34a2d8e778fed8a05fefded55430f827007e826f5ee7f5a3df85ed64735f3d3026f40f0cee1781ca7dd3b8033e4f6bb3c1706b35ae478e2d1e630d053b316ec1357e056a3ac701c9ad8ed72a1f80e942292643a882c3b5897a9cdf45def7ad08cc69ee6501ec8921da55318a8239039ffff363a76cd4f1bdfdcc45250d83b39550e4047172a0ec78223959a33905675dc12efeaa8a2e2b862b3873e2d3d0f6ab715f0cedd10889a281df8b2c4238a72a405a057438bf0224e3f0f00c92892503c6c0dd2a3ec28e59aa40c8b7686efea5be9d48c667b6eeefa80dea8e555b75843cceef79ffbbeab9ef9e791b9f59b0c6b30515e8e35524ab947ba2762b0c858651ff2e87a829dfe3b92a7f1c6e800deda0441bc5cb0cc00645612f26e71fe699565aab8745cd905726fe88f0fe529c78261664a0cb146161357ec35e49a0c92c00f5f0ecbaa6d282180ccb6fc64722bfa364e5f8ed30337de4733a39c030baf472494c7b6611b71920ccd3b1bc5fa5c240b7e85522e084a8877382543b1ac74b8d2b565b75e8fa0409c02f29c59f409fbe5b8907837121b84458a53a8c51e09d858aa5b64c9fe805de3caef6a0f08dd86e1119982874968e2e9760ab702a08488fef4017dc01fc843a19690acd6c34e8a816f794ff566008a58d26108b8221bf6ec82e8b7a7b7630cc54a804592ad641d6ce853bdcd725076d01554a247476e217801418097494162bab4ff865a9c1e8c51048aaafe355aabaf74c84f1e2cb2a193b319521908a5e5a46633cd79ffc2c95d85461805089e491f70ef71fec13dc4f45e1f49e7583631ba1e70930178d05c17e25f5835501e96cffc71e645bdd5a833a0760b514c899cb3bc2e2427ae0d9329c58fac2c7e645c35e703b2a088e7364f5d6de6dadb3c1da2b5ea5cdf4597ee037176de0fcf50c19331effe04e9db09be67722b2ccec8b92445b32c1616abcdfe637c90e527d47ce3cf83d1c6cb28cace7ff8d9c5d0d3c045cd6bb36cb7965f37632a3bf4ef066fcc98f2f17f65168cbf71a3e92eac3c504931ad768dff219b10fd1514d3ecece394d4515f6904745a0ad88efcb77a38de242cb677ed727067648aa0013bbe50ff5538119554431fab96edb94136688405d453cefcbf445e564e5879f6eae81f81c5bd71af458e5cfb5959d4d3109ef84a50c82bc210a48cb62fbb01baeebedfafc6ba0b5d8741faa64730ce72611fc70588f92057ca71f272b65da83adb199f7b291d3d1dca5b325235931f72cb431a55eae6514bd59d1d908d0e774beb7b9af28ffd99143a1e2c342cbe8b92a07e2e4e528547d079712df0a0506c0c8f91668faa5d1653f45df68d750c20398da3fd7037377bfa11cfd4b10c51e838f7fe030974fd1c33b3f6f28813e3e8575f7af2654fb1a6515e20a3f8492ca6d9e4a4c4277f06e18276df8f29bd121bdf3855ebb4913fad5cae5a6e52f3a92a43f33152ed0815b586670258b1c61c06e6292ee2468e71926116ca5b0155d120a6d1cb6cca852a524ecae2d1edd5a6c3d093cb75db371458c9d24c8a8a054bfc3ff95f1d6bd20a332db676d7dd12b7c43bc484e64f4d2cef987e9075945de65d437e977519d9a7687439427c225af18034f21ca14ea5b0c22d66ee0297ea917153dd80203a04db229a86e7289bf80b4b715fa8159a4acdd17332c2ecf995644d2ef146bbeef79392c7290897c861be4267778ef696b5a8099f5c3fd7d41eaf4a926b3f26136600fbac583115f3f0548420c2e9ab4edc64e64e15ade3c1161862ca3ca0c4a578ec21dd202fc1335b9532164512b1872b78e6db272f0351589263b6082ccb113f3e4f334e87007b74eec777d0d5c853a3a0750ac8b856efb873f93b38f18326ccb13e4be3ca536f2c8bded55c0895bb6a015ba5e65092198e591c0644c38f7cd6e4b05111078779e3a520343cdaf709bdfe5980ce0690df81b3cbb57d44d8255b89b434f2ffe9029d1be797c618f166cad165df4c76861009d6a196934a52dc1cc4c49e04bcf65bdc6b462887406848a540058f40c33d2e1627f41d7bbe1758fb15b70056fbc9f742e12a7bc2d41aae59ea05309927e18d3cf91562847b459aa4d2e1e93391f137fe6752b35312bf597c6b2050ba6d916ad340af9e7b26f4b703ceb8f86084b4ac9acb69caf0ef785597ce59a16b1d44639eeb6f8af02e7735dc8665009adbda86fc1b348ef2d0c7822c361e2622467ceee6f5273223a0a5e9db7da3dfc6f979d953e7d0dd68c7a1cf978662fd5e7a3a2e01f4d9b4eb98ee1a5f715562b21b4da4fa791592463743449ed77a6949288bbe016a23889a4e829964ab556538a744833ee097ef4dfab5e28f7dbe1d9788d6864d9963342c2b52ace40af010b022b166c05e57b35563a83b8d6774efa59d59bb1c13cd72b21932d6d78229d9a1b8bf7da1860742a4ff7b87277f26e8e58e28697dbd946503101c0ca678c5df71b014b0885fb2fe7b1549c955047c57e68e7a2292005eddf04fbf2c350a683e2659fdd09fa76ab0a9d97a2bc8a4c29274d4b605f5110168f109d3dfea1a27f5b7deff6783aabaa8a8ecab7950452878355280ff7be28e0e16dc1860820cdaf841b4641f77a01bd3ccf8a20debeac69ad7a089ea81a87b3f89e2577acd9dedc73c1315228a07d8ef690ab19fad2b7747e9982b96247e111eb0a7dfded5e1eb9b1b60f8b5ac49ecd879c493075452037b9d2ffeb83ac3d148bc4d99bc40637a98599dbf2c7f551489767418f06c730399c9c243bd50f2180a4b182c9106e8e134688f4cadbb2fb3a0c997f9c5ffc381e83c82fd0c2f85db7cbe5a64ad6a2df20e083f61c214db6a29a933a5ee240df6489eff47faf23de53ef75a0f31ceb8e04f42864785940079e835af99f455e0149f771a333c9139429e6f3b2ca591d921e2d93afd4a992d8c4cf66190750fdf0032a038fc5f9458c1b132885ff42f0484261bfaecb6441f522ad9589dc8c4eeebe4d38bff0272b74bf375b623cdb5e64aafd4adf4ba0e24c89ce802686a932d0641283d0a2285df23329d565ade17f43eff4042cac62ef6596b32d1fea6e2492e82d34234744ba13718560a220f35311ca07a21bf71cc02a128410b0d363d92578ef0c339be90b3ee0bcc08f9c8c66c94ea38d89faddc3917f9e17171c829d99706e1ea596100c467bf43aefedaf93419061875478a1451e23aa1fba7bdba5a9ead69d05975a76c585b0fc250a333cea145bfb035c9f6fa7419370ecffb359791f8ec8d84af8ff7c9a2f3d20dba7f993acd65e7e68ad38429d6a84f1fe552717650a7d66d9dfe6a50b159d59143ef8a62d716c9f4d81afe890dde96f41d1477179c666815eb1cb3e70420b9c868c7dea6da5f218bb11f73202846e3fe05ec6e36142c5a0282bf66a7473a4a0033f684281c081a66bbd4bcb023f60c0c47b1606ef18e8e1c3ed1abeec089080ecad5898654b5ef77eb330a39968446d10f0c39081b8c775542a0bb3ffdd1d5488086ee5ac5f62dbaa3b023ae84f7cd3936b5790850149d1a167bf0cfeb561f481bdd6494da61afdb155d875bb46be8d3e35f7370cb0433c1204a8bfe1505f24090ad4bbfe04337956a99b7f8be017968915040b11e99dae758f3c4f66f209617b42dfadb891f5d08edbb40eca8c87c26e6bfc24711a95374ef54a5da8d8b8ece9e2a8adcb994fde172e523361cf7fedb3a67c9f87acd48f06bf3bf0e85de158ae5f3792a959393f1f287dd6fc30d09663c64dc4772587a5ed8bdba9cd4c64a97e64e6c5200d262808a31699f01f3406ded82a56a546bbbb768c446581c92d81f2556b1ef4ee811235832886ff715b6fbfe23dccccb0eccb7467b73e48a9b49bbb3ffab36c1133b2f11f5d1d2cb8536d3cf91b1962d51c4bf9ee125cb2579d4bf26b9c5080242dd6bb9623c36d8353080bf8b908c840f064e2d9d3f058f12457dda5865ac10393344a65caaf3818cf487ebdd0f78862c4ece2304b65402f525c4097285855fd349f65bd60191e30bcc0f989b29ea030659c7a0a51bebf31a5cb92d51fd4f2d4dca8d489bd62ac1a56f62f2216e7b67495fc1efa89db984cd69b69f337ec3ba99ea4f2fd99b9da557f69772645f3df7350c3aafdf904216c5170a865f8e0029cf916288d902044665826100c33e279bb20d3fd507f34ad240b1d97756223ede6224ae415f9b3a405bf92307629f3720e315ae2a85cb8aad258acdadd927c141350219c8cff303866aac3ea7202ae3e8f448e89c</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkdownToHtml</title>
    <url>/2019/03/15/MarkdownToHTML/</url>
    <content><![CDATA[<h1 id="MarkdownToHtml"><a href="#MarkdownToHtml" class="headerlink" title="MarkdownToHtml"></a>MarkdownToHtml</h1><blockquote>
<p>将 Markdown 文档转换为 HTML 显示</p>
</blockquote>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote>
<p>本应用是采用 node.js + Express 搭建的</p>
<p>运用的模板：art-template</p>
<ul>
<li><a href="https://aui.github.io/art-template/zh-cn/docs/index.html">art-template</a> 是一个简约、超快的模板引擎。</li>
</ul>
</blockquote>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>我把 <em>MarkdownToHTML.md</em> 放在目录 <strong>public/doc</strong> 下（放在那里看你心情咯！）</p>
<h2 id="安装-marked"><a href="#安装-marked" class="headerlink" title="安装 marked"></a>安装 marked</h2><blockquote>
<p>npm install marked –save</p>
</blockquote>
<h1 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h1><p>路由部分关键代码：router.js （ 里面的部分代码是关键 ）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&quot;/:docName&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    docId = req.params.docName.replace(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    publish.findById(docId, <span class="function"><span class="keyword">function</span> (<span class="params">err, publish</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">return</span> next(err)</span><br><span class="line">        &#125;</span><br><span class="line">        fs.readFile(__dirname + src + publish.publishMainBodyUrl + <span class="string">&#x27;.md&#x27;</span>,           <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                htmlStr = marked(data.toString());</span><br><span class="line">                res.type(<span class="string">&#x27;html&#x27;</span>)</span><br><span class="line">                message.find(&#123;</span><br><span class="line">                    message_type: publish.publishMainBodyUrl</span><br><span class="line">                &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, message</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        <span class="keyword">return</span> next(err)</span><br><span class="line">                    &#125;</span><br><span class="line">                    message.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">                        e.UTCtodata = <span class="keyword">new</span> <span class="built_in">Date</span>(e.message_time).toLocaleString()</span><br><span class="line">                    &#125;)</span><br><span class="line">                    res.render(<span class="string">&#x27;MainBody.html&#x27;</span>, &#123;</span><br><span class="line">                        doc: htmlStr,</span><br><span class="line">                        publish: publish,</span><br><span class="line">                        message: message</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>##</p>
<p>MainBody.html: 用 art-template 模板渲染后台传来的数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   &#123;&#123;@ doc &#125;&#125;或者  &lt;%- doc %&gt;</span></span><br><span class="line"><span class="comment"> （ @和- 很关键 ==&gt;原文输出语句不会对 HTML 内容进行转义处理，可能存在安全风险，请谨慎使用。这个坑害我多走了好多弯路。）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;markfs&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;@ doc &#125;&#125; <span class="comment">&lt;!-- 或者  &lt;%- doc %&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="http://static.zxinc520.com/blogimage/20190314/x6s26FzHS5go.png?imageslim" alt="g"></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>md转HTML</category>
      </categories>
      <tags>
        <tag>art-template</tag>
      </tags>
  </entry>
</search>
